<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/iBlogWebsite/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/iBlogWebsite/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/iBlogWebsite/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/iBlogWebsite/images/logo.svg" color="#222">

<link rel="stylesheet" href="/iBlogWebsite/css/main.css">


<link rel="stylesheet" href="/iBlogWebsite/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"leeeyou.github.io","root":"/iBlogWebsite/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 延时消息的原理无论通过Handler的哪个post函数发消息，最终都会来到sendMessageAtTime，基于android.os.SystemClock#uptimeMillis时间，最终以SystemClock.uptimeMillis()+delayMillis的结果作为入队列和消息执行的基准。 1.1 延时消息是怎样入队列的？消息入队列是通过MessageQueue#enque">
<meta property="og:type" content="article">
<meta property="og:title" content="⎡稳扎稳打系列⎦：Handler机制全面解析3(3&#x2F;3)">
<meta property="og:url" content="https://leeeyou.github.io/iBlogWebsite/2022/02/18/2022/2022-02-18-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%903/index.html">
<meta property="og:site_name" content="Liyou">
<meta property="og:description" content="1. 延时消息的原理无论通过Handler的哪个post函数发消息，最终都会来到sendMessageAtTime，基于android.os.SystemClock#uptimeMillis时间，最终以SystemClock.uptimeMillis()+delayMillis的结果作为入队列和消息执行的基准。 1.1 延时消息是怎样入队列的？消息入队列是通过MessageQueue#enque">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/Leeeyou/blog/blob/master/images/2022/wallpaper/2022-02-18-ekaterina-sazonova-CMhxw3lgZ7M-unsplash-modified.webp?raw=true">
<meta property="og:image" content="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2022/code/2022-02-18-combination-of-screen-refresh-mechanism-and-message-mechanism.png?raw=true">
<meta property="article:published_time" content="2022-02-17T16:00:00.000Z">
<meta property="article:modified_time" content="2022-12-02T02:20:28.733Z">
<meta property="article:author" content="Liyou">
<meta property="article:tag" content="Handler">
<meta property="article:tag" content="稳扎稳打系列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/Leeeyou/blog/blob/master/images/2022/wallpaper/2022-02-18-ekaterina-sazonova-CMhxw3lgZ7M-unsplash-modified.webp?raw=true">

<link rel="canonical" href="https://leeeyou.github.io/iBlogWebsite/2022/02/18/2022/2022-02-18-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%903/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>⎡稳扎稳打系列⎦：Handler机制全面解析3(3/3) | Liyou</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/iBlogWebsite/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Liyou</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/iBlogWebsite/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/iBlogWebsite/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/iBlogWebsite/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/iBlogWebsite/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2022/02/18/2022/2022-02-18-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%903/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Liyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liyou">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ⎡稳扎稳打系列⎦：Handler机制全面解析3(3/3)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-18 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-18T00:00:00+08:00">2022-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-02 10:20:28" itemprop="dateModified" datetime="2022-12-02T10:20:28+08:00">2022-12-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://github.com/Leeeyou/blog/blob/master/images/2022/wallpaper/2022-02-18-ekaterina-sazonova-CMhxw3lgZ7M-unsplash-modified.webp?raw=true" alt="2022-02-18-ekaterina-sazonova-CMhxw3lgZ7M-unsplash-modified.webp"></p>
<h1 id="1-延时消息的原理"><a href="#1-延时消息的原理" class="headerlink" title="1. 延时消息的原理"></a>1. 延时消息的原理</h1><p>无论通过Handler的哪个post函数发消息，最终都会来到sendMessageAtTime，基于android.os.SystemClock#uptimeMillis时间，最终以<strong>SystemClock.uptimeMillis()+delayMillis</strong>的结果作为入队列和消息执行的基准。</p>
<h2 id="1-1-延时消息是怎样入队列的？"><a href="#1-1-延时消息是怎样入队列的？" class="headerlink" title="1.1 延时消息是怎样入队列的？"></a>1.1 延时消息是怎样入队列的？</h2><p>消息入队列是通过MessageQueue#enqueueMessage函数，when表示消息执行的时间，通过下方源码可知如果当前消息队列为空，或者when等于0，或者新消息的when小于头消息的when，则直接将新消息替换为头消息。否则按照when的值将消息插入到队列的合适位置中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="comment">// 当前消息队列为空 or when等于0 or 新消息的when小于头消息的when</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123; </span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="comment">// 否则按照when的值将消息插入到队列的合适位置中</span></span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="1-2-延时消息是怎样被唤醒并执行的？"><a href="#1-2-延时消息是怎样被唤醒并执行的？" class="headerlink" title="1.2 延时消息是怎样被唤醒并执行的？"></a>1.2 延时消息是怎样被唤醒并执行的？</h2><p>其实这个问题在上一节中已经分析过了，在MessageQueue#next中会调用nativePollOnce在native层轮询一次，这里可能会导致阻塞，最终会进入native层Looper.cpp中的pollInner函数，调用epoll_wait等待感兴趣的事件或超时发生，而这里会有个timeoutMillis描述需要等待的时间。</p>
<p>有关epoll_wait更详细的分析，参考<a href="https://leeeyou.github.io/iBlogWebsite/2021/12/16/2021/2021-12-16-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%902/#3-%E5%90%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%96%E6%B6%88%E6%81%AF">2021-12-16-⎡稳扎稳打系列⎦：Handler机制全面解析2/#3-向消息队列取消息</a></p>
<h1 id="2-IdleHandler的作用和原理"><a href="#2-IdleHandler的作用和原理" class="headerlink" title="2. IdleHandler的作用和原理"></a>2. IdleHandler的作用和原理</h1><p>IdleHandler是定义在MessageQueue中的静态内部接口，源码如下：</p>
<p><strong>frameworks/base/core/java/android/os/MessageQueue.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">IdleHandler</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">queueIdle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IdleHandler终归也是一种Handler，也是需要执行的，只是它的执行时机有点特殊而已。</p>
<blockquote>
<p>a. 消息队列为空<br>b. 消息队列中的消息还没到执行时间</p>
</blockquote>
<p>通过其执行时机，可以知道IdleHandler的作用就是在消息队列空闲的时候处理一些非紧急任务或者优先级不那么高的任务。</p>
<p><strong>frameworks/base/core/java/android/os/MessageQueue.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;IdleHandler&gt;();</span><br><span class="line"><span class="keyword">private</span> IdleHandler[] mPendingIdleHandlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.remove(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部通过MessageQueue#addIdleHandler添加IdleHandler，在next函数中会将IdleHandler拷贝到临时数组mPendingIdleHandlers中。然后在next函数空闲时遍历mPendingIdleHandlers并逐一回调queueIdle执行。</p>
<p><strong>frameworks/base/core/java/android/os/MessageQueue.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果空闲会走到下面代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">        pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">        mBlocked = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">        mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); <span class="comment">// 拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i]; <span class="comment">// 取出IdleHandler实例</span></span><br><span class="line">        mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// 每次都清空临时数组中的实例</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 逐一回调queueIdle</span></span><br><span class="line">            keep = idler.queueIdle(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果不需要保留IdleHandler实例，则移除mIdleHandlers中的实例</span></span><br><span class="line">                mIdleHandlers.remove(idler); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">    nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下IdleHandler流程</p>
<blockquote>
<p>a. 本次轮询中如果msg为空，或者msg还没到触发时间，则判定为空闲状态<br>b. 接着遍历mPendingIdleHandlers数组取出IdleHandler实例并调用queueIdle方法<br>c. 如果queueIdle返回false表示执行完后不需要保留，则在mIdleHandlers中直接彻底移除</p>
</blockquote>
<p>处理完IdleHandler后会将nextPollTimeoutMillis置为0，也就是不阻塞消息队列，这里要注意queueIdle不能太耗时，因为它是同步执行的，如果太耗时肯定会影响后面的message执行。</p>
<h1 id="3-Android消息通信机制中IPC方式的变迁"><a href="#3-Android消息通信机制中IPC方式的变迁" class="headerlink" title="3. Android消息通信机制中IPC方式的变迁"></a>3. Android消息通信机制中IPC方式的变迁</h1><p>Android所拥有的IPC总共有这些：</p>
<blockquote>
<p>a. 基于Unix系统的IPC的管道，FIFO，信号<br>b. 基于SystemV和Posix系统的IPC的消息队列，信号量，共享内存<br>c. 基于Socket的IPC<br>d. Linux的内存映射函数mmap()<br>e. Linux 2.6.22版本后才有的eventfd<br>f. Android系统独有的Binder和匿名共享内存Ashmen</p>
</blockquote>
<p>这里要讨论的是消息通信机制中的IPC变迁，其实也就是Looper唤醒方式的变迁，大体上是从【a. 基于Unix系统的IPC的管道，FIFO，信号】到【e. Linux 2.6.22版本后才有的eventfd】的升级。</p>
<h2 id="3-1-管道"><a href="#3-1-管道" class="headerlink" title="3.1 管道"></a>3.1 管道</h2><p>PIPE和FIFO都是指管道，只是PIPE独指匿名管道，FIFO独指有名管道。有关管道的具体分析参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6876046258406948878#heading-0">深入理解Android进程间通信机制-管道</a></p>
<p>pipe和fifo的异同点</p>
<table>
<thead>
<tr>
<th>相同</th>
<th>不同</th>
</tr>
</thead>
<tbody><tr>
<td>IPC的本质都是通过在内核创建虚拟文件，并且调用文件读写函数来进行数据通信</td>
<td>pipe是单向通信，fifo可以双向通信</td>
</tr>
<tr>
<td>都只能接收字节流数据</td>
<td>pipe只能在父子，兄弟进程间通信，fifo没有这个限制</td>
</tr>
<tr>
<td>都是半双工通信</td>
<td>pipe是单向通信，不存在并发问题；fifo可以双向通信，这样不可避免的带来了并发的问题</td>
</tr>
</tbody></table>
<p>在Android6.0以下版本中，主线程Looper的唤醒就使用到了管道。</p>
<p><strong>android-5.0.1_r1分支，system/core/libutils/Looper.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Looper::<span class="built_in">Looper</span>(<span class="type">bool</span> allowNonCallbacks) :</span><br><span class="line">        <span class="built_in">mAllowNonCallbacks</span>(allowNonCallbacks), <span class="built_in">mSendingMessage</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mResponseIndex</span>(<span class="number">0</span>), <span class="built_in">mNextMessageUptime</span>(LLONG_MAX) &#123;</span><br><span class="line">    <span class="type">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">pipe</span>(wakeFds); <span class="comment">// 创建pipe</span></span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(result != <span class="number">0</span>, <span class="string">&quot;Could not create wake pipe.  errno=%d&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>]; <span class="comment">// 写文件描述符</span></span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>]; <span class="comment">// 读文件描述符</span></span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">fcntl</span>(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(result != <span class="number">0</span>, <span class="string">&quot;Could not make wake read pipe non-blocking.  errno=%d&quot;</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">fcntl</span>(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(result != <span class="number">0</span>, <span class="string">&quot;Could not make wake write pipe non-blocking.  errno=%d&quot;</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    mIdling = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate the epoll instance and register the wake pipe.</span></span><br><span class="line">    mEpollFd = <span class="built_in">epoll_create</span>(EPOLL_SIZE_HINT);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mEpollFd &lt; <span class="number">0</span>, <span class="string">&quot;Could not create epoll instance.  errno=%d&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItem;</span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="built_in">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.fd = mWakeReadPipeFd;</span><br><span class="line">    result = <span class="built_in">epoll_ctl</span>(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(result != <span class="number">0</span>, <span class="string">&quot;Could not add wake read pipe to epoll instance.  errno=%d&quot;</span>,</span><br><span class="line">            errno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">&quot;%p ~ wake&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 往管道mWakeWritePipeFd里写入一个字母“W”</span></span><br><span class="line">        nWrite = <span class="built_in">write</span>(mWakeWritePipeFd, <span class="string">&quot;W&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Could not write wake signal, errno=%d&quot;</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，唤醒函数其实就是往管道mWakeWritePipeFd里写入一个字母“W”，mWakeReadPipeFd接收到数据后，就会唤醒Looper。</p>
<h2 id="3-2-eventfd"><a href="#3-2-eventfd" class="headerlink" title="3.2 eventfd"></a>3.2 eventfd</h2><p>eventfd是Linux 2.6.22后才开始支持的一种IPC通信方式，它的作用主要是用来做事件通知，并且完全可以替代pipe，对于内核来说，eventfd的开销更低，eventfd只需要创建一个虚拟文件，而pipe需要创建两个，并且可用于select或epoll等多路复用模型中，来实现异步的信号通知功能。所以eventfd是很好用的一种IPC方式，而且它的使用也简单。</p>
<p>eventfd在内核里的核心是一个计数器counter，它是一个uint64_t的整形变量counter，初始值为initval。</p>
<p>当调用read() 函数读取eventfd时，会根据counter值执行下列操作：</p>
<blockquote>
<p>a. 如果当前counter &gt; 0，那么read返回counter值，并重置counter为0<br>b. 如果当前counter等于0，那么read 函数阻塞直到counter大于0，如果设置了NONBLOCK，那么返回-1</p>
</blockquote>
<p>当调用write() 往eventfd写数据时，我们只能写入一个64bit的整数value。</p>
<p>正是因为eventfd比管道更简单高效，所以在Android6.0之后，Looper的唤醒就换成了eventfd。</p>
<p><strong>android-6.0.0_r1分支，system/core/libutils/Looper.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Looper::<span class="built_in">Looper</span>(<span class="type">bool</span> allowNonCallbacks) :</span><br><span class="line">        <span class="built_in">mAllowNonCallbacks</span>(allowNonCallbacks), <span class="built_in">mSendingMessage</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mPolling</span>(<span class="literal">false</span>), <span class="built_in">mEpollFd</span>(<span class="number">-1</span>), <span class="built_in">mEpollRebuildRequired</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mNextRequestSeq</span>(<span class="number">0</span>), <span class="built_in">mResponseIndex</span>(<span class="number">0</span>), <span class="built_in">mNextMessageUptime</span>(LLONG_MAX) &#123;</span><br><span class="line">    mWakeEventFd = <span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK); <span class="comment">// 创建eventfd</span></span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mWakeEventFd &lt; <span class="number">0</span>, <span class="string">&quot;Could not make wake event fd.  errno=%d&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="built_in">rebuildEpollLocked</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">&quot;%p ~ wake&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nWrite = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">write</span>(mWakeEventFd, &amp;inc, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>))); <span class="comment">// 写入数字1</span></span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Could not write wake signal, errno=%d&quot;</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Looper的构造函数中mWakeEventFd已经由之前提到的pipe换成了evnentfd，wake()函数也不是之前的写入一个“w”字符，而是写入了一个64位整数1。</p>
<p>从pipe到eventfd可以看出，即使在Android源码级别，也是在不断更迭代码，往更简单更高效的方向在努力和优化。</p>
<h1 id="4-屏幕刷新机制与消息机制的结合运作"><a href="#4-屏幕刷新机制与消息机制的结合运作" class="headerlink" title="4. 屏幕刷新机制与消息机制的结合运作"></a>4. 屏幕刷新机制与消息机制的结合运作</h1><p>关于Android屏幕刷新机制原理，强烈推荐这篇：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1685247">“终于懂了” 系列：Android屏幕刷新机制—VSync、Choreographer 全面理解！</a></p>
<p>在这一系列文章中，屏幕刷新机制感兴趣的看上面的文章，这里我们重点关注<strong>屏幕刷新绘制与消息机制是怎么结合运作的</strong>？</p>
<h2 id="4-1-绘制入口"><a href="#4-1-绘制入口" class="headerlink" title="4.1 绘制入口"></a>4.1 绘制入口</h2><p><strong>所有UI的变化最终都是走到ViewRootImpl的scheduleTraversals()方法</strong>，那么scheduleTraversals()到performTraversals()中间经历了什么呢？是立刻执行吗？答案很显然是否定的，只有在VSync信号到来时才会执行绘制，即performTraversals()方法。</p>
<p>下面就从源码角度分析这是如何实现的：</p>
<p><strong>frameworks/base/core/java/android/view/ViewRootImpl.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 发送消息屏障，屏蔽同步消息，从而保证VSync到来立即执行绘制</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">// TraversalRunnable是内部类，会走run()方法，最终执行doTraversal()方法</span></span><br><span class="line">        <span class="comment">// 注意这里的callback类型是CALLBACK_TRAVERSAL</span></span><br><span class="line">        mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 移除同步屏障</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(<span class="string">&quot;ViewAncestor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始三大绘制流程</span></span><br><span class="line">        performTraversals();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下scheduleTraversals()方法到performTraversals()方法的流程：</p>
<blockquote>
<p>a. 发送消息屏障，屏蔽同步消息，从而保证VSYNC信号到来时可被立即执行<br>b. mChoreographer.postCallback()方法投递mTraversalRunnable，其消息类型是CALLBACK_TRAVERSAL<br>c. 执行mTraversalRunnable的run()方法，移除屏障，并执行performTraversals()方法</p>
</blockquote>
<p>上面只是大致流程，这里还有一些疑问点：</p>
<blockquote>
<p>a. VSYNC信号是怎么到来的，是怎样跟消息机制结合的？<br>b. mChoreographer.postCallback()发送的CALLBACK_TRAVERSAL代表什么含义？<br>c. mTraversalRunnable的run()方法是怎么被调起执行的？</p>
</blockquote>
<p>带着这些问题继续看下面的分析。</p>
<h2 id="4-2-Choreographer与FrameHandler结合"><a href="#4-2-Choreographer与FrameHandler结合" class="headerlink" title="4.2 Choreographer与FrameHandler结合"></a>4.2 Choreographer与FrameHandler结合</h2><p>在ViewRootImpl的构造函数中会获取Choreographer实例，在Choreographer的构造函数中会创建FrameHandler实例，所以Choreographer与FrameHandler结合在于其构造函数，同时利用FrameHandler将VSYNC信号到来时的消息同步到主线程中。</p>
<p><strong>frameworks/base/core/java/android/view/Choreographer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Choreographer</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper); <span class="comment">// 创建FrameHandler实例</span></span><br><span class="line">    <span class="comment">//USE_VSYNC 4.1以上默认是true，表示具备接受VSync的能力，这个接受能力就是FrameDisplayEventReceiver</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource) <span class="comment">// vsync信号接收器</span></span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算一帧的时间，Android手机屏幕是60Hz的刷新频率，就是16ms</span></span><br><span class="line">    mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个链表类型CallbackQueue的数组，大小为5，</span></span><br><span class="line">    <span class="comment">//也就是数组中有五个链表，每个链表存相同类型的任务：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL）</span></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b/68769804: For low FPS experiments.</span></span><br><span class="line">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Choreographer中的CALLBACK类型总共是5类，分别是：输入、动画、插入更新动画、布局和绘制、提交</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Callback type: Input callback.  Runs first.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_INPUT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Callback type: Animation callback.  Runs before &#123;<span class="doctag">@link</span> #CALLBACK_INSETS_ANIMATION&#125;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_ANIMATION</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Callback type: Animation callback to handle inset updates. This is separate from</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #CALLBACK_ANIMATION&#125; as we need to &quot;gather&quot; all inset animation updates via</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> WindowInsetsAnimationController#setInsetsAndAlpha(Insets, float, float)&#125; for multiple</span></span><br><span class="line"><span class="comment">* ongoing animations but then update the whole view system with a single callback to</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> View#dispatchWindowInsetsAnimationProgress&#125; that contains all the combined updated</span></span><br><span class="line"><span class="comment">* insets.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* Both input and animation may change insets, so we need to run this after these callbacks, but</span></span><br><span class="line"><span class="comment">* before traversals.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* Runs before traversals.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_INSETS_ANIMATION</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Callback type: Traversal callback.  Handles layout and draw.  Runs</span></span><br><span class="line"><span class="comment">* after all other asynchronous messages have been handled.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_TRAVERSAL</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Callback type: Commit callback.  Handles post-draw operations for the frame.</span></span><br><span class="line"><span class="comment">* Runs after traversal completes.  The &#123;<span class="doctag">@link</span> #getFrameTime() frame time&#125; reported</span></span><br><span class="line"><span class="comment">* during this callback may be updated to reflect delays that occurred while</span></span><br><span class="line"><span class="comment">* traversals were in progress in case heavy layout operations caused some frames</span></span><br><span class="line"><span class="comment">* to be skipped.  The frame time reported during this callback provides a better</span></span><br><span class="line"><span class="comment">* estimate of the start time of the frame in which animations (and other updates</span></span><br><span class="line"><span class="comment">* to the view hierarchy state) actually took effect.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_COMMIT</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_LAST</span> <span class="operator">=</span> CALLBACK_COMMIT;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>五种类型任务存入对应的CallbackQueue中，每当收到VSYNC信号时，Choreographer将首先处理INPUT类型的任务，然后是ANIMATION类型，最后才是TRAVERSAL类型。</p>
<p>现在回头看mChoreographer.postCallback()，最终会进入到scheduleVsyncLocked()方法中，通过mDisplayEventReceiver.scheduleVsync()申请vsync信号。</p>
<p><strong>frameworks/base/core/java/android/view/Choreographer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayedInternal</span><span class="params">(<span class="type">int</span> callbackType, Object action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">// 延迟时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dueTime</span> <span class="operator">=</span> now + delayMillis;</span><br><span class="line">        <span class="comment">// 取对应类型的CallbackQueue添加任务</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            <span class="comment">// 立即执行</span></span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 延迟运行，最终也会走到scheduleFrameLocked()</span></span><br><span class="line">            <span class="comment">// mHandler就是FrameHandler实例</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>); <span class="comment">// 设置成异步</span></span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FrameHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_FRAME:</span><br><span class="line">                <span class="comment">// 布局和绘制过程</span></span><br><span class="line">                doFrame(System.nanoTime(), <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">DisplayEventReceiver</span>.VsyncEventData());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                <span class="comment">// 申请VSYNC信号，例如当前需要绘制任务时</span></span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                <span class="comment">// 需要延迟的任务，最终还是执行上述两个事件</span></span><br><span class="line">                doScheduleCallback(msg.arg1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doScheduleCallback</span><span class="params">(<span class="type">int</span> callbackType)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class="line">                scheduleFrameLocked(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleFrameLocked</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 开启了VSYNC</span></span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前执行的线程，是否是mLooper所在线程</span></span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                <span class="comment">// 申请VSYNC信号</span></span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="literal">true</span>); <span class="comment">// 异步消息</span></span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">nextFrameTime</span> <span class="operator">=</span> Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果未开启VSYNC则直接doFrame方法（4.1后默认开启）</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleVsyncLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Choreographer#scheduleVsyncLocked&quot;</span>);</span><br><span class="line">        <span class="comment">// vsync信号接收器</span></span><br><span class="line">        mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FrameHandler的作用很明显里了</p>
<blockquote>
<p>a. 发送异步消息(因为前面设置了同步屏障)<br>b. 有延迟的任务发延迟消息<br>c. 不在原线程的切换到原线程<br>d. 没开启VSYNC的直接走doFrame方法取执行绘制</p>
</blockquote>
<p>总结下Choreographer与FrameHandler结合这一小节</p>
<blockquote>
<p>a. 如果系统未开启VSYNC机制，此时直接发送MSG_DO_FRAME消息到FrameHandler执行doFrame()方法<br>b. Android4.1之后系统默认开启VSYNC，最终通过scheduleVsyncLocked()方法申请VSYNC信号<br>c. 如果当前不在原线程，通过FrameHandler切换到主线程，最终还是调用scheduleVsyncLocked()方法申请VSYNC信号</p>
</blockquote>
<h2 id="4-3-申请vsync信号后的执行流程"><a href="#4-3-申请vsync信号后的执行流程" class="headerlink" title="4.3 申请vsync信号后的执行流程"></a>4.3 申请vsync信号后的执行流程</h2><p>通过scheduleVsyncLocked()方法申请VSYNC信号最终会来到DisplayEventReceiver中的scheduleVsync()方法，内部会调用 nativeScheduleVsync()方法，在DisplayEventReceiver的构造函数中会注册VSYNC信号监听者mReceiverPtr，当VSYNC信号到来时，会回调onVsync()方法。下面整理出源码的调用路径：</p>
<p><strong>frameworks/base/core/java/android/view/DisplayEventReceiver.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeScheduleVsync</span><span class="params">(<span class="type">long</span> receiverPtr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource, <span class="type">int</span> eventRegistration)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;looper must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    <span class="comment">// 注册VSYNC信号监听者</span></span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class="built_in">this</span>), mMessageQueue,</span><br><span class="line">            vsyncSource, eventRegistration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleVsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class="line">                + <span class="string">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 申请VSYNC中断信号，会回调onVsync方法</span></span><br><span class="line">        nativeScheduleVsync(mReceiverPtr); <span class="comment">// mReceiverPtr是VSYNC信号监听者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame,</span></span><br><span class="line"><span class="params">        VsyncEventData vsyncEventData)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onVsync的实现在FrameDisplayEventReceiver类中，最终会执行doFrame()方法</p>
<p><strong>frameworks/base/core/java/android/view/Choreographer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame,</span></span><br><span class="line"><span class="params">        VsyncEventData vsyncEventData)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW,</span><br><span class="line">                    <span class="string">&quot;Choreographer#onVsync &quot;</span> + vsyncEventData.id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">        <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">        <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">        <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">        <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">                    + <span class="string">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class="line">                    + <span class="string">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class="line">            timestampNanos = now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class="line">                    + <span class="string">&quot;one at a time.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mHavePendingVsync = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mTimestampNanos = timestampNanos;</span><br><span class="line">        mFrame = frame;</span><br><span class="line">        mLastVsyncEventData = vsyncEventData;</span><br><span class="line">        <span class="comment">// 将本身作为runnable传入msg， 发消息后等待执行</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>); <span class="comment">// 异步消息</span></span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当MessageQueue轮询到该消息后，会走run()方法，最终会调用doFrame()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">    doFrame(mTimestampNanos, mFrame, mLastVsyncEventData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame, DisplayEventReceiver.VsyncEventData vsyncEventData)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> startNanos;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">frameIntervalNanos</span> <span class="operator">=</span> vsyncEventData.frameInterval;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            ... </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">                traceMessage(<span class="string">&quot;Frame not scheduled&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ... </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 预计执行时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">intendedFrameTimeNanos</span> <span class="operator">=</span> frameTimeNanos;</span><br><span class="line">            startNanos = System.nanoTime();</span><br><span class="line">            <span class="comment">// 超时时间是否超过一帧</span></span><br><span class="line">            <span class="comment">// 这是因为MessageQueue虽然添加了同步屏障，但还是有正在执行的同步任务，导致doFrame()延迟执行了</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> startNanos - frameTimeNanos;</span><br><span class="line">            <span class="keyword">if</span> (jitterNanos &gt;= frameIntervalNanos) &#123;</span><br><span class="line">                <span class="comment">// 计算掉帧数</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">skippedFrames</span> <span class="operator">=</span> jitterNanos / frameIntervalNanos;</span><br><span class="line">                <span class="comment">// 掉帧数超过30，打印日志</span></span><br><span class="line">                <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Skipped &quot;</span> + skippedFrames + <span class="string">&quot; frames!  &quot;</span></span><br><span class="line">                            + <span class="string">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lastFrameOffset</span> <span class="operator">=</span> jitterNanos % frameIntervalNanos;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Missed vsync by &quot;</span> + (jitterNanos * <span class="number">0.000001f</span>) + <span class="string">&quot; ms &quot;</span></span><br><span class="line">                            + <span class="string">&quot;which is more than the frame interval of &quot;</span></span><br><span class="line">                            + (frameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">&quot; ms!  &quot;</span></span><br><span class="line">                            + <span class="string">&quot;Skipping &quot;</span> + skippedFrames + <span class="string">&quot; frames and setting frame &quot;</span></span><br><span class="line">                            + <span class="string">&quot;time to &quot;</span> + (lastFrameOffset * <span class="number">0.000001f</span>) + <span class="string">&quot; ms in the past.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Frame time appears to be going backwards.  May be due to a &quot;</span></span><br><span class="line">                            + <span class="string">&quot;previously skipped frame.  Waiting for next vsync.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                traceMessage(<span class="string">&quot;Frame time goes backward&quot;</span>);</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mFPSDivisor &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">timeSinceVsync</span> <span class="operator">=</span> frameTimeNanos - mLastFrameTimeNanos;</span><br><span class="line">                <span class="keyword">if</span> (timeSinceVsync &lt; (frameIntervalNanos * mFPSDivisor) &amp;&amp; timeSinceVsync &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    traceMessage(<span class="string">&quot;Frame skipped due to FPSDivisor&quot;</span>);</span><br><span class="line">                    scheduleVsyncLocked();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos, vsyncEventData.id,</span><br><span class="line">                    vsyncEventData.frameDeadline, startNanos, vsyncEventData.frameInterval);</span><br><span class="line">            <span class="comment">// Frame标志位恢复</span></span><br><span class="line">            mFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 记录最后一帧时间</span></span><br><span class="line">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">            mLastFrameIntervalNanos = frameIntervalNanos;</span><br><span class="line">            mLastVsyncEventData = vsyncEventData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按类型顺序执行任务</span></span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        <span class="comment">// 输入类型</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos, frameIntervalNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        <span class="comment">// 动画类型</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos, frameIntervalNanos);</span><br><span class="line">        <span class="comment">// 动画更新类型</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos,</span><br><span class="line">                frameIntervalNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        <span class="comment">// 布局和绘制</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos, frameIntervalNanos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos, frameIntervalNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doCallbacks</span><span class="params">(<span class="type">int</span> callbackType, <span class="type">long</span> frameTimeNanos, <span class="type">long</span> frameIntervalNanos)</span> &#123;</span><br><span class="line">    CallbackRecord callbacks;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">// 根据指定类型查找到达执行时间的CallbackRecord</span></span><br><span class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS;</span><br><span class="line">        <span class="keyword">if</span> (callbacks == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCallbacksRunning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务类型</span></span><br><span class="line">        <span class="keyword">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> now - frameTimeNanos;</span><br><span class="line">            <span class="keyword">if</span> (jitterNanos &gt;= <span class="number">2</span> * frameIntervalNanos) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lastFrameOffset</span> <span class="operator">=</span> jitterNanos % frameIntervalNanos + frameIntervalNanos;</span><br><span class="line">                frameTimeNanos = now - lastFrameOffset;</span><br><span class="line">                mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历执行所有任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">CallbackRecord</span> <span class="variable">c</span> <span class="operator">=</span> callbacks; c != <span class="literal">null</span>; c = c.next) &#123;</span><br><span class="line">            <span class="comment">// 回调run()方法，内部回调Callback类型的run()</span></span><br><span class="line">            c.run(frameTimeNanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mCallbacksRunning = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">CallbackRecord</span> <span class="variable">next</span> <span class="operator">=</span> callbacks.next;</span><br><span class="line">                <span class="comment">// 回收CallbackRecord</span></span><br><span class="line">                recycleCallbackLocked(callbacks); </span><br><span class="line">                callbacks = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (callbacks != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CallbackRecord</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> CallbackRecord next;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> dueTime;</span><br><span class="line">    <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">    <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">             <span class="comment">// 通过postFrameCallback或postFrameCallbackDelayed会执行这里</span></span><br><span class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行Runnable的run()</span></span><br><span class="line">            ((Runnable)action).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前面看到mChoreographer.postCallback传的token是null，所以取出action就是Runnable，执行run()，这里的action就是 ViewRootImpl发起的绘制任务mTraversalRunnable了，那么这样整个逻辑就闭环了。</p>
<p>下面整理了完整的流程图：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2022/code/2022-02-18-combination-of-screen-refresh-mechanism-and-message-mechanism.png?raw=true" alt="2022-02-18-屏幕刷新机制与消息机制的结合运作.png"></p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>Handler机制全面解析系列共3篇终于完成了。</p>
<p><a href="https://leeeyou.github.io/iBlogWebsite/2021/12/01/2021/2021-12-01-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%901/">2021-12-01-⎡稳扎稳打系列⎦：Handler机制全面解析1.md</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2021/12/16/2021/2021-12-16-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%902/">2021-12-16-⎡稳扎稳打系列⎦：Handler机制全面解析2.md</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2022/02/18/2022/2022-02-18-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%903/">2022-02-18-⎡稳扎稳打系列⎦：Handler机制全面解析3.md</a></p>
<p>系列开篇分析了Handler的运行机制，ActivityThread、Handler、Looper、MessageQueue之间关系，Message的类型，消息分发回调的优先级是怎样的以及Handler的内存泄漏。这些都是Handler机制的核心基础知识，比如Message的类型这一点，之前自己是不清楚的，导致对于全面理解机制原理是很困难的，系统怎么保证某类消息优先执行，为什么业务层传的Message其target不能为空等问题其实都跟Message的类型有关。</p>
<p>打通知识连贯性是很重要的，知识点不应该是一个一个单独的，而是相互关连相互牵扯的。再比如消息分发回调的优先级，在某些插件化方案中，这里Callback作为Hook点被使用，所以消息机制跟插件化有了关连关系。试想如果对消息机制不清楚的话，插件话开发找hook点怎么可能想到这里？</p>
<p>在第二篇中主要是分析了“存消息”和“取消息”的源码和原理，这里涉及到Java和Native两个世界的协同工作，而MessageQueue就是它们协作的桥梁。在看源码过程中，看到Looper取消息是一个死循环，进而分析了死循环的意义。“存消息”和“取消息”的过程涉及唤醒和等待，这里就牵扯出了epoll机制以及IPC机制。在Android6.0以下版本中，主线程Looper的唤醒就使用到了管道。到了Android6.0之后，Looper的唤醒就换成了eventfd。这便是IPC机制的变迁和升级。</p>
<p>在最后一篇中，先是分析了两个小问题：延时消息的原理以及IdleHandler的作用和原理，这两块算是自己的知识盲区，这里疏通了。最后其实我一直有个疑问就是：屏幕刷新绘制到底是怎么被通知和执行的呢？都知道绘制是从performTraversals()开始进行三大绘制流程，那么它本身是如何被调起执行的？VSYNC信号是怎么产生并给到主线程的？主线程收到信号后是怎么组织代码进行一系列处理的？这些问题在最后一篇的最后一节进行了全过程分析。这一部分也有全流程图供查阅源码时参考。</p>
<p>写完三篇文章后，自己对Handler机制的知识点有了大致的把握，后续如有需要再更新和完善吧。</p>
<hr>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1685247">“终于懂了” 系列：Android屏幕刷新机制—VSync、Choreographer 全面理解！</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/iBlogWebsite/tags/Handler/" rel="tag"># Handler</a>
              <a href="/iBlogWebsite/tags/%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97/" rel="tag"># 稳扎稳打系列</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/iBlogWebsite/2021/12/16/2021/2021-12-16-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%902/" rel="prev" title="⎡稳扎稳打系列⎦：Handler机制全面解析2(2/3)">
      <i class="fa fa-chevron-left"></i> ⎡稳扎稳打系列⎦：Handler机制全面解析2(2/3)
    </a></div>
      <div class="post-nav-item">
    <a href="/iBlogWebsite/2022/12/02/2022/2022-12-02-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2hexo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="next" title="个人博客hexo环境搭建">
      个人博客hexo环境搭建 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">1. 延时消息的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E6%98%AF%E6%80%8E%E6%A0%B7%E5%85%A5%E9%98%9F%E5%88%97%E7%9A%84%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 延时消息是怎样入队列的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A2%AB%E5%94%A4%E9%86%92%E5%B9%B6%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 延时消息是怎样被唤醒并执行的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-IdleHandler%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">2. IdleHandler的作用和原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Android%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E4%B8%ADIPC%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E8%BF%81"><span class="nav-number">3.</span> <span class="nav-text">3. Android消息通信机制中IPC方式的变迁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E7%AE%A1%E9%81%93"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-eventfd"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 eventfd</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%B1%8F%E5%B9%95%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BB%93%E5%90%88%E8%BF%90%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">4. 屏幕刷新机制与消息机制的结合运作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E7%BB%98%E5%88%B6%E5%85%A5%E5%8F%A3"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 绘制入口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Choreographer%E4%B8%8EFrameHandler%E7%BB%93%E5%90%88"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 Choreographer与FrameHandler结合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E7%94%B3%E8%AF%B7vsync%E4%BF%A1%E5%8F%B7%E5%90%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 申请vsync信号后的执行流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">5. 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liyou"
      src="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
  <p class="site-author-name" itemprop="name">Liyou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/iBlogWebsite/archives/">
        
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/iBlogWebsite/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/iBlogWebsite/tags/">
          
        <span class="site-state-item-count">74</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Leeeyou" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Leeeyou" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liyou</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/iBlogWebsite/lib/anime.min.js"></script>
  <script src="/iBlogWebsite/lib/velocity/velocity.min.js"></script>
  <script src="/iBlogWebsite/lib/velocity/velocity.ui.min.js"></script>

<script src="/iBlogWebsite/js/utils.js"></script>

<script src="/iBlogWebsite/js/motion.js"></script>


<script src="/iBlogWebsite/js/schemes/muse.js"></script>


<script src="/iBlogWebsite/js/next-boot.js"></script>




  




  
<script src="/iBlogWebsite/js/local-search.js"></script>













  

  

</body>
</html>
