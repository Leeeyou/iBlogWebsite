<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/iBlogWebsite/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/iBlogWebsite/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/iBlogWebsite/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/iBlogWebsite/images/logo.svg" color="#222">

<link rel="stylesheet" href="/iBlogWebsite/css/main.css">


<link rel="stylesheet" href="/iBlogWebsite/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"leeeyou.github.io","root":"/iBlogWebsite/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Liyou">
<meta property="og:url" content="https://leeeyou.github.io/iBlogWebsite/page/4/index.html">
<meta property="og:site_name" content="Liyou">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liyou">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://leeeyou.github.io/iBlogWebsite/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Liyou</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/iBlogWebsite/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Liyou</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/iBlogWebsite/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/iBlogWebsite/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/iBlogWebsite/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/iBlogWebsite/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2018/09/17/2018/2018-09-17-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part2%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Liyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liyou">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2018/09/17/2018/2018-09-17-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part2%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">JVM系列之对象-Part2布局</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-17 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-17T00:00:00+08:00">2018-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对象的布局其实就是对象在虚拟机中的组成部分。在Hotspot虚拟机中，对象分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>对象头包括两部分信息：对象自身的运行时数据（官方称它为“Mark Word”）以及类型指针。</p>
<p>对象自身的运行时数据包含：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit。需要注意的是对象头信息是与对象自身定义的数据无关的额外存储成本。</p>
<p>类型指针是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，可以理解为对象的实例信息（即下文的oops）。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。</p>
<p>实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。Hotspot虚拟机默认的分配策略为：longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true，那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于Hotspot VM的自动内存管理系统要求对象其实地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<p>下面通过一个详细的例子说明JVM的分配策略以及对齐填充，以加深对象的布局理解。通过Unsafe拿到对象属性的offset与Instrumentation计算的大小对比是否一致，如下所以一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.javamex.classmexer.MemoryUtil;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SizeOfUnsafe</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String s; <span class="comment">//4</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> i;<span class="comment">//4</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> b;<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">double</span> d;<span class="comment">//8</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> b2;<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">private</span> Score obj;<span class="comment">//4</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> b3;<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> i2;<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        byUnsafe();</span><br><span class="line">        byInstrumentation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">byUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field[] declaredFields = Person.class.getDeclaredFields();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;定义顺序&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Field f : declaredFields) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;field &quot;</span> + f.getName() + <span class="string">&quot; \t offset : &quot;</span> + unsafe.objectFieldOffset(f) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;重排顺序&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Arrays.sort(declaredFields, (left, right) -&gt; Math.toIntExact(unsafe.objectFieldOffset(left) - unsafe.objectFieldOffset(right)));</span><br><span class="line">            <span class="keyword">for</span> (Field f : declaredFields) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;field &quot;</span> + f.getName() + <span class="string">&quot; \t offset : &quot;</span> + unsafe.objectFieldOffset(f) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">byInstrumentation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Shallow Size : 对象自身占用的内存大小，不包括它引用的对象。针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。针对数组类型的对象，它的大小是数组元素对象的大小总和。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Shallow Size: &quot;</span> + MemoryUtil.memoryUsageOf(person) + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Retained Size : 当前对象大小+当前对象可直接或间接引用到的对象的大小总和。(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Retained Size: &quot;</span> + MemoryUtil.deepMemoryUsageOf(person) + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果如下所示，可以看到重排顺序offset是36，加上4个字节即36 + 4 = 40 bytes，同Instrumentation计算出来的40 bytes一致。运行Instrumentation时，我这里采用了 <a target="_blank" rel="noopener" href="https://www.javamex.com/classmexer/classmexer-0_03.zip">classmexer-0_03.zip</a> 这个jar包来帮我统计大小。我采用IntelliJ运行，需要添加一下jvm的运行时参数 <strong>-javaagent:classmexer.jar</strong>，如下图所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">定义顺序</span><br><span class="line">field s 	 offset : <span class="number">32</span>	</span><br><span class="line">field i 	 offset : <span class="number">12</span>	</span><br><span class="line">field b 	 offset : <span class="number">28</span>	</span><br><span class="line">field d 	 offset : <span class="number">16</span>	</span><br><span class="line">field b2 	 offset : <span class="number">29</span>	</span><br><span class="line">field obj 	 offset : <span class="number">36</span>	</span><br><span class="line">field b3 	 offset : <span class="number">30</span>	</span><br><span class="line">field i2 	 offset : <span class="number">24</span>	</span><br><span class="line"></span><br><span class="line">重排顺序</span><br><span class="line">field i 	 offset : <span class="number">12</span>	</span><br><span class="line">field d 	 offset : <span class="number">16</span>	</span><br><span class="line">field i2 	 offset : <span class="number">24</span>	</span><br><span class="line">field b 	 offset : <span class="number">28</span>	</span><br><span class="line">field b2 	 offset : <span class="number">29</span>	</span><br><span class="line">field b3 	 offset : <span class="number">30</span>	</span><br><span class="line">field s 	 offset : <span class="number">32</span>	</span><br><span class="line">field obj 	 offset : <span class="number">36</span>	</span><br><span class="line"></span><br><span class="line">Shallow Size: <span class="number">40</span> bytes</span><br><span class="line">Retained Size: <span class="number">40</span> bytes</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/jvm-object-object-layout-analysis.png?raw=true" alt="jvm-object-object-layout-analysis"></p>
<p>下面分析未采用分配策略与采用了分配策略之间的区别，针对上述代码中的Person对象，如果未采用分配策略，直接分配内存，在内存中的布局如下所示，有9个对齐位，可以看到需要用到48 bytes：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[HEADER:   <span class="number">8</span> bytes]  <span class="number">8</span></span><br><span class="line">[oops:     <span class="number">4</span> bytes]  <span class="number">12</span></span><br><span class="line">[s:        <span class="number">4</span> bytes]  <span class="number">16</span></span><br><span class="line">[i:        <span class="number">4</span> bytes]  <span class="number">20</span></span><br><span class="line">[b:        <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">21</span></span><br><span class="line">[padding:  <span class="number">3</span> bytes]  <span class="number">24</span></span><br><span class="line">[d:        <span class="number">8</span> bytes]  <span class="number">32</span></span><br><span class="line">[b2:       <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">33</span></span><br><span class="line">[obj:      <span class="number">4</span> bytes]  <span class="number">37</span></span><br><span class="line">[b3:       <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">38</span></span><br><span class="line">[padding:  <span class="number">2</span> <span class="type">byte</span> ]  <span class="number">40</span></span><br><span class="line">[i2:       <span class="number">4</span> bytes]  <span class="number">44</span></span><br><span class="line">[padding:  <span class="number">4</span> <span class="type">byte</span> ]  <span class="number">48</span></span><br></pre></td></tr></table></figure>

<p>而采用分配策略后，按照longs/doubles、ints、shorts/chars、bytes/booleans、oops的顺序排列，在内存中的布局如下所示，只有1个对齐位，整体用到40 bytes，较上面的方式显然更加节省内存空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[HEADER:   <span class="number">8</span> bytes]  <span class="number">8</span></span><br><span class="line">[oops:     <span class="number">4</span> bytes]  <span class="number">12</span></span><br><span class="line">[i:        <span class="number">4</span> bytes]  <span class="number">16</span></span><br><span class="line">[d:        <span class="number">8</span> bytes]  <span class="number">24</span></span><br><span class="line">[i2:       <span class="number">4</span> bytes]  <span class="number">28</span></span><br><span class="line">[b:        <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">29</span></span><br><span class="line">[b2:       <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">30</span></span><br><span class="line">[b3:       <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">31</span></span><br><span class="line">[padding:  <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">32</span></span><br><span class="line">[s:        <span class="number">4</span> bytes]  <span class="number">36</span></span><br><span class="line">[obj:      <span class="number">4</span> bytes]  <span class="number">40</span></span><br></pre></td></tr></table></figure>

<p>另外关于对象头占用空间大小，这里说明一下32位系统和64位系统中对象所占用内存空间的大小：</p>
<ul>
<li>在32位系统下，存放Class Pointer的空间大小是4字节，MarkWord是4字节，对象头为8字节;</li>
<li>在64位系统下，存放Class Pointer的空间大小是8字节，MarkWord是8字节，对象头为16字节;</li>
<li>64位开启指针压缩的情况下，存放Class Pointer的空间大小是4字节，MarkWord是8字节，对象头为12字节;</li>
<li>如果是数组对象，对象头的大小为：数组对象头8字节+数组长度4字节+对齐4字节=16字节。其中对象引用占4字节（未开启指针压缩的64位为8字节），数组MarkWord为4字节（64位未开启指针压缩的为8字节）;</li>
<li>静态属性不算在对象大小内。</li>
</ul>
<hr>
<p>参考： </p>
<ol>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/91e398d5d17c">Java对象内存布局</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ITer_ZC/article/details/41822719">聊聊JVM（三）两种计算Java对象大小的方法</a></li>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/1305.html">Java对象内存结构</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2018/09/15/2018/2018-09-15-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part1%E5%88%9B%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Liyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liyou">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2018/09/15/2018/2018-09-15-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part1%E5%88%9B%E5%BB%BA/" class="post-title-link" itemprop="url">JVM系列之对象-Part1创建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-15T00:00:00+08:00">2018-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章讨论一个在Java语言层面来看非常简单的问题：怎样创建对象？通常仅仅一个 new 关键字而已，但是在虚拟机中，对象（特指普通对象，不包括数组对象和Class对象）的创建流程又是怎样的呢？</p>
<p>根据 <a target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a> 中的知识，我画出了虚拟机创建普通对象的流程如，如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/jvm-object-the-process-of-creating-common-objects-in-virtual-machines.png?raw=true" alt="jvm-object-the-process-of-creating-common-objects-in-virtual-machines"></p>
<p>虚拟机在遇到一条new指令时，首先会检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>在类加载检查通过后，接下来是虚拟机为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。Java堆是否规整决定了分配方式是 “指针碰撞” 还是 “空闲列表”。而Java堆是否规整依据的是GC的收集器采用的哪种分配算法，像Serial、ParNew等带整理算法的收集器，JVM会采用 “指针碰撞” 分配；而使用CMS这种标记-清除算法的收集器，JVM通常采用“空闲列表”分配。</p>
<ul>
<li><p>“指针碰撞”仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。因为所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器。</p>
</li>
<li><p>“空闲列表”是由于已使用内存和空间内存相互交错，虚拟机必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象示例，并更新列表上的记录。</p>
</li>
</ul>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>接下来虚拟机要对对象进行必要的设置，通俗说就是设置对象头：类的元数据信息、对象的哈希表、对象的GC分带年龄、是否启用偏斜锁等。后续会对对象头做详细介绍。</p>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——<init>方法还没有执行，所有的字段都还为零。所以，一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<hr>
<p>参考： </p>
<ol>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2018/09/14/2018/2018-09-14-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Liyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liyou">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2018/09/14/2018/2018-09-14-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" class="post-title-link" itemprop="url">JVM系列之内存区域</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-14 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-14T00:00:00+08:00">2018-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>下面这张图是结合《深入理解Java虚拟机2》以及《Java核心36讲》中的内容画出来的，理论上看算是比较详细的描述了JVM运行时内存区域。从图中可以看出主要包含了两部分：运行时数据区与其他数据区（主要指直接内存和Code Cache），而在运行时数据区中又分为线程隔离和线程共享。</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/jvm-runtime-memory-area.png?raw=true" alt="jvm-runtime-memory-area"></p>
<h1 id="1-运行时数据区"><a href="#1-运行时数据区" class="headerlink" title="1. 运行时数据区"></a>1. 运行时数据区</h1><h2 id="1-1-线程隔离"><a href="#1-1-线程隔离" class="headerlink" title="1.1. 线程隔离"></a>1.1. 线程隔离</h2><ul>
<li><p>程序计数器</p>
<p>程序计数器（PC，Program Counter Register）。在 JVM 规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。</p>
<p>该区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
</li>
<li><p>Java虚拟机栈</p>
<p>Java 虚拟机栈（Java Virtual Machine Stack）。每个线程在创建时都会创建一个虚拟机栈，它的生命周期与线程相同，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。</p>
<p>在一个时间点，对应的只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈。</p>
<p>栈帧中存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。栈帧结构详细说明可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/40043991">《Java虚拟机原理图解》3、JVM运行时数据区</a>。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展且无法申请到足够内存时，将会抛出OutOfMemoryError异常。</p>
</li>
<li><p>本地方法栈</p>
<p>本地方法栈（Native Method Stack）。它和 Java 虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个。在 Oracle Hotspot JVM 中，本地方法栈和 Java 虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
</li>
</ul>
<h2 id="1-2-线程共享"><a href="#1-2-线程共享" class="headerlink" title="1.2. 线程共享"></a>1.2. 线程共享</h2><ul>
<li><p>堆</p>
<p>堆（Heap），它是 Java 内存管理的核心区域，用来放置 Java 对象实例，几乎所有创建的 Java 对象实例都是被直接分配在堆上，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有对象都在堆上分配变得不是那么绝对了。堆被所有的线程共享，在虚拟机启动时，我们指定的 “Xmx” 之类参数就是用来指定最大堆空间等指标。理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。</p>
<p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
</li>
<li><p>方法区</p>
<p>方法区（Method Area）。这也是所有线程共享的一块内存区域，用于存储所谓的元（Meta）数据，例如类结构信息，以及对应的运行时常量池、类型信息、字段信息、方法信息、类变量、指向类加载器的引用、指向Class实例的引用、方法表等。由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK 8 中将永久代移除，同时增加了元数据区（Metaspace）。方法区结构的详细说明可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/40043991">《Java虚拟机原理图解》3、JVM运行时数据区</a>。</p>
<p>运行时常量池（Run-Time Constant Pool），这是方法区的一部分。如果仔细分析过反编译的类文件结构，你能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。Java 的常量池可以存放各种常量信息，<strong>不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</strong> 例如下面这段展示代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">testI</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="variable">testF</span> <span class="operator">=</span> <span class="number">1.234f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过javap命令后，观察它的常量池情况，第10行起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  D:\Project\IntellJ2\DemoIO\src&gt;javap -v ConstantTest.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Classfile</span> /D:/Project/IntellJ2/DemoIO/src/ConstantTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2018</span>-<span class="number">9</span>-<span class="number">14</span>; size <span class="number">337</span> bytes</span><br><span class="line">  MD5 checksum 4088cb12575ced51f0f0f09ac26c14ff</span><br><span class="line">  Compiled from <span class="string">&quot;ConstantTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantTest</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">5.</span>#<span class="number">19</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Float              <span class="number">1.234f</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">4.</span>#<span class="number">20</span>         <span class="comment">// ConstantTest.testF:F</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">21</span>            <span class="comment">// ConstantTest</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">22</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">6</span> = Utf8               testI</span><br><span class="line">   #<span class="number">7</span> = Utf8               I</span><br><span class="line">   #<span class="number">8</span> = Utf8               ConstantValue</span><br><span class="line">   #<span class="number">9</span> = Integer            <span class="number">1</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               testF</span><br><span class="line">  #<span class="number">11</span> = Utf8               F</span><br><span class="line">  #<span class="number">12</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">13</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">14</span> = Utf8               Code</span><br><span class="line">  #<span class="number">15</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">16</span> = Utf8               &lt;clinit&gt;</span><br><span class="line">  #<span class="number">17</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">18</span> = Utf8               ConstantTest.java</span><br><span class="line">  #<span class="number">19</span> = NameAndType        #<span class="number">12</span>:#<span class="number">13</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">20</span> = NameAndType        #<span class="number">10</span>:#<span class="number">11</span>        <span class="comment">// testF:F</span></span><br><span class="line">  #<span class="number">21</span> = Utf8               ConstantTest</span><br><span class="line">  #<span class="number">22</span> = Utf8               java/lang/Object</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2-其他数据区"><a href="#2-其他数据区" class="headerlink" title="2. 其他数据区"></a>2. 其他数据区</h1><h2 id="2-1-直接内存"><a href="#2-1-直接内存" class="headerlink" title="2.1. 直接内存"></a>2.1. 直接内存</h2><p>直接内存（Direct Memory）区域并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分内存会被频繁地使用，而且也可能导致OutOfMemoryError异常。本机直接内存显然不会受到Java堆大小的限制，但肯定还是会受到本机总内存大小以及处理器寻址控件的限制。</p>
<p>在JDK1.4中新引入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用操作，从而避免了Java堆和Native堆中来回复制数据的麻烦。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-12-jiang-java-you-ji-zhong-wen-jian-kao-bei-fang-shi-ff1f-na-yi-zhong-zui-gao-xiao-ff1f.md">第12讲 | Java有几种文件拷贝方式？哪一种最高效？</a> 这篇文章详细介绍了拷贝的实现机制以及NIO的特性，建议阅读以加深对DirectMemory的理解。</p>
<h2 id="2-2-Code-Cache等区域"><a href="#2-2-Code-Cache等区域" class="headerlink" title="2.2. Code Cache等区域"></a>2.2. Code Cache等区域</h2><p>JVM 本身是个本地程序，还需要其他的内存去完成各种基本任务，比如，JIT Compiler 在运行时对热点方法进行编译，就会将编译后的方法储存在 Code Cache 里面；GC 等功能需要运行在本地线程之中，类似部分都需要占用内存空间。这些是实现 JVM JIT 等功能的需要，但规范中并不涉及。</p>
<hr>
<p>参考： </p>
<ol>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-25-jiang-tan-tan-jvm-nei-cun-qu-yu-de-hua-fen-ff0c-na-xie-qu-yu-ke-neng-fa-sheng-outofmemoryerror.md">第25讲 | 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2018/08/29/2018/2018-08-29-Gradle%20for%20Android/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Liyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liyou">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2018/08/29/2018/2018-08-29-Gradle%20for%20Android/" class="post-title-link" itemprop="url">Gradle for Android</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-29T00:00:00+08:00">2018-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h1><h2 id="1-1-理解基本的Gradle"><a href="#1-1-理解基本的Gradle" class="headerlink" title="1.1. 理解基本的Gradle"></a>1.1. 理解基本的Gradle</h2><p>Gradle是一种构建工具，Gradle脚本不是像传统的xml文件那样，而是一种基于Groovy的动态DSL。</p>
<ul>
<li>DSL: 指的是用于一个特定领域的语言（功能领域、业务领域），可以简单理解成就是一个配置文件，或者说是面向领域的某种配置文件，如Ant的build.xml某种意义上就是Ant的DSL文件。</li>
<li>Groovy语言: 是一种基于jvm的动态语言.</li>
</ul>
<p>当我们把Gradle作为构建工具使用时，我们只需要掌握它的配置脚本的基本写法就OK了；而当我们需要对构建流程进行高度定制时，就务必要掌握Groovy等相关知识了。如果想开始创建自己的tasks和插件，那么你最好对Groovy有一个较深的理解。</p>
<h2 id="1-2-两个重要的概念"><a href="#1-2-两个重要的概念" class="headerlink" title="1.2. 两个重要的概念"></a>1.2. 两个重要的概念</h2><h3 id="1-2-1-Project"><a href="#1-2-1-Project" class="headerlink" title="1.2.1. Project"></a>1.2.1. Project</h3><p>每一个build.grade文件代表着一个project。每个project有至少一个tasks，一个apk文件的构建包含以下Task：Java源码编译、资源文件编译、Lint检查、打包以生成最终的apk文件等等。</p>
<p>每一次构建都是有至少一个project来完成，所以Android studio中的project和Gradle中的project不是一个概念但可以简单理解为：Android Studio中的一个Module即为Gradle中的一个Project。</p>
<h3 id="1-2-2-Tasks"><a href="#1-2-2-Tasks" class="headerlink" title="1.2.2. Tasks"></a>1.2.2. Tasks</h3><p>tasks在build.gradle中定义，当初始化构建进程时，gradle会基于build文件集合所有的project和tasks。一个tasks包含了一系列动作，然后它们将会按照顺序执行，一个动作就是一段被执行的代码，很像Java中的方法。</p>
<h2 id="1-3-构建的生命周期"><a href="#1-3-构建的生命周期" class="headerlink" title="1.3. 构建的生命周期"></a>1.3. <a target="_blank" rel="noopener" href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html">构建的生命周期</a></h2><p>初始化阶段：project实例在这儿创建，如果有多个模块，即有多个build.gradle文件，多个project将会被创建。</p>
<p>配置阶段：在该阶段，build.gradle脚本将会执行，为每个project创建和配置所有的tasks。</p>
<p>执行阶段：这一阶段，gradle会决定哪一个tasks会被执行，哪一个tasks会被执行完全依赖开始构建时传入的参数和当前所在的文件夹位置有关。</p>
<h2 id="1-4-Gradle工作流程"><a href="#1-4-Gradle工作流程" class="headerlink" title="1.4. Gradle工作流程"></a>1.4. Gradle工作流程</h2><p><img src="../../../../images/githubpages/gradle/Gradle%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="gradle工作流程"></p>
<p>首先是初始化阶段，就是执行settings.gradle。</p>
<p>Configration阶段的目标是解析每个project中的build.gradle，解析每个子目录中的build.gradle。在这两个阶段之间，我们可以加一些定制化的Hook。这当然是通过API来添加的。</p>
<p>Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。前面说过一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。所以我们可以添加一个HOOK，即当Task关系图建立好后，执行一些操作，另外不包含依赖的Tasks总是优先执行。</p>
<p>最后一个阶段就是执行任务了，当然任务执行完后，我们还可以加Hook。</p>
<h2 id="1-5-插件"><a href="#1-5-插件" class="headerlink" title="1.5. 插件"></a>1.5. 插件</h2><p>思考下为什么能在build.gradle中使用android标签？</p>
<p>因为应用”com.android.application”这个插件来构建app模块，如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:<span class="string">&#x27;com.android.application&#x27;</span></span><br></pre></td></tr></table></figure>

<p>整个插件中定义了如下4个顶级任务</p>
<ol>
<li>assemble: 构建项目的输出（apk）</li>
<li>check: 进行校验工作</li>
<li>build: 执行assemble任务与check任务</li>
<li>clean: 清除项目的输出</li>
</ol>
<p>还有一个插件是library，但不能同时使用他们2个，否则导致构建失败，一个模块要么使用Android application或者Android library插件，而不是二者。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:<span class="string">&#x27;com.android.library&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-6-使用Gradle-Wrapper"><a href="#1-6-使用Gradle-Wrapper" class="headerlink" title="1.6. 使用Gradle Wrapper"></a>1.6. 使用Gradle Wrapper</h2><p>grade只是一个构建工具，而新版本总是在更迭，所以使用Gradle Wrapper将会是一个好的选择去避免由于gradle版本更新导致的问题。</p>
<p>利用命令行./gradlew -v来查看当前gradle版本。</p>
<ul>
<li>gradlew是gradle wrapper的缩写，也就是说它对gradle的命令进行了包装</li>
<li>解压gradle-wrapper.jar看看</li>
</ul>
<p>在gradle-wrapper.properties中可以改变该url来改变你的gradle版本，如导入github项目跑不起来，可以尝试修改url。<a target="_blank" rel="noopener" href="https://services.gradle.org/distributions">参考</a></p>
<h1 id="2-基本配置"><a href="#2-基本配置" class="headerlink" title="2. 基本配置"></a>2. 基本配置</h1><h2 id="2-1-根目录的build-gradle"><a href="#2-1-根目录的build-gradle" class="headerlink" title="2.1. 根目录的build.gradle"></a>2.1. 根目录的build.gradle</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">     repositories &#123;</span><br><span class="line">         jcenter()</span><br><span class="line">     &#125;</span><br><span class="line">      dependencies &#123;</span><br><span class="line">          classpath <span class="string">&#x27;com.android.tools.build:gradle:1.2.3&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">     repositories &#123;</span><br><span class="line">          jcenter()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buildscript方法是定义了全局的相关属性，repositories定义了jcenter作为仓库，一个仓库代表着你的依赖包的来源。</p>
<p>allprojects方法可以用来定义各个模块的默认属性，你可以不仅仅局限于默认的配置，未来你可以自己创造tasks在allprojects方法体内，这些tasks将会在所有模块中可见。</p>
<h2 id="2-2-模块内的build-gradle"><a href="#2-2-模块内的build-gradle" class="headerlink" title="2.2. 模块内的build.gradle"></a>2.2. <a target="_blank" rel="noopener" href="http://apdr.qiniudn.com/index.html">模块内的build.gradle</a></h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载用于构建Android项目的插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line"></span><br><span class="line">android &#123; <span class="comment">//构建Android项目使用的配置</span></span><br><span class="line">    compileSdkVersion <span class="number">23</span> <span class="comment">//指定编译项目时使用的SDK版本</span></span><br><span class="line">    buildToolsVersion <span class="string">&quot;23.0.1&quot;</span> <span class="comment">//指定构建工具的版本</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.absfree.debugframwork&quot;</span> <span class="comment">//包名</span></span><br><span class="line">        minSdkVersion <span class="number">15</span>  <span class="comment">//指定支持的最小SDK版本</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span> <span class="comment">//针对的目标SDK版本</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123; <span class="comment">//针对不同的构建版本进行一些设置</span></span><br><span class="line">        release &#123; <span class="comment">//对release版本进行的设置</span></span><br><span class="line">            minifyEnabled <span class="literal">false</span> <span class="comment">//是否开启混淆</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span>  <span class="comment">//指定混淆文件的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123; <span class="comment">//指定当前模块的依赖</span></span><br><span class="line">    compile fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    testCompile <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;com.android.support:appcompat-v7:23.1.1&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;com.android.support:design:23.1.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性applicationId复写了AndroidManifest文件中的包名packagename，但是关于applicationId和package name有一些不同。package name在AndroidManifest.xml有两个作用：其作为一个app的唯一标示，并且其被用在了R资源文件的包名。</p>
<p>buildTypes方法定义了如何构建不同版本的app。<a target="_blank" rel="noopener" href="https://developer.android.com/studio/build/index.html">参考</a></p>
<h2 id="2-3-依赖管理"><a href="#2-3-依赖管理" class="headerlink" title="2.3. 依赖管理"></a>2.3. 依赖管理</h2><p>依赖模块作为gradle默认的属性之一（这也是为什么其放在了Android的外面），为你的app定义了所有的依赖包。</p>
<h3 id="2-3-1-依赖第三方库"><a href="#2-3-1-依赖第三方库" class="headerlink" title="2.3.1. 依赖第三方库"></a>2.3.1. 依赖第三方库</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">       compile <span class="string">&#x27;com.google.code.gson:gson:2.3&#x27;</span></span><br><span class="line">       compile <span class="string">&#x27;com.squareup.retrofit:retrofit:1.9.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个依赖需要定义三个元素：group，name和version。</p>
<ul>
<li>group意味着创建该library的组织名，通常这会是包名</li>
<li>name是该library的唯一标示</li>
<li>version是该library的版本号</li>
</ul>
<h3 id="2-3-2-依赖本地jar包"><a href="#2-3-2-依赖本地jar包" class="headerlink" title="2.3.2. 依赖本地jar包"></a>2.3.2. 依赖本地jar包</h3><p>默认情况下，我们依赖了所有在libs文件下的jar文件，同时包含了AppCompat这个aar文件。</p>
<h3 id="2-3-3-依赖其它模块"><a href="#2-3-3-依赖其它模块" class="headerlink" title="2.3.3. 依赖其它模块"></a>2.3.3. 依赖其它模块</h3><p>compile project(‘:other’)</p>
<h3 id="2-3-4-动态版本"><a href="#2-3-4-动态版本" class="headerlink" title="2.3.4. 动态版本"></a>2.3.4. 动态版本</h3><p>在一些情形中，在构建你的app或者library的时候通过动态版本能使用到最新的依赖包。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">       compile <span class="string">&#x27;com.android.support:support-v4:22.2.+&#x27;</span><span class="comment">//我们告诉gradle,得到最新的生产版本。  </span></span><br><span class="line">       compile <span class="string">&#x27;com.android.support:appcompat-v7:22.2+&#x27;</span><span class="comment">//我们告诉gradle，我们想得到最新的minor版本，并且其最小的版本号是2。</span></span><br><span class="line">       compile <span class="string">&#x27;com.android.support:recyclerview-v7:+&#x27;</span><span class="comment">//我们告诉gradle,得到最新的library。  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你应该小心去使用动态版本，如果当你允许gradle去挑选最新版本，可能导致挑选的依赖版本并不是稳定版，这将会对构建产生很多问题，更糟糕的是你可能在你的服务器和私人pc上得到不同的依赖版本，这直接导致你的应用不同步。</p>
<p>如果你在你的build.gradle中使用了动态版本，Android studio将会警告你关于动态版本的潜在问题。</p>
<p>关于版本号的介绍</p>
<ul>
<li><p>Apache组织的目标是将APR独立出来形成单独的第三方库，因此对其而言稳定的API接口就成为一个非常重要的必须考虑的方面。不过由于APR需要不断的往前方展，因此API接口的变化又是必然的趋势，因此如何平衡稳定性和变化性是APR开发者面临的一个极需解决的问题。为此APR采用了严格的版本规则来实现这一点。用户只需要简单的判断APR版本号，就可以很容易确定当前版本的兼容性：向前兼容、向后兼容还是前后同时兼容。</p>
</li>
<li><p>APR中使用三个整数来记录APR版本号：MAJOR.MINOR.PATCH。MAJOR表示当前APR的主版本号，它的变化通常意味着APR的巨大的变化，比如体系结构的重新设计，API的重新设计等等，而且这种变化通常会导致APR版本的向前不兼容。</p>
</li>
<li><p>MINOR称之为APR的次版本号，它通常只反映了一些较大的更改，比如APR的API的增加等等，但是这些更改并不影响与旧版本源代码和二进制代码之间的兼容性。</p>
</li>
<li><p>PATCH通常称之为补丁版本，通常情况下如果只是对APR函数的修改而不影响API接口的话都会导致PATCH的变化。</p>
</li>
</ul>
<h2 id="2-4-全局设置"><a href="#2-4-全局设置" class="headerlink" title="2.4. 全局设置"></a>2.4. 全局设置</h2><p>更好的做法是你在全局的gradle文件中定义一些属性，然后在模块中运用它们。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">       compileSdkVersion = <span class="number">22</span></span><br><span class="line">       buildToolsVersion = <span class="string">&quot;22.0.1&quot;</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">       compileSdkVersion rootProject.ext.compileSdkVersion</span><br><span class="line">       buildToolsVersion rootProject.ext.buildToolsVersion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-aar文件"><a href="#2-5-aar文件" class="headerlink" title="2.5. aar文件"></a>2.5. aar文件</h2><p>如果你想分享一个library，该依赖包使用了Android api，或者包含了Android资源文件，那么aar文件适合你。</p>
<p>应用工程和依赖工程的区别在于输出文件，应用工程会生成APK文件，并且其可以安装在Android设备上，而依赖工程会生成.aar文件，该文件可以被Android应用工程当做依赖来使用。</p>
<h1 id="3-构建变体"><a href="#3-构建变体" class="headerlink" title="3. 构建变体"></a>3. 构建变体</h1><h2 id="3-1-构建版本"><a href="#3-1-构建版本" class="headerlink" title="3.1. 构建版本"></a>3.1. 构建版本</h2><h3 id="3-1-1-创建自己的构建版本"><a href="#3-1-1-创建自己的构建版本" class="headerlink" title="3.1.1. 创建自己的构建版本"></a>3.1.1. 创建自己的构建版本</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">staging.initWith(buildTypes.debug)</span><br><span class="line">staging &#123;</span><br><span class="line">    applicationIdSuffix <span class="string">&quot;.staging&quot;</span></span><br><span class="line">    versionNameSuffix <span class="string">&quot;-staging&quot;</span></span><br><span class="line">    debuggable = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initWith()方法创建了一个新版本的同时，复制所有存在的构建版本，类似继承。我们也可以复写该存在版本的所有属性。</p>
<h3 id="3-1-2-Source-sets"><a href="#3-1-2-Source-sets" class="headerlink" title="3.1.2. Source sets"></a>3.1.2. Source sets</h3><p>nothing to show</p>
<h2 id="3-2-product-flavors"><a href="#3-2-product-flavors" class="headerlink" title="3.2. product flavors"></a>3.2. product flavors</h2><p>和构建版本不同，product flavors用来为一个app创建不同版本。典型的例子是，一个app有付费和免费版。</p>
<p>如果你不确定是否需要一个新的构建版本或者product flavors，你应该问你自己，你是否需要内部使用和外部使用的apk。如果你需要一个完全新的app去发布，和之前的版本完全隔离开，那么你需要product flavors，否则你只是需要构建版本。</p>
<p>创建product flavors</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        red &#123;</span><br><span class="line">             applicationId <span class="string">&#x27;com.gradleforandroid.red&#x27;</span></span><br><span class="line">             versionCode <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">        blue &#123;</span><br><span class="line">             applicationId <span class="string">&#x27;com.gradleforandroid.blue&#x27;</span></span><br><span class="line">             minSdkVersion <span class="number">14</span></span><br><span class="line">             versionCode <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Groovy入门介绍"><a href="#4-Groovy入门介绍" class="headerlink" title="4. Groovy入门介绍"></a>4. <a target="_blank" rel="noopener" href="http://www.groovy-lang.org/api.html">Groovy入门介绍</a></h1><h2 id="4-1-前提知识"><a href="#4-1-前提知识" class="headerlink" title="4.1. 前提知识"></a>4.1. 前提知识</h2><p>Groovy语句可以不用分号结尾。</p>
<p>Groovy中支持动态类型，即定义变量的时候可以不指定其类型。变量定义可以使用关键字def，注意虽然def不是必须的，但是为了代码清晰，建议还是使用def关键字。  </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> variable1 = <span class="number">1</span>   <span class="comment">//可以不使用分号结尾  </span></span><br><span class="line"><span class="keyword">def</span> varable2 = <span class="string">&quot;I ama person&quot;</span>  </span><br><span class="line"><span class="keyword">def</span>  <span class="type">int</span> x = <span class="number">1</span>  <span class="comment">//变量定义时，也可以直接指定类型  </span></span><br></pre></td></tr></table></figure>

<p>函数定义时，参数的类型也可以不指定。比如:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String testFunction(arg1,arg2)&#123;<span class="comment">//无需指定参数类型  </span></span><br><span class="line">  ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>除了变量定义可以不指定类型外，Groovy中函数的返回值也可以是无类型的。比如:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//无类型的函数定义，必须使用def关键字  </span></span><br><span class="line"><span class="keyword">def</span>  nonReturnTypeFunc()&#123;  </span><br><span class="line">    last_line   <span class="comment">//最后一行代码的执行结果就是本函数的返回值  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果指定了函数返回类型，则可不必加def关键字来定义函数  </span></span><br><span class="line">String getString()&#123;  </span><br><span class="line">   <span class="keyword">return</span><span class="string">&quot;I am a string&quot;</span>  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Groovy对字符串支持相当强大，充分吸收了一些脚本语言的优点。</p>
<p>单引号’’中的内容严格对应Java中的String，不对$符号进行转义：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defsingleQuote=<span class="string">&#x27;I am $ dolloar&#x27;</span>  <span class="comment">//输出就是I am $ dolloar </span></span><br></pre></td></tr></table></figure>

<p>双引号””的内容则和脚本语言的处理有点像，如果字符中有$号的话，则它会$表达式先求值：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">defdoubleQuoteWithoutDollar = <span class="string">&quot;I am one dollar&quot;</span> <span class="comment">//输出 I am one dollar  </span></span><br><span class="line"><span class="keyword">def</span> x = <span class="number">1</span>  </span><br><span class="line">defdoubleQuoteWithDollar = <span class="string">&quot;I am $x dolloar&quot;</span> <span class="comment">//输出I am 1 dolloar</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">三个引号<span class="string">&#x27;&#x27;&#x27;xxx&#x27;&#x27;&#x27;</span>中的字符串支持随意换行 比如</span><br><span class="line"></span><br><span class="line">```groovy</span><br><span class="line">defmultieLines = <span class="string">&#x27;&#x27;&#x27; begin  </span></span><br><span class="line"><span class="string">line  1  </span></span><br><span class="line"><span class="string">line  2  </span></span><br><span class="line"><span class="string">end &#x27;&#x27;&#x27;</span>  </span><br></pre></td></tr></table></figure>

<p>最后，除了每行代码不用加分号外，Groovy中函数调用的时候还可以不加括号。比如：  </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;test&quot;</span>) ---&gt; println<span class="string">&quot;test&quot;</span>  </span><br></pre></td></tr></table></figure>

<p>注意，虽然写代码的时候，对于函数调用可以不带括号，但是Groovy经常把属性和函数调用混淆。比如:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> getSomething()&#123;  </span><br><span class="line">  <span class="string">&quot;hello&quot;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数要不要带括号，我个人意见是如果这个函数是Groovy API或者Gradle API中比较常用的，比如println，就可以不带括号，否则还是带括号。</p>
<h2 id="4-2-Collections"><a href="#4-2-Collections" class="headerlink" title="4.2. Collections"></a>4.2. Collections</h2><p>List：链表，其底层对应Java中的List接口，一般用ArrayList作为真正的实现类。</p>
<p>Map：键-值表，其底层对应Java中的LinkedHashMap。</p>
<p>Range：范围，它其实是List的一种拓展。</p>
<h2 id="4-3-方法"><a href="#4-3-方法" class="headerlink" title="4.3. 方法"></a>4.3. 方法</h2><h3 id="4-3-1-闭包"><a href="#4-3-1-闭包" class="headerlink" title="4.3.1. 闭包"></a>4.3.1. 闭包</h3><p>闭包，英文叫Closure，是Groovy中非常重要的一个数据类型或者说一种概念了。</p>
<p>闭包，是一种数据类型，它代表了一段可执行的代码。其外形如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> aClosure = &#123;<span class="comment">//闭包是一段代码，所以需要用花括号括起来..  </span></span><br><span class="line">    String param1, <span class="type">int</span> param2 -&gt;  <span class="comment">//这个箭头很关键。箭头前面是参数定义，箭头后面是代码  </span></span><br><span class="line">    println<span class="string">&quot;this is code&quot;</span> <span class="comment">//这是代码，最后一句是返回值，  </span></span><br><span class="line">   <span class="comment">//也可以使用return，和Groovy中普通函数一样  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。比如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> greeting = &#123; <span class="string">&quot;Hello, $it!&quot;</span> &#125;</span><br><span class="line"><span class="keyword">assert</span> greeting(<span class="string">&#x27;Patrick&#x27;</span>) == <span class="string">&#x27;Hello, Patrick!&#x27;</span></span><br><span class="line"></span><br><span class="line">等同于：</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> greeting = &#123; it -&gt; <span class="string">&quot;Hello, $it!&quot;</span>&#125;</span><br><span class="line"><span class="keyword">assert</span> greeting(<span class="string">&#x27;Patrick&#x27;</span>) == <span class="string">&#x27;Hello, Patrick!&#x27;</span></span><br><span class="line"></span><br><span class="line">但是，如果在闭包定义时，采用下面这种写法，则表示闭包没有参数！</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> noParamClosure = &#123; -&gt; <span class="literal">true</span> &#125;</span><br><span class="line">这个时候，我们就不能给noParamClosure传参数了！</span><br><span class="line">noParamClosure (<span class="string">&quot;test&quot;</span>)  &lt;==报错喔！</span><br></pre></td></tr></table></figure>

<p>Closure使用中的注意如下两点</p>
<ol>
<li>省略圆括号</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt;each(List&lt;T&gt; self, Closure closure)</span><br></pre></td></tr></table></figure>

<p>上面这个函数表示针对List的每一个元素都会调用closure做一些处理。这里的closure，就有点回调函数的感觉。但是在使用这个each函数的时候，我们传递一个怎样的Closure进去呢？比如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> iamList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  <span class="comment">//定义一个List</span></span><br><span class="line">iamList.each&#123; <span class="comment">//调用它的each，这段代码的格式看不懂了吧？each是个函数，圆括号去哪了？</span></span><br><span class="line">      println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码有两个知识点：</p>
<p>each函数调用的圆括号不见了! 原来，Groovy中，当函数的最后一个参数是闭包的话，可以省略圆括号。比如</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> testClosure(<span class="type">int</span> a1,String b1, Closure closure)&#123;</span><br><span class="line">      <span class="comment">//dosomething</span></span><br><span class="line">     closure() <span class="comment">//调用闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么调用的时候，就可以免括号！</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testClosure (<span class="number">4</span>, <span class="string">&quot;test&quot;</span>, &#123;</span><br><span class="line">   println<span class="string">&quot;i am in closure&quot;</span></span><br><span class="line">&#125; )  <span class="comment">//圆括号可以不写</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如何确定Closure的参数</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt;self, Closure closure)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> iamList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  <span class="comment">//定义一个List变量</span></span><br><span class="line">iamList.each&#123; <span class="comment">//调用它的each函数，只要传入一个Closure就可以了。</span></span><br><span class="line">  println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于each所需要的Closure，它的参数是什么？有多少个参数？返回值是什么？</p>
<p>Closure虽然很方便，但是它一定会和使用它的上下文有极强的关联。要不作为类似回调这样的东西，我如何知道调用者传递什么参数给Closure呢？<a target="_blank" rel="noopener" href="http://www.groovy-lang.org/api.html">只能通过查询API文档才能了解上下文语义</a>。</p>
<p><img src="../../../../images/githubpages/gradle/groovy-each.png" alt="groovy-each"></p>
<h1 id="5-其他实践"><a href="#5-其他实践" class="headerlink" title="5. 其他实践"></a>5. 其他实践</h1><h2 id="5-1-加速模块构建"><a href="#5-1-加速模块构建" class="headerlink" title="5.1. 加速模块构建"></a>5.1. 加速模块构建</h2><p><a target="_blank" rel="noopener" href="https://developer.android.com/studio/build/optimize-your-build.html">https://developer.android.com/studio/build/optimize-your-build.html</a></p>
<h2 id="5-2-集成签名配置"><a href="#5-2-集成签名配置" class="headerlink" title="5.2. 集成签名配置"></a>5.2. 集成签名配置</h2><p>nothing to show</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2018/08/28/2018/2018-08-28-Java%E4%B9%8B%E5%A4%9A%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Liyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liyou">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2018/08/28/2018/2018-08-28-Java%E4%B9%8B%E5%A4%9A%E6%80%81/" class="post-title-link" itemprop="url">Java之多态</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-28 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-28T00:00:00+08:00">2018-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-实现机制"><a href="#1-实现机制" class="headerlink" title="1. 实现机制"></a>1. 实现机制</h1><p>多态靠的是父类的引用变量可以指向子类的具体实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。</p>
<h1 id="2-多态的前提"><a href="#2-多态的前提" class="headerlink" title="2. 多态的前提"></a>2. 多态的前提</h1><p>必须是类与类之间的关系。要么继承，要么实现。</p>
<p>通常还有一个前提就是：覆盖。</p>
<h1 id="3-多态的利弊"><a href="#3-多态的利弊" class="headerlink" title="3. 多态的利弊"></a>3. 多态的利弊</h1><ul>
<li>多态的出现大大的提高了程序的扩展性。</li>
<li>提高了扩展性的同时，只能使用父类的引用访问父类中的成员。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Activities</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">doActivity</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">			a.eat();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">			((Cat) a).catchMouse();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">			((Dog) a).kanJia();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Pig) &#123;</span><br><span class="line">			((Pig) a).sleep();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃鱼&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃骨头&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">kanJia</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;看家&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃饲料&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;老是睡觉&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DuoTaiDemo1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// new Activities().doActivity(null);</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//类型提升，向上转型</span></span><br><span class="line">		a.eat();</span><br><span class="line">		<span class="comment">//如果想要调用猫的特有方法，如何操作？？</span></span><br><span class="line">		<span class="comment">//强制将父类的应用转成子类类型，向下转型</span></span><br><span class="line">		<span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;</span><br><span class="line">		c.catchMouse();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 注意：前往不能将父类对象转成子类类型</span></span><br><span class="line"><span class="comment">		 * Animal a = new Animal();</span></span><br><span class="line"><span class="comment">		 * Cat c = (Cat)a;</span></span><br><span class="line"><span class="comment">		 * 我们能转换的是父类引用执行了自己子类对象是，该应用可以被提升</span></span><br><span class="line"><span class="comment">		 * 多态自始至终都是子类对象在做着变化</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//下面代码是利用Activities类创建对象完成对Cat，Dog，Pig进行的活动</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Activities</span>().doActivity(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Activities</span>().doActivity(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Activities</span>().doActivity(<span class="keyword">new</span> <span class="title class_">Pig</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：电脑运行实例，电脑运行基于主板，提供扩展功能</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LeeYou</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PCI</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主板，使用PCI接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainBoard</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;mainBoard run...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userPCI</span><span class="params">(PCI p)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">			p.open();</span><br><span class="line">			p.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 网卡扩展类，实现PCI接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetCard</span> <span class="keyword">implements</span> <span class="title class_">PCI</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;netcard open...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;netcard close...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声卡扩展类，实现PCI接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SoundCard</span> <span class="keyword">implements</span> <span class="title class_">PCI</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;soundcard open...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;soundcard close...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DuoTaiDemo3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MainBoard</span> <span class="variable">mb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MainBoard</span>();</span><br><span class="line">		mb.run();</span><br><span class="line">		mb.userPCI(<span class="keyword">new</span> <span class="title class_">SoundCard</span>());</span><br><span class="line">		mb.userPCI(<span class="keyword">new</span> <span class="title class_">NetCard</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-多态的注意事项"><a href="#4-多态的注意事项" class="headerlink" title="4. 多态的注意事项"></a>4. 多态的注意事项</h1><h2 id="4-1-在多态中成员函数的特点"><a href="#4-1-在多态中成员函数的特点" class="headerlink" title="4.1. 在多态中成员函数的特点"></a>4.1. 在多态中成员函数的特点</h2><ul>
<li>在编译时期：参阅引用型变量所属的类是否有调用的方法。如果有，编译通过；如果没有，编译失败。</li>
<li>在运行时期：参阅对象所属的类中是否有调用的方法。</li>
</ul>
<h2 id="4-2-在多态中，成员变量的特点（常用于面试）"><a href="#4-2-在多态中，成员变量的特点（常用于面试）" class="headerlink" title="4.2. 在多态中，成员变量的特点（常用于面试）"></a>4.2. 在多态中，成员变量的特点（常用于面试）</h2><p>无论编译和运行，都参考左边（引用型变量所属的类）</p>
<h2 id="4-3-在多态中，静态成员函数的特点（常用于面试）"><a href="#4-3-在多态中，静态成员函数的特点（常用于面试）" class="headerlink" title="4.3. 在多态中，静态成员函数的特点（常用于面试）"></a>4.3. 在多态中，静态成员函数的特点（常用于面试）</h2><p>无论在编译和运行，都参考左边（引用型变量所属的类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Father Class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father method 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father method 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father method 4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Son Class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son method 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son method 3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son method 4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DuoTaiDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//演示6.1</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        f.method1();</span><br><span class="line">        f.method2();<span class="comment">//对应6.1.2</span></span><br><span class="line">        <span class="comment">//f.method3(); //对应6.1.1,这一行会报错</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示6.2</span></span><br><span class="line">        System.out.println(f.num);</span><br><span class="line">        System.out.println(f.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示6.3</span></span><br><span class="line">        f.method4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../../../images/githubpages/%E5%A4%9A%E6%80%81/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="运行结果"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2018/08/28/2018/2018-08-28-Java%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Liyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liyou">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2018/08/28/2018/2018-08-28-Java%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/" class="post-title-link" itemprop="url">Java之内部类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-28 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-28T00:00:00+08:00">2018-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1. 成员内部类"></a>1. 成员内部类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Coco&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Jayden&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.name);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> o.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等。</p>
<p>Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性age。</p>
<p>定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 = 外部类对象.new 内部类( ); 。</p>
<p>编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}</p>
<p>成员内部类中不能存在任何 static 的变量和方法,可以定义常量: 1. 因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关,简而言之:在加载静态域时,根本没有外部类,所在在非静态内部类中不能定义静态域或方法,编译不通过;非静态内部类的作用域是实例级别 2. 常量是在编译器就确定的,放到所谓的常量池了。静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。</p>
<p>友情提示：1.外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字,如:Outer.this.name。</p>
<h1 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2. 静态内部类"></a>2. 静态内部类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Coco&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Jayden&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(Outer.name);</span><br><span class="line">            System.out.println(name);                  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问。如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员。</p>
<p>创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类();</p>
<h1 id="3-方法内部类"><a href="#3-方法内部类" class="headerlink" title="3. 方法内部类"></a>3. 方法内部类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用的形参为何要为 final???在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;访问外部类:&quot;</span> + a);</span><br><span class="line">                System.out.println(<span class="string">&quot;访问内部类:&quot;</span> + c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        i.print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        o.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。只能访问方法中定义的 final 类型的局部变量，当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在,直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量;而使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期。局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数;防止被篡改数据,而导致内部类得到的值不一致。</p>
<h1 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4. 匿名内部类"></a>4. 匿名内部类</h1><p>使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口；同时它没有class关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引用，当然这个引用是隐式的。</p>
<p>对于匿名内部类的使用存在一个缺陷，即它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> InnerClass <span class="title function_">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span>   num,String str2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>()&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> num + <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;        <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> out.getInnerClass(<span class="number">2</span>, <span class="string">&quot;chenssy&quot;</span>);</span><br><span class="line">        System.out.println(inner.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-注意事项"><a href="#4-1-注意事项" class="headerlink" title="4.1. 注意事项"></a>4.1. 注意事项</h2><p>1 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。<br>2 匿名内部类中是不能定义构造函数的。<br>3 匿名内部类中不能存在任何的静态成员变量和静态方法。<br>4 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。<br>5 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
<h2 id="4-2-使用的形参为什么要final修饰"><a href="#4-2-使用的形参为什么要final修饰" class="headerlink" title="4.2. 使用的形参为什么要final修饰"></a>4.2. 使用的形参为什么要final修饰</h2><p>在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数，所以他们两者是可以任意变化的</p>
<p>也就是说在内部类中对属性的改变并不会影响到外部的形参，然而这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。</p>
<p>简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2018/08/17/2018/2018-08-17-Android%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Liyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liyou">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2018/08/17/2018/2018-08-17-Android%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Android之多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-17 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-17T00:00:00+08:00">2018-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Android 程序的大多数代码操作都必须执行在主线程，例如：系统事件(例如设备屏幕发生旋转)，输入事件(例如用户点击滑动等)，程序回调服务，UI 绘制以及闹钟事件等等。那么我们在上述事件或者方法中插入的代码也将执行在主线程</p>
<p>一旦我们在主线程里面添加了操作复杂的代码，这些代码就很可能阻碍主线程去响应点击/滑动事件，阻碍主线程的 UI 绘制等等。</p>
<p>我们知道，为了让屏幕的刷新帧率达到 60fps，我们需要确保 16ms 内完成单次刷新的操作。一旦我们在主线程里面执行的任务过于繁重就可能导致接收到刷新信号的时候因为资源被占用而无法完成这次刷新操作，这样就会产生掉帧的现象，刷新帧率自然也就跟着下降了(一旦刷新帧率降到 20fps 左右，用户就可以明显感知到卡顿不流畅了)。</p>
<h1 id="1-Android-系统为我们提供的若干组工具类"><a href="#1-Android-系统为我们提供的若干组工具类" class="headerlink" title="1. Android 系统为我们提供的若干组工具类"></a>1. Android 系统为我们提供的若干组工具类</h1><h2 id="1-1-AsyncTask"><a href="#1-1-AsyncTask" class="headerlink" title="1.1. AsyncTask"></a>1.1. AsyncTask</h2><p>为 UI 线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。</p>
<p>默认情况下，所有的 AsyncTask 任务都是被线性调度执行的，他们处在同一个任务队列当中，按顺序逐个执行。假设你按照顺序启动20个 AsyncTask，一旦其中的某个 AsyncTask 执行时间过长，队列中的其他剩余 AsyncTask 都处于阻塞状态，必须等到该任务执行完毕之后才能够有机会执行下一个任务。</p>
<p>如何才能够真正的取消一个 AsyncTask 的执行呢？我们知道 AsyncTaks 有提供 cancel()的方法，但是这个方法实际上做了什么事情呢？线程本身并不具备中止正在执行的代码的能力，为了能够让一个线程更早的被销毁，我们需要在 doInBackground()的代码中不断的添加程序是否被中止的判断逻辑，一旦任务被成功中止，AsyncTask 就不会继续调用 onPostExecute()，而是通过调用 onCancelled()的回调方法反馈任务执行取消的结果。我们可以根据任务回调到哪个方法（是 onPostExecute 还是 onCancelled）来决定是对 UI 进行正常的更新还是把对应的任务所占用的内存进行销毁等。</p>
<p>使用 AsyncTask 很容易导致内存泄漏，一旦把 AsyncTask 写成 Activity 的内部类的形式就很容易因为 AsyncTask 生命周期的不确定而导致 Activity 发生泄漏。</p>
<h2 id="1-2-HandlerThread"><a href="#1-2-HandlerThread" class="headerlink" title="1.2. HandlerThread"></a>1.2. HandlerThread</h2><p>为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。</p>
<p>HandlerThread 比较合适处理那些在工作线程执行，需要花费时间偏长的任务。我们只需要把任务发送给 HandlerThread，然后就只需要等待任务执行结束的时候通知返回到主线程就好了。</p>
<p>另外很重要的一点是，一旦我们使用了 HandlerThread，需要特别注意给 HandlerThread 设置不同的线程优先级，CPU 会根据设置的不同线程优先级对所有的线程进行调度优化。</p>
<h2 id="1-3-IntentService"><a href="#1-3-IntentService" class="headerlink" title="1.3. IntentService"></a>1.3. IntentService</h2><p>适合于执行由 UI 触发的后台 Service 任务，并可以把后台任务执行的情况通过一定的机制反馈给 UI。</p>
<p>首先，因为 IntentService 内置的是 HandlerThread 作为异步线程，所以每一个交给 IntentService 的任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。</p>
<p>其次，通常使用到 IntentService 的时候，我们会结合使用 BroadcastReceiver 把工作线程的任务执行结果返回给主 UI 线程。使用广播容易引起性能问题，我们可以使用 LocalBroadcastManager 来发送在程序内部传递的广播，从而提升广播的性能。我们也可以使用 runOnUiThread() 快速回调到主 UI 线程。</p>
<p>最后，包含正在运行的 IntentService 的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的</p>
<p>IntentService 继承自普通 Service 同时又在内部创建了一个 HandlerThread，在 onHandlerIntent()的回调里面处理扔到 IntentService 的任务。所以 IntentService 就不仅仅具备了异步线程的特性，还同时保留了 Service 不受主页面生命周期影响的特点。</p>
<h2 id="1-4-ThreadPool"><a href="#1-4-ThreadPool" class="headerlink" title="1.4. ThreadPool"></a>1.4. ThreadPool</h2><p>把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</p>
<h3 id="1-4-1-线程池的基本概念"><a href="#1-4-1-线程池的基本概念" class="headerlink" title="1.4.1. 线程池的基本概念"></a>1.4.1. 线程池的基本概念</h3><p><img src="../../../../images/githubpages/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadPoolExecutor%E6%9C%89%E5%9B%9B%E4%B8%AA%E9%87%8D%E8%BD%BD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt="ThreadPoolExecutor有四个重载的构造方法"></p>
<p>corePoolSize：线程池中核心线程的数量</p>
<p>maximumPoolSize：线程池中最大线程数量</p>
<p>keepAliveTime：非核心线程的超时时长，当系统中非核心线程闲置时间超过keepAliveTime之后，则会被回收。如果ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，则该参数也表示核心线程的超时时长</p>
<p>unit：第三个参数的单位，有纳秒、微秒、毫秒、秒、分、时、天等</p>
<p>workQueue：线程池中的任务队列，该队列主要用来存储已经被提交但是尚未执行的任务。存储在这里的任务是由ThreadPoolExecutor的execute方法提交来的。</p>
<ul>
<li><p>workQueue是一个BlockingQueue类型，它是一个特殊的队列，当我们从BlockingQueue中取数据时，如果BlockingQueue是空的，则取数据的操作会进入到阻塞状态，当BlockingQueue中有了新数据时，这个取数据的操作又会被重新唤醒。同理，如果BlockingQueue中的数据已经满了，往BlockingQueue中存数据的操作又会进入阻塞状态，直到BlockingQueue中又有新的空间，存数据的操作又会被冲洗唤醒。</p>
</li>
<li><p>1.ArrayBlockingQueue 这个表示一个规定了大小的BlockingQueue，ArrayBlockingQueue的构造函数接受一个int类型的数据，该数据表示BlockingQueue的大小，存储在ArrayBlockingQueue中的元素按照FIFO（先进先出）的方式来进行存取。</p>
</li>
<li><p>2.LinkedBlockingQueue 这个表示一个大小不确定的BlockingQueue，在LinkedBlockingQueue的构造方法中可以传一个int类型的数据，这样创建出来的LinkedBlockingQueue是有大小的，也可以不传，不传的话，LinkedBlockingQueue的大小就为Integer.MAX_VALUE</p>
</li>
<li><p>3.PriorityBlockingQueue 这个队列和LinkedBlockingQueue类似，不同的是PriorityBlockingQueue中的元素不是按照FIFO来排序的，而是按照元素的Comparator来决定存取顺序的（这个功能也反映了存入PriorityBlockingQueue中的数据必须实现了Comparator接口）。</p>
</li>
<li><p>4.SynchronousQueue 这个是同步Queue，属于线程安全的BlockingQueue的一种，在SynchronousQueue中，生产者线程的插入操作必须要等待消费者线程的移除操作，Synchronous内部没有数据缓存空间，因此我们无法对SynchronousQueue进行读取或者遍历其中的数据，元素只有在你试图取走的时候才有可能存在。我们可以理解为生产者和消费者互相等待，等到对方之后然后再一起离开。</p>
</li>
</ul>
<p>threadFactory ：为线程池提供创建新线程的功能，这个我们一般使用默认即可</p>
<p>handler：拒绝策略，当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的）默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。</p>
<h3 id="1-4-2-线程池的运行规则"><a href="#1-4-2-线程池的运行规则" class="headerlink" title="1.4.2. 线程池的运行规则"></a>1.4.2. 线程池的运行规则</h3><ul>
<li>1.execute一个线程之后，如果线程池中的线程数未达到核心线程数，则会立马启用一个核心线程去执行</li>
<li>2.execute一个线程之后，如果线程池中的线程数已经达到核心线程数，且workQueue未满，则将新线程放workQueue中等待执行</li>
<li>3.execute一个线程之后，如果线程池中的线程数已经达到核心线程数但未超过非核心线程数，且wrkQueue已满，则开启一个非核心线程来执行任务</li>
<li>4.execute一个线程之后，如果线程池中的线程数已经超过非核心线程数，则拒绝执行该任</li>
</ul>
<h3 id="1-4-3-ThreadPool的使用"><a href="#1-4-3-ThreadPool的使用" class="headerlink" title="1.4.3. ThreadPool的使用"></a>1.4.3. ThreadPool的使用</h3><p>参考<a href="https://leeeyou.github.io/2017/04/14/blog-2017-04-14-Java%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/#ThreadPool%E7%94%A8%E6%B3%95%E4%B8%8E%E4%BC%98%E5%8A%BF">leeyou.xyz</a></p>
<h3 id="1-4-4-线程池其他常用功能"><a href="#1-4-4-线程池其他常用功能" class="headerlink" title="1.4.4. 线程池其他常用功能"></a>1.4.4. 线程池其他常用功能</h3><ul>
<li>shutDown()  关闭线程池，不影响已经提交的任务</li>
<li>shutDownNow() 关闭线程池，并尝试去终止正在执行的线程</li>
<li>allowCoreThreadTimeOut(boolean value) 允许核心线程闲置超时时被回收</li>
<li>submit 一般情况下我们使用execute来提交任务，但是有时候可能也会用到submit，使用submit的好处是submit有返回值</li>
</ul>
<h3 id="1-4-5-使用时要注意的几点"><a href="#1-4-5-使用时要注意的几点" class="headerlink" title="1.4.5. 使用时要注意的几点"></a>1.4.5. 使用时要注意的几点</h3><p>使用线程池需要特别注意同时并发线程数量的控制，理论上来说，我们可以设置任意你想要的并发数量，但是这样做非常的不好。因为 CPU 只能同时执行固定数量的线程数，一旦同时并发的线程数量超过 CPU 能够同时执行的阈值，CPU 就需要花费精力来判断到底哪些线程的优先级比较高，需要在不同的线程之间进行调度切换。</p>
<p>一旦同时并发的线程数量达到一定的量级，这个时候 CPU 在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降。另外需要关注的一点是，每开一个新的线程，都会耗费至少 64K+ 的内存。为了能够方便的对线程数量进行控制，ThreadPoolExecutor 为我们提供了初始化的并发线程数量，以及最大的并发数量进行设置。</p>
<p>另外需要关注的一个问题是：Runtime.getRuntime().availableProcesser()方法并不可靠，他返回的值并不是真实的 CPU 核心数，因为 CPU 会在某些情况下选择对部分核心进行睡眠处理，在这种情况下，返回的数量就只能是激活的 CPU 核心数。</p>
<h1 id="2-Android中的任务线程模型"><a href="#2-Android中的任务线程模型" class="headerlink" title="2. Android中的任务线程模型"></a>2. Android中的任务线程模型</h1><p>Looper：能够确保线程持续存活并且可以不断的从任务队列中获取任务并进行执行。</p>
<p>Handler：能够帮助实现队列任务的管理，不仅仅能够把任务插入到队列的头部，尾部，还可以按照一定的时间延迟来确保任务从队列中能够来得及被取消掉。</p>
<p>MessageQueue：使用 Intent，Message，Runnable 作为任务的载体在不同的线程之间进行传递。</p>
<p>三个组件打包到一起进行协作，这就是 HandlerThread</p>
<p><img src="../../../../images/githubpages/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/HandlerThread.png" alt="HandlerThread"></p>
<h1 id="3-平衡并发的线程数和内存消耗的问题"><a href="#3-平衡并发的线程数和内存消耗的问题" class="headerlink" title="3. 平衡并发的线程数和内存消耗的问题"></a>3. 平衡并发的线程数和内存消耗的问题</h1><p>多线程并发访问同一块内存区域有可能带来很多问题，例如读写的权限争夺问题，ABA 问题等等。为了解决这些问题，我们会需要引入锁的概念。</p>
<h2 id="3-1-Android中多线程引起的问题"><a href="#3-1-Android中多线程引起的问题" class="headerlink" title="3.1. Android中多线程引起的问题"></a>3.1. Android中多线程引起的问题</h2><p>Android UI 对象的创建，更新，销毁等等操作都默认是执行在主线程，但是如果我们在非主线程对UI对象进行操作，程序将可能出现异常甚至是崩溃。</p>
<p>在非 UI 线程中直接持有 UI 对象的引用也很可能出现问题。例如Work线程中持有某个 UI 对象的引用，在 Work 线程执行完毕之前，UI 对象在主线程中被从 ViewHierarchy 中移除了，这个时候 UI 对象的任何属性都已经不再可用了，另外对这个 UI 对象的更新操作也都没有任何意义了，因为它已经从 ViewHierarchy 中被移除，不再绘制到画面上了。</p>
<p>View 对象本身对所属的 Activity 是有引用关系的，如果工作线程持续保有 View 的引用，这就可能导致 Activity 无法完全释放。除了直接显式的引用关系可能导致内存泄露之外，我们还需要特别留意隐式的引用关系也可能导致泄露。例如通常我们会看到在 Activity 里面定义的一个 AsyncTask，这种类型的 AsyncTask 与外部的 Activity 是存在隐式引用关系的，只要 Task 没有结束，引用关系就会一直存在，这很容易导致 Activity 的泄漏。更糟糕的情况是，它不仅仅发生了内存泄漏，还可能导致程序异常或者崩溃。</p>
<p><strong>我们需要谨记的原则就是：不要在任何非 UI 线程里面去持有 UI 对象的引用。</strong></p>
<p><strong>系统为了确保所有的 UI 对象都只会被 UI 线程所进行创建，更新，销毁的操作，特地设计了对应的工作机制(当 Activity 被销毁的时候，由该 Activity 所触发的非 UI 线程都将无法对UI对象进行操作，否者就会抛出程序执行异常的错误)来防止 UI 对象被错误的使用。</strong></p>
<h1 id="4-Loaders"><a href="#4-Loaders" class="headerlink" title="4. Loaders"></a>4. Loaders</h1><p>当启动工作线程的 Activity 被销毁的时候，我们应该做点什么呢？</p>
<p>为了方便的控制工作线程的启动与结束，Android 为我们引入了 Loader 来解决这个问题。<br>我们知道 Activity 有可能因为用户的主动切换而频繁的被创建与销毁，也有可能是因为类似屏幕发生旋转等被动原因而销毁再重建。在 Activity 不停的创建与销毁的过程当中，很有可能因为工作线程持有 Activity 的 View 而导致内存泄漏(因为工作线程很可能持有 View 的强引用，另外工作线程的生命周期还无法保证和 Activity 的生命周期一致，这样就容易发生内存泄漏了)。除了可能引起内存泄漏之外，在 Activity 被销毁之后，工作线程还继续更新视图是没有意义的，因为此时视图已经不在界面上显示了。</p>
<p><img src="../../../../images/githubpages/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/loaders.jpg" alt="Loaders"></p>
<p>Loader 的出现就是为了确保工作线程能够和 Activity 的生命周期保持一致</p>
<ul>
<li><p>LoaderManager 会对查询的操作进行缓存，只要对应 Cursor 上的数据源没有发生变化，在配置信息发生改变的时候(例如屏幕的旋转)，Loader  可以直接把缓存的数据回调到 onLoadFinished()，从而避免重新查询数据。另外系统会在 Loader 不再需要使用到的时候(例如使用 Back 按钮退出当前页面)回调 onLoaderReset()方法，我们可以在这里做数据的清除等等操作。</p>
</li>
<li><p>在 Activity 或者 Fragment 中使用 Loader 可以方便的实现异步加载的框架，Loader 有诸多优点。但是实现 Loader 的这套代码还是稍微有点点复杂，Android 官方为我们提供了使用 Loader 的示例代码进行参考学习。</p>
</li>
</ul>
<h1 id="5-线程优先级的重要性"><a href="#5-线程优先级的重要性" class="headerlink" title="5. 线程优先级的重要性"></a>5. 线程优先级的重要性</h1><p>Android 系统会根据当前运行的可见的程序和不可见的后台程序对线程进行归类，划分为 forground 的那部分线程会大致占用掉 CPU 的90%左右的时间片，background 的那部分线程就总共只能分享到5%-10%左右的时间片。之所以设计成这样是因为 forground 的程序本身的优先级就更高，理应得到更多的执行时间。</p>
<p>默认情况下，新创建的线程的优先级默认和创建它的母线程保持一致。如果主 UI 线程创建出了几十个工作线程，这些工作线程的优先级就默认和主线程保持一致了，为了不让新创建的工作线程和主线程抢占 CPU 资源，需要把这些线程的优先级进行降低处理，这样才能给帮助 CPU 识别主次，提高主线程所能得到的系统资源。</p>
<p>在 Android 系统里面，我们可以通过 android.os.Process.setThreadPriority(int) 设置线程的优先级，参数范围从-20到19，数值越小优先级越高。Android 系统还为我们提供了以下的一些预设值，我们可以通过给不同的工作线程设置不同数值的优先级来达到更细粒度的控制。</p>
<p><img src="../../../../images/githubpages/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.jpg" alt="线程优先级"></p>
<p>Android 系统里面的 AsyncTask 与 IntentService已经默认帮助我们设置线程的优先级，但是对于那些非官方提供的多线程工具类，我们需要特别留意根据需要自己手动来设置线程的优先级。</p>
<p><img src="../../../../images/githubpages/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A72.jpg" alt="线程优先级"></p>
<p><img src="../../../../images/githubpages/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A73.jpg" alt="线程优先级"></p>
<h1 id="6-工具篇"><a href="#6-工具篇" class="headerlink" title="6. 工具篇"></a>6. 工具篇</h1><p>从 Android M 系统开始，系统更新了 GPU Profiling 的工具来帮助我们定位 UI 的渲染性能问题。早期的 CPU Profiling 工具只能粗略的显示出 Process，Execute，Update 三大步骤的时间耗费情况。但是仅仅显示三大步骤的时间耗费情况，还是不太能够清晰帮助我们定位具体的程序代码问题，所以在 Android M 版本开始，GPU Profiling 工具把渲染操作拆解成8个详细的步骤进行显示。</p>
<p>Sync &amp; Upload：通常表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片本身的大小。</p>
<p>Measure &amp; Layou：这里表示的是布局的 onMeasure 与 onLayout 所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题。</p>
<p>Animation：表示的是计算执行动画所需要花费的时间，包含的动画有 ObjectAnimator，ViewPropertyAnimator，Transition 等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等。</p>
<p>Input Handling：表示的是系统处理输入事件所耗费的时间，粗略等于对于的事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作。</p>
<p>Misc/Vsync Delay：如果稍加注意，我们可以在开发应用的 Log 日志里面看到这样一行提示：I/Choreographer(691): Skipped XXX frames! The application may be doing too much work on its main thread。这意味着我们在主线程执行了太多的任务，导致 UI 渲染跟不上 vSync 的信号而出现掉帧的情况。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2018/08/14/2018/2018-08-14-Java%E4%B9%8B%E6%A0%B8%E5%BF%8336%E8%AE%B2%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Liyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liyou">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2018/08/14/2018/2018-08-14-Java%E4%B9%8B%E6%A0%B8%E5%BF%8336%E8%AE%B2%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">Java之核心36讲整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-14 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-14T00:00:00+08:00">2018-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这里是将极客时间上杨晓峰老师的专栏文章，在这里整理出来方便自己后续复习用。文章分为5大模块：</p>
<ul>
<li>Java 基础：我会围绕 Java 语言基本特性和机制，由点带面，让你构建牢固的 Java 技术工底。  </li>
<li>Java 进阶：将围绕并发编程、Java 虚拟机等领域展开，助你攻坚大厂 Java 面试的核心阵地。  </li>
<li>Java 应用开发扩展：从数据库编程、主流开源框架、分布式开发等，帮你掌握 Java 开发的十八般兵器。  </li>
<li>Java 安全基础：让你理解常见的应用安全问题和处理方法，掌握如何写出符合大厂规范的安全代码。  </li>
<li>Java 性能基础：你将掌握相关工具、方法论与基础实践。  </li>
</ul>
<p>对于Android开发人员来说，后面章节内容更多偏向后端开发，对于这部分内容，我自己是量力而行。很多知识点以前只是听说或是了解不透彻，比如CAS、AQS、内存模型、多线程并发等，这次在专栏中，收获满满；只要用心读，保持清晰的头脑，应该还会有进一步的提升。</p>
<p>技术之外，杨老师在文章中有意的提到了许多思想层面的内容，个人觉得对于意识的提升非常有帮助。比如说“你需要尽量表现出自己的思维深入并系统化”、“知其然并知其所以然，明白基本组成和机制”、“应用场景是我们在选择哪个API前需要考虑的，不能一概而论的说A比B绝对好”等等。当然意识层面的提高也绝非说说而已，还需结合实践和自己的思考不断摸索和总结。</p>
<p>在某些文章中，我添加了一些自己不太熟悉的内容补充，在相应的章节里面做好记录，也算是查漏补缺，消除自己的疑虑吧。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/kai-pian-ci-yi-mian-shi-ti-wei-qie-ru-dian-ff0c-you-xiao-ti-sheng-ni-de-java-nei-gong.md">开篇词 | 以面试题为切入点，有效提升你的Java内功</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-1-jiang-tan-tan-ni-dui-java-ping-tai-de-li-jie-ff1f.md">第1讲 | 谈谈你对Java平台的理解？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-2-jiang-exception-he-error-you-shi-yao-qu-bie-ff1f.md">第2讲 | Exception和Error有什么区别？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-3-jiang-tan-tan-final-finally-finalize-you-shi-yao-bu-tong-ff1f.md">第3讲 | 谈谈final、finally、 finalize有什么不同？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-4-jiang-qiang-yin-yong-3001-ruan-yin-yong-3001-ruo-yin-yong-3001-huan-xiang-yin-yong-you-shi-yao-qu-bie-ff1f.md">第4讲 | 强引用、软引用、弱引用、幻象引用有什么区别？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-5-jiang-string-stringbuffer-stringbuilder-you-shi-yao-qu-bie-ff1f.md">第5讲 | String、StringBuffer、StringBuilder有什么区别？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-6-jiang-dong-tai-dai-li-shi-ji-yu-shi-yao-yuan-li-ff1f.md">第6讲 | 动态代理是基于什么原理？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-7-jiang-int-he-integer-you-shi-yao-qu-bie-ff1f.md">第7讲 | int和Integer有什么区别？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-8-jiang-dui-bi-vector-arraylist-linkedlist-you-he-qu-bie-ff1f.md">第8讲 | 对比Vector、ArrayList、LinkedList有何区别？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-9-jiang-dui-bi-hashtable-hashmap-treemap-you-shi-yao-bu-tong-ff1f.md">第9讲 | 对比Hashtable、HashMap、TreeMap有什么不同？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-10-jiang-ru-he-baozheng-ji-he-shi-xian-cheng-an-quan-76843f-concurrenthashmap-ru-he-shi-xian-gao-xiao-di-xian-cheng-an-quan-ff1f.md">第10讲 | 如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-11-jiang-java-ti-gong-le-na-xie-io-fang-shi-ff1f-nio-ru-he-shi-xian-duo-lu-fu-yong-ff1f.md">第11讲 | Java提供了哪些IO方式？ NIO如何实现多路复用？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-12-jiang-java-you-ji-zhong-wen-jian-kao-bei-fang-shi-ff1f-na-yi-zhong-zui-gao-xiao-ff1f.md">第12讲 | Java有几种文件拷贝方式？哪一种最高效？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-13-jiang-tan-tan-jie-kou-he-chou-xiang-lei-you-shi-yao-qu-bie-ff1f.md">第13讲 | 谈谈接口和抽象类有什么区别？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-14-jiang-tan-tan-ni-zhi-dao-de-she-ji-mo-shi-ff1f.md">第14讲 | 谈谈你知道的设计模式？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-15-jiang-synchronized-he-reentrantlock-you-shi-yao-qu-bie-ni-ff1f.md">第15讲 | synchronized和ReentrantLock有什么区别呢？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/zhou-mo-fu-li-tan-tan-wo-dui-java-xue-xi-he-mian-shi-de-kan-fa.md">周末福利 | 谈谈我对Java学习和面试的看法</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-16-jiang-synchronized-di-ceng-ru-he-shi-xian-ff1f-shi-yao-shi-suo-de-sheng-ji-3001-jiang-ji-ff1f.md">第16讲 | synchronized底层如何实现？什么是锁的升级、降级？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-17-jiang-yi-ge-xian-cheng-liang-ci-diao-yong-start-fang-fa-hui-chu-xian-shi-yao-qing-kuang-ff1f.md">第17讲 | 一个线程两次调用start()方法会出现什么情况？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-18-jiang-shi-yao-qing-kuang-xia-java-cheng-xu-hui-chan-sheng-si-suo-ff1f-ru-he-ding-wei-3001-xiu-fu-ff1f.md">第18讲 | 什么情况下Java程序会产生死锁？如何定位、修复？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-19-jiang-java-bing-fa-bao-ti-gong-le-na-xie-bing-fa-gong-ju-lei-ff1f.md">第19讲 | Java并发包提供了哪些并发工具类？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-20-jiang-bing-fa-bao-zhong-de-concurrentlinkedqueue-he-linkedblockingqueue-you-shi-yao-qu-bie-ff1f.md">第20讲 | 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-21-jiang-java-bing-fa-lei-ku-ti-gong-de-xian-cheng-chi-you-na-ji-zhong-ff1f-fen-bie-you-shi-yao-te-dian-ff1f.md">第21讲 | Java并发类库提供的线程池有哪几种？ 分别有什么特点？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-22-jiang-atomicinteger-di-ceng-shi-xian-yuan-li-shi-shi-yao-ff1f-ru-he-zai-zi-ji-de-chan-pin-dai-ma-zhong-ying-yong-cas-cao-zuo-ff1f.md">第22讲 | AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-23-jiang-qing-jie-shao-lei-jia-zai-guo-cheng-ff0c-shi-yao-shi-shuang-qin-wei-pai-mo-xing-ff1f.md">第23讲 | 请介绍类加载过程，什么是双亲委派模型？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-24-jiang-you-na-xie-fang-fa-ke-yi-zai-yun-xing-shi-dong-tai-sheng-cheng-yi-ge-java-lei-ff1f.md">第24讲 | 有哪些方法可以在运行时动态生成一个Java类？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-25-jiang-tan-tan-jvm-nei-cun-qu-yu-de-hua-fen-ff0c-na-xie-qu-yu-ke-neng-fa-sheng-outofmemoryerror.md">第25讲 | 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-26-jiang-ru-he-jian-kong-he-zhen-duan-jvm-dui-nei-he-dui-wai-nei-cun-shi-yong-ff1f.md">第26讲 | 如何监控和诊断JVM堆内和堆外内存使用？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-27-jiang-java-chang-jian-de-la-ji-shou-ji-qi-you-na-xie-ff1f.md">第27讲 | Java常见的垃圾收集器有哪些？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-28-jiang-tan-tan-ni-de-gc-diao-you-si-8def3f.md">第28讲 | 谈谈你的GC调优思路?</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-29-jiang-java-nei-cun-mo-xing-zhong-de-happen-before-shi-shi-yao-ff1f.md">第29讲 | Java内存模型中的happen-before是什么？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-30-jiang-java-cheng-xu-yun-xing-zai-docker-deng-rong-qi-huan-jing-you-na-xie-xin-wen-ti-ff1f.md">第30讲 | Java程序运行在Docker等容器环境有哪些新问题？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-31-jiang-ni-le-jie-java-ying-yong-kai-fa-zhong-de-zhu-ru-gong-ji-ma-ff1f.md">第31讲 | 你了解Java应用开发中的注入攻击吗？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-32-jiang-ru-he-xie-chu-an-quan-de-java-dai-ma-ff1f.md">第32讲 | 如何写出安全的Java代码？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-33-jiang-hou-tai-fu-wu-chu-xian-ming-xian-201c-bian-man-201d-ff0c-tan-tan-ni-de-zhen-duan-si-lu-ff1f.md">第33讲 | 后台服务出现明显“变慢”，谈谈你的诊断思路？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-34-jiang-you-ren-shuo-201c-lambda-neng-rang-java-cheng-xu-man-30-bei-201d-ff0c-ni-zen-yao-kan-ff1f.md">第34讲 | 有人说“Lambda能让Java程序慢30倍”，你怎么看？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-35-jiang-jvm-you-hua-java-dai-ma-shi-du-zuo-le-shi-yao-ff1f.md">第35讲 | JVM优化Java代码时都做了什么？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-36-jiang-tan-tan-mysql-zhi-chi-de-shi-wu-ge-li-ji-bie-ff0c-yi-ji-bei-guan-suo-he-le-guan-suo-de-yuan-li-he-ying-yong-chang-jing-ff1f.md">第36讲 | 谈谈MySQL支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-37-jiang-tan-tan-spring-bean-de-sheng-ming-zhou-qi-he-zuo-yong-yu-ff1f.md">第37讲 | 谈谈Spring Bean的生命周期和作用域？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-38-jiang-duibi-java-biao-zhun-nio-lei-ku-ff0c-ni-zhi-dao-netty-shi-ru-he-shi-xian-geng-gao-xing-neng-de-ma-ff1f.md">第38讲 | 对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-39-jiang-tan-tan-chang-yong-de-fen-bu-shi-id-de-she-ji-fang-an-ff1f-snowflake-shi-fou-shou-dong-ling-shi-qie-huan-ying-xiang-ff1f.md">第39讲 | 谈谈常用的分布式ID的设计方案？Snowflake是否受冬令时切换影响？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/jie-shu-yu-ji-zhu-mei-you-zhong-dian.md">结束语 | 技术没有终点</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2018/08/09/2018/2018-08-09-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Liyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liyou">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2018/08/09/2018/2018-08-09-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/" class="post-title-link" itemprop="url">读书笔记之财务自由之路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-09 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-09T00:00:00+08:00">2018-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/opinion/" itemprop="url" rel="index"><span itemprop="name">opinion</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="../../../../images/readingNotes/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF.jpg" alt="财务自由之路.jpg"></p>
<p>“先完成财务保障，再实现财务安全，最后最后才 <strong>有点可能</strong> 实现财务自由。如若不遵循这一投资哲学，你将会处于危险之地，更别谈实现你的梦想了” , 这点对我而言可能是读这本书的最大收获了。</p>
<p><img src="../../../../images/readingNotes/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/20180815135720.png" alt="20180815135720.png"></p>
<p>是的，正如上图展示的那样，只有当第一个水壶被住满水以后，你才能加注第二个水壶。你只能使用第二水壶盈余的部分（你不需要用来实现财务安全的金钱）来对第三个水壶进行加注。这样，你的财务安全就永远不会承担风险。而现在的我，解决财务保障可能是最最紧迫的事情了。</p>
<p>老实说，这本书的副标题 “7年内赚到你的第一个1000万” 有点夺眼球的噱头之意，鉴于作者的声望和MacTalk的推荐，读完以后，副标题带来的负面作用可以完全忽略不计。作者的一些思想或者说是一些行为准则，对我而言，有较大的启发；当然你也可以理解为鸡汤，但在我看来，确实值得干了它。比如作者系统的分析你的收入时，从能力、精力、影响力、自我评价和创意五个方面着手，并非空口说白话，而是给出具体某方面的指导和建议；再比如作者提到的责任、持续学习和成长、思维的转变这些无一不是当今竞争激烈的社会上，你我的立足之本。</p>
<p>我们真的可以想象下7年之后自己的财务状况，至少可以定下一个目标吧。达到财务安全线对我而言可能有点难度，但是你的思维方式铸就了你今天的样子，做出改变，持续不断地学习和成长，还是有很大机会搏一搏的，谁说不是呢？</p>
<h4 id="金句摘录"><a href="#金句摘录" class="headerlink" title="金句摘录"></a>金句摘录</h4><blockquote>
<p>1、如果你想获得不一样的结果，那你就必须有所行动：你必须改变自己的方式，首先需要改变的便是你的思维方式，你的思维方式铸了你今天的样子，这样的思维方式却并不能让你变成你想成为的样子。  </p>
</blockquote>
<blockquote>
<p>2、你的思维方式铸就了你今天的样子，这样的思维方式却并不能让你变成你想成为的样子，如果你想获得不一样的结果，那你就必须有所行动：你必须改变自己的方式，首先需要改变的便是你的思维方式。</p>
</blockquote>
<blockquote>
<p>3、不管你相不相信，金钱确实改变了我生活中的许多东西，金钱不会解决你的所有问题，它也绝不是万能的，但是，缺钱却能使你的幸福蒙上一层阴影，有了金钱，你在处理问题的时候便能尝试许多方式，而且，你也将会有机会结识更多的人，参观风景优美的地方，得到更加有趣的工作，获得更多的自信，赢得更多的赞赏，获得更多的机会。 </p>
</blockquote>
<blockquote>
<p>4、我们想要自己掌控将来事态的发展，还是让我们的错误及其后果掌握将来的事态？如果我们在事件发生时勇于承担责任，那么所有的负面情绪在这一刻都会失去掌控力。  </p>
</blockquote>
<blockquote>
<p>5、只有你（绝非任何人）能对你7年内收获多少金钱负责，首先离开你的舒适环境；其次将困难当做成长的机会，并且问自己：我如何创造一种情况，是这个问题不再出现？接着提出正确的问题；最后扩展你的个人范畴，同时你的可控领域也得到了拓展，这世上有一些事你无能为力，但你可以决定，你打算如何判断以及如何对此作出反应，在这方面，你一直都是拥有权利的。  </p>
</blockquote>
<blockquote>
<p>6、责任意味着：没有任何东西能改变你的态度或品格，因为你是按照自己的本性对事情做出反应，你可以决定自己以哪种方式去生活，这种态度是你能够生活幸福，并且成为最好的自己，如果你勇于承担责任，那么你就能在7年内变得富有。  </p>
</blockquote>
<blockquote>
<p>7、随着年龄的增长，你只会对自己没有做过的事情感到后悔。  </p>
</blockquote>
<blockquote>
<p>8、引发奇迹的4个法则，被我统称为持续不断地学习和成长，对我来说，持续不断地学习和成长已经成为我的人生信条，当我们不再成长，我们就与死亡无异了，成长就是生命，持续不断地学习和成长意味着，感受到自身源源不断的活力，也意味着你能成为最好的自己。  </p>
</blockquote>
<blockquote>
<p>9、我们的自信心决定了我们是否敢于冒险，不去冒险便不可能获得成长。  </p>
</blockquote>
<blockquote>
<p>10、大多数人高估了自己1年内能做到的事情，也低估了自己10年内能做到的事情。  </p>
</blockquote>
<blockquote>
<p>11、我们不应该以他人来衡量自己，而应该与自己做纵向对比。  </p>
</blockquote>
<blockquote>
<p>12、我们常常忘记，顺着我们目前为止走过的道路继续前行，同样有风险，这条路给我们一种熟悉感，但也不会更安全，生活就是一场比赛，不去冒险的人不可能获得成功，立即采取行动！因为你永远不能为成功做好完美的准备。</p>
</blockquote>
<blockquote>
<p>13、世上唯一从来不犯错的人，是从来不做任何事的人。  </p>
</blockquote>
<blockquote>
<p>14、我们倾向于将自己无法理解的事物视为奇迹或好运，然而你也看到了，奇迹是可以创造的，就连好运也是多年准备的结果，最终还是在于我们的态度，态度决定我们是否将无法解释的奇迹定义为一种超自然的现象，决定我们是否将坏运气当作理由，答案如果是肯定的话，那么你就不再负有责任，你的坏运气也会成为一个很好的借口，然而，如果你主动承担责任，那么你的好运气就是可以期待的，每个人都会得到属于自己的机会，根本问题是：我们是否愿意对所有事情（包括奇迹和好运）承担责任？如果愿意承担责任，你将为自己创造的奇迹感到惊讶，如果拒绝承担责任，你就会声称“坏运气已经发生了”（但谁又能与之对抗呢），如果勇敢地承担责任，那么好运气就在你的安排计划之中。  </p>
</blockquote>
<blockquote>
<p>15、知足常乐的人也是主动放弃的人，我们拥有什么样的期望，也就决定了我们能获得什么，渴望从生活中获取许多东西的人，生活会给予更多的回报，乔纳森.斯威夫特曾经说过一句讽刺的话：“不期望任何事的人是有福之人，因为他也不会失望”。  </p>
</blockquote>
<blockquote>
<p>16、永远不让目标低于期望，永远不要劝自己说：你不“值得”拥有，你自己是可以决定你值得拥有什么的，你的期望决定你会获得什么，灯光下有你的一席之地。  </p>
</blockquote>
<blockquote>
<p>17、永远不要用短期解决方案来应对长期问题。  </p>
</blockquote>
<blockquote>
<p>18、每个人获得的东西都恰好是他值得获得的东西，虽然我总听到有人抱怨：“我远比我现在获得的东西有价值的多” 但这是错误的，正确的说法应该是：如果你“值得”更多，那么你早该获得了。  </p>
</blockquote>
<blockquote>
<p>19、你必须了解市场法则，你收入的高低取决于此，你今天的收入就是你昨天所做之决定的结果，如果不理解这一点，你就不能说：“现在我要另做选择” 作为自己人生的设计师，你的收入或加薪是由你自己创造的，不是你被加薪，而是你主动获得加薪，如果别人能够决定你的收入高低，那么他们也就拥有了操纵你人生的权利，你（也只有你）能增加自己的收入，你个人对此负责，你个人就可以做出决定。  </p>
</blockquote>
<blockquote>
<p>20、金钱和机遇并不会应需求而产生，而是应能力而产生，你不会因为自己需要更多金钱而获得加薪，你只会因为你所拥有的能力而获得加薪。  </p>
</blockquote>
<blockquote>
<p>21、永远不要将你对自己的怀疑告知任何人，要展示自己的强项，人们不会追随一个自我怀疑的人，只会追随那些坚强不屈的、对目标坚定不移的人，你的强项往往会为你挣得更多的报酬。  </p>
</blockquote>
<blockquote>
<p>22、如果说世上存在成功之终极秘密，那就是刻不容缓地去处理日常事务的能力，为自己确定一条指导原则：尽可能快地着手去做，不要害怕犯错误，IBM创始人说过：“在我的公司里，想要出成绩，就必须犯下双倍的错误” 犯错使人积累经验，经验帮助你快速做出正确决策。  </p>
</blockquote>
<blockquote>
<p>23、如果想让事物想着利于你的方向发展，那么首先你自己必须变得更好。  </p>
</blockquote>
<blockquote>
<p>24、如何分析你的收入之能力：你在自己的专业领域是一个什么水平？你有没有将自己定位为专家？你了解自己的专业领域吗？你是否已为自己建立起能提升你知识和能力的导师及专家团队？你在个人专业领域之外是否还继续深造？你的个人能力是否和你的专业技能共同成长？你了解成功的法则吗，是否运用了成功的法则？你具备领导资质吗？同你所在领域的优秀人士相比，你的能力如何？  </p>
</blockquote>
<blockquote>
<p>25、如何分析你的收入之精力：你准备将多少精力投入专业技能的提升中去？你实际投入了多少精力？你还有多少能量？你能否将精力集中起来，全身心做某件事情？对于你现在所做的事情，你的热情和激情有多大？你热爱你的工作吗？从长远来看，你在将来需要更多的精力，你是否任然为自己的健康、运动、家庭和持续学习以及成长而投入时间？  </p>
</blockquote>
<blockquote>
<p>26、如何分析你的收入之影响力/知名度：你是否知道这是你的收入板块中最重要的版块？影响力是最强大的乘数，你的产品/你的服务受众面有多广？知识、技术、产品在当今社会比比皆是，你能否利用你的产品挣到钱，取决于有多少人知道。  </p>
</blockquote>
<blockquote>
<p>27、如何分析你的收入之自我评价：你是否知道感知即现实？你推销自己的技巧如何？你对自己的举止有多自信？你的自信有多强？你是否认为自己出类拔萃、鹤立鸡群？你是否能很好地表现自己？别人是否认为你是一名专家？是否有人因为你优秀而愿意无偿地为你服务？别人是否认为认识你是莫大的荣幸？你能准确定位自己吗？  </p>
</blockquote>
<blockquote>
<p>28、如何分析你的收入之创意：你具有创造力吗？你是否易于接受新事物？你是否坚持自己的目标，同时准备不断尝试实现目标的新方法？你是否灵活变通？你会把自己的灵感马上写下来吗？你相信自己的灵感并付诸实施吗？你个人的创意工厂发展壮大了吗？你是否不断问自己，“这个创意如何才能切和我的情况”，“我如何才能快速采取行动”，你相信每一个你需要的信息和解决方法，都可以被找出来？你相信要得到这些信息，你就必须不断发展新的创意吗？  </p>
</blockquote>
<blockquote>
<p>29、你的收入水平很大程度上取决于你能做那些别人不能做的事情，“尽快”这条法则同样适用于此，不要等到自己能力足够了才去做，尽快放权，放权那些别人都能做的事情，把空出来的时间集中用于收入丰厚的活动上，放权其他无用的事情，将时间用来定位自己，在同等时间内，只要你挣到的钱别付给助你做事的人要多，账单就永远不会来烦你。  </p>
</blockquote>
<blockquote>
<p>30、借口是我们讲给自己听的谎言，我们应该自己对自己越来越诚实，承担越来越多的责任，许多人声称:“我没有时间去学习正确的投资方法” 是这样吗?这是真的吗?或者说这些人还可以对自己更诚实吗？“我还没有准备好为此投入更多的时间”，这样说会不会显得更诚实? 一位真正的人物不会将生活中的机会滥用在道歉和寻找借口上，借口使我们贫穷。  </p>
</blockquote>
<blockquote>
<p>31、我们能否实现财务自由，对此起决定性作用的是，我们听从的是两个声音中的哪一个：受害者的声音还是勇于承担责任者的声音，永远不要让你内心中那个弱小的人战胜强大的那个人。  </p>
</blockquote>
<blockquote>
<p>32、即使一直以来都没有什么意外发生，你还是应该坚持，因为有了这笔储备金，你才拥有安全感，安全感是每个人都需要的，当你面临困境时，有支持你的后盾，你才可以更好地解决困难，财务保障便是我们所说的后盾，没人能保证自己在意外和不幸来临时不受伤害，但是我们可以未雨绸缪，让我们在意外发生时，能够从容面对，如果意外来临时，我们还要面临财务危机，或者是因为财务问题而妥协，那才是真正的不幸。  </p>
</blockquote>
<blockquote>
<p>33、财务保障是短期目标：这应当是你下一个目标，一个必须尽快完成的目标。  </p>
</blockquote>
<blockquote>
<p>34、为你的强项找一位教练，为你的弱项找一个解决方案。  </p>
</blockquote>
<blockquote>
<p>35、开始阶段简单的事情以后会变得困难，开始阶段困难的事情以后也会变得简单、储蓄并不难，但由于这对你而言是一项全新的开始，所以在开始阶段你应该会感到十分陌生，用储蓄明智地投资不是一件易事，但你会觉得相对简单，因为有很多容易上手的投资形式，因为你有投资顾问、内行的朋友和其他可供参考的例子。  </p>
</blockquote>
<blockquote>
<p>36、第一项计划财务保障能给你带来很多的益处你可以安全地渡过一次危机，你会感到有安全感，可以时刻准备好面对一些未知的意外，但是财务保障有一个很大的缺点一旦意外情况发生，你会花光所有的积蓄，虽然你在财务上安然无恙地渡过了一次危机，但是你的积蓄都没了，真正保险的办法是，你需要积累足够的资金，使你可以靠利息生活。  </p>
</blockquote>
<blockquote>
<p>37、7年后，你要么就根本没有改变你的财务状况，要么就至少部分实现了你的财务安全，7年之后开始的未来，正是你今天所准备的未来，有的人不去从事自己感兴趣的职业，主要原因就是缺钱，这令人感到惋惜，也是一种才能的浪费，这之所以尤其可悲，是因为我们只有在做自己喜爱的事情时才会真正感到幸福，一个从来没有长期做过使自己快乐的有意义的事情的人，从来不会知道，自身究竟蕴藏着多少潜力，如果有人无法走出关键性的一步，不能做自己感兴趣的工作，那么原因往往都在于金钱。  </p>
</blockquote>
<blockquote>
<p>38、在你做出明确的决定之前，请不要继续读下去，这个决定应该包含你实际做的你所了解的必要之事，你知道，你首先必须着手改变信仰，你必须将巨大的痛苦与目标无法实现联系在一起，将巨大的快乐与目标得以实现联系在一起，你应该意识到为什么你一定要这样生活，记住你必须每天提升自己，全力以赴，你必须不断地学习和成长，你必须付出110%的努力，你必须全力以赴，成为最好的自己。你真的想要这样吗?你真的愿意为了财富和幸福去付出每个人都必须付出的代价吗?如果你决定好了这样做(我也想鼓励你这样做)，你就负有责任了你应该向自己承诺，不到最好，永不满足。多年前，第一次听到这一理念时，我几乎不敢相信，但它确确实实是正确的，当你为自己定好一个目标，制订出书面的计划，你就已经成功50%了，以下也有4个足以证明这一点的重要原因：目标拓宽你的机会意识，目标为你指出解决问题的方向，目标是你为了“赢”而去比赛，你有了一个目标，一切都变得很重要。  </p>
</blockquote>
<blockquote>
<p>39、他人可以短暂地阻止你，但只有你自己才可以永远地使自己停下来。  </p>
</blockquote>
<blockquote>
<p>40、你自己决定受谁影响、向谁学习、学习什么：只模仿那些比你成功的人。  </p>
</blockquote>
<blockquote>
<p>41、成功意味着获得你所爱的东西，而幸福意味着享受你获得的东西。  </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2018/04/18/2018/2018-04-18-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Liyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liyou">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2018/04/18/2018/2018-04-18-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/" class="post-title-link" itemprop="url">读书笔记之在耶鲁精进</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-18 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-18T00:00:00+08:00">2018-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/opinion/" itemprop="url" rel="index"><span itemprop="name">opinion</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B.jpg" alt="在耶鲁精进.jpg"></p>
<p>对于我来说，这是一本信息量巨大的书。</p>
<p>我先试着整理出每个章节的摘录，然后找出关键词，再选择其中的某几个来展开，发现还有10多个，一时不知如何下笔。罢了，既然无从下笔，就写写最想说的吧。</p>
<p>首先是精进这个词，记得在罗振宇时间的朋友跨年晚会上也提过，大意是只有不停的迭代自己，成功的概率才能不断提高。这个惟一靠谱的人生策略，希望自己能铭记，不断的学习、总结、迭代、精进。</p>
<p>其次是通识教育，说实话之前一直没有通识教育的概念，以前在校读书是为了读而读，也没读出个什么花样来。知识结构过于片面，更不用谈触类旁通的智慧了。两年前自己有整理过专业方面的知识架构，目前也一直在完善它；但是通识这块可以说毫无准备，毫无积累，这可不是件好事。通识体系大致包括：文学、数学、科学、经济学、哲学、心理学等，多去了解，扩展自己的涉猎广度何乐而不为。</p>
<p>最后我想说说关于孩子的问题，吴军老师在如何给孩子最好的教育分享会中，讲到“如果有起跑线的话，父母的见识、格局，是孩子的第一起跑线”，父母是孩子的第一任老师，那么上面我们讲到的精进、迭代又或者是扩展自己的通识储备是不是等于在提高将来孩子的第一起跑线呢？此外，还有两点令我影响深刻，①小时候严格要求，长大尊重个人选择。顺序千万别反了。“你是愿意孩子小时候没有多少空间长大后有很多空间呢，还是小时候很多空间长大后没有空间？”什么使人幸福？有选择才有幸福。②让孩子知道生活不易，人生的错误要尽量犯在前面，犯在后面的错误你无法承受，少年则是最好的犯错时期，这时犯错的收益/风险比高到惊人，不犯错简直是虚度人生。将这种思想输送到孩子，不比什么十八线教育培训机构层次高太多？所以我特别特别认同“父母的见识、格局，是孩子的第一起跑线”。</p>
<p>为了利于重复翻阅，还是将摘录做成图片插入在下面:<br><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E5%BA%8F%E8%A8%80.png" alt="序言"></p>
<p><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E8%80%B6%E9%B2%81%E6%95%85%E4%BA%8B.png" alt="耶鲁故事"></p>
<p><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E6%9E%81%E7%AE%80%E9%87%91%E8%9E%8D%E8%AF%BE.png" alt="极简金融课"></p>
<p><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E6%9E%81%E7%AE%80%E8%B0%88%E5%88%A4%E8%AF%BE.png" alt="极简谈判课"></p>
<p><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E5%9C%A8%E7%BE%8E%E5%9B%BD%E7%9C%8B%E7%BE%8E%E5%9B%BD.png" alt="在美国看美国"></p>
<p><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E5%A4%A7%E5%AD%A6.%E9%97%AE.%E7%AD%94%E7%BD%91%E5%8F%8B.png" alt="大学.问.答网友"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/iBlogWebsite/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/iBlogWebsite/">1</a><span class="space">&hellip;</span><a class="page-number" href="/iBlogWebsite/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/iBlogWebsite/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/iBlogWebsite/page/11/">11</a><a class="extend next" rel="next" href="/iBlogWebsite/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liyou"
      src="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
  <p class="site-author-name" itemprop="name">Liyou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/iBlogWebsite/archives/">
        
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/iBlogWebsite/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/iBlogWebsite/tags/">
          
        <span class="site-state-item-count">74</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Leeeyou" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Leeeyou" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liyou</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/iBlogWebsite/lib/anime.min.js"></script>
  <script src="/iBlogWebsite/lib/velocity/velocity.min.js"></script>
  <script src="/iBlogWebsite/lib/velocity/velocity.ui.min.js"></script>

<script src="/iBlogWebsite/js/utils.js"></script>

<script src="/iBlogWebsite/js/motion.js"></script>


<script src="/iBlogWebsite/js/schemes/muse.js"></script>


<script src="/iBlogWebsite/js/next-boot.js"></script>




  




  
<script src="/iBlogWebsite/js/local-search.js"></script>













  

  

</body>
</html>
