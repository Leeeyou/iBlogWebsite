<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/iBlogWebsite/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/iBlogWebsite/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/iBlogWebsite/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/iBlogWebsite/images/logo.svg" color="#222">

<link rel="stylesheet" href="/iBlogWebsite/css/main.css">


<link rel="stylesheet" href="/iBlogWebsite/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"leeeyou.github.io","root":"/iBlogWebsite/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Leeeyou123">
<meta property="og:url" content="https://leeeyou.github.io/iBlogWebsite/page/6/index.html">
<meta property="og:site_name" content="Leeeyou123">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Leeeyou">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://leeeyou.github.io/iBlogWebsite/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Leeeyou123</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/iBlogWebsite/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Leeeyou123</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/iBlogWebsite/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/iBlogWebsite/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/iBlogWebsite/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/iBlogWebsite/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2017/01/16/2017/2017-01-16-%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Leeeyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leeeyou123">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2017/01/16/2017/2017-01-16-%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/" class="post-title-link" itemprop="url">加解密算法，了解一下</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-16 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-16T00:00:00+08:00">2017-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Base64编码算法"><a href="#1-Base64编码算法" class="headerlink" title="1. Base64编码算法"></a>1. Base64编码算法</h1><p>Base64只是一种编码方式，并不是一种加密算法，不要使用Base64来加密数据。</p>
<p>Base64编码算法是一种用64个字符，在计算机网络发展的早期，由于“历史原因”，电子邮件不支持非ASCII码字符，如果要传送的电子邮件带有非ASCII码字符（诸如中文）或者图片，用户收到的电子邮件将会是一堆乱码，因此发明了Base64编码算法。</p>
<p>在加解密算法中，原始的数据和加密后的数据一般也是二进制数据，为了不传输出错，方便保存或者调试代码，一般需要对加密后的数据进行base64编码。</p>
<p>Android提供了Base64编码的工具类android.util.Base64</p>
<p><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//base64.jpg" alt="Base64编码"></p>
<h1 id="2-随机数生成器"><a href="#2-随机数生成器" class="headerlink" title="2. 随机数生成器"></a>2. 随机数生成器</h1><p>在Android加密算法中需要随机数时要使用SecureRandom来获取随机数，如下图示：</p>
<p><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8.jpg" alt="随机数生成器"></p>
<p>注意不要给SecureRandom设置种子。调用seeded constructor或者setSeed(byte[])是不安全的。SecureRandom()默认使用的是dev/urandom作为种子产生器，这个种子是不可预测的。</p>
<p>开发者建议</p>
<ul>
<li>不要使用Random类来获取随机数</li>
<li>在使用SecureRandom时候，不要设置种子。使用以下函数设置种子都是有风险的</li>
</ul>
<p><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//SecureRandom.jpg" alt="SecureRandom"></p>
<h1 id="3-Hash算法"><a href="#3-Hash算法" class="headerlink" title="3. Hash算法"></a>3. Hash算法</h1><p>Hash算法是指任意长度的字符串输入，此算法能给出固定n比特的字符串输出，输出的字符串一般称为Hash值。</p>
<p>两个特点</p>
<ol>
<li><p>抗碰撞性</p>
<p> 抗碰撞性使Hash算法对原始输入的任意一点更改，都会导致产生不同的Hash值，因此Hash算法可以用来检验数据的完整性。</p>
</li>
<li><p>不可逆性</p>
<p> 不可逆的特性使Hash算法成为一种单向密码体制，只能加密不能解密，可以用来加密用户的登录密码等凭证。</p>
</li>
</ol>
<p>开发者建议</p>
<ol>
<li>建议使用SHA-256、SHA-3算法，不建议使用MD2、MD4、MD5、SHA-1、RIPEMD算法来加密用户密码等敏感信息。这一类算法已经有很多破解办法，例如md5算法，网上有很多查询的字典库，给出md5值，可以查到加密前的数据。</li>
<li>不要使用哈希函数做为对称加密算法的签名，当多个字符串串接后再做hash，要非常当心。实际开发过程中经常会对url的各个参数，做词典排序，然后取参数名和值串接后加上某个SECRET字符串，计算出hash值，作为此URL的签名。</li>
</ol>
<h1 id="4-消息认证算法"><a href="#4-消息认证算法" class="headerlink" title="4. 消息认证算法"></a>4. 消息认证算法</h1><p>要确保加密的消息不是别人伪造的，需要提供一个消息认证码（MAC，Message authentication code）。消息认证码是带密钥的hash函数，基于密钥和hash函数。消息发送者使用MAC算法计算出消息的MAC值，追加到消息后面一起发送给接收者。接收者收到消息后，用相同的MAC算法计算接收到消息MAC值，并与接收到的MAC值对比是否一样。</p>
<h1 id="5-对称加密算法"><a href="#5-对称加密算法" class="headerlink" title="5. 对称加密算法"></a>5. 对称加密算法</h1><p>在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，<br>这就要求解密方事先必须知道加密密钥。该算法的缺点是，如果一旦密钥泄漏，那么加密的内容将都不可信了。</p>
<p>开发者建议</p>
<p>建议使用AES算法，DES默认的是56位的加密密钥，已经不安全，不建议使用。</p>
<p><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//ECB.png" alt="ECB"></p>
<p>注意加密模式不要使用ECB模式。ECB模式不安全，说明问题的经典的三张图片。</p>
<p><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//AndroidAES.jpg" alt="AndroidAES"></p>
<p>Android 提供的AES加密算法API默认使用的是ECB模式，所以要显式指定加密算法为：CBC或CFB模式，可带上PKCS5Padding填充。AES密钥长度最少是128位，推荐使用256位。</p>
<h1 id="6-非对称加密"><a href="#6-非对称加密" class="headerlink" title="6. 非对称加密"></a>6. 非对称加密</h1><p>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密（这个过程可以做数字签名）。非对称加密主要使用的是RSA算法</p>
<p>开发者建议</p>
<ol>
<li>注意密钥长度不要低于512位，建议使用2048位的密钥长度。 使用RSA进行数字签名的算法。<br><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//RSA.jpg" alt="RSA"></li>
<li>使用RSA算法做加密，RSA加密算法应使用Cipher.getInstanceRSA/ECB/OAEPWithSHA256AndMGF1Padding)，否则会存在重放攻击的风险。<br><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//RSA2.jpg" alt="RSA2"></li>
</ol>
<h1 id="7-加密算法PBE"><a href="#7-加密算法PBE" class="headerlink" title="7. 加密算法PBE"></a>7. 加密算法PBE</h1><p>PBE是一种基于口令的加密算法，其特点是使用口令代替了密钥，而口令由用户自己掌管，采用随机数杂凑多重加密等方法保证数据的安全性。</p>
<p>开发者建议</p>
<ol>
<li>使用基于口令的加密算法PBE时，生成密钥时要加盐，盐的取值最好来自SecureRandom，并指定迭代次数。<br><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//PBE.jpg" alt="PBE"></li>
</ol>
<h1 id="8-加密和解密"><a href="#8-加密和解密" class="headerlink" title="8. 加密和解密"></a>8. 加密和解密</h1><p>加密要用公钥 (n,e)</p>
<ul>
<li>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</li>
<li>所谓”加密”，就是算出下式的c：me ≡ c (mod n),于是，c等于2790，鲍勃就把2790发给了爱丽丝。</li>
</ul>
<p>解密要用私钥(n,d)</p>
<ul>
<li>爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：cd ≡ m (mod n)</li>
<li>也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出：27902753 ≡ 65 (mod 3233)</li>
<li>因此，爱丽丝知道了鲍勃加密前的原文就是65。</li>
</ul>
<p>公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？</p>
<ul>
<li>一种是把长信息分割成若干段短消息，每段分别加密；</li>
<li>另一种是先选择一种”对称性加密算法”（比如DES），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2017/01/06/2017/2017-01-06-%E6%95%B0%E6%8D%AE%E6%91%98%E8%A6%81%E3%80%81%E7%AD%BE%E5%90%8D%E5%92%8C%E8%AF%81%E4%B9%A6%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Leeeyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leeeyou123">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2017/01/06/2017/2017-01-06-%E6%95%B0%E6%8D%AE%E6%91%98%E8%A6%81%E3%80%81%E7%AD%BE%E5%90%8D%E5%92%8C%E8%AF%81%E4%B9%A6%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/" class="post-title-link" itemprop="url">数据摘要、签名和证书，了解一下</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-06 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-06T00:00:00+08:00">2017-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-密码学的三大作用"><a href="#1-密码学的三大作用" class="headerlink" title="1. 密码学的三大作用"></a>1. 密码学的三大作用</h1><ol>
<li>加密：防止坏人获取你的数据</li>
<li>认证：防止坏人修改了你的数据而你却并没有发现</li>
<li>鉴权：防止坏人假冒你的身份</li>
</ol>
<h1 id="2-数据摘要"><a href="#2-数据摘要" class="headerlink" title="2. 数据摘要"></a>2. 数据摘要</h1><p>一个数据源进行一个算法之后得到一个摘要，也叫作数据指纹。著名的摘要算法有RSA公司的MD5算法和SHA-1算法及其大量的变体。</p>
<p>消息摘要的主要特点</p>
<ul>
<li>无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。例如应用MD5算法摘要的消息有128个比特位，用SHA-1算法摘要的消息最终有160比特位的输出。</li>
<li>一般来说（不考虑碰撞的情况下），只要输入的原始数据不同，对其进行摘要以后产生的消息摘要也必不相同，即使原始数据稍有改变，输出的消息摘要便完全不同。但是，相同的输入必会产生相同的输出。</li>
<li>具有不可逆性，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的原始消息。</li>
</ul>
<p>下面是Java中采用MD5和SHA-1进行摘要计算的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.other;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDigitalSummary</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;curriculum&quot;</span>;</span><br><span class="line"></span><br><span class="line">        md5(<span class="literal">null</span>);</span><br><span class="line">        md5(s1);</span><br><span class="line">        md5(s2);</span><br><span class="line"></span><br><span class="line">        sha1(<span class="literal">null</span>);</span><br><span class="line">        sha1(s1);</span><br><span class="line">        sha1(s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">md5</span><span class="params">(String plainText)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (plainText == <span class="literal">null</span> || plainText.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md5</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">            md5.reset();</span><br><span class="line">            md5.update(plainText.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="type">byte</span>[] digestByteArray = md5.digest();</span><br><span class="line">            System.out.println(<span class="string">&quot;the plain text is : &quot;</span> + plainText);</span><br><span class="line">            System.out.println(<span class="string">&quot;the length is : &quot;</span> + digestByteArray.length);<span class="comment">//16 bytes represent 128 bits</span></span><br><span class="line">            System.out.println(<span class="string">&quot;the plain byte array is : &quot;</span> + Arrays.toString(digestByteArray));</span><br><span class="line">            System.out.println(<span class="string">&quot;the digital summary after md5 is : &quot;</span> + byteArrayTo32Md5String(digestByteArray));</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteArrayTo32Md5String</span><span class="params">(<span class="type">byte</span>[] byteArray)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (byteArray == <span class="literal">null</span> || byteArray.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="number">1</span>, byteArray);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(bigInteger.toString(<span class="number">16</span>));</span><br><span class="line">        <span class="keyword">while</span> (s.length() &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            s.append(<span class="string">&quot;0&quot;</span>).append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sha1</span><span class="params">(String plainText)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (plainText == <span class="literal">null</span> || plainText.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">sha1</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">            sha1.reset();</span><br><span class="line">            sha1.update(plainText.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="type">byte</span>[] digestByteArray = sha1.digest();</span><br><span class="line">            System.out.println(<span class="string">&quot;the plain text is : &quot;</span> + plainText);</span><br><span class="line">            System.out.println(<span class="string">&quot;the length is : &quot;</span> + digestByteArray.length);<span class="comment">//20 bytes represent 128 bits</span></span><br><span class="line">            System.out.println(<span class="string">&quot;the plain byte array is : &quot;</span> + Arrays.toString(digestByteArray));</span><br><span class="line">            System.out.println(<span class="string">&quot;the digital summary after SHA-1 is : &quot;</span> + byteArrayToSha1String(digestByteArray));</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteArrayToSha1String</span><span class="params">(<span class="type">byte</span>[] byteArray)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (byteArray == <span class="literal">null</span> || byteArray.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="number">1</span>, byteArray);</span><br><span class="line">        <span class="keyword">return</span> bigInteger.toString(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其结果如下所示，可以看到md5之后得到了一个长度为32的字符串，而byte数组的长度是16，即128比特。而SHA-1之后得到了一个长度为40的字符串，而byte数组的长度为20，即160比特。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">the plain text is : abc</span><br><span class="line">the length is : <span class="number">16</span></span><br><span class="line">the plain <span class="type">byte</span> array is : [-<span class="number">112</span>, <span class="number">1</span>, <span class="number">80</span>, -<span class="number">104</span>, <span class="number">60</span>, -<span class="number">46</span>, <span class="number">79</span>, -<span class="number">80</span>, -<span class="number">42</span>, -<span class="number">106</span>, <span class="number">63</span>, <span class="number">125</span>, <span class="number">40</span>, -<span class="number">31</span>, <span class="number">127</span>, <span class="number">114</span>]</span><br><span class="line">the digital summary after md5 is : 900150983cd24fb0d6963f7d28e17f72</span><br><span class="line"></span><br><span class="line">the plain text is : curriculum</span><br><span class="line">the length is : <span class="number">16</span></span><br><span class="line">the plain <span class="type">byte</span> array is : [-<span class="number">69</span>, <span class="number">99</span>, <span class="number">119</span>, <span class="number">60</span>, -<span class="number">83</span>, -<span class="number">105</span>, -<span class="number">1</span>, -<span class="number">49</span>, -<span class="number">45</span>, -<span class="number">97</span>, <span class="number">92</span>, -<span class="number">4</span>, <span class="number">102</span>, -<span class="number">19</span>, <span class="number">18</span>, -<span class="number">26</span>]</span><br><span class="line">the digital summary after md5 is : bb63773cad97ffcfd39f5cfc66ed12e6</span><br><span class="line"></span><br><span class="line">the plain text is : abc</span><br><span class="line">the length is : <span class="number">20</span></span><br><span class="line">the plain <span class="type">byte</span> array is : [-<span class="number">87</span>, -<span class="number">103</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">71</span>, <span class="number">6</span>, -<span class="number">127</span>, <span class="number">106</span>, -<span class="number">70</span>, <span class="number">62</span>, <span class="number">37</span>, <span class="number">113</span>, <span class="number">120</span>, <span class="number">80</span>, -<span class="number">62</span>, <span class="number">108</span>, -<span class="number">100</span>, -<span class="number">48</span>, -<span class="number">40</span>, -<span class="number">99</span>]</span><br><span class="line">the digital summary after SHA-<span class="number">1</span> is : a9993e364706816aba3e25717850c26c9cd0d89d</span><br><span class="line"></span><br><span class="line">the plain text is : curriculum</span><br><span class="line">the length is : <span class="number">20</span></span><br><span class="line">the plain <span class="type">byte</span> array is : [<span class="number">74</span>, <span class="number">19</span>, <span class="number">10</span>, -<span class="number">20</span>, <span class="number">7</span>, <span class="number">4</span>, -<span class="number">59</span>, -<span class="number">94</span>, -<span class="number">113</span>, -<span class="number">70</span>, <span class="number">8</span>, -<span class="number">111</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">40</span>, <span class="number">21</span>, -<span class="number">54</span>, -<span class="number">35</span>, -<span class="number">85</span>, -<span class="number">14</span>]</span><br><span class="line">the digital summary after SHA-<span class="number">1</span> is : 4a130aec0704c5a28fba08917f032815caddabf2</span><br></pre></td></tr></table></figure>

<h1 id="3-签名文件和证书"><a href="#3-签名文件和证书" class="headerlink" title="3. 签名文件和证书"></a>3. 签名文件和证书</h1><p>要确保通信安全，需要确保两个问题：① 要确定<strong>消息的来源</strong>确实是其申明的那个人，② 要保证信息在传递的过程中<strong>不被第三方篡改，即使被篡改了，也可以发觉出来</strong>。</p>
<p>对于消息的发送者来说，先要生成一对公私钥对，将公钥给消息的接收者。</p>
<p>发送方：发送者发消息给接收者，对要发送的原始消息提取<strong>消息摘要</strong>，对提取的<strong>消息摘要</strong>用自己的私钥加密，这里就是原始信息的<strong>数字签名</strong>。<br>接收方：对原始消息部分提取<strong>消息摘要</strong>，注意这里使用的消息摘要算法要和发送方使用的一致；对附加上的那段<strong>数字签名</strong>，使用预先得到的公钥解密；比较前两步所得到的两段消息是否一致。如果一致，则表明消息确实是期望的发送者发的，且内容没有被篡改过；相反，如果不一致，则表明传送的过程中一定出了问题，消息不可信。</p>
<p>通过这种所谓的数字签名技术，确实可以有效解决可靠通信的问题。如果原始消息在传送的过程中被篡改了，那么在接收者那里，对被篡改的消息提取的<strong>消息摘要</strong>肯定和原始的不一样。并且，由于篡改者没有消息发送方的私钥，即使他可以重新算出被篡改消息的摘要，也不能伪造出<strong>数字签名</strong>。</p>
<p>数字签名和签名验证的大体流程</p>
<p><img src="/images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E7%9A%84%E5%A4%A7%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="数字签名和签名验证的大体流程"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2017/01/04/2017/2017-01-04-Android%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Leeeyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leeeyou123">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2017/01/04/2017/2017-01-04-Android%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">Android之性能优化整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-04T00:00:00+08:00">2017-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2017年第一篇日志：【性能优化】知识汇总新鲜出炉，包括UI和组件的优化、图片的优化、线程优化、内存优化以及响应速度及卡顿优化，知道内存泄漏和内存溢出的区别吗？知道图片放错drawable文件夹导致失真的问题吗？赶紧瞅一瞅吧。</p>
<h1 id="1-UI和组件的优化"><a href="#1-UI和组件的优化" class="headerlink" title="1. UI和组件的优化"></a>1. UI和组件的优化</h1><h2 id="1-1-Android中常见的度量单位"><a href="#1-1-Android中常见的度量单位" class="headerlink" title="1.1. Android中常见的度量单位"></a>1.1. Android中常见的度量单位</h2><h3 id="1-1-1-inch"><a href="#1-1-1-inch" class="headerlink" title="1.1.1. inch"></a>1.1.1. inch</h3><p>它表示设备的物理屏幕的对角线长度，其中1 inch = 2.54 cm。</p>
<h3 id="1-1-2-px"><a href="#1-1-2-px" class="headerlink" title="1.1.2. px"></a>1.1.2. px</h3><p>表示屏幕的像素。如分辨率为1920*1080，它表示屏幕的X方向上有1080个像素，Y方向上有1920个像素。</p>
<h3 id="1-1-3-dpi和densityDpi"><a href="#1-1-3-dpi和densityDpi" class="headerlink" title="1.1.3. dpi和densityDpi"></a>1.1.3. dpi和densityDpi</h3><p>dot per inch简称为dpi，它表示每英寸上的像素点个数，所以它也常为屏幕密度。</p>
<p>在Android中使用DisplayMetrics中的densityDpi字段表示该值，并且不少文档中常用dpi来简化或者指代densityDpi。</p>
<p>如下屏幕密度对照表</p>
<p><img src="../../../../images/githubpages/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6%E5%AF%B9%E7%85%A7%E8%A1%A8.png" alt="屏幕密度对照表"></p>
<p>问题：通过代码获取到的densityDpi和我们计算出来的屏幕实际密度值440.582不一样，为什么？</p>
<ul>
<li><p>在每部手机出厂时都会为该手机设置屏幕密度，若其屏幕的实际密度是440dpi那么就会将其屏幕密度设置为与之接近的480dpi；如果实际密度为325dpi那么就会将其屏幕密度设置为与之接近的20dpi。这也就是说常见的屏幕密度是与每个显示级别的最大值相对应的，比如：120、160、240、320、480、640等。</p>
</li>
<li><p>有的手机不一定会选择120、160、240、320、480、640中的值作为屏幕密度，而是选择实际的dpi作为屏幕密度。比如小米手机，它的某些机型的densityDpi就是个非常规的值。</p>
</li>
</ul>
<h3 id="1-1-4-dp"><a href="#1-1-4-dp" class="headerlink" title="1.1.4. dp"></a>1.1.4. dp</h3><p>density-independent pixel简称为dip或者dp,它表示与密度无关的像素。如果使用dp作为长度单位，那么该长度在不同密度的屏幕中显示的比例将保持一致。</p>
<p>如下密度无关像素与屏幕密度对照表</p>
<p><img src="../../../../images/githubpages/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%AF%86%E5%BA%A6%E6%97%A0%E5%85%B3%E5%83%8F%E7%B4%A0%E4%B8%8E%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6%E5%AF%B9%E7%85%A7%E8%A1%A8.png" alt="密度无关像素与屏幕密度对照表"></p>
<h3 id="1-1-5-sp"><a href="#1-1-5-sp" class="headerlink" title="1.1.5. sp"></a>1.1.5. sp</h3><p>scale-independent pixel简称为sp，它类似于dp，但主要用于表示字体的大小。</p>
<h2 id="1-2-屏幕适配的问题"><a href="#1-2-屏幕适配的问题" class="headerlink" title="1.2. 屏幕适配的问题"></a>1.2. 屏幕适配的问题</h2><ol>
<li>采用主流的分辨率设计UI(xhdpi或者xxhdpi)</li>
<li>放在正确的drawable文件夹中</li>
<li>统一使用dp和sp作为尺寸单位，利用dimens.xml自动切换</li>
<li>利用开源项目：SupportMultipleScreensUtil、com.android.support:percent:22.2.0<ul>
<li>PercentRelativeLayout</li>
<li>PercentFrameLayout</li>
<li>支持宽高以及margin</li>
</ul>
</li>
</ol>
<h2 id="1-3-布局优化"><a href="#1-3-布局优化" class="headerlink" title="1.3. 布局优化"></a>1.3. 布局优化</h2><ol>
<li>删除布局中无用的控件和层级</li>
<li>有选择的使用性能较低的ViewGroup：优先LinearLayout,FrameLayout</li>
<li>采用<include>标签、<merge>标签和ViewStub。其中ViewStub的意义在于按需加载所需的布局文件</li>
</ol>
<h2 id="1-4-绘制优化"><a href="#1-4-绘制优化" class="headerlink" title="1.4. 绘制优化"></a>1.4. 绘制优化</h2><ol>
<li>View的onDraw方法要避免执行大量的操作</li>
</ol>
<ul>
<li>onDraw中不要创建新的局部对象</li>
<li>onDraw方法中不要做耗时的任务，也不能执行成千上万次的循环操作。</li>
</ul>
<ol>
<li>尽管每次循环都很轻量级，但是大量的循环仍然十分抢占CPU的时间片，这样会造成View的绘制过程不流畅</li>
</ol>
<h2 id="1-5-ListView优化"><a href="#1-5-ListView优化" class="headerlink" title="1.5. ListView优化"></a>1.5. ListView优化</h2><h3 id="1-5-1-重用converView"><a href="#1-5-1-重用converView" class="headerlink" title="1.5.1. 重用converView"></a>1.5.1. 重用converView</h3><p>通过复用converview来减少不必要的view的创建，另外Infalte操作会把xml文件实例化成相应的View实例，属于IO操作，是耗时操作。</p>
<h3 id="1-5-2-减少findViewById-操作"><a href="#1-5-2-减少findViewById-操作" class="headerlink" title="1.5.2. 减少findViewById()操作"></a>1.5.2. 减少findViewById()操作</h3><p>将xml文件中的元素封装成viewholder静态类，通过converview的setTag和getTag方法将view与相应的holder对象绑定在一起，避免不必要的findviewbyid操作。</p>
<h3 id="1-5-3-避免在-getView-方法中做耗时的操作"><a href="#1-5-3-避免在-getView-方法中做耗时的操作" class="headerlink" title="1.5.3. 避免在 getView 方法中做耗时的操作"></a>1.5.3. 避免在 getView 方法中做耗时的操作</h3><p>例如加载本地 Image 需要载入内存以及解析 Bitmap ，都是比较耗时的操作，如果用户快速滑动listview，会因为getview逻辑过于复杂耗时而造成滑动卡顿现象。用户滑动时候不要加载图片，待滑动完成再加载，可以使用这个第三方库glide</p>
<h3 id="1-5-4-Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘"><a href="#1-5-4-Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘" class="headerlink" title="1.5.4. Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘"></a>1.5.4. Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘</h3><h3 id="1-5-5-尽量能保证Adapter的hasStableIds-返回-true"><a href="#1-5-5-尽量能保证Adapter的hasStableIds-返回-true" class="headerlink" title="1.5.5. 尽量能保证Adapter的hasStableIds() 返回 true"></a>1.5.5. 尽量能保证Adapter的hasStableIds() 返回 true</h3><p>这样在 notifyDataSetChanged() 的时候，如果item内容并没有变化，ListView 将不会重新绘制这个 View，达到优化的目的。</p>
<p>在一些场景中，ScollView内会包含多个ListView，可以把listview的高度写死固定下来。由于ScollView在快速滑动过程中需要大量计算每一个listview的高度，阻塞了UI线程导致卡顿现象出现，如果我们每一个item的高度都是均匀的，可以通过计算把listview的高度确定下来，避免卡顿现象出现。</p>
<h3 id="1-5-6-使用-RecycleView-代替listview"><a href="#1-5-6-使用-RecycleView-代替listview" class="headerlink" title="1.5.6. 使用 RecycleView 代替listview"></a>1.5.6. 使用 RecycleView 代替listview</h3><p>每个item内容的变动，listview都需要去调用notifyDataSetChanged来更新全部的item，太浪费性能了。RecycleView可以实现当个item的局部刷新，并且引入了增加和删除的动态效果，在性能上和定制上都有很大的改善。</p>
<h3 id="1-5-7-ListView中元素避免半透明"><a href="#1-5-7-ListView中元素避免半透明" class="headerlink" title="1.5.7. ListView中元素避免半透明"></a>1.5.7. ListView中元素避免半透明</h3><p>半透明绘制需要大量乘法计算，在滑动时不停重绘会造成大量的计算，在比较差的机子上会比较卡。在设计上能不半透明就不不半透明。实在要弄就把在滑动的时候把半透明设置成不透明，滑动完再重新设置成半透明。根据列表的滑动状态来控制任务的执行频率，比如当列表滑动时显然不太适合开启大量的异步任务。</p>
<h3 id="1-5-8-尽量开启硬件加速"><a href="#1-5-8-尽量开启硬件加速" class="headerlink" title="1.5.8. 尽量开启硬件加速"></a>1.5.8. 尽量开启硬件加速</h3><p>硬件加速提升巨大，避免使用一些不支持的函数导致含泪关闭某个地方的硬件加速。当然这一条不只是对 ListView。</p>
<h1 id="2-图片的优化"><a href="#2-图片的优化" class="headerlink" title="2. 图片的优化"></a>2. 图片的优化</h1><h2 id="2-1-Bitmap优化"><a href="#2-1-Bitmap优化" class="headerlink" title="2.1. Bitmap优化"></a>2.1. Bitmap优化</h2><ol>
<li>及时的销毁</li>
</ol>
<ul>
<li>recycle并不能确定立即就会将Bitmap释放掉，但是会给虚拟机一个暗示：“该图片可以释放了”,还有就是， 虽然recycle()从源码上看，调用它应该能立即释放Bitmap的主要内存，但是测试表明它并没能立即释放内存。故我们还需手动设置为NULL这样还能大大的加速Bitmap的主要内存的释放。</li>
</ul>
<ol>
<li>设置一定的采样率</li>
<li>使用缓存LruCache 以及本地缓存</li>
</ol>
<h2 id="2-2-drawable图片的加载导致失真的问题"><a href="#2-2-drawable图片的加载导致失真的问题" class="headerlink" title="2.2. drawable图片的加载导致失真的问题"></a>2.2. drawable图片的加载导致失真的问题</h2><p><img src="../../../../images/githubpages/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%9B%BE%E7%89%87%E7%9A%84%E5%AE%BD%E4%B8%BA144%EF%BC%8C%E9%AB%98%E4%B8%BA180%E6%94%BE%E5%9C%A8%E4%B8%8D%E5%90%8Cdrawable%E4%B8%AD%E5%86%85%E5%AD%98%E7%9A%84%E6%B6%88%E8%80%97%E6%83%85%E5%86%B5.png" alt="图片的宽为144，高为180放在不同drawable中内存的消耗情况"></p>
<p>假设手机的dpi值为480，把有一张图片放到drawable-xxhdpi里在手机上显示出来是不失真的，非常合适；但是错放到了drawable-xhdpi(其TypedValue的value值为320)后再次显示时发现图片被放大了，而且放大了480/320=1.5倍。既然图片被放大了那么该图片所占的内存当然也变大了。</p>
<p>这也就解释了我们有时遇到的类似困惑：为什么图片放在drawable-xxhdpi是正常的，但是放到drawable-mdpi后图片不仅仅放大失真而且所占内存也大幅增加了。</p>
<p>图片放在drawable-nodpi中，那么该图片不会被缩放；也就是说该图片在不同分辨率的手机上都只显示原图的大小。例如，把刚才这张图片放到drawable-nodpi中，那么它在各个手机上显示时它的宽均为144，高均为180。</p>
<h1 id="3-线程优化"><a href="#3-线程优化" class="headerlink" title="3. 线程优化"></a>3. 线程优化</h1><h2 id="3-1-采用线程池"><a href="#3-1-采用线程池" class="headerlink" title="3.1. 采用线程池"></a>3.1. 采用线程池</h2><p>线程池可以重用内部的线程，从而避免了线程的创建和销毁所带来的性能开销</p>
<p>同时线程池还能有效的控制线程池的最大并发数，避免大量的线程因互相抢占系统资源而导致阻塞现象的发生</p>
<h1 id="4-内存优化"><a href="#4-内存优化" class="headerlink" title="4. 内存优化"></a>4. 内存优化</h1><h2 id="4-1-内存管理"><a href="#4-1-内存管理" class="headerlink" title="4.1. 内存管理"></a>4.1. 内存管理</h2><h3 id="4-1-1-分配机制"><a href="#4-1-1-分配机制" class="headerlink" title="4.1.1. 分配机制"></a>4.1.1. 分配机制</h3><p>Android采用弹性的分配方式，也就是刚开始并不会一下分配很多内存给每个进程，而是给每一个进程分配一个“够用”的量。这个量是根据每一个设备实际的物理内存大小来决定的。</p>
<p>当前的内存可能不够使用了，这时候Android又会为每个进程分配一些额外的内存大小。</p>
<p>Android系统的宗旨是最大限度的让更多的进程存活在内存中，因为这样的话，下一次用户再启动应用，不需要重新创建进程，只需要恢复已有的进程就可以了，减少了应用的启动时间，提高了用户体验。</p>
<h3 id="4-1-2-回收机制"><a href="#4-1-2-回收机制" class="headerlink" title="4.1.2. 回收机制"></a>4.1.2. 回收机制</h3><p>Android对内存的使用方式是“尽最大限度的使用”，这一点继承了Linux的优点。Android会在内存中保存尽可能多的数据，即使有些进程不再使用了，但是它的数据还被存储在内存中，所以Android现在不推荐显式的“退出”应用。</p>
<p>当用户下次再启动应用的时候，只需要恢复当前进程就可以了，不需要重新创建进程，这样就可以减少应用的启动时间。</p>
<p>只有当Android系统发现内存不够使用，需要回收内存的时候，Android系统就会需要杀死其他进程，来回收足够的内存。所以Android会有限清理那些已经不再使用的进程，以保证最小的副作用。</p>
<p>Android杀死进程有两个参考条件</p>
<ol>
<li><p>进程优先级</p>
<ul>
<li>前台进程</li>
<li>可见进程</li>
<li>服务进程</li>
<li>后台进程</li>
<li>存放于一个LRU缓存列表中，先杀死处于列表尾部的进程</li>
<li>空进程</li>
<li>正常情况下，为了平衡系统整体性能，Android不保存这些进程</li>
</ul>
</li>
<li><p>回收收益</p>
<ul>
<li>当Android系统开始杀死LRU缓存中的进程时，系统会判断每个进程杀死后带来的回收收益。因为Android总是倾向于杀死一个能回收更多内存的进程，从而可以杀死更少的进程，来获取更多的内存。杀死的进程越少，对用户体验的影响就越小。</li>
</ul>
</li>
</ol>
<h3 id="4-1-3-官方推荐的App内存使用方式"><a href="#4-1-3-官方推荐的App内存使用方式" class="headerlink" title="4.1.3. 官方推荐的App内存使用方式"></a>4.1.3. 官方推荐的App内存使用方式</h3><ol>
<li>当Service完成任务后，尽量停止它</li>
<li>在UI不可见的时候，释放掉一些只有UI使用的资源</li>
<li>在系统内存紧张的时候，尽可能多的释放掉一些非重要资源</li>
<li>检查自己最大可用的内存大小</li>
<li>避免滥用Bitmap导致的内存浪费</li>
<li>使用针对内存优化过的数据容器</li>
<li>意识到内存的过度消耗<ul>
<li>避免创建不必要的对象。</li>
<li>在合适的生命周期中，合理的管理资源。</li>
<li>在系统内存不足时，主动释放更多的资源。</li>
</ul>
</li>
<li>抽象代码也会带来更多的内存消耗</li>
<li>避免使用依赖注入的框架</li>
<li>使用多进程<ul>
<li>把消耗内存过大的模块，或者需要长期在后台运行的模块，移入到单独的进程中运行。Android会为每一个进程单独分配内存，所以理论上App就可以使用到更多的内存。但是多进程是一把双刃剑，错误的使用，会带来其他很多的问题。</li>
</ul>
</li>
</ol>
<h2 id="4-2-内存泄漏"><a href="#4-2-内存泄漏" class="headerlink" title="4.2. 内存泄漏"></a>4.2. 内存泄漏</h2><p>指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p>
<h3 id="4-2-1-Activity引起内存泄漏"><a href="#4-2-1-Activity引起内存泄漏" class="headerlink" title="4.2.1. Activity引起内存泄漏"></a>4.2.1. Activity引起内存泄漏</h3><p>在 Java 中，非静态匿名内部类会持有其外部类的隐式引用，如果你没有考虑过这一点，那么存储该引用会导致 Activity 被保留，而不是被垃圾回收机制回收。</p>
<p>如果你的内存泄漏发生在 Activity 中，那么你将损失大量的内存空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  示例向我们展示了在 Activity 的配置改变时（配置改变会导致其下的 Activity 实例被销</span></span><br><span class="line"><span class="comment">    *  毁）存活。此外，Activity 的 context 也是内存泄漏的一部分，因为每一个线程都被初始</span></span><br><span class="line"><span class="comment">    *  化为匿名内部类，使得每一个线程都持有一个外部 Activity 实例的隐式引用，使得</span></span><br><span class="line"><span class="comment">    *  Activity 不会被 Java 的垃圾回收机制回收。</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    exampleOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exampleOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例来说，在使用应用的时候，你执行了10次横屏/竖屏操作，每一次方向的改变都会执行下面的代码，每一次配置的改变都会使 Android 系统新建一个 Activity 并把改变前的 Activity 交给垃圾回收机制回收。但因为线程持有旧 Activity 的隐式引用，使该 Activity 没有被垃圾回收机制回收。这样的问题会导致每一个新建的 Activity 都将发生内存泄漏，与 Activity 相关的所有资源文件也不会被回收，其中的内存泄漏有多严重可想而知。（该线程类声明为私有的静态内部类就可以解决这个问题）</p>
<h3 id="4-2-2-AsyncTask导致的内存泄漏"><a href="#4-2-2-AsyncTask导致的内存泄漏" class="headerlink" title="4.2.2. AsyncTask导致的内存泄漏"></a>4.2.2. AsyncTask导致的内存泄漏</h3><p>问题点</p>
<ul>
<li>持有外部context强引用</li>
<li>持有外部UI组件强引用</li>
</ul>
<p>解决办法</p>
<ul>
<li>对context采用WeakRefrence,在使用之前判断是否为空。</li>
<li>在Activity生命周期结束前，去cancel AsyncTask，因为Activity都要销毁了，这个时候再跑线程，绘UI显然已经没什么意义了。</li>
</ul>
<h3 id="4-2-3-线程引起内存泄漏"><a href="#4-2-3-线程引起内存泄漏" class="headerlink" title="4.2.3. 线程引起内存泄漏"></a>4.2.3. 线程引起内存泄漏</h3><p>在Java中线程是垃圾回收机制的根源，也就是说，在运行系统中DVM虚拟机总会使硬件持有所有运行状态的进程的引用，结果导致处于运行状态的线程将永远不会被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 除了我们需要实现销毁逻辑以保证线程不会发生内存泄漏，其他代码和示例2相同。在退出当前</span></span><br><span class="line"><span class="comment">* Activity 前使用 onDestroy() 方法结束你的运行中线程是个不错的选择</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyThread mThread;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        exampleThree();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exampleThree</span><span class="params">()</span> &#123;</span><br><span class="line">        mThread = <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        mThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 私有的静态内部类不会持有其外部类的引用，使得 Activity 实例不会在配置改变时发生内</span></span><br><span class="line"><span class="comment">    * 存泄漏</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mRunning</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            mRunning = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (mRunning) &#123;</span><br><span class="line">            SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">            mRunning = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        mThread.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-结论"><a href="#4-2-4-结论" class="headerlink" title="4.2.4. 结论"></a>4.2.4. 结论</h3><ol>
<li>避免写出内存泄露的代码<ul>
<li>静态变量导致的内存泄露</li>
<li>单例模式导致的内存泄露，单例模式的特点是其生命周期和Application保持一致，因此Activity对象无法被及时释放</li>
<li>属性动画导致的内存泄露，在Activity的onDestroy中调用animator.cancel()来停止动画</li>
<li>创建过多对象导致内存在短时间内快速被消耗掉了</li>
</ul>
</li>
<li>通过TraceView、MAT等工具找出潜在的内存泄露</li>
<li>适当的使用WeakReference</li>
<li>尽可能使用静态内部类而不是非静态内部类</li>
<li>不要总想着 Java 的垃圾回收机制会帮你解决所有内存回收问题<ul>
<li>为你的后台线程实现销毁逻辑是你在使用线程时必须时刻铭记的细节，此外，你在设计销毁逻辑时要根据 Activity 的生命周期去设计，避免出现 Bug。</li>
</ul>
</li>
<li>考虑你是否真的需要使用线程</li>
</ol>
<h2 id="4-3-内存溢出"><a href="#4-3-内存溢出" class="headerlink" title="4.3. 内存溢出"></a>4.3. 内存溢出</h2><p>指程序在申请内存时，没有足够的内存空间供其使用，出现OOM。memory leak会最终会导致out of memory。比如申请了一个integer，但给它存了long才能存下的数，那就是内存溢出</p>
<p>解决办法</p>
<ul>
<li>减少每个对象占用的内存，比如压缩图片</li>
<li>申请大内存</li>
</ul>
<h2 id="4-4-APK大小优化"><a href="#4-4-APK大小优化" class="headerlink" title="4.4. APK大小优化"></a>4.4. APK大小优化</h2><p>不必过度优化你的代码，要优化你的选择。</p>
<h3 id="4-4-1-优点"><a href="#4-4-1-优点" class="headerlink" title="4.4.1. 优点"></a>4.4.1. 优点</h3><ol>
<li>减少APP下载和安装的时间</li>
<li>减少APP安装后占用的存储空间</li>
<li>理论上更少的字节码也意味着需要执行的指令更少，需要加载进内存的代码页发生缺页的情况也更少，这些显然对于资源密集型使用场景例如应用冷启动起到很好的性能优化作用。</li>
</ol>
<h3 id="4-4-2-具体实施"><a href="#4-4-2-具体实施" class="headerlink" title="4.4.2. 具体实施"></a>4.4.2. 具体实施</h3><ol>
<li>压缩图片<ul>
<li>没有alpha通道的png图，可压缩成jpg减少体积；</li>
<li>对于体积特别大(超过50k)的图片资源可以考虑有损压缩，jpg采用优图压缩，png尝试采用pngquant压缩，输出视觉判断是否可行；</li>
<li>采用webp格式的图片</li>
<li>采用 ImageOptim压缩图片</li>
</ul>
</li>
<li>删除无用资源</li>
</ol>
<h1 id="5-响应速度及卡顿优化"><a href="#5-响应速度及卡顿优化" class="headerlink" title="5. 响应速度及卡顿优化"></a>5. 响应速度及卡顿优化</h1><p>大多数手机的屏幕刷新频率是60hz，如果在1000/60=16.67ms内没有办法把这一帧的任务执行完毕，就会发生丢帧的现象。丢帧越多，用户感受到的卡顿情况就越严重。</p>
<p>渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。CPU通常存在的问题的原因是存在非必需的视图组件，它不仅仅会带来重复的计算操作，而且还会占用额外的GPU资源。</p>
<p>针对原理来作出解释如何优化</p>
<ul>
<li>减少视图的层级结构</li>
<li>移除Window默认的Background</li>
<li>移除XML布局文件中非必需的Background</li>
<li>按需显示占位背景图片</li>
<li>优化自定义view的ondraw方法</li>
<li>listview滑动取消图片加载</li>
<li>listview采用viewholder</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2016/12/28/2016/2016-12-28-Android%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Leeeyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leeeyou123">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2016/12/28/2016/2016-12-28-Android%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">Android之网络通信整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-28 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-28T00:00:00+08:00">2016-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>花了将近7、8个小时粗略整理了自己遇到的一些关于网络通信的问题，也算是对这一大块内容的一个交代。这节的内容非常多，主要包括如下几个主题：网络各层的结构、TCP和UDP、Http协议的理解和用法、Socket编程、以及一些扩展，包括访问一个网页的流程、ping的整个过程等。当然一些常见的问题：三次握手四次挥手以及Socket与Http、Socket与TCP/IP的纠缠在文档中都有说明。</p>
<h1 id="1-网络各层的结构"><a href="#1-网络各层的结构" class="headerlink" title="1. 网络各层的结构"></a>1. 网络各层的结构</h1><h2 id="1-1-OSI模型"><a href="#1-1-OSI模型" class="headerlink" title="1.1. OSI模型"></a>1.1. OSI模型</h2><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<h2 id="1-2-层模型"><a href="#1-2-层模型" class="headerlink" title="1.2. 层模型"></a>1.2. 层模型</h2><p>1.2.1 物理层、数据链路层、网络层、运输层、 应用层</p>
<h2 id="1-3-各层协议与作用"><a href="#1-3-各层协议与作用" class="headerlink" title="1.3. 各层协议与作用"></a>1.3. 各层协议与作用</h2><p>物理层</p>
<ul>
<li>RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）</li>
<li>通过媒介传输比特,确定机械及电气规范（比特Bit）</li>
</ul>
<p>数据链路</p>
<ul>
<li>PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）</li>
<li>将比特组装成帧和点到点的传递（帧Frame）</li>
</ul>
<p>网络层</p>
<ul>
<li>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li>
<li>负责数据包从源到宿的传递和网际互连（包PackeT）</li>
</ul>
<p>传输层</p>
<ul>
<li>TCP、UDP、SPX</li>
<li>提供端到端的可靠报文传递和错误恢复（段Segment）</li>
</ul>
<p>会话层</p>
<ul>
<li>NFS、SQL、NETBIOS、RPC</li>
<li>建立、管理和终止会话（会话协议数据单元SPDU）</li>
</ul>
<p>表示层</p>
<ul>
<li>JPEG、MPEG、ASII</li>
<li>对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
</ul>
<p>应用层</p>
<ul>
<li>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li>
<li>允许访问OSI环境的手段（应用协议数据单元APDU）</li>
</ul>
<h1 id="2-UDP协议"><a href="#2-UDP协议" class="headerlink" title="2. UDP协议"></a>2. UDP协议</h1><h1 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3. TCP协议"></a>3. TCP协议</h1><h2 id="3-1-TCP-UDP的区别"><a href="#3-1-TCP-UDP的区别" class="headerlink" title="3.1. TCP/UDP的区别"></a>3.1. TCP/UDP的区别</h2><ul>
<li><p>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。TCP需要建立连接，而UDP不需要建立连接（无连接传输）</p>
</li>
<li><p>TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。</p>
</li>
<li><p>是否建立真实连接的特性，造成了双方可靠性的差距。</p>
<ul>
<li><p>TCP属于可靠的传输协议：因为传输前双方建立好了连接，相当于买卖双方建立好了交易合同，传输中一般不会出现意外，直到连接终止；</p>
</li>
<li><p>UDP属于不可靠的传输协议：UDP的所谓连接相当于一种映射，UDP单方面的认为目标地址（端口）是可用的，从而进行收发数据，而实际上目标地址（端口）未必可用，所以传输数据不可靠</p>
</li>
</ul>
</li>
<li><p>由于TCP需要建立真实的连接，所以需要消耗服务器的负载要大于UDP</p>
</li>
</ul>
<h2 id="3-2-TCP报文结构"><a href="#3-2-TCP报文结构" class="headerlink" title="3.2. TCP报文结构"></a>3.2. TCP报文结构</h2><p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/tcp%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.jpg" alt="tcp报文结构"></p>
<p>源端口、目标端口</p>
<ul>
<li>计算机上的进程要和其他进程通信是要通过计算机端口的，而一个计算机端口某个时刻只能被一个进程占用，所以通过指定源端口和目标端口，就可以知道是哪两个进程需要通信。源端口、目标端口是用16位表示的，可推算计算机的端口个数为2^16个。</li>
</ul>
<p>序列号</p>
<ul>
<li><p>表示本报文段所发送数据的第一个字节的编号。在TCP连接中所传送的字节流的每一个字节都会按顺序编号。由于序列号由32位表示，所以每2^32个字节，就会出现序列号回绕，再次从 0 开始。</p>
</li>
<li><p>那如何区分两个相同序列号的不同TCP报文段就是一个问题了，后面会有答案，暂时可以不管。</p>
</li>
</ul>
<p>确认号</p>
<ul>
<li>表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。也就是告诉发送发：我希望你（指发送方）下次发送的数据的第一个字节数据的编号是这个确认号。也就是告诉发送方：我希望你（指发送方）下次发送给我的TCP报文段的序列号字段的值是这个确认号。</li>
</ul>
<p>TCP首部长度</p>
<ul>
<li>由于TCP首部包含一个长度可变的选项部分，所以需要这么一个值来指定这个TCP报文段到底有多长。或者可以这么理解：就是表示TCP报文段中数据部分在整个TCP报文段中的位置。该字段的单位是32位字，即：4个字节。</li>
</ul>
<p>URG</p>
<ul>
<li>表示本报文段中发送的数据是否包含紧急数据。URG=1，表示有紧急数据。后面的紧急指针字段只有当URG=1时才有效。</li>
</ul>
<p>ACK</p>
<ul>
<li>表示是否前面的确认号字段是否有效。ACK=1，表示有效。只有当ACK=1时，前面的确认号字段才有效。TCP规定，连接建立后，ACK必须为1。</li>
</ul>
<p>PSH</p>
<ul>
<li>告诉对方收到该报文段后是否应该立即把数据推送给上层。如果为1，则表示对方应当立即把数据提交给上层，而不是缓存起来。</li>
</ul>
<p>RST</p>
<ul>
<li>只有当RST=1时才有用。如果你收到一个RST=1的报文，说明你与主机的连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。或者说明你上次发送给主机的数据有问题，主机拒绝响应。</li>
</ul>
<p>SYN</p>
<ul>
<li>在建立连接时使用，用来同步序号。当SYN=1，ACK=0时，表示这是一个请求建立连接的报文段；当SYN=1，ACK=1时，表示对方同意建立连接。SYN=1，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中SYN才置为1。</li>
</ul>
<p>FIN</p>
<ul>
<li>标记数据是否发送完毕。如果FIN=1，就相当于告诉对方：“我的数据已经发送完毕，你可以释放连接了”</li>
</ul>
<p>窗口大小</p>
<ul>
<li>表示现在运行对方发送的数据量。也就是告诉对方，从本报文段的确认号开始允许对方发送的数据量。</li>
</ul>
<p>校验和</p>
<ul>
<li>提供额外的可靠性。具体如何校验，参考其他资料。</li>
</ul>
<p>紧急指针</p>
<ul>
<li>标记紧急数据在数据字段中的位置。</li>
</ul>
<p>选项部分</p>
<ul>
<li>其最大长度可根据TCP首部长度进行推算。TCP首部长度用4位表示，那么选项部分最长为：(2^4-1)*4-20=40字节。</li>
</ul>
<h2 id="3-3-三次握手"><a href="#3-3-三次握手" class="headerlink" title="3.3. 三次握手"></a>3.3. 三次握手</h2><ul>
<li><p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F.jpg" alt="三次握手示意"></p>
<ul>
<li><p>SYN攻击</p>
<ul>
<li><p>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。</p>
</li>
<li><p>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。</p>
</li>
<li><p>SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：#netstat -nap | grep SYN_RECV</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-4-四次挥手"><a href="#3-4-四次挥手" class="headerlink" title="3.4. 四次挥手"></a>3.4. 四次挥手</h2><ul>
<li><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p>
</li>
<li><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p>
</li>
<li><p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>
</li>
<li><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
</li>
<li><p>由于TCP连接是全双工的，因此每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%A4%BA%E6%84%8F.jpg" alt="四次挥手示意"></p>
<p>为什么建立连接是三次而关闭连接却要四次呢？</p>
<ul>
<li>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</li>
</ul>
<h2 id="3-5-流量控制"><a href="#3-5-流量控制" class="headerlink" title="3.5. 流量控制"></a>3.5. 流量控制</h2><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不<br>是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" alt="流量控制"></p>
<p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p>
<p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p>
<h2 id="3-6-拥塞控制"><a href="#3-6-拥塞控制" class="headerlink" title="3.6. 拥塞控制"></a>3.6. 拥塞控制</h2><p>拥塞</p>
<ul>
<li>即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。</li>
</ul>
<p>拥塞控制</p>
<ul>
<li>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</li>
</ul>
<p>流量控制</p>
<ul>
<li>指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
<p>拥塞控制代价</p>
<ul>
<li>需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。</li>
</ul>
<p>几种拥塞控制方法</p>
<ul>
<li><p>慢开始算法</p>
<ul>
<li>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</li>
</ul>
</li>
<li><p>拥塞控制算法</p>
<ul>
<li><p>当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。</p>
</li>
<li><p>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd 增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长。</p>
</li>
<li><p>假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小。</p>
</li>
<li><p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F.jpg" alt="拥塞控制算法示意"></p>
<ul>
<li><p>快重传算法</p>
<ul>
<li>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</li>
</ul>
</li>
<li><p>快恢复算法</p>
<ul>
<li><p>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p>
</li>
<li><p>由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E5%BF%AB%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F.jpg" alt="快恢复算法示意"></p>
<ul>
<li><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。</p>
</li>
<li><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
</li>
</ul>
<h1 id="4-Http协议"><a href="#4-Http协议" class="headerlink" title="4. Http协议"></a>4. Http协议</h1><h2 id="4-1-报文结构"><a href="#4-1-报文结构" class="headerlink" title="4.1. 报文结构"></a>4.1. 报文结构</h2><p>请求报文</p>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt="请求报文"></p>
<p>响应报文</p>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" alt="响应报文"></p>
<h2 id="4-2-状态说明"><a href="#4-2-状态说明" class="headerlink" title="4.2. 状态说明"></a>4.2. 状态说明</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值</p>
<ul>
<li>100~199：指示信息，表示请求已接收，继续处理</li>
<li>200~299：请求成功，表示请求已被成功接收、理解、接受</li>
<li>300~399：重定向，要完成请求必须进行更进一步的操作</li>
<li>400~499：客户端错误，请求有语法错误或请求无法实现</li>
<li>500~599：服务器端错误，服务器未能实现合法的请求</li>
</ul>
<p>常见的状态码如下</p>
<ul>
<li>200 OK 客户端请求成功</li>
<li>400 Bad Request 客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li>
<li>403 Forbidden 服务器收到请求，但是拒绝提供服务</li>
<li>500 Internal Server Error 服务器发生不可预期的错误</li>
<li>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<h2 id="4-3-Request的几种类型"><a href="#4-3-Request的几种类型" class="headerlink" title="4.3. Request的几种类型"></a>4.3. Request的几种类型</h2><p>OPTIONS</p>
<ul>
<li>返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</li>
</ul>
<p>HEAD</p>
<ul>
<li>向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</li>
</ul>
<p>GET</p>
<ul>
<li>向特定的资源发出请求。</li>
</ul>
<p>POST</p>
<ul>
<li>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和 / 或已有资源的修改。</li>
</ul>
<p>PUT</p>
<ul>
<li>向指定资源位置上传其最新内容。</li>
</ul>
<p>DELETE</p>
<ul>
<li>请求服务器删除Request-URI所标识的资源。</li>
</ul>
<p>TRACE</p>
<ul>
<li>回显服务器收到的请求，主要用于测试或诊断。</li>
</ul>
<h2 id="4-4-Http1-1和Http1-0的区别"><a href="#4-4-Http1-1和Http1-0的区别" class="headerlink" title="4.4. Http1.1和Http1.0的区别"></a>4.4. Http1.1和Http1.0的区别</h2><p>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p>
<ul>
<li><p>HTTP 1.0规定浏览器与服务器只保持短暂的连接，而HTTP 1.1 支持长连接。</p>
<ul>
<li><p>在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</p>
</li>
<li><p>在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p>
</li>
</ul>
</li>
<li><p>HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。HTTP1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p>
</li>
<li><p>HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。</p>
</li>
<li><p>HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。</p>
</li>
</ul>
<h2 id="4-5-Http怎么处理长连接"><a href="#4-5-Http怎么处理长连接" class="headerlink" title="4.5. Http怎么处理长连接"></a>4.5. Http怎么处理长连接</h2><p>http长连接即持久连接是http1.1版本的一个特性，即一个http连接建立完成一个请求-回应后，可以不需要立刻关闭，可以重复使用。http的长连接是可以发送多个请求而不用等待每个响应的。</p>
<h2 id="4-6-HTTP缓存机制"><a href="#4-6-HTTP缓存机制" class="headerlink" title="4.6. HTTP缓存机制"></a>4.6. HTTP缓存机制</h2><p>缓存对于移动端是非常重要的存在。</p>
<p>优点</p>
<ul>
<li>减少请求次数，减小服务器压力.</li>
<li>本地数据读取速度更快，让页面不会空白几百毫秒。</li>
<li>在无网络的情况下提供数据。</li>
</ul>
<p>具体实施</p>
<ul>
<li>缓存一般由服务器控制(通过某些方式可以本地控制缓存，比如向过滤器添加缓存控制信息)。</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/http%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E8%AF%B7%E6%B1%82%E5%A4%B4.png" alt="http缓存相关请求头"></p>
<ul>
<li>客户端发起请求的时候要检查缓存。遵循下面步骤，注意服务器返回304意思是数据没有变动滚去读缓存信息。</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.png" alt="浏览器缓存机制"></p>
<h1 id="5-Socket"><a href="#5-Socket" class="headerlink" title="5. Socket"></a>5. Socket</h1><h2 id="5-1-套接字的概念"><a href="#5-1-套接字的概念" class="headerlink" title="5.1. 套接字的概念"></a>5.1. 套接字的概念</h2><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>
<p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<h2 id="5-2-建立socket连接"><a href="#5-2-建立socket连接" class="headerlink" title="5.2. 建立socket连接"></a>5.2. 建立socket连接</h2><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<p>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p>
<p>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p>
<p>连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与服务端建立Socket连接</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(GlobalParams.HOST, GlobalParams.PORT);</span><br><span class="line">Log.e(TAG, <span class="string">&quot;开始发送Socket请求&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往服务端写数据</span></span><br><span class="line">writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(client.getOutputStream());</span><br><span class="line">writer.write(packageJSON());<span class="comment">// 将封装好的 JSON传递到服务端</span></span><br><span class="line">writer.flush();<span class="comment">// 字节流需要flush</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取服务端传回的数据</span></span><br><span class="line"><span class="keyword">if</span> (client.isConnected()) &#123;</span><br><span class="line">  Log.e(TAG, <span class="string">&quot;socket已连接成功&quot;</span>)</span><br><span class="line">  reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(client.getInputStream()));</span><br><span class="line">  <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;接收到了服务端传来的数据：&quot;</span> + line + <span class="string">&quot;----长度：&quot;</span> + line.length());</span><br><span class="line">    result.append(line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">IOUtils.close(reader, writer);</span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure>

<h2 id="5-3-短线重连怎么实现"><a href="#5-3-短线重连怎么实现" class="headerlink" title="5.3. 短线重连怎么实现"></a>5.3. 短线重连怎么实现</h2><p>利用心跳检测客户端是否与服务端连接正常，如断开了就发起重连</p>
<h2 id="5-4-心跳机制又是怎样实现"><a href="#5-4-心跳机制又是怎样实现" class="headerlink" title="5.4. 心跳机制又是怎样实现"></a>5.4. 心跳机制又是怎样实现</h2><p>介绍</p>
<ul>
<li><p>心跳信息是单方向的，只有终端发到应用服务器；</p>
</li>
<li><p>心跳信息的周期比较长，比如旧版QQ的心跳周期为30s，新版QQ为180s，微信为300s，Google原生应用为1680s左右。</p>
</li>
<li><p>另外，互联网应用的心跳包除了宣告终端在线外，还有一项重要的任务，就是提供终端的即时地址，方便应用服务器的寻址。</p>
</li>
<li><p>有了互联网应用的心跳机制，应用服务器可以及时下发(Push)用户相关的信息，比如微信中的短消息、图片或者语音等。</p>
</li>
<li><p>心跳包也会带来很多副作用，比如终端更为费电，还可能给移动通信网络带来信令风暴。</p>
</li>
</ul>
<p>实现</p>
<ul>
<li><p>轮询：定时去server查询数据</p>
</li>
<li><p>推送：使用XMPP长连接</p>
</li>
</ul>
<p>移动无线网络的特点</p>
<ul>
<li><p>因IPv4的数量有限，运营商分配给手机终端的 IP 是运营商内网的 IP，手机要连接 Internet，就需要通过运营商的网关做一个网络地址转换（Network Address Translation，NAT）。简单的说运营商的网关需要维护一个外网 IP、端口到内网 IP、端口的对应关系，以确保内网的手机可以跟 Internet 的服务器通讯</p>
</li>
<li><p>我们知道移动端要和Internet进行通信，必须通过运营商的网关，所以，为了不让NAT映射表失效，我们需要定时向Internet发送数据，因为只是为了不然NAT映射表失效，所以只需发送长度为0的数据即可。</p>
</li>
</ul>
<h1 id="6-扩展"><a href="#6-扩展" class="headerlink" title="6. 扩展"></a>6. 扩展</h1><h2 id="6-1-Socket、TCP-IP与HTTP"><a href="#6-1-Socket、TCP-IP与HTTP" class="headerlink" title="6.1. Socket、TCP/IP与HTTP"></a>6.1. Socket、TCP/IP与HTTP</h2><h3 id="6-1-1-Socket连接与TCP-IP连接"><a href="#6-1-1-Socket连接与TCP-IP连接" class="headerlink" title="6.1.1. Socket连接与TCP/IP连接"></a>6.1.1. Socket连接与TCP/IP连接</h3><p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p>
<p>Socket是对TCP/IP协议的封装和应用（程序员层面上）。也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</p>
<p>我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。</p>
<p>实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket我们才能使用TCP/IP协议。Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。</p>
<p>实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。Socket是对端口通信开发的工具,它要更底层一些。</p>
<h3 id="6-1-2-Socket连接与HTTP连接"><a href="#6-1-2-Socket连接与HTTP连接" class="headerlink" title="6.1.2. Socket连接与HTTP连接"></a>6.1.2. Socket连接与HTTP连接</h3><p>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p>
<p>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</p>
<p>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。</p>
<p>有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</p>
<p>两个计算机之间的交流无非是两个端口之间的数据通信，具体的数据会以什么样的形式展现，是以不同的应用层协议来定义的：如HTTP，FTP…</p>
<h2 id="6-2-Cookie与Session的作用与原理"><a href="#6-2-Cookie与Session的作用与原理" class="headerlink" title="6.2. Cookie与Session的作用与原理"></a>6.2. Cookie与Session的作用与原理</h2><h3 id="6-2-1-Cookie"><a href="#6-2-1-Cookie" class="headerlink" title="6.2.1. Cookie"></a>6.2.1. Cookie</h3><p>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于在服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上还有其他选择。  </p>
<p>会话cookie和持久cookie的区别</p>
<ul>
<li><p>如果不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。  </p>
</li>
<li><p>如果设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。  </p>
</li>
<li><p>存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。</p>
</li>
</ul>
<h3 id="6-2-2-Sessioin"><a href="#6-2-2-Sessioin" class="headerlink" title="6.2.2. Sessioin"></a>6.2.2. Sessioin</h3><p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。</p>
<p>保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID，而。比如weblogic对于web应用程序生成的cookie，JSESSIONID=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764，它的名字就是JSESSIONID。 由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，表现形式为http://…../xxx;jsessionid=ByOK … 99zWpBng!-145788764。另一种是作为查询字符串附加在URL后面，表现形式为http://…../xxx?jsessionid=ByOK …99zWpBng!-145788764</p>
<p>另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。这种技术现在已较少应用，笔者接触过的很古老的iPlanet6(SunONE应用服务器的前身)就使用了这种技术。 实际上这种技术可以简单的用对action应用URL重写来代替。这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把session id的信息和正常程序参数区分开来。 为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。</p>
<p>在谈论session机制的时候，常常听到这样一种误解“只要关闭浏览器，session就消失了”。其实可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对session来说也是一样的，除非程序通知服务器删除一个session，否则服务器会一直保留，程序一般都是在用户做log off的时候发个指令去删除session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接服务器时也就无法找到原来的session。如果服务器设置的cookie被保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的session id发送给服务器，则再次打开浏览器仍然能够找到原来的session。</p>
<p>恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。</p>
<h2 id="6-3-访问一个网页其整个过程是怎样的？"><a href="#6-3-访问一个网页其整个过程是怎样的？" class="headerlink" title="6.3. 访问一个网页其整个过程是怎样的？"></a>6.3. 访问一个网页其整个过程是怎样的？</h2><p>浏览器先尝试从Host文件中获取 <a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com/</a> 对应的IP地址，如果能取到当然万事大吉大家都能嗨，如果不能，就使用DNS协议来获取IP咯。</p>
<p>得到百度的IP，下一步是使用TCP协议，建立TCP连接。（在TCP协议中，建立TCP需要与百度服务器握手三次，你先告诉服务器你要给服务器发东西（SYN），服务器应答你并告诉你它也要给你发东西（SYN、ACK），然后你应答服务器（ACK），总共来回了3次，称为3次握手。）</p>
<p>不过，建立TCP连接有个前提，为了将消息从你的PC上传到服务器上，需要用到IP协议、ARP协议和OSPF协议。你的PC和百度服务器之间一般会有许多路由器之类的东西，IP协议指定了出发地（你的PC）和目的地（服务器）；你的数据会经过一个又一个路由器，OSPF决定了会经过那些路由器（用一种叫路由算法的玩意，找出最佳路径）；从一个路由器怎么传给下一个路由器？这是ARP协议的JOB，ARP负责求下一个节点的地址（我们不止是要目的地，还要中间节点的地址）。IP协议使用的是IP地址，整个发送过程中只涉及出发地和目的地2个IP地址，而ARP协议使用的是MAC地址，整个发送过程中涉及到每一个节点的MAP地址</p>
<p>发送HTTP请求报文给服务器，如果服务器禁止你访问它就给你回个”Forbidden”，如果它暂时挂掉了就给你回个“内部服务错误”，如果它正常才给你回个“OK“并将你要的数据传给你；如果你还需要其它的东西再去跟它要（它一般还会给你的-_-）。</p>
<p>你收到了服务器的回复，是一坨HTML形式的文本。浏览器必须要能够理解文本的内容，并快速地渲染到屏幕上（浏览器一般用有限自动机来理解文本内容，渲染的话就各看本事了，之所以微软IE卡成狗而谷歌浏览器很6，就是它们的渲染速度不同…）</p>
<h2 id="6-4-Ping的整个过程，ICMP报文是什么"><a href="#6-4-Ping的整个过程，ICMP报文是什么" class="headerlink" title="6.4. Ping的整个过程，ICMP报文是什么"></a>6.4. Ping的整个过程，ICMP报文是什么</h2><h3 id="6-4-1-ICMP报文"><a href="#6-4-1-ICMP报文" class="headerlink" title="6.4.1. ICMP报文"></a>6.4.1. ICMP报文</h3><ul>
<li>在IP通信中，经常有数据包到达不了对方的情况。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。这时，在错误发生的现场，为了联络而飞过来的信鸽就是ICMP 报文。在IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助IP 协议，交换各种各样的控制信息而被制造出来的。</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/icmp%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg" alt="icmp报文格式"></p>
<ul>
<li>差错通知和信息查询</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E5%B7%AE%E9%94%99%E9%80%9A%E7%9F%A5%E5%92%8C%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2.jpg" alt="差错通知和信息查询"></p>
<h3 id="6-4-2-ping-命令"><a href="#6-4-2-ping-命令" class="headerlink" title="6.4.2. ping 命令"></a>6.4.2. ping 命令</h3><p>ping 命令用来在IP 层次上调查与指定机器是否连通，调查数据包往复需要多少时间。为了实现这个功能，ping 命令使用了两个ICMP 报文。</p>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/ping%E5%91%BD%E4%BB%A4.jpg" alt="ping命令"></p>
<p>同一网段内（实际过程的发生不到1毫秒）</p>
<ul>
<li><p>首先，如果主机A，要去ping主机B，那么主机A，就要封装二层报文，他会先查自己的MAC地址表，如果没有B的MAC地址，就会向外发送一个ARP广播包</p>
</li>
<li><p>交换机会收到这个报文后，交换机有学习MAC地址的功能，所以他会检索自己有没有保存主机B的MAC地址，如果有，就返回给主机A，如果没有，就会向所有端口发送ARP广播，其它主机收到后，发现不是在找自己，就纷纷丢弃了该报文，不去理会。直到主机B收到了报文后，就立即响应，我的MAC地址是多少，同时学到主机A的MAC地址，并按同样的ARP报文格式返回给主机A。</p>
</li>
</ul>
<p>跨网段的ping</p>
<ul>
<li><p>如果主机A要ping主机C，那么主机A发现主机C的IP和自己不是同一网段，他就去找网关转发，但是他也不知道网关的MAC地址情况下呢？他就会像之前那个步骤一样先发送一个ARP广播，学到网关的MAC地址，再发封装ICMP报文给网关路由器.。</p>
</li>
<li><p>当路由器收到主机A发过来的ICMP报文，发现自己的目的地址是其本身MAC地址，根据目的的IP2.1.1.1，查路由表，发现2.1.1.1/24的路由表项，得到一个出口指针，去掉原来的MAC头部，加上自己的MAC地址向主机C转发。(如果网关也没有主机C的MAC地址，还是要向前面一个步骤一样，ARP广播一下即可相互学到。路由器2端口能学到主机D的MAC地址，主机D也能学到路由器2端口的MAC地址。)</p>
</li>
<li><p>最后，在主机C已学到路由器2端口MAC地址，路由器2端口转发给路由器1端口，路由1端口学到主机A的MAC地址的情况下，他们就不需要再做ARP解析，就将ICMP的回显请求回复过来。</p>
</li>
</ul>
<h2 id="6-5-SSID、ESSID、BSSID区别"><a href="#6-5-SSID、ESSID、BSSID区别" class="headerlink" title="6.5. SSID、ESSID、BSSID区别"></a>6.5. SSID、ESSID、BSSID区别</h2><h3 id="6-5-1-SSID"><a href="#6-5-1-SSID" class="headerlink" title="6.5.1. SSID"></a>6.5.1. SSID</h3><p>SSID是Service Set Identifier的缩写，意思是：服务集标识。SSID技术可以将一个无线局域网分为几个需要不同身份验证的子网络，每一个子网络都需要独立的身份验证，只有通过身份验证的用户才可以进入相应的子网络，防止未被授权的用户进入本网络。</p>
<p>什么是SSID？SSID（Service Set Identifier）也可以写为ESSID，用来区分不同的网络，最多可以有32个字符，无线网卡设置了不同的SSID就可以进入不同网络，SSID通常由AP广播出来，通过XP自带的扫描功能可以相看当前区域内的SSID。出于安全考虑可以不广播SSID，此时用户就要手工设置SSID才能进入相应的网络。简单说，SSID就是一个局域网的名称，只有设置为名称相同SSID的值的电脑才能互相通信。</p>
<p>禁用SSID广播通俗地说，SSID便是你给自己的无线网络所取的名字。需要注意的是，同一生产商推出的无线路由器或AP都使用了相同的SSID，一旦那些企图非法连接的攻击者利用通用的初始化字符串来连接无线网络，就极易建立起一条非法的连接，从而给我们的无线网络带来威胁。因此，建议最好能够将 SSID命名为一些较有个性的名字。</p>
<p>无线路由器一般都会提供“允许SSID广播”功能。如果不想让自己的无线网络被别人通过SSID名称搜索到，那么最好“禁止SSID广播”。你的无线网络仍然可以使用，只是不会出现在其他人所搜索到的可用网络列表中。</p>
<p>小提示:通过禁止SSID广播设置后，无线网络的效率会受到一定的影响，但以此换取安全性的提高，笔者认为还是值得的。</p>
<p>测试结果:由于没有进行SSID广播，该无线网络被无线网卡忽略了，尤其是在使用Windows XP管理无线网络时，达到了“掩人耳目”的目的。</p>
<h3 id="6-5-2-BSSID"><a href="#6-5-2-BSSID" class="headerlink" title="6.5.2. BSSID"></a>6.5.2. BSSID</h3><p>BSS:一种特殊的Ad-hoc LAN的应用，称为Basic Service Set (BSS)，一群计算机设定相同的BSS名称，即可自成一个group，而此BSS名称，即所谓BSSID。</p>
<h3 id="6-5-3-ESSID"><a href="#6-5-3-ESSID" class="headerlink" title="6.5.3. ESSID"></a>6.5.3. ESSID</h3><p>ESSID（也称为服务区别号）将被放置在到每个无线访问接入点中，它是无线客户端与无线访问接入点联系所必不可少的。利用特定存取点的ESSID来做存取的控制，是AP的一种安全保护机制，它强制每一个客户端都必须要有跟存取点相同的ESSID值。但是，如果你在无线网卡上设定其ESSID为“ANY”时，它就可以自动的搜寻在讯号范围内所有的存取点，并试图连上它。</p>
<p>对于任何一个可能存取UWA-11接入点的适配器来说，无线设备首先决定这个适配器是否属于该网络，或扩展服务集。无线设备判断适配器的32位字符的标识ESSID是否和它自己的相符。即使有另外一套UWA-11产品，也没有人能够加入到网络或学习到跳频序列和定时。ESSID编程写入无线设备,并且在一个安装者密码的控制下，而且只能通过和设备的直接连接才能修改。如果需要在一个网络上有分别的网段，比如财务部门和公司其他部门拥有不同的网段，那么你可以编写不同的SSID。如果你需要支持移动用户和扩大带宽而连接多个无线设备，那么它们的SSID必须设置成一致而跳频序列应该不一样。所有这些设置都受UWA-11安装者密码的控制。<br>由于有了32位字符的SSID和3位字符的跳频序列，你会发现对于那些试图经由局域网的无线网段进入局域网的人来讲，想推断出确切的SSID和跳频序列有多么困难。</p>
<hr>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3141d4e46240">Android网络请求心路历程</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2016/12/09/2016/2016-12-09-Monkey%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Leeeyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leeeyou123">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2016/12/09/2016/2016-12-09-Monkey%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B/" class="post-title-link" itemprop="url">Monkey命令示例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-09 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-09T00:00:00+08:00">2016-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1、整机测试，而不测试拨号键盘应用，忽略所有错误，次数100万次</p>
<p>adb shell monkey –ignore-crashes –ignore-timeouts –pkg-blaklist-file -v -v 1000000</p>
<p>2、测试计算器30万次，随机种子为100，随机延迟0-1秒，忽略所有错误</p>
<p>adb shell monkey -p com.android.calculator2 -s 100 –throttle 1000 –randomize-throttle –ignore-crashes –ignore-timeouts -v -v 30000</p>
<p>3、测试计算器，触摸事件30%，其他按键50%，错误停止，延时200</p>
<p>adb shell monkey -p com.android.calculator2 –throttle 200 –pct-touch 30 –pct-anyevent 50 -v -v 100000</p>
<p>4、对计算器进行旋转压力测试，事件延时2秒，10万次</p>
<p>adb shell monkey -p com.android.calculator2 –pct-rotation 100 –throttle 2000 100000</p>
<p>5、仅对整机的应用开启测试，事件延时5秒，10万次</p>
<p>adb shell monkey –pct-appswitch 100 –throttle 5000 100000</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2016/10/08/2016/2016-10-08-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Leeeyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leeeyou123">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2016/10/08/2016/2016-10-08-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之代理模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-08 00:00:00" itemprop="dateCreated datePublished" datetime="2016-10-08T00:00:00+08:00">2016-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>定义：&nbsp;为另一个对象提供一个替身或占位符以访问这个对象。</p>
</blockquote>
<p>后续补充更多的内容：  </p>
<p>  在实际开发过程中，代理类的实现比上述代码要复杂很多，代理模式根据其目的和实现方式不同可分为很多种类，其中常用的几种代理模式简要说明如下：<br>       (1) 远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。<br>       (2) 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>       (3) 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。<br>       (4) 缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>       (5) 智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。<br>       在这些常用的代理模式中，有些代理类的设计非常复杂，例如远程代理类，它封装了底层网络通信和对远程对象的调用，其实现较为复杂。</p>
<p>下面的内容转载自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>代理模式是常用的结构型设计模式之一，它为对象的间接访问提供了一个解决方案，可以对对象的访问进行控制。<br>代理模式类型较多，其中远程代理、虚拟代理、保护代理等在软件开发中应用非常广泛。</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8227953">代理模式（一）：代理模式概述，代理模式结构与实现</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8228042">代理模式（二）：代理模式应用实例（收费商务信息查询系统）</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8228132">代理模式（三）：远程代理，虚拟代理，缓冲代理</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8228156">代理模式（四）：代理模式效果与适用场景</a></p>
<p>关于java的代理机制及分析,下面有两篇文章详细的介绍：<br><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/j-lo-proxy1/index.html">Java 动态代理机制分析及扩展，第 1 部分</a><br><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/j-lo-proxy2/index.html">Java 动态代理机制分析及扩展，第 2 部分</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2016/10/07/2016/2016-10-07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Leeeyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leeeyou123">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2016/10/07/2016/2016-10-07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之状态模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-07 00:00:00" itemprop="dateCreated datePublished" datetime="2016-10-07T00:00:00+08:00">2016-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>定义：&nbsp;允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
</blockquote>
<p>下面的内容转载自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p> 状态模式将一个对象在不同状态下的不同行为封装在一个个状态类中，通过设置不同的状态对象可以让环境对象拥有不同的行为，而状态转换的细节对于客户端而言是透明的，方便了客户端的使用。<br> 在实际开发中，状态模式具有较高的使用频率，在工作流和游戏开发中状态模式都得到了广泛的应用，例如公文状态的转换、游戏中角色的升级等。</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8522982">处理对象的多种状态及其相互转换——状态模式（一）：银行系统中的账户类设计</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8523062">处理对象的多种状态及其相互转换——状态模式（二）：状态模式概述</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8523083">处理对象的多种状态及其相互转换——状态模式（三）：账户类的状态模式解决方案</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8523105">处理对象的多种状态及其相互转换——状态模式（四）：共享状态的实现</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8523130">处理对象的多种状态及其相互转换——状态模式（五）：使用环境类实现状态转换</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8523162">处理对象的多种状态及其相互转换——状态模式（六）：状态模式总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2016/10/06/2016/2016-10-06-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Leeeyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leeeyou123">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2016/10/06/2016/2016-10-06-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之组合模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-06 00:00:00" itemprop="dateCreated datePublished" datetime="2016-10-06T00:00:00+08:00">2016-10-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>定义：&nbsp;允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致对方法处理个别对象以及对象组合。</p>
</blockquote>
<p>在这章节中作者引出了非常基本的设计原则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 类应该只有一个改变的理由  </span><br></pre></td></tr></table></figure>

<p>组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。<br>同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。<br>如果不使用组合模式，客户端代码将过多地依赖于容器对象复杂的内部实现结构，容器对象内部实现结构的变化将引起客户代码的频繁变化，带来了代码维护复杂、可扩展性差等弊端。组合模式的引入将在一定程度上解决这些问题。</p>
<p>下面的内容转载自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p> 组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。<br> 由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式，Java SE中的AWT和Swing包的设计就基于组合模式，在这些界面包中为用户提供了大量的容器构件（如Container）和成员构件（如Checkbox、Button和TextComponent等）</p>
<p> <a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/7956898">树形结构的处理——组合模式（一）：设计杀毒软件的框架结构</a><br> <a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/7956908">树形结构的处理——组合模式（二）：组合模式概述</a><br> <a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/7956931">树形结构的处理——组合模式（三）：杀毒软件的框架结构的组合模式解决方案</a><br> <a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/7956937">树形结构的处理——组合模式（四）：透明组合模式与安全组合模式</a><br> <a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/7956962">树形结构的处理——组合模式（五）：公司组织结构，组合模式总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2016/10/05/2016/2016-10-05-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Leeeyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leeeyou123">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2016/10/05/2016/2016-10-05-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之迭代器模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-05 00:00:00" itemprop="dateCreated datePublished" datetime="2016-10-05T00:00:00+08:00">2016-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>定义：&nbsp;提供一种方法顺序访问一个聚合对象中的某个元素，而又不是暴露其内部的表示。</p>
</blockquote>
<p>在这章节中作者引出了非常基本的设计原则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 类应该只有一个改变的理由</span><br></pre></td></tr></table></figure>

<p>下面的内容转载自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p> 迭代器模式是一种使用频率非常高的设计模式，通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。<br> 由于很多编程语言的类库都已经实现了迭代器模式，因此在实际开发中，我们只需要直接使用Java、C#等语言已定义好的迭代器即可，迭代器已经成为我们操作聚合对象的基本工具之一。</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/9992005">遍历聚合对象中的元素——迭代器模式（一）：销售管理系统中数据的遍历</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/9992243">遍历聚合对象中的元素——迭代器模式（二）：迭代器模式概述</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/9992679">遍历聚合对象中的元素——迭代器模式（三）：销售管理系统中数据的遍历的迭代器模式解决方案</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/9992731">遍历聚合对象中的元素——迭代器模式（四）：使用内部类实现迭代器</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/9992799">遍历聚合对象中的元素——迭代器模式（五）：JDK内置迭代器的使用</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/9992931">遍历聚合对象中的元素——迭代器模式（六）：迭代器模式总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leeeyou.github.io/iBlogWebsite/2016/10/04/2016/2016-10-04-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
      <meta itemprop="name" content="Leeeyou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leeeyou123">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iBlogWebsite/2016/10/04/2016/2016-10-04-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之模板方法模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-04 00:00:00" itemprop="dateCreated datePublished" datetime="2016-10-04T00:00:00+08:00">2016-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-29 20:35:27" itemprop="dateModified" datetime="2022-11-29T20:35:27+08:00">2022-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/iBlogWebsite/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>定义：&nbsp;在一个方法中定义一个算法的骨架，而将一些步骤延迟到子来中。模板方法使得子类可以在不改变算法接口的情况下，重新定义算法中的某些步骤。</p>
</blockquote>
<p>在这章节中作者引出了非常基本的设计原则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 别找我，我会找你</span><br></pre></td></tr></table></figure>

<p>下面的内容转载自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>模板方法模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式。模板方法模式广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序（如框架的初始化，测试流程的设置等）。</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8299794">模板方法模式深度解析（一）：模板方法模式概述，模板方法模式结构与实现</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8299863">模板方法模式深度解析（二）：模板方法模式应用实例（银行利息计算模块）</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/8299927">模板方法模式深度解析（三）：钩子方法的使用，模板方法模式效果与适用场景</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/iBlogWebsite/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/iBlogWebsite/">1</a><span class="space">&hellip;</span><a class="page-number" href="/iBlogWebsite/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/iBlogWebsite/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/iBlogWebsite/page/11/">11</a><a class="extend next" rel="next" href="/iBlogWebsite/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Leeeyou"
      src="https://avatars1.githubusercontent.com/u/6735624?s=460&v=4">
  <p class="site-author-name" itemprop="name">Leeeyou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/iBlogWebsite/archives/">
        
          <span class="site-state-item-count">109</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/iBlogWebsite/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/iBlogWebsite/tags/">
          
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Leeeyou" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Leeeyou" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leeeyou</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/iBlogWebsite/lib/anime.min.js"></script>
  <script src="/iBlogWebsite/lib/velocity/velocity.min.js"></script>
  <script src="/iBlogWebsite/lib/velocity/velocity.ui.min.js"></script>

<script src="/iBlogWebsite/js/utils.js"></script>

<script src="/iBlogWebsite/js/motion.js"></script>


<script src="/iBlogWebsite/js/schemes/muse.js"></script>


<script src="/iBlogWebsite/js/next-boot.js"></script>




  




  
<script src="/iBlogWebsite/js/local-search.js"></script>













  

  

</body>
</html>
