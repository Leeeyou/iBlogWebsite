<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇Github Pages博客写点啥？</title>
    <url>/iBlogWebsite/2015/12/15/2015/2015-12-15-first-githubpage-blog/</url>
    <content><![CDATA[<p>很久很久很久，我没有正儿八经的写一篇博客了。</p>
<p>12月的北京下了三场雪，至于雾霾天，已经不记得有多少次了。但是这又能代表什么呢？照样，有很多人来来往往，穿梭于此。</p>
<p>从昨天下午开始倒腾搭建独立博客这件事，到晚上的时候终于在window上弄完了。参看<a href="http://beiyuu.com/github-pages/">使用Github Pages建独立博客</a>，其实我博客的架构也是fork了<a href="http://beiyuu.com/">【BeiYuu】</a>的，在此特意说明下。</p>
<p>在window下安装jekyll真的不是件容易的事，需要填的坑太多，这里列出几篇我搭建的过程中参看的博客：</p>
<p><a href="http://jingyan.baidu.com/article/925f8cb8f6422ac0dde056ee.html">windows下安装jekyll</a><br><a href="http://blog.csdn.net/dreamzml/article/details/8847879">Python– easy_install 的安装</a></p>
<p><a href="http://www.cnblogs.com/huangjacky/archive/2012/03/28/2421866.html">python - easy_install的安装和使用</a><br><a href="http://www.tuicool.com/articles/UnM7NfN">在本地运行jekyll网站</a></p>
<p>但是可悲的是到此为止，我运行<code>jekyll serve</code>命令再也没有成功过。<br>也罢，到mac上再试试得了。</p>
]]></content>
      <categories>
        <category>opinion</category>
      </categories>
      <tags>
        <tag>北京</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之RecyclerView的使用</title>
    <url>/iBlogWebsite/2015/12/30/2015/2015-12-30-Android%E4%B9%8BRecyclerView%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>RecyclerView提供了一种插拔式的体验，高度的解耦，异常的灵活，通过设置它提供的不同LayoutManager、ItemDecoration、ItemAnimator实现令人瞠目的效果。RecyclerView的基本使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mRecyclerView = findView(R.id.id_recyclerview);</span><br><span class="line"><span class="comment">//设置布局管理器</span></span><br><span class="line">mRecyclerView.setLayoutManager(layout);</span><br><span class="line"><span class="comment">//设置adapter</span></span><br><span class="line">mRecyclerView.setAdapter(adapter)</span><br><span class="line"><span class="comment">//设置Item增加、移除动画</span></span><br><span class="line">mRecyclerView.setItemAnimator(<span class="keyword">new</span> <span class="title class_">DefaultItemAnimator</span>());</span><br><span class="line"><span class="comment">//添加分割线</span></span><br><span class="line">mRecyclerView.addItemDecoration(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DividerItemDecoration</span>(getActivity(), DividerItemDecoration.HORIZONTAL_LIST)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>相较于ListView的代码可能只需要去设置一个adapter就能正常使用，RecyclerView基本需要上面一系列的步骤，原因总得来说是<strong>高度解耦</strong>，给予各组件充分定制自由，轻松实现如GridView、瀑布流效果。RecyclerView的<a href="https://developer.android.com/training/material/lists-cards.html">官方Traning页</a>里面详细说明了RecyclerView推出的原因、优点以及使用方式，强烈推荐阅读。</p>
<h1 id="RecyclerView中三个重要类"><a href="#RecyclerView中三个重要类" class="headerlink" title="RecyclerView中三个重要类"></a>RecyclerView中三个重要类</h1><h2 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a><a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.LayoutManager.html">LayoutManager</a></h2><table>
<thead>
<tr>
<th>LayoutManager</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>LinearLayoutManager</td>
<td align="left">shows items in a vertical or horizontal scrolling list.</td>
</tr>
<tr>
<td>GridLayoutManager</td>
<td align="left">shows items in a grid.</td>
</tr>
<tr>
<td>StaggeredGridLayoutManager</td>
<td align="left">shows items in a staggered grid.</td>
</tr>
</tbody></table>
<h2 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a><a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ItemDecoration.html">ItemDecoration</a></h2><p>我们可以通过该方法添加分割线：mRecyclerView.addItemDecoration(RecyclerView.ItemDecoration)，该方法的参数是为抽象类，官方目前提供了一个默认的实现类DividerItemDecoration。绘制时机是在RecyclerView的measure中先测量出每个child的decoration，添加到mItemDecorations数组中；然后在onDraw中会遍历mItemDecorations数组注意绘制decoration。onDraw和onDrawOver在调用时机上有所区别:</p>
<blockquote>
<p>onDraw方法先于drawChildren<br>onDrawOver在drawChildren之后，一般我们选择复写其中一个即可<br>getItemOffsets 可以通过outRect.set()为每个Item设置一定的偏移量，主要用于绘制Decorator</p>
</blockquote>
<p>关于如何自定义ItemDecoration，参考<a href="http://blog.csdn.net/lmj623565791/article/details/45059587">Android RecyclerView 使用完全解析 体验艺术般的控件</a></p>
<h2 id="ItemAnimator"><a href="#ItemAnimator" class="headerlink" title="ItemAnimator"></a><a href="(https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ItemAnimator.html)">ItemAnimator</a></h2><p>ItemAnimator也是一个抽象类，好在系统为我们提供了一种默认的实现类<a href="https://developer.android.com/reference/android/support/v7/widget/DefaultItemAnimator.html">DefaultItemAnimator</a>，github上已经有很多类似的项目了，这里我们直接引用下：<a href="https://github.com/gabrielemariotti/RecyclerViewItemAnimators">RecyclerViewItemAnimators</a>，大家自己下载查看。项目提供如下效果：</p>
<blockquote>
<p>SlideInOutLeftItemAnimator,<br>SlideInOutRightItemAnimator,<br>SlideInOutTopItemAnimator,<br>SlideInOutBottomItemAnimator</p>
</blockquote>
<h1 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h1><p>需要指出的是RecyclerView使用的adapter必须是<a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html">RecyclerView.Adapter</a>的子类，Google已经开始强制我们使用ViewHolder这种模式了。</p>
<h2 id="关于Click-and-LongClick"><a href="#关于Click-and-LongClick" class="headerlink" title="关于Click and LongClick"></a>关于Click and LongClick</h2><p>一个挺郁闷的地方就是，系统没有提供ClickListener和LongClickListener。 不过我们也可以自己去添加，只是会多了些代码而已。实现的方式比较多，可以通过mRecyclerView.addOnItemTouchListener去监听然后去判断手势，当然你也可以通过adapter中自己去提供回调，这里我们选择后者，前者的方式，大家有兴趣自己去实现。</p>
<hr>
<p>参考：</p>
<ol>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/45059587">Android RecyclerView 使用完全解析 体验艺术般的控件</a></li>
<li><a href="https://developer.android.com/training/material/lists-cards.html">Create a List with RecyclerView</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title>2015年的总结</title>
    <url>/iBlogWebsite/2015/12/31/2015/2015-12-31-2015%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>赶在2015年的最后一天，趁着北京的雾霾天里出了点太阳星子，我也来总结总结一番。</p>
<p>提笔的时候，突然想起《浮城大亨》里的一句，是在阿娘的葬礼上，牧师回忆的一段：改走的路也都走了，改信的道也都信了</p>
<p>阿娘的人生最后似乎也圆满了…？但是于我们这些刚踏上轨道的人来说，似乎也就是走该走的路，信该信的道吧，最终是否会落得圆满，管他呢，终究都会归于平淡。</p>
<p>看了很多别人的年终总结，高大上的出书，博客，工作…把我甩了好几条街！先容我静静。</p>
<p>三分钟过了后，该继续的还是得继续。</p>
<p>一句话概括就是：看了几本书，出了两趟远门，写了几篇博客，上传了几个Demo，搭建了一个个人网站，然后就只剩下工作了。</p>
<p>看过的技术书最满意的莫非《Android开发艺术探索》，该书前几章的内容质量实属上成之作，目前正在整理成思维导图，只剩下两章的内容未总结了，到时候一张巨大的思维导图就能输出了。非技术类的书印象最深的是《MacTalk跨越边境》，这本书还是池老师亲笔签名的，非常喜欢。书的排版，质量，内容的水准都很高。近期也会总结摘抄整理并输出。</p>
<p>国庆节的时候，去了趟青岛-泰山-济南，青岛的老城区和延绵的海岸线还是挺让人怀念的。泰山十八弯的险要陡峭堪称大自然杰作，登上山顶俯视或者闭上眼睛感受，会有一种由衷的崇敬。<br>至于博客的维护，在下甚是惭愧，断断续续，藕断丝连。所以我很佩服那些能把一件事坚持下去的人，比如逻辑思维的罗胖，每天早上六点发一条语音；比如某些公众号大牛每天推送随笔和文章；比如某些github大神每天贡献代码…</p>
<p><img src="../../../../images/githubpages/2015%E5%B9%B4%E9%9D%92%E5%B2%9B/2015%E9%9D%92%E5%B2%9B%E5%B4%82%E5%B1%B1.jpg" alt="青岛崂山"></p>
<p><img src="../../../../images/githubpages/2015%E5%B9%B4%E9%9D%92%E5%B2%9B/2015%E6%B3%B0%E5%B1%B1%E5%8D%81%E5%85%AB%E5%BC%AF.jpg" alt="泰山十八弯"></p>
<p>坚持一件事情下去是挺艰难的，但还是有很多很多人完成了，所以我也要加油。</p>
<p>上传到github上的项目也没什么人star，是没有好好写readme的原因吗？不过我还是会将一些自己认为有用的项目上传，没准哪天就帮助了别人也不一定，想想就有点小激动。</p>
<p>2016年最大的愿望就是实现在2015年写的那些在2014年没有实现的事。还有就是多读书，为什么，因为身和心总要有一个在路上不是，得了吧，主要是人丑还需多读书。</p>
]]></content>
      <categories>
        <category>opinion</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之Dagger2+Retrofit2上传图片</title>
    <url>/iBlogWebsite/2015/12/18/2015/2015-12-18-Android%E4%B9%8BDagger2+Retrofit2%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>经历了几个小时的折腾之后，终于，用Retrofit2成功上传了一张图片到服务器。<br>此时我用一句话安慰自己：“生命在于折腾”。<br>一段正确的Retrofit2上传单张图片的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImageService</span> &#123;</span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST(&quot;/Web/index.php?m=Home&amp;c=Index&amp;a=upload&quot;)</span></span><br><span class="line">    Call&lt;Image&gt; <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@Part(&quot;image\&quot;; filename=\&quot;abc.jpg&quot;)</span> RequestBody file)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageModule</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">endPoint</span> <span class="operator">=</span> <span class="string">&quot;http://115.28.138.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MediaType</span> <span class="variable">MEDIA_TYPE_IMAGE</span> <span class="operator">=</span> MediaType.parse(<span class="string">&quot;image/*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> Call&lt;Image&gt; <span class="title function_">provideImage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RequestBody</span> <span class="variable">imgFile</span> <span class="operator">=</span> RequestBody.create(MEDIA_TYPE_IMAGE, <span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">        <span class="keyword">return</span> ServiceFactory</span><br><span class="line">                .createRetrofitService(ImageService.class, endPoint)</span><br><span class="line">                .uploadImage(imgFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于采用Retrofit2上传图片遇到了很多问题，加上项目进度紧张的缘故，于是拿出以前写过的最原始上传图片的代码，在调通之后，继续转战Retrofit2。</p>
<p>下面的代码是原始上传图片的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(String actionUrl, File uploadFile,String token,String babyID,String filename)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">end</span> <span class="operator">=</span> <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">twoHyphens</span> <span class="operator">=</span> <span class="string">&quot;--&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">boundary</span> <span class="operator">=</span> <span class="string">&quot;***joybaby***&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(actionUrl);</span><br><span class="line">            <span class="type">HttpURLConnection</span> <span class="variable">con</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">            con.setDoInput(<span class="literal">true</span>);</span><br><span class="line">            con.setDoOutput(<span class="literal">true</span>);</span><br><span class="line">            con.setUseCaches(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            con.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line"></span><br><span class="line">            con.setRequestProperty(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">            con.setRequestProperty(<span class="string">&quot;Charset&quot;</span>, HTTP.UTF_8);</span><br><span class="line">            con.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;multipart/form-data;boundary=&quot;</span> + boundary);</span><br><span class="line"></span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(con.getOutputStream());</span><br><span class="line">            ds.writeBytes(twoHyphens + boundary + end);</span><br><span class="line">            ds.writeBytes(<span class="string">&quot;Content-Disposition: form-data; &quot;</span> + <span class="string">&quot;name=\&quot;token\&quot;&quot;</span> + end);</span><br><span class="line">            ds.writeBytes(end);</span><br><span class="line">            ds.writeBytes(token + end);</span><br><span class="line"></span><br><span class="line">            ds.writeBytes(twoHyphens + boundary + end);</span><br><span class="line">            ds.writeBytes(<span class="string">&quot;Content-Disposition: form-data; &quot;</span> + <span class="string">&quot;name=\&quot;babyID\&quot;&quot;</span> + end);</span><br><span class="line">            ds.writeBytes(end);</span><br><span class="line">            ds.writeBytes(babyID + end);</span><br><span class="line"></span><br><span class="line">            ds.writeBytes(twoHyphens + boundary + end);</span><br><span class="line">            ds.writeBytes(<span class="string">&quot;Content-Disposition: form-data; &quot;</span> + <span class="string">&quot;name=\&quot;file\&quot;;filename=\&quot;&quot;</span> + filename + <span class="string">&quot;\&quot;&quot;</span> + end);</span><br><span class="line">            ds.writeBytes(<span class="string">&quot;Content-Type:image/png&quot;</span> + end);</span><br><span class="line">            ds.writeBytes(end);</span><br><span class="line"></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(uploadFile);</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = fStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                ds.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            ds.writeBytes(end);</span><br><span class="line">            ds.writeBytes(twoHyphens + boundary + twoHyphens + end);</span><br><span class="line">            fStream.close();</span><br><span class="line">            ds.flush();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> con.getInputStream();</span><br><span class="line">            <span class="type">int</span> ch;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="keyword">while</span> ((ch = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                b.append((<span class="type">char</span>) ch);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (b.length() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            ds.close();</span><br><span class="line">            <span class="keyword">return</span> b.toString().trim();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了实现Retrofit2上传图片，我真的也是拼了。<br>总结起来，出现问题的原因就在于：以post方式提交表单文件中的数据格式有误造成上传失败。</p>
<p>下面展示了错误提交后，头部信息的对比；左侧是正确的方式提交图片，右侧是错误的方式提交图片：<br><img src="../../../../images/githubpages/post%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E5%88%86%E6%9E%90.png" alt="post方式提示图片对比图"></p>
<p>想了想，错误代码展示就算了，以免误人子弟。</p>
<p>下面记录下利用Fiddler抓包Android手机的网络请求方法：<br><a href="http://jingyan.baidu.com/article/03b2f78c7b6bb05ea237aed2.html">如何用Fiddler对Android应用进行抓包</a></p>
<p>Fiddler设置过滤条件如下图所示：<br><img src="../../../../images/githubpages/fiddler%E8%BF%87%E6%BB%A4%E8%AE%BE%E7%BD%AE.png" alt="Fiddler设置过滤条件"></p>
<p>折腾这个东西这么久，明白了一个道理：尘归尘、土归土。<br>不管你上层的思想多么前卫、开源框架封装的多么优秀、结构多么清晰，归结起来都是HTTP协议的内容罢了。<br>当然这里不是说思想、结构就不重要了，但是认识到这一点还是很重要的，起码你知其所以然了。</p>
<p>另外再补充一点，在开发过程中遇到的一个bug:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.094</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err: com.google.gson.JsonSyntaxException: com.google.gson.stream.MalformedJsonException: Use JsonReader.setLenient(<span class="literal">true</span>) to accept malformed JSON at line <span class="number">1</span> column <span class="number">48</span> path $</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.098</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at com.google.gson.Gson.assertFullConsumption(Gson.java:<span class="number">786</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.098</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at com.google.gson.Gson.fromJson(Gson.java:<span class="number">776</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.098</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at retrofit.GsonResponseBodyConverter.convert(GsonResponseBodyConverter.java:<span class="number">36</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.098</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at retrofit.GsonResponseBodyConverter.convert(GsonResponseBodyConverter.java:<span class="number">24</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.098</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at retrofit.OkHttpCall.parseResponse(OkHttpCall.java:<span class="number">148</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.099</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at retrofit.OkHttpCall.access$<span class="number">100</span>(OkHttpCall.java:<span class="number">29</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.099</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at retrofit.OkHttpCall$<span class="number">1.</span>onResponse(OkHttpCall.java:<span class="number">94</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.099</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at com.squareup.okhttp.Call$AsyncCall.execute(Call.java:<span class="number">168</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.099</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at com.squareup.okhttp.internal.NamedRunnable.run(NamedRunnable.java:<span class="number">33</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.099</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1112</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.100</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">587</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.100</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at java.lang.Thread.run(Thread.java:<span class="number">818</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.100</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err: Caused by: com.google.gson.stream.MalformedJsonException: Use JsonReader.setLenient(<span class="literal">true</span>) to accept malformed JSON at line <span class="number">1</span> column <span class="number">48</span> path $</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.102</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at com.google.gson.stream.JsonReader.syntaxError(JsonReader.java:<span class="number">1573</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.102</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at com.google.gson.stream.JsonReader.checkLenient(JsonReader.java:<span class="number">1423</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.102</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at com.google.gson.stream.JsonReader.doPeek(JsonReader.java:<span class="number">546</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.102</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at com.google.gson.stream.JsonReader.peek(JsonReader.java:<span class="number">429</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.102</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err:     at com.google.gson.Gson.assertFullConsumption(Gson.java:<span class="number">782</span>)</span><br><span class="line"><span class="number">12</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">47.102</span> <span class="number">4825</span>-<span class="number">4825</span>/com.example.leeyou.drr W/System.err: 	... <span class="number">11</span> more</span><br></pre></td></tr></table></figure>
<p>我遇到这个bug的原因是表单提交时，双引号缺失导致的，也是google百度了很久无果，用fiddler抓包比对得出的结论。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Dagger2</tag>
        <tag>Retrofit2</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之高仿微信图片选择器</title>
    <url>/iBlogWebsite/2015/12/29/2015/2015-12-29-Android%E4%B9%8B%E9%AB%98%E4%BB%BF%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<p>这个Demo建立在 <a href="http://blog.csdn.net/lmj623565791/article/details/39943731">张鸿洋的博客Android 超高仿微信图片选择器图片该这么加载</a>  的基础上，<br>先上个动态效果图：<br><br><img src="../../../../images/githubpages/%E9%AB%98%E4%BB%BF%E5%BE%AE%E4%BF%A1%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87.gif" alt="高仿微信选择图片"><br><br></p>
<p>穿越去下载：<a href="https://github.com/LeeeYou/demoimgpick">https://github.com/LeeeYou/demoimgpick</a></p>
<p>主要的修改有以下几点：</p>
<p>1、根据用户的选择，动态显示已选张数情况<br><br>2、新增图片预览功能</p>
<blockquote>
<p>2.1：预览图片入口有两个：①点击gridview图片预览区域；②点击右下角的【预览】按钮<br>2.2：预览图片界面可以放大、缩小图片<br>2.3: 预览图片界面可以选中和取消选中图片，在退出界面后“根据情况”动态刷新ImageGridShowActivity界面中图片的选中状态<br>2.4：上述的“根据情况”有如下两种：<br>&emsp;&emsp;2.4.1：如果用户点击预览图片，只是单单预览而未做任何选中、取消选中图片的操作，则在退出界面时不会刷新ImageGridShowActivity界面<br>&emsp;&emsp;2.4.2：如果用户在退出界面时选中的图片和进入界面时不同，则在退出界面时会动态刷新ImageGridShowActivity界面<br>2.5：预览图片界面处理OOM<br>2.6：监听物理返回键，动态刷新ImageGridShowActivity界面</p>
</blockquote>
<p>3、修改选择文件夹界面的样式</p>
<blockquote>
<p>3.1：文件夹名称不显示问题<br>3.2：文件名错误显示问题<br>3.3：文件夹默认都选中问题<br>3.4：文件夹item选择时的样式</p>
</blockquote>
<p>4、选中图片区域和预览图片区域的划分</p>
<p>5、优化 createAdapter() 方法，adapter只创建一次</p>
<p>6、文件夹和图片按照时间倒序</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>图片选择器</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之ViewPager的切换动画效果</title>
    <url>/iBlogWebsite/2015/12/31/2015/2015-12-31-Android%E4%B9%8BViewPager%E7%9A%84%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://developer.android.com/reference/android/support/v4/view/ViewPager.html">ViewPager</a> API地址 <a href="http://developer.android.com/reference/android/support/v4/view/ViewPager.html">http://developer.android.com/reference/android/support/v4/view/ViewPager.html</a></p>
</blockquote>
<p>这里介绍三种ViewPager的动画切换效果</p>
<h2 id="setPageTransformer实现动画的切换"><a href="#setPageTransformer实现动画的切换" class="headerlink" title="setPageTransformer实现动画的切换"></a>setPageTransformer实现动画的切换</h2><p>ViewPager的切换，从A页切换到B页</p>
<ul>
<li>A页的position：  0.0 ~ -1.0</li>
<li>B页的position：  1.0 ~ 0.0</li>
</ul>
<p>可以利用ViewPager.setPageTransformer实现动画的切换，只支持3.0API+<br>为了兼容3.0以下的系统，可以修改ViewPager内部代码加上nineoldandroids代替属性动画实现向下兼容。</p>
<p>setPageTransformer的源码如下，可以看到源码中一句 <strong>if(Build.VERSION.SDK_INT &gt;= 11)</strong> 的判断限制了系统的版本，其实就是由于属性动画是在3.0以后引入的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set a &#123;<span class="doctag">@link</span> PageTransformer&#125; that will be called for each attached page whenever</span></span><br><span class="line"><span class="comment">    * the scroll position is changed. This allows the application to apply custom property</span></span><br><span class="line"><span class="comment">    * transformations to each page, overriding the default sliding look and feel.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Prior to Android 3.0 the property animation APIs did not exist.</span></span><br><span class="line"><span class="comment">    * As a result, setting a PageTransformer prior to Android 3.0 (API 11) will have no effect.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> reverseDrawingOrder true if the supplied PageTransformer requires page views</span></span><br><span class="line"><span class="comment">    *                            to be drawn from last to first instead of first to last.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> transformer PageTransformer that will modify each page&#x27;s animation properties</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPageTransformer</span><span class="params">(<span class="type">boolean</span> reverseDrawingOrder, PageTransformer transformer)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">11</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasTransformer</span> <span class="operator">=</span> transformer != <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needsPopulate</span> <span class="operator">=</span> hasTransformer != (mPageTransformer != <span class="literal">null</span>);</span><br><span class="line">           mPageTransformer = transformer;</span><br><span class="line">           setChildrenDrawingOrderEnabledCompat(hasTransformer);</span><br><span class="line">           <span class="keyword">if</span> (hasTransformer) &#123;</span><br><span class="line">               mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               mDrawingOrder = DRAW_ORDER_DEFAULT;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (needsPopulate) populate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义ViewPager实现动画切换"><a href="#自定义ViewPager实现动画切换" class="headerlink" title="自定义ViewPager实现动画切换"></a>自定义ViewPager实现动画切换</h2><p>观察API的规律，自定义ViewPager的切换动画。同时我们也可以自定义ViewPager实现动画切换效果。如下代码实现效果是Translation和Scale，完成的前提是：</p>
<ul>
<li>a 需要拿到当前切换的两个View –&gt; 通过Map存储于获取</li>
<li>b 需要得到一个动画的梯度 –&gt; 通过offset,offsetPixels</li>
</ul>
<p>在初始化的时候，将View保存到一个HashMap中，利用position找到View</p>
<ul>
<li>0<del>1 – pisition = 0 ；offset:0</del>1</li>
<li>1<del>0 – pisition = 0 ；offset:1</del>0</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewPagerWithTranformAnim</span> <span class="keyword">extends</span> <span class="title class_">ViewPager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> View mLeft;</span><br><span class="line">    <span class="keyword">private</span> View mRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mTrans;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mScale;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">MIN_SCALE</span> <span class="operator">=</span> <span class="number">0.7F</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, View&gt; mChildren = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, View&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setViewForPosition</span><span class="params">(View view, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        mChildren.put(position, view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeViewFromPosition</span><span class="params">(Integer position)</span> &#123;</span><br><span class="line">        mChildren.remove(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewPagerWithTranformAnim</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewPagerWithTranformAnim</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPageScrolled</span><span class="params">(<span class="type">int</span> position, <span class="type">float</span> offset, <span class="type">int</span> offsetPixels)</span> &#123;</span><br><span class="line">        mLeft = mChildren.get(position);</span><br><span class="line">        mRight = mChildren.get(position + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        animStack(mLeft, mRight, offset, offsetPixels);</span><br><span class="line">        <span class="built_in">super</span>.onPageScrolled(position, offset, offsetPixels);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">animStack</span><span class="params">(View left, View right, <span class="type">float</span> offset, <span class="type">int</span> offsetPixels)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//从0到1页，offset:0~1</span></span><br><span class="line">            mScale = (<span class="number">1</span> - MIN_SCALE) * offset + MIN_SCALE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//-width~0</span></span><br><span class="line">            mTrans = -getWidth()-getPageMargin()+offsetPixels;</span><br><span class="line"></span><br><span class="line">            ViewHelper.setScaleX(right,mScale);</span><br><span class="line">            ViewHelper.setScaleY(right, mScale);</span><br><span class="line"></span><br><span class="line">            ViewHelper.setTranslationX(right,mTrans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            left.bringToFront();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在activity中维护一个HashMap保存view,代码如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vp_transform_anim.setAdapter(<span class="keyword">new</span> <span class="title class_">PagerAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mImgIds.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isViewFromObject</span><span class="params">(View view, Object object)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> view==object;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">instantiateItem</span><span class="params">(ViewGroup container, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">                <span class="type">ImageView</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageView</span>(ViewPagerWithTranformAnimActivity.<span class="built_in">this</span>);</span><br><span class="line">                iv.setImageResource(mImgIds[position]);</span><br><span class="line">                iv.setScaleType(ImageView.ScaleType.CENTER_CROP);</span><br><span class="line">                container.addView(iv);</span><br><span class="line">                mImages.add(iv);</span><br><span class="line">                vp_transform_anim.setViewForPosition(iv,position);</span><br><span class="line">                <span class="keyword">return</span> iv;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyItem</span><span class="params">(ViewGroup container, <span class="type">int</span> position, Object object)</span> &#123;</span><br><span class="line">                container.removeView(mImages.get(position));</span><br><span class="line">                vp_transform_anim.removeViewFromPosition(position);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="利用开源项目"><a href="#利用开源项目" class="headerlink" title="利用开源项目"></a>利用开源项目</h2><p>ViewPager的切换动画开源项目 <a href="https://github.com/jfeinstein10/JazzyViewPager">JazzyViewPager</a><br>下面贴出了<strong>jazzyviewpager</strong>的源码，里面提供了非常多的动画效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jfeinstein.jazzyviewpager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.TargetApi;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.TypedArray;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Camera;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.view.PagerAdapter;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.view.ViewPager;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.nineoldandroids.view.ViewHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JazzyViewPager</span> <span class="keyword">extends</span> <span class="title class_">ViewPager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;JazzyViewPager&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mEnabled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mFadeEnabled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mOutlineEnabled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sOutlineColor</span> <span class="operator">=</span> Color.WHITE;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TransitionEffect</span> <span class="variable">mEffect</span> <span class="operator">=</span> TransitionEffect.Standard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Object&gt; mObjs = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;Integer, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">SCALE_MAX</span> <span class="operator">=</span> <span class="number">0.5f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ZOOM_MAX</span> <span class="operator">=</span> <span class="number">0.5f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">ROT_MAX</span> <span class="operator">=</span> <span class="number">15.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TransitionEffect</span> &#123;</span><br><span class="line">        Standard,</span><br><span class="line">        Tablet,</span><br><span class="line">        CubeIn,</span><br><span class="line">        CubeOut,</span><br><span class="line">        FlipVertical,</span><br><span class="line">        FlipHorizontal,</span><br><span class="line">        Stack,</span><br><span class="line">        ZoomIn,</span><br><span class="line">        ZoomOut,</span><br><span class="line">        RotateUp,</span><br><span class="line">        RotateDown,</span><br><span class="line">        Accordion</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> API_11;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        API_11 = Build.VERSION.SDK_INT &gt;= <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JazzyViewPager</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;incomplete-switch&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JazzyViewPager</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">        setClipChildren(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// now style everything!</span></span><br><span class="line">        <span class="type">TypedArray</span> <span class="variable">ta</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, R.styleable.JazzyViewPager);</span><br><span class="line">        <span class="type">int</span> <span class="variable">effect</span> <span class="operator">=</span> ta.getInt(R.styleable.JazzyViewPager_style, <span class="number">0</span>);</span><br><span class="line">        String[] transitions = getResources().getStringArray(R.array.jazzy_effects);</span><br><span class="line">        setTransitionEffect(TransitionEffect.valueOf(transitions[effect]));</span><br><span class="line">        setFadeEnabled(ta.getBoolean(R.styleable.JazzyViewPager_fadeEnabled, <span class="literal">false</span>));</span><br><span class="line">        setOutlineEnabled(ta.getBoolean(R.styleable.JazzyViewPager_outlineEnabled, <span class="literal">false</span>));</span><br><span class="line">        setOutlineColor(ta.getColor(R.styleable.JazzyViewPager_outlineColor, Color.WHITE));</span><br><span class="line">        <span class="keyword">switch</span> (mEffect) &#123;</span><br><span class="line">        <span class="keyword">case</span> Stack:</span><br><span class="line">        <span class="keyword">case</span> ZoomOut:</span><br><span class="line">            setFadeEnabled(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTransitionEffect</span><span class="params">(TransitionEffect effect)</span> &#123;</span><br><span class="line">        mEffect = effect;</span><br><span class="line"><span class="comment">//      reset();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPagingEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">        mEnabled = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFadeEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">        mFadeEnabled = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getFadeEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mFadeEnabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOutlineEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">        mOutlineEnabled = enabled;</span><br><span class="line">        wrapWithOutlines();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOutlineColor</span><span class="params">(<span class="type">int</span> color)</span> &#123;</span><br><span class="line">        sOutlineColor = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">wrapWithOutlines</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">            <span class="type">View</span> <span class="variable">v</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!(v <span class="keyword">instanceof</span> OutlineContainer)) &#123;</span><br><span class="line">                removeView(v);</span><br><span class="line">                <span class="built_in">super</span>.addView(wrapChild(v), i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> View <span class="title function_">wrapChild</span><span class="params">(View child)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mOutlineEnabled || child <span class="keyword">instanceof</span> OutlineContainer) <span class="keyword">return</span> child;</span><br><span class="line">        <span class="type">OutlineContainer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutlineContainer</span>(getContext());</span><br><span class="line">        out.setLayoutParams(generateDefaultLayoutParams());</span><br><span class="line">        child.setLayoutParams(<span class="keyword">new</span> <span class="title class_">OutlineContainer</span>.LayoutParams(</span><br><span class="line">                LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));</span><br><span class="line">        out.addView(child);</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View child)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addView(wrapChild(child));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View child, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addView(wrapChild(child), index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View child, LayoutParams params)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addView(wrapChild(child), params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View child, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addView(wrapChild(child), width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View child, <span class="type">int</span> index, LayoutParams params)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addView(wrapChild(child), index, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent arg0)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mEnabled ? <span class="built_in">super</span>.onInterceptTouchEvent(arg0) : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State mState;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> oldPage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> View mLeft;</span><br><span class="line">    <span class="keyword">private</span> View mRight;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mRot;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mTrans;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mScale;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        IDLE,</span><br><span class="line">        GOING_LEFT,</span><br><span class="line">        GOING_RIGHT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  public void reset() &#123;</span></span><br><span class="line"><span class="comment">//  resetPrivate();</span></span><br><span class="line"><span class="comment">//  int curr = getCurrentItem();</span></span><br><span class="line"><span class="comment">//  onPageScrolled(curr, 0.0f, 0);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//private void resetPrivate() &#123;</span></span><br><span class="line"><span class="comment">//  for (int i = 0; i &lt; getChildCount(); i++) &#123;</span></span><br><span class="line"><span class="comment">//      View v = getChildAt(i);</span></span><br><span class="line"><span class="comment">//      //          ViewHelper.setRotation(v, -ViewHelper.getRotation(v));</span></span><br><span class="line"><span class="comment">//      //          ViewHelper.setRotationX(v, -ViewHelper.getRotationX(v));</span></span><br><span class="line"><span class="comment">//      //          ViewHelper.setRotationY(v, -ViewHelper.getRotationY(v));</span></span><br><span class="line"><span class="comment">//      //</span></span><br><span class="line"><span class="comment">//      //          ViewHelper.setTranslationX(v, -ViewHelper.getTranslationX(v));</span></span><br><span class="line"><span class="comment">//      //          ViewHelper.setTranslationY(v, -ViewHelper.getTranslationY(v));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      ViewHelper.setRotation(v, 0);</span></span><br><span class="line"><span class="comment">//      ViewHelper.setRotationX(v, 0);</span></span><br><span class="line"><span class="comment">//      ViewHelper.setRotationY(v, 0);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      ViewHelper.setTranslationX(v, 0);</span></span><br><span class="line"><span class="comment">//      ViewHelper.setTranslationY(v, 0);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      ViewHelper.setAlpha(v, 1.0f);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      ViewHelper.setScaleX(v, 1.0f);</span></span><br><span class="line"><span class="comment">//      ViewHelper.setScaleY(v, 1.0f);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      ViewHelper.setPivotX(v, 0);</span></span><br><span class="line"><span class="comment">//      ViewHelper.setPivotY(v, 0);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      logState(v, &quot;Child &quot; + i);</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logState</span><span class="params">(View v, String title)</span> &#123;</span><br><span class="line">        Log.v(TAG, title + <span class="string">&quot;: ROT (&quot;</span> + ViewHelper.getRotation(v) + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">                ViewHelper.getRotationX(v) + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">                ViewHelper.getRotationY(v) + <span class="string">&quot;), TRANS (&quot;</span> +</span><br><span class="line">                ViewHelper.getTranslationX(v) + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">                ViewHelper.getTranslationY(v) + <span class="string">&quot;), SCALE (&quot;</span> +</span><br><span class="line">                ViewHelper.getScaleX(v) + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">                ViewHelper.getScaleY(v) + <span class="string">&quot;), ALPHA &quot;</span> +</span><br><span class="line">                ViewHelper.getAlpha(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">animateScroll</span><span class="params">(<span class="type">int</span> position, <span class="type">float</span> positionOffset)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mState != State.IDLE) &#123;</span><br><span class="line">            mRot = (<span class="type">float</span>)(<span class="number">1</span>-Math.cos(<span class="number">2</span>*Math.PI*positionOffset))/<span class="number">2</span>*<span class="number">30.0f</span>;</span><br><span class="line">            ViewHelper.setRotationY(<span class="built_in">this</span>, mState == State.GOING_RIGHT ? mRot : -mRot);</span><br><span class="line">            ViewHelper.setPivotX(<span class="built_in">this</span>, getMeasuredWidth()*<span class="number">0.5f</span>);</span><br><span class="line">            ViewHelper.setPivotY(<span class="built_in">this</span>, getMeasuredHeight()*<span class="number">0.5f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">animateTablet</span><span class="params">(View left, View right, <span class="type">float</span> positionOffset)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mState != State.IDLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(left, <span class="literal">true</span>);</span><br><span class="line">                mRot = <span class="number">30.0f</span> * positionOffset;</span><br><span class="line">                mTrans = getOffsetXForRotation(mRot, left.getMeasuredWidth(),</span><br><span class="line">                        left.getMeasuredHeight());</span><br><span class="line">                ViewHelper.setPivotX(left, left.getMeasuredWidth()/<span class="number">2</span>);</span><br><span class="line">                ViewHelper.setPivotY(left, left.getMeasuredHeight()/<span class="number">2</span>);</span><br><span class="line">                ViewHelper.setTranslationX(left, mTrans);</span><br><span class="line">                ViewHelper.setRotationY(left, mRot);</span><br><span class="line">                logState(left, <span class="string">&quot;Left&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(right, <span class="literal">true</span>);</span><br><span class="line">                mRot = -<span class="number">30.0f</span> * (<span class="number">1</span>-positionOffset);</span><br><span class="line">                mTrans = getOffsetXForRotation(mRot, right.getMeasuredWidth(),</span><br><span class="line">                        right.getMeasuredHeight());</span><br><span class="line">                ViewHelper.setPivotX(right, right.getMeasuredWidth()*<span class="number">0.5f</span>);</span><br><span class="line">                ViewHelper.setPivotY(right, right.getMeasuredHeight()*<span class="number">0.5f</span>);</span><br><span class="line">                ViewHelper.setTranslationX(right, mTrans);</span><br><span class="line">                ViewHelper.setRotationY(right, mRot);</span><br><span class="line">                logState(right, <span class="string">&quot;Right&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">animateCube</span><span class="params">(View left, View right, <span class="type">float</span> positionOffset, <span class="type">boolean</span> in)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mState != State.IDLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(left, <span class="literal">true</span>);</span><br><span class="line">                mRot = (in ? <span class="number">90.0f</span> : -<span class="number">90.0f</span>) * positionOffset;</span><br><span class="line">                ViewHelper.setPivotX(left, left.getMeasuredWidth());</span><br><span class="line">                ViewHelper.setPivotY(left, left.getMeasuredHeight()*<span class="number">0.5f</span>);</span><br><span class="line">                ViewHelper.setRotationY(left, mRot);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(right, <span class="literal">true</span>);</span><br><span class="line">                mRot = -(in ? <span class="number">90.0f</span> : -<span class="number">90.0f</span>) * (<span class="number">1</span>-positionOffset);</span><br><span class="line">                ViewHelper.setPivotX(right, <span class="number">0</span>);</span><br><span class="line">                ViewHelper.setPivotY(right, right.getMeasuredHeight()*<span class="number">0.5f</span>);</span><br><span class="line">                ViewHelper.setRotationY(right, mRot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">animateAccordion</span><span class="params">(View left, View right, <span class="type">float</span> positionOffset)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mState != State.IDLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(left, <span class="literal">true</span>);</span><br><span class="line">                ViewHelper.setPivotX(left, left.getMeasuredWidth());</span><br><span class="line">                ViewHelper.setPivotY(left, <span class="number">0</span>);</span><br><span class="line">                ViewHelper.setScaleX(left, <span class="number">1</span>-positionOffset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(right, <span class="literal">true</span>);</span><br><span class="line">                ViewHelper.setPivotX(right, <span class="number">0</span>);</span><br><span class="line">                ViewHelper.setPivotY(right, <span class="number">0</span>);</span><br><span class="line">                ViewHelper.setScaleX(right, positionOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">animateZoom</span><span class="params">(View left, View right, <span class="type">float</span> positionOffset, <span class="type">boolean</span> in)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mState != State.IDLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(left, <span class="literal">true</span>);</span><br><span class="line">                mScale = in ? ZOOM_MAX + (<span class="number">1</span>-ZOOM_MAX)*(<span class="number">1</span>-positionOffset) :</span><br><span class="line">                    <span class="number">1</span>+ZOOM_MAX - ZOOM_MAX*(<span class="number">1</span>-positionOffset);</span><br><span class="line">                ViewHelper.setPivotX(left, left.getMeasuredWidth()*<span class="number">0.5f</span>);</span><br><span class="line">                ViewHelper.setPivotY(left, left.getMeasuredHeight()*<span class="number">0.5f</span>);</span><br><span class="line">                ViewHelper.setScaleX(left, mScale);</span><br><span class="line">                ViewHelper.setScaleY(left, mScale);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(right, <span class="literal">true</span>);</span><br><span class="line">                mScale = in ? ZOOM_MAX + (<span class="number">1</span>-ZOOM_MAX)*positionOffset :</span><br><span class="line">                    <span class="number">1</span>+ZOOM_MAX - ZOOM_MAX*positionOffset;</span><br><span class="line">                ViewHelper.setPivotX(right, right.getMeasuredWidth()*<span class="number">0.5f</span>);</span><br><span class="line">                ViewHelper.setPivotY(right, right.getMeasuredHeight()*<span class="number">0.5f</span>);</span><br><span class="line">                ViewHelper.setScaleX(right, mScale);</span><br><span class="line">                ViewHelper.setScaleY(right, mScale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">animateRotate</span><span class="params">(View left, View right, <span class="type">float</span> positionOffset, <span class="type">boolean</span> up)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mState != State.IDLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(left, <span class="literal">true</span>);</span><br><span class="line">                mRot = (up ? <span class="number">1</span> : -<span class="number">1</span>) * (ROT_MAX * positionOffset);</span><br><span class="line">                mTrans = (up ? -<span class="number">1</span> : <span class="number">1</span>) * (<span class="type">float</span>) (getMeasuredHeight() - getMeasuredHeight()*Math.cos(mRot*Math.PI/<span class="number">180.0f</span>));</span><br><span class="line">                ViewHelper.setPivotX(left, left.getMeasuredWidth()*<span class="number">0.5f</span>);</span><br><span class="line">                ViewHelper.setPivotY(left, up ? <span class="number">0</span> : left.getMeasuredHeight());</span><br><span class="line">                ViewHelper.setTranslationY(left, mTrans);</span><br><span class="line">                ViewHelper.setRotation(left, mRot);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(right, <span class="literal">true</span>);</span><br><span class="line">                mRot = (up ? <span class="number">1</span> : -<span class="number">1</span>) * (-ROT_MAX + ROT_MAX*positionOffset);</span><br><span class="line">                mTrans = (up ? -<span class="number">1</span> : <span class="number">1</span>) * (<span class="type">float</span>) (getMeasuredHeight() - getMeasuredHeight()*Math.cos(mRot*Math.PI/<span class="number">180.0f</span>));</span><br><span class="line">                ViewHelper.setPivotX(right, right.getMeasuredWidth()*<span class="number">0.5f</span>);</span><br><span class="line">                ViewHelper.setPivotY(right, up ? <span class="number">0</span> : right.getMeasuredHeight());</span><br><span class="line">                ViewHelper.setTranslationY(right, mTrans);</span><br><span class="line">                ViewHelper.setRotation(right, mRot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">animateFlipHorizontal</span><span class="params">(View left, View right, <span class="type">float</span> positionOffset, <span class="type">int</span> positionOffsetPixels)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mState != State.IDLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(left, <span class="literal">true</span>);</span><br><span class="line">                mRot = <span class="number">180.0f</span> * positionOffset;</span><br><span class="line">                <span class="keyword">if</span> (mRot &gt; <span class="number">90.0f</span>) &#123;</span><br><span class="line">                    left.setVisibility(View.INVISIBLE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (left.getVisibility() == View.INVISIBLE)</span><br><span class="line">                        left.setVisibility(View.VISIBLE);</span><br><span class="line">                    mTrans = positionOffsetPixels;</span><br><span class="line">                    ViewHelper.setPivotX(left, left.getMeasuredWidth()*<span class="number">0.5f</span>);</span><br><span class="line">                    ViewHelper.setPivotY(left, left.getMeasuredHeight()*<span class="number">0.5f</span>);</span><br><span class="line">                    ViewHelper.setTranslationX(left, mTrans);</span><br><span class="line">                    ViewHelper.setRotationY(left, mRot);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(right, <span class="literal">true</span>);</span><br><span class="line">                mRot = -<span class="number">180.0f</span> * (<span class="number">1</span>-positionOffset);</span><br><span class="line">                <span class="keyword">if</span> (mRot &lt; -<span class="number">90.0f</span>) &#123;</span><br><span class="line">                    right.setVisibility(View.INVISIBLE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (right.getVisibility() == View.INVISIBLE)</span><br><span class="line">                        right.setVisibility(View.VISIBLE);</span><br><span class="line">                    mTrans = -getWidth()-getPageMargin()+positionOffsetPixels;</span><br><span class="line">                    ViewHelper.setPivotX(right, right.getMeasuredWidth()*<span class="number">0.5f</span>);</span><br><span class="line">                    ViewHelper.setPivotY(right, right.getMeasuredHeight()*<span class="number">0.5f</span>);</span><br><span class="line">                    ViewHelper.setTranslationX(right, mTrans);</span><br><span class="line">                    ViewHelper.setRotationY(right, mRot);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">animateFlipVertical</span><span class="params">(View left, View right, <span class="type">float</span> positionOffset, <span class="type">int</span> positionOffsetPixels)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(mState != State.IDLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(left, <span class="literal">true</span>);</span><br><span class="line">                mRot = <span class="number">180.0f</span> * positionOffset;</span><br><span class="line">                <span class="keyword">if</span> (mRot &gt; <span class="number">90.0f</span>) &#123;</span><br><span class="line">                    left.setVisibility(View.INVISIBLE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (left.getVisibility() == View.INVISIBLE)</span><br><span class="line">                        left.setVisibility(View.VISIBLE);</span><br><span class="line">                    mTrans = positionOffsetPixels;</span><br><span class="line">                    ViewHelper.setPivotX(left, left.getMeasuredWidth()*<span class="number">0.5f</span>);</span><br><span class="line">                    ViewHelper.setPivotY(left, left.getMeasuredHeight()*<span class="number">0.5f</span>);</span><br><span class="line">                    ViewHelper.setTranslationX(left, mTrans);</span><br><span class="line">                    ViewHelper.setRotationX(left, mRot);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(right, <span class="literal">true</span>);</span><br><span class="line">                mRot = -<span class="number">180.0f</span> * (<span class="number">1</span>-positionOffset);</span><br><span class="line">                <span class="keyword">if</span> (mRot &lt; -<span class="number">90.0f</span>) &#123;</span><br><span class="line">                    right.setVisibility(View.INVISIBLE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (right.getVisibility() == View.INVISIBLE)</span><br><span class="line">                        right.setVisibility(View.VISIBLE);</span><br><span class="line">                    mTrans = -getWidth()-getPageMargin()+positionOffsetPixels;</span><br><span class="line">                    ViewHelper.setPivotX(right, right.getMeasuredWidth()*<span class="number">0.5f</span>);</span><br><span class="line">                    ViewHelper.setPivotY(right, right.getMeasuredHeight()*<span class="number">0.5f</span>);</span><br><span class="line">                    ViewHelper.setTranslationX(right, mTrans);</span><br><span class="line">                    ViewHelper.setRotationX(right, mRot);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">animateStack</span><span class="params">(View left, View right, <span class="type">float</span> positionOffset, <span class="type">int</span> positionOffsetPixels)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mState != State.IDLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(right, <span class="literal">true</span>);</span><br><span class="line">                mScale = (<span class="number">1</span>-SCALE_MAX) * positionOffset + SCALE_MAX;</span><br><span class="line">                mTrans = -getWidth()-getPageMargin()+positionOffsetPixels;</span><br><span class="line">                ViewHelper.setScaleX(right, mScale);</span><br><span class="line">                ViewHelper.setScaleY(right, mScale);</span><br><span class="line">                ViewHelper.setTranslationX(right, mTrans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                left.bringToFront();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">manageLayer</span><span class="params">(View v, <span class="type">boolean</span> enableHardware)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!API_11) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">layerType</span> <span class="operator">=</span> enableHardware ? View.LAYER_TYPE_HARDWARE : View.LAYER_TYPE_NONE;</span><br><span class="line">        <span class="keyword">if</span> (layerType != v.getLayerType())</span><br><span class="line">            v.setLayerType(layerType, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">disableHardwareLayer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!API_11) <span class="keyword">return</span>;</span><br><span class="line">        View v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">            v = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (v.getLayerType() != View.LAYER_TYPE_NONE)</span><br><span class="line">                v.setLayerType(View.LAYER_TYPE_NONE, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Matrix</span> <span class="variable">mMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Camera</span> <span class="variable">mCamera</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span>[] mTempFloat2 = <span class="keyword">new</span> <span class="title class_">float</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> <span class="title function_">getOffsetXForRotation</span><span class="params">(<span class="type">float</span> degrees, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        mMatrix.reset();</span><br><span class="line">        mCamera.save();</span><br><span class="line">        mCamera.rotateY(Math.abs(degrees));</span><br><span class="line">        mCamera.getMatrix(mMatrix);</span><br><span class="line">        mCamera.restore();</span><br><span class="line"></span><br><span class="line">        mMatrix.preTranslate(-width * <span class="number">0.5f</span>, -height * <span class="number">0.5f</span>);</span><br><span class="line">        mMatrix.postTranslate(width * <span class="number">0.5f</span>, height * <span class="number">0.5f</span>);</span><br><span class="line">        mTempFloat2[<span class="number">0</span>] = width;</span><br><span class="line">        mTempFloat2[<span class="number">1</span>] = height;</span><br><span class="line">        mMatrix.mapPoints(mTempFloat2);</span><br><span class="line">        <span class="keyword">return</span> (width - mTempFloat2[<span class="number">0</span>]) * (degrees &gt; <span class="number">0.0f</span> ? <span class="number">1.0f</span> : -<span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">animateFade</span><span class="params">(View left, View right, <span class="type">float</span> positionOffset)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            ViewHelper.setAlpha(left, <span class="number">1</span>-positionOffset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            ViewHelper.setAlpha(right, positionOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">animateOutline</span><span class="params">(View left, View right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(left <span class="keyword">instanceof</span> OutlineContainer))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (mState != State.IDLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(left, <span class="literal">true</span>);</span><br><span class="line">                ((OutlineContainer)left).setOutlineAlpha(<span class="number">1.0f</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                manageLayer(right, <span class="literal">true</span>);</span><br><span class="line">                ((OutlineContainer)right).setOutlineAlpha(<span class="number">1.0f</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>)</span><br><span class="line">                ((OutlineContainer)left).start();</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>)</span><br><span class="line">                ((OutlineContainer)right).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageScrolled</span><span class="params">(<span class="type">int</span> position, <span class="type">float</span> positionOffset, <span class="type">int</span> positionOffsetPixels)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mState == State.IDLE &amp;&amp; positionOffset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            oldPage = getCurrentItem();</span><br><span class="line">            mState = position == oldPage ? State.GOING_RIGHT : State.GOING_LEFT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">goingRight</span> <span class="operator">=</span> position == oldPage;</span><br><span class="line">        <span class="keyword">if</span> (mState == State.GOING_RIGHT &amp;&amp; !goingRight)</span><br><span class="line">            mState = State.GOING_LEFT;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mState == State.GOING_LEFT &amp;&amp; goingRight)</span><br><span class="line">            mState = State.GOING_RIGHT;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">effectOffset</span> <span class="operator">=</span> isSmall(positionOffset) ? <span class="number">0</span> : positionOffset;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      mLeft = getChildAt(position);</span></span><br><span class="line"><span class="comment">//      mRight = getChildAt(position+1);</span></span><br><span class="line">        mLeft = findViewFromObject(position);</span><br><span class="line">        mRight = findViewFromObject(position+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFadeEnabled)</span><br><span class="line">            animateFade(mLeft, mRight, effectOffset);</span><br><span class="line">        <span class="keyword">if</span> (mOutlineEnabled)</span><br><span class="line">            animateOutline(mLeft, mRight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mEffect) &#123;</span><br><span class="line">        <span class="keyword">case</span> Standard:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Tablet:</span><br><span class="line">            animateTablet(mLeft, mRight, effectOffset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CubeIn:</span><br><span class="line">            animateCube(mLeft, mRight, effectOffset, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CubeOut:</span><br><span class="line">            animateCube(mLeft, mRight, effectOffset, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FlipVertical:</span><br><span class="line">            animateFlipVertical(mLeft, mRight, positionOffset, positionOffsetPixels);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FlipHorizontal:</span><br><span class="line">            animateFlipHorizontal(mLeft, mRight, effectOffset, positionOffsetPixels);</span><br><span class="line">        <span class="keyword">case</span> Stack:</span><br><span class="line">            animateStack(mLeft, mRight, effectOffset, positionOffsetPixels);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ZoomIn:</span><br><span class="line">            animateZoom(mLeft, mRight, effectOffset, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ZoomOut:</span><br><span class="line">            animateZoom(mLeft, mRight, effectOffset, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RotateUp:</span><br><span class="line">            animateRotate(mLeft, mRight, effectOffset, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RotateDown:</span><br><span class="line">            animateRotate(mLeft, mRight, effectOffset, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Accordion:</span><br><span class="line">            animateAccordion(mLeft, mRight, effectOffset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.onPageScrolled(position, positionOffset, positionOffsetPixels);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (effectOffset == <span class="number">0</span>) &#123;</span><br><span class="line">            disableHardwareLayer();</span><br><span class="line">            mState = State.IDLE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSmall</span><span class="params">(<span class="type">float</span> positionOffset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(positionOffset) &lt; <span class="number">0.0001</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObjectForPosition</span><span class="params">(Object obj, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        mObjs.put(Integer.valueOf(position), obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">findViewFromObject</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> mObjs.get(Integer.valueOf(position));</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">PagerAdapter</span> <span class="variable">a</span> <span class="operator">=</span> getAdapter();</span><br><span class="line">        View v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">            v = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (a.isViewFromObject(v, o))</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手debug源码之Retrofit</title>
    <url>/iBlogWebsite/2019/01/25/2019/2019-01-25-%E6%89%8B%E6%8A%8A%E6%89%8Bdebug%E6%BA%90%E7%A0%81%E4%B9%8BRetrofit/</url>
    <content><![CDATA[<p>本文基于Retrofit2.5.0进行源码分析，以发送一个异步get网络请求为例，直到取回数据再渲染到页面的整个过程。Gif示例如下：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-retrofit-demo.gif?raw=true" alt="source-code-analysis-retrofit-demo"></p>
<p>本文不过多解释Retrofit是怎样使用的，本文假设你已经使用过它并对其有一定程度的了解，那么你应该清楚它有几个可以自由配置的属性分别是：callFactory、converterFactories、callAdapterFactories、callbackExecutor；掌握这几个属性对于理解Retrofit源码起着关键作用。</p>
<blockquote>
<p><em><strong>callFactory</strong></em>：网络请求器，用于发起真正的网络请求。<br><em><strong>converterFactories</strong></em>：数据转换器，用于将网络请求的结果转换成你想要的目标数据结构，比如<em>Gson</em>、<em>Jackson</em>、<em>Simple XML</em>。<br><em><strong>callAdapterFactories</strong></em>：网络请求适配器，用于将网络请求包装成不同的类型，如默认的Call、<a href="https://github.com/square/retrofit/blob/master/retrofit-adapters/rxjava2/README.md"><em>RxJava2的Observable</em></a>、<a href="https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter"><em>Kotlin的coroutines</em></a>。<br><em><strong>callbackExecutor</strong></em>：回调执行器，用于将网络请求的结果从子线程拉回到主线程。</p>
</blockquote>
<p>使用Retrofit发送一个网络请求的代码如下所示，你也可以直接下载<a href="https://github.com/Leeeyou/SourceCodeAnalysisRetrofit"><em>demo</em></a>运行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//step1:创建Retrofit实例</span></span><br><span class="line"><span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">&quot;http://gank.io/api/&quot;</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line"><span class="comment">//step2:创建接口服务类的代理对象，这里是gankService</span></span><br><span class="line"><span class="keyword">val</span> gankService = retrofit.create(GankService::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line"><span class="comment">//step3:访问接口服务类中的具体业务方法，得到一个适配器对象，这里的categoriesCall是Call&lt;ResponseCategory&gt;类型</span></span><br><span class="line"><span class="keyword">val</span> categoriesCall = gankService.categories()</span><br><span class="line"></span><br><span class="line"><span class="comment">//step4:通过categoriesCall发起网络请求，在Callback中解析数据并处理后续业务逻辑。</span></span><br><span class="line">categoriesCall.enqueue(<span class="keyword">object</span> : Callback&lt;ResponseCategory&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseCategory</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;访问失败&quot;</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseCategory</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">ResponseCategory</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> body = response.body()</span><br><span class="line">        body?.takeIf &#123; result -&gt; !result.isError &#125;?.also &#123; category -&gt;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, <span class="string">&quot;访问成功 -&gt; &quot;</span> + Gson().toJson(category), Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在上面代码中对step1至step4做了详细的注释，这四个步骤基本就是Retrofit发起网络请求的流程。但源码分析还可以继续深究，在step4发起网络请求时，其中的细节还有很多精彩好戏。这里看上去是categoriesCall这个适配器发起网络请求，但它并不具备这个能力，真正发起网络请求的是callFactory这个网络请求器，callFactory作为网络请求适配器中的一个属性，在构造时就被传到了网络请求适配器中，这里的细节后续会结合代码和debug截图再次分析。</p>
<p>当拿到网络请求返回结果后，会将数据给到数据转换器转换成你想要的目标数据结构，这步我们看作是step5，这个步骤发生在OkHttpCall中。</p>
<p><em>demo</em>中我们发起异步请求，所以目标数据转换成功后，需要将执行线程从子线程切换到主线程，这步我们看作是step6，这个步骤发生在ExecutorCallbackCall中；另外如果发送同步请求时，是没有这一步骤的。</p>
<p>所以利用Retrofit发送一个异步get网络请求，具体流程如下：</p>
<blockquote>
<p>step1. 创建Retrofit实例<br>step2. 创建网络请求接口服务类的代理对象<br>step3. 通过代理对象访问接口服务类中的具体业务方法<br>step4. 通过网络请求结果适配器发起网络请求<br>step5. 通过数据转换器转成目标数据结构<br>step6. 通过回调器将代码执行从子线程拉回到主线程</p>
</blockquote>
<h2 id="step1-创建Retrofit实例"><a href="#step1-创建Retrofit实例" class="headerlink" title="step1. 创建Retrofit实例"></a>step1. 创建Retrofit实例</h2><p>下面的代码是最简洁的创建Retrofit实例的代码，这里只配置了数据转换器，其余没有配置的属性，如callFactory、callAdapterFactories、callbackExecutor都采用默认的，接下来会详细分析。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">&quot;http://gank.io/api/&quot;</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>

<p>首先这里通过外观模式，提供了一个统一的接口（Retrofit）用来访问子系统中的一群接口。然后通过建造者模式，配置了baseUrl以及ConverterFactory。建造者模式将Retrofit这个对象的构造过程抽象了出来，开发者可以灵活的组合和配置这几个属性。如若不采用这种方式，Retrofit务必要提供多种重载的构造函数来满足不同开发者的需求，现在通过这种设计模式，直接将这个问题抛给了开发者，开发者要用哪个则配置哪个。</p>
<p>在Retrofit.Buildre()的源码中，有如下构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Platform.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要重点分析下Platform这个类，这个类描述了Retrofit当前处于哪个平台，以及callFactory等属性的默认实现。在2.5.0版本的源码中区分三个平台：Android、Java8以及默认的Platform。源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Platform</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Platform</span> <span class="variable">PLATFORM</span> <span class="operator">=</span> findPlatform();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Platform <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PLATFORM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title function_">findPlatform</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">&quot;android.os.Build&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//Android平台</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Android</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">&quot;java.util.Optional&quot;</span>);</span><br><span class="line">      <span class="comment">//Java8平台</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Java8</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认平台</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Platform</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们重点分析Android平台下的表现，源码如下所示，defaultCallbackExecutor()中返回了MainThreadExecutor的实例对象，里面创建了一个基于主线程looper的handler对象；defaultCallAdapterFactories()中创建了ExecutorCallAdapterFactory的实例对象，它是Android平台默认的网络请求结果适配器工厂；defaultConverterFactories()中在SDK24及以上的版本创建了OptionalConverterFactory的实例对象，在24以下是EmptyList的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Android</span> <span class="keyword">extends</span> <span class="title class_">Platform</span> &#123;</span><br><span class="line">  <span class="meta">@IgnoreJRERequirement</span> <span class="comment">// Guarded by API check.</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">isDefaultMethod</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">24</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method.isDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认回调执行器</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Executor <span class="title function_">defaultCallbackExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MainThreadExecutor</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认网络请求结果适配器的工厂列表</span></span><br><span class="line">  <span class="meta">@Override</span> List&lt;? <span class="keyword">extends</span> <span class="title class_">CallAdapter</span>.Factory&gt; defaultCallAdapterFactories(</span><br><span class="line">      <span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callbackExecutor == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    <span class="type">ExecutorCallAdapterFactory</span> <span class="variable">executorFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutorCallAdapterFactory</span>(callbackExecutor);</span><br><span class="line">    <span class="keyword">return</span> Build.VERSION.SDK_INT &gt;= <span class="number">24</span></span><br><span class="line">      ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)</span><br><span class="line">      : singletonList(executorFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="type">int</span> <span class="title function_">defaultCallAdapterFactoriesSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Build.VERSION.SDK_INT &gt;= <span class="number">24</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认数据转换器的工厂列表</span></span><br><span class="line">  <span class="meta">@Override</span> List&lt;? <span class="keyword">extends</span> <span class="title class_">Converter</span>.Factory&gt; defaultConverterFactories() &#123;</span><br><span class="line">    <span class="keyword">return</span> Build.VERSION.SDK_INT &gt;= <span class="number">24</span></span><br><span class="line">        ? singletonList(OptionalConverterFactory.INSTANCE)</span><br><span class="line">        : Collections.&lt;Converter.Factory&gt;emptyList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="type">int</span> <span class="title function_">defaultConverterFactoriesSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Build.VERSION.SDK_INT &gt;= <span class="number">24</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">      handler.post(r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到网络请求结果适配器和数据转换器都采用了工厂模式，你只要将工厂配置进来，至于怎么创建对象，则不需要你过多关心，只需要知道调用create()就可以。</p>
<p>我们回到代码主线分支，在执行到Retrofit.Buildre().build()时，就会将刚才基于Andorid平台各个属性的默认配置传入到Retrofit的构造函数中，最后通过new关键字创建好Retrofit实例对象，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build源码</span></span><br><span class="line"><span class="keyword">public</span> Retrofit <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (baseUrl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Base URL required.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//网络执行器，demo中没有设置，故采用默认的OkHttpClient</span></span><br><span class="line">  okhttp3.Call.<span class="type">Factory</span> <span class="variable">callFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.callFactory;</span><br><span class="line">  <span class="keyword">if</span> (callFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">    callFactory = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//回调执行器，这里用到了装饰者模式，这里本来想要一个普通的Executor</span></span><br><span class="line">  <span class="comment">//然后返回了一个带有线程切换功能的Executor，动态地将责任附加到callbackExecutor上</span></span><br><span class="line">  <span class="type">Executor</span> <span class="variable">callbackExecutor</span> <span class="operator">=</span> <span class="built_in">this</span>.callbackExecutor;</span><br><span class="line">  <span class="keyword">if</span> (callbackExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">    callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//网络请求结果适配器</span></span><br><span class="line">  List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.callAdapterFactories);</span><br><span class="line">  callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//数据转换器</span></span><br><span class="line">  List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">      <span class="number">1</span> + <span class="built_in">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">  converterFactories.add(<span class="keyword">new</span> <span class="title class_">BuiltInConverters</span>());</span><br><span class="line">  converterFactories.addAll(<span class="built_in">this</span>.converterFactories);</span><br><span class="line">  converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造Retrofit实例对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">      unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：在这一步中，通过建造者模式，灵活配置所需的各个属性（网络请求器、数据转换器、网络请求结果适配器、回调执行器），最后通过new关键字创建Retrofit的实例对象。遇到没有配置的属性，则通过Platform找到对应的平台，然后再找到该平台下的各个属性的默认配置，最后将属性值递到Retrofit的构造函数中。数据转换器和网络请求结果适配器还采取了工厂模式，隐藏具体的创建细节，让具体工厂自己创建其对象。</p>
<h2 id="step2-创建网络请求接口的代理对象"><a href="#step2-创建网络请求接口的代理对象" class="headerlink" title="step2. 创建网络请求接口的代理对象"></a>step2. 创建网络请求接口的代理对象</h2><p>通过Retrofit实例创建代理对象的源码如下所示，传入参数是网络请求服务接口的Class对象（即GankService），返回的是该接口的代理对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> gankService = retrofit.create(GankService::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure>

<p>在2.5.0版本的Retrofit源码中，create的源码如下所示，因为我们没有设置validateEagerly的值，所以它默认false，然后就是通过Proxy.newProxyInstance创建代理对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T create(<span class="keyword">final</span> Class&lt;T&gt; service) &#123;</span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//代理模式</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">    new InvocationHandler() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.<span class="keyword">get</span>();</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = new Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> Object invoke(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span><br><span class="line">          throws Throwable &#123;</span><br><span class="line">        <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.<span class="keyword">class</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">          <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="literal">null</span> ? args : emptyArgs);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newProxyInstance方法中的第一个参数service.getClassLoader()得到类加载器是PathClassLoader，它是Android系统默认的类加载器 <em>（另外DexClassLoader与PathClassLoader的区别感兴趣的童鞋可以自行查阅资料）</em> ；第二个参数是GankService接口的Class对象，这个数组表明要代理哪些接口；第三个参数是动态代理对象，就是外部调用GankService的业务方法时，实际上会被代理回调到这里，然后在invoke方法里面准备网络请求所必须的全部实例对象，如：callAdapter选哪个，responseConverter选哪个等。下面截图是debug create方法的标注说明：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-retrofit-create.jpg?raw=true" alt="source-code-analysis-retrofit-create"></p>
<p>总结：在这一步中，Retrofit通过代理模式创建代理对象，当你在外部调用业务方法时会进行拦截，然后进入到InvocationHandler的invoke方法中控制程序的执行逻辑和流程。</p>
<h2 id="step3-通过代理对象访问接口服务类中的具体业务方法"><a href="#step3-通过代理对象访问接口服务类中的具体业务方法" class="headerlink" title="step3. 通过代理对象访问接口服务类中的具体业务方法"></a>step3. 通过代理对象访问接口服务类中的具体业务方法</h2><p>前面两步分别创建了Retrofit实例，然后通过该实例创建了网络请求接口的代理对象，接下来就是通过代理对象访问接口服务类中的具体业务方法，对应如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> categoriesCall = gankService.fetchCategories()</span><br></pre></td></tr></table></figure>

<p>下面截图是debug gankService.fetchCategories方法的标注说明：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-retrofit-gan-service-fetch-categories.jpg?raw=true" alt="source-code-analysis-retrofit-gan-service-fetch-categories"></p>
<p>通过上面截图可以看到调用gankService.fetchCategories()后，程序流程来到了InvocationHandler的invoke方法中，这里主要分析这句：<em><strong>return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);</strong></em> 。这里分三步走，第一步：loadServiceMethod(method)；第二步：invoke(args != null ? args : emptyArgs)；第三步：return。</p>
<h3 id="loadServiceMethod-method"><a href="#loadServiceMethod-method" class="headerlink" title="loadServiceMethod(method)"></a>loadServiceMethod(method)</h3><p>loadServiceMethod顾名思义就是将加载fetchCategories()这个method对象，这个方法会返回一个ServiceMethod类型的实例，实际上是返回HttpServiceMethod类型。下面是loadServiceMethod的源码，可以看到进入该方法，会先从serviceMethodCache缓存中去取（这里用到单例模式思想），没有的话就上锁然后解析method的注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  <span class="comment">//先取缓存</span></span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//上锁</span></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//解析method对象的注解</span></span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="built_in">this</span>, method);</span><br><span class="line">      <span class="comment">//存入缓存</span></span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面我们重点分析ServiceMethod是怎样解析method对象的注解的。进入到ServiceMethod.parseAnnotations，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; ServiceMethod&lt;T&gt; <span class="title function_">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> &#123;</span><br><span class="line">  <span class="comment">//RequestFactory描述了一个网络请求所需的全部属性</span></span><br><span class="line">  <span class="type">RequestFactory</span> <span class="variable">requestFactory</span> <span class="operator">=</span> RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line"></span><br><span class="line">  <span class="type">Type</span> <span class="variable">returnType</span> <span class="operator">=</span> method.getGenericReturnType();</span><br><span class="line">  <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method,</span><br><span class="line">        <span class="string">&quot;Method return type must not include a type variable or wildcard: %s&quot;</span>, returnType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Service methods cannot return void.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将retrofit实例、method实例以及requestFactory实例传到HttpServiceMethod中去解析</span></span><br><span class="line">  <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到第一行通过RequestFactory去解析注解，得到一个RequestFactory实例对象，这个对象非常重要，它包含了网络请求的所有必要数据，我们可以将其看作是一个网络请求的对象描述。RequestFactory解析源码如下，这里并不是完整源码，只截取关键部分用于说明流程，下面的代码都在必要处添加了注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RequestFactory中的所有属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line"><span class="keyword">final</span> String httpMethod;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> String relativeUrl;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Headers headers;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> MediaType contentType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> hasBody;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isFormEncoded;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isMultipart;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ParameterHandler&lt;?&gt;[] parameterHandlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> RequestFactory <span class="title function_">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> &#123;</span><br><span class="line">  <span class="comment">//用建造者模式按需拼装各个属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Builder</span>(retrofit, method).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Builder类的构造函数，保存method和methodAnnotations以及参数信息</span></span><br><span class="line">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">  <span class="built_in">this</span>.retrofit = retrofit;</span><br><span class="line">  <span class="built_in">this</span>.method = method;</span><br><span class="line">  <span class="built_in">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">  <span class="built_in">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="built_in">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//build方法关键代码</span></span><br><span class="line">RequestFactory <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//循环解析methodAnnotations</span></span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">    parseMethodAnnotation(annotation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析方法体注解的关键源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseMethodAnnotation</span><span class="params">(Annotation annotation)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;DELETE&quot;</span>, ((DELETE) annotation).value(), <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;GET&quot;</span>, ((GET) annotation).value(), <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HEAD) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;HEAD&quot;</span>, ((HEAD) annotation).value(), <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PATCH) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;PATCH&quot;</span>, ((PATCH) annotation).value(), <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;POST&quot;</span>, ((POST) annotation).value(), <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PUT) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;PUT&quot;</span>, ((PUT) annotation).value(), <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> OPTIONS) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;OPTIONS&quot;</span>, ((OPTIONS) annotation).value(), <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HTTP) &#123;</span><br><span class="line">    <span class="type">HTTP</span> <span class="variable">http</span> <span class="operator">=</span> (HTTP) annotation;</span><br><span class="line">    parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> retrofit2.http.Headers) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Multipart) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> FormUrlEncoded) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析参数的关键代码，里面再通过parseParameter解析每个注解</span></span><br><span class="line"><span class="type">int</span> <span class="variable">parameterCount</span> <span class="operator">=</span> parameterAnnotationsArray.length;</span><br><span class="line">parameterHandlers = <span class="keyword">new</span> <span class="title class_">ParameterHandler</span>&lt;?&gt;[parameterCount];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">  parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//build方法的最后一句构造了一个描述网络请求的工厂</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestFactory</span>(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>下面截图是debug RequestFactory.parseAnnotations方法的标注说明：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-retrofit-requestfactory-parseannotations.jpg?raw=true" alt="source-code-analysis-retrofit-requestfactory-parseannotations"></p>
<p>小结下这一步，RequestFactory通过其自身的静态方法parseAnnotations解析出method对象上的所有注解，最终通过 new RequestFactory(this); 构造出一个描述网络请求的工厂并将其返回。至此我们拿到了描述一个网络请求的工厂，接着ServiceMethod的parseAnnotations往下看，程序会执行 HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); 这一句，其源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title function_">parseAnnotations</span><span class="params">(</span></span><br><span class="line"><span class="params">    Retrofit retrofit, Method method, RequestFactory requestFactory)</span> &#123;</span><br><span class="line">  <span class="comment">//网络请求适配器</span></span><br><span class="line">  CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method);</span><br><span class="line">  <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span> callAdapter.responseType();</span><br><span class="line">  <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line">        + Utils.getRawType(responseType).getName()</span><br><span class="line">        + <span class="string">&quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (requestFactory.httpMethod.equals(<span class="string">&quot;HEAD&quot;</span>) &amp;&amp; !Void.class.equals(responseType)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;HEAD method must use Void as response type.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//数据转换器</span></span><br><span class="line">  Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//okhttp3.Call.Factory，这里就是OkHttpClient</span></span><br><span class="line">  okhttp3.Call.<span class="type">Factory</span> <span class="variable">callFactory</span> <span class="operator">=</span> retrofit.callFactory;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpServiceMethod</span>&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会创建网络请求适配器，接着创建数据转换器，再获取之前配好的okhttp3.Call.Factory以及上文创建的requestFactory，最后一并传入到HttpServiceMethod的构造函数中。经过这么多的步骤，我们发现到这里其实全在准备Retrofit所需的各个零部件，不过也算是全部准备就绪。此时我们会得到一个HttpServiceMethod，该对象包含了发送网络请求的所有必要零部件，下面截图是debug HttpServiceMethod.parseAnnotations方法的标注说明：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-retrofit-httpservicemethod-parseannotations.jpg?raw=true" alt="source-code-analysis-retrofit-httpservicemethod-parseannotations"></p>
<p>这里以创建网络请求适配器为例说明Retrofit中是怎样选择合适的适配器的，另外选择数据转换器的逻辑差不多，故不再细述。createCallAdapter源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt; <span class="title function_">createCallAdapter</span><span class="params">(Retrofit retrofit, Method method)</span> &#123;</span><br><span class="line">  <span class="comment">//得到返回值类型</span></span><br><span class="line">  <span class="type">Type</span> <span class="variable">returnType</span> <span class="operator">=</span> method.getGenericReturnType();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//得到所有注解</span></span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="keyword">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(method, e, <span class="string">&quot;Unable to create call adapter for %s&quot;</span>, returnType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先通过method对象拿到返回值类型和注解数组，再通过retrofit实例对象的callAdapter，传入返回值类型和注解，来寻找合适的CallAdapter，这里其实用到了策略模式，根据不同的返回值类型拿到不同的callAdapter就是一种策略选择，retrofit.callAdapter的源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">  <span class="keyword">return</span> nextCallAdapter(<span class="literal">null</span>, returnType, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(<span class="meta">@Nullable</span> CallAdapter.Factory skipPast, Type returnType,Annotation[] annotations) &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> callAdapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (adapter != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其实就是在callAdapterFactories这个集合对象中寻找一个跟返回值类型匹配的callAdapter。因为我们处于Android平台上，又是默认的callAdapter，所以callAdapterFactories.get(i)这里得到的实际就是ExecutorCallAdapterFactory，再调用里面的get方法得到一个类型匹配的CallAdapter，这个网络请求结果适配器能发起真正的网络请求。这里得到的是默认的网络请求结果适配器：ExecutorCallbackCall。源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExecutorCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title class_">CallAdapter</span>.Factory &#123;</span><br><span class="line">  <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="built_in">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span> Utils.getCallResponseType(returnType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CallAdapter</span>&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> Type <span class="title function_">responseType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> Call&lt;Object&gt; <span class="title function_">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> &#123;</span><br><span class="line">        <span class="comment">//默认的网络请求结果适配器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExecutorCallbackCall</span>&lt;&gt;(callbackExecutor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结下这里就是创建了HttpServiceMethod实例对象，这个实例对象包含了网络请求适配器，数据转换器，okhttp3.Call.Factory以及网络请求工厂requestFactory。</p>
<h3 id="invoke-args-null-args-emptyArgs"><a href="#invoke-args-null-args-emptyArgs" class="headerlink" title="invoke(args != null ? args : emptyArgs)"></a>invoke(args != null ? args : emptyArgs)</h3><p>为了更好的说明调用流程，下面截图是debug Retrofit的create方法中的invoke方法的标注说明：<br><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-retrofit-create-invoke.jpg?raw=true" alt="source-code-analysis-retrofit-create-invoke"></p>
<p>这里其实调用了上面HttpServiceMethod实例对象的invoke方法，源码如下所示，首先会创建OkHttpCall的实例对象，OkHttpCall实现了Retrofit的Call接口，Call接口描述的是发起网络请求的功能，包括同步和异步两种方式。所以这里的OkHttpCall并不是真正的okhttp3.Call，只是Retrofit对网络请求功能的一种包装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HttpServiceMethod的invoke方法</span></span><br><span class="line"><span class="meta">@Override</span> ReturnT <span class="title function_">invoke</span><span class="params">(Object[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//就是上面的ExecutorCallbackCall</span></span><br><span class="line">  <span class="keyword">return</span> callAdapter.adapt(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">OkHttpCall</span>&lt;&gt;(requestFactory, args, callFactory, responseConverter));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OkHttpCall实现了Call</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OkHttpCall</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Call</span>&lt;T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  OkHttpCall(RequestFactory requestFactory, Object[] args,</span><br><span class="line">    okhttp3.Call.Factory callFactory, Converter&lt;ResponseBody, T&gt; responseConverter) &#123;</span><br><span class="line">    <span class="built_in">this</span>.requestFactory = requestFactory;</span><br><span class="line">    <span class="built_in">this</span>.args = args;</span><br><span class="line">    <span class="built_in">this</span>.callFactory = callFactory;</span><br><span class="line">    <span class="built_in">this</span>.responseConverter = responseConverter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Retrofit中的Call接口，描述了网络请求的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Call</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//同步执行</span></span><br><span class="line">  Response&lt;T&gt; <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//异步执行</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback&lt;T&gt; callback)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//网络请求</span></span><br><span class="line">  Request <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：在这一步中，外部通过代理对象访问接口服务类中的具体业务方法，即：gankService.fetchCategories()。此时会被代理对象的InvocationHandler拦截执行它里面的invoke方法，该方法会得到一个HttpServiceMethod实例对象，并调用它自身的invoke方法；进入HttpServiceMethod中的invoke方法后，接下来的流程便会转入到callAdapter，实际会转入到ExecutorCallAdapterFactory的adapt中，最终会返回一个带有回调功能的适配器。这个跟我们在GankService中定义的业务方法fetchCategories返回值类型一致：Call<ResponseCategory>，不过Call的实际类型是ExecutorCallbackCall而已。</p>
<h2 id="step4-通过适配器发起网络请求"><a href="#step4-通过适配器发起网络请求" class="headerlink" title="step4. 通过适配器发起网络请求"></a>step4. 通过适配器发起网络请求</h2><p>终于拿到了网络请求结果适配器，此时可以发起同步或者异步的网络请求了，demo中发起了异步请求，所以这里分析异步流程，同步请求流程可自行debug调试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">categoriesCall.enqueue(object : Callback&lt;ResponseCategory&gt; &#123;</span><br><span class="line">    override fun <span class="title function_">onFailure</span><span class="params">(call: Call&lt;ResponseCategory&gt;, t: Throwable)</span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;访问失败&quot;</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onResponse</span><span class="params">(call: Call&lt;ResponseCategory&gt;, response: Response&lt;ResponseCategory&gt;)</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">body</span> <span class="operator">=</span> response.body()</span><br><span class="line">        body?.takeIf &#123; result -&gt; !result.isError &#125;?.also &#123; category -&gt;</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span><span class="meta">@MainActivity</span>, <span class="string">&quot;访问成功 -&gt; &quot;</span> + Gson().toJson(category), Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上文中提到过categoriesCall的实际类型是ExecutorCallbackCall，下面是ExecutorCallbackCall的部分源码，在enqueue()中执行delegate.enqueue，这里的delegate的实际类型是OkHttpCall，所以实际上执行了OkHttpCall里面的enqueue方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExecutorCallbackCall</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Call</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> Executor callbackExecutor;<span class="comment">//回调执行器</span></span><br><span class="line">  <span class="keyword">final</span> Call&lt;T&gt; delegate;<span class="comment">//实际类型是OkHttpCall</span></span><br><span class="line"></span><br><span class="line">  ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">    <span class="built_in">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> &#123;</span><br><span class="line">    checkNotNull(callback, <span class="string">&quot;callback == null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际执行的是OkHttpCall的enqueue()</span></span><br><span class="line">    delegate.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;T&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> &#123;</span><br><span class="line">        <span class="comment">//回调执行器将运行流程从子线程拉到主线程</span></span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">              <span class="comment">// Emulate OkHttp&#x27;s behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">              callback.onFailure(ExecutorCallbackCall.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//成功时的回调，此时response就是目标数据结构，将这份数据传回到业务调用发起的地方</span></span><br><span class="line">              callback.onResponse(ExecutorCallbackCall.<span class="built_in">this</span>, response);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> &#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//失败时回调</span></span><br><span class="line">            callback.onFailure(ExecutorCallbackCall.<span class="built_in">this</span>, t);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面debug截图也验证了delegate的类型：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-retrofit-executor-call-adapter-factory-delegate-enqueue.jpg?raw=true" alt="source-code-analysis-retrofit-executor-call-adapter-factory-delegate-enqueue"></p>
<p>下面是OkHttpCall中的enqueue方法源码，终于要发起网络请求了，在这个方法里面定义了okhttp3.Call类型的call，然后通过createRawCall方法创建了真正的网络请求执行器，后面再通过call.enqueue发起了真正的网络请求。一路分析下来，终于发起了真正的网络请求，开不开心，激不激动…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//主要类型是okhttp3.Call</span></span><br><span class="line">  okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already executed.&quot;</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    call = rawCall;</span><br><span class="line">    failure = creationFailure;</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="literal">null</span> &amp;&amp; failure == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建okhttp3.Call类型的原始Call对象，这个对象才真正具备发送网络请求的能力</span></span><br><span class="line">        call = rawCall = createRawCall();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        throwIfFatal(t);</span><br><span class="line">        failure = creationFailure = t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过call对象发起异步网络请求</span></span><br><span class="line">  call.enqueue(<span class="keyword">new</span> <span class="title class_">okhttp3</span>.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> &#123;</span><br><span class="line">      Response&lt;T&gt; response;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//解析网络请求的结果数据</span></span><br><span class="line">        response = parseResponse(rawResponse);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        throwIfFatal(e);</span><br><span class="line">        callFailure(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过callback回调到ExecutorCallbackCall中</span></span><br><span class="line">        callback.onResponse(OkHttpCall.<span class="built_in">this</span>, response);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步的流程基本分析结束，接下来分析okhttp3.Call的实例对象是如何创建的，我们看下createRawCall方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> okhttp3.Call <span class="title function_">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">//通过callFactory的newCall()，传入requestFactory所描述的一个网络请求所需的必要属性，创建了okhttp3.Call的实例对象。</span></span><br><span class="line">  <span class="comment">//这里callFactory的实际类型是OkHttpClient。</span></span><br><span class="line">  okhttp3.<span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> callFactory.newCall(requestFactory.create(args));</span><br><span class="line">  <span class="keyword">if</span> (call == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Call.Factory returned null.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>requestFactory.create(args)这里会创建一个okhttp3.Request，requestFactory描述了一个网络请求所需的完整信息。而callFactory实际上是okhttp3.Call.Factory类型，在创建Retrofit实例的时候就配置好了，实际上就是OkHttpClient的实例对象。这里通过OkHttpClient和okhttp3.Request创建了一个okhttp3.Call。下面截图展示了okhttp3.Call的组成部分：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-retrofit-create-raw-call.jpg?raw=true" alt="source-code-analysis-retrofit-create-raw-call"></p>
<p>总结：在这一步中，外部通过网络请求结果适配器发起异步的网络请求 <em>（categoriesCall.enqueue()）</em>，实际执行流程是：ExecutorCallbackCall的enqueue -&gt; OkHttpCall的enqueue -&gt; okhttp3.Call的call调用enqueue。</p>
<h2 id="step5-通过数据转换器转成目标数据结构"><a href="#step5-通过数据转换器转成目标数据结构" class="headerlink" title="step5. 通过数据转换器转成目标数据结构"></a>step5. 通过数据转换器转成目标数据结构</h2><p>在上面的代码片段中，在call.enqueue里面拿到请求结果后，会调用 parseResponse(rawResponse); 解析rawResponse为目标数据结构，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Response&lt;T&gt; <span class="title function_">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">ResponseBody</span> <span class="variable">rawBody</span> <span class="operator">=</span> rawResponse.body();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove the body&#x27;s source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">  rawResponse = rawResponse.newBuilder()</span><br><span class="line">      .body(<span class="keyword">new</span> <span class="title class_">NoContentResponseBody</span>(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> rawResponse.code();</span><br><span class="line">  <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">      <span class="type">ResponseBody</span> <span class="variable">bufferedBody</span> <span class="operator">=</span> Utils.buffer(rawBody);</span><br><span class="line">      <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">    rawBody.close();</span><br><span class="line">    <span class="keyword">return</span> Response.success(<span class="literal">null</span>, rawResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ExceptionCatchingResponseBody</span> <span class="variable">catchingBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionCatchingResponseBody</span>(rawBody);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//真正转换数据的地方</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">body</span> <span class="operator">=</span> responseConverter.convert(catchingBody);</span><br><span class="line">    <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    catchingBody.throwIfCaught();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键一句是 T body = responseConverter.convert(catchingBody); 将rawBody转成了目标T，responseConverter是创建OkHttpCall时就传入进来的。下面debug截图展示了response中存放的目标数据结构就是我定义的ResponseCategory类型。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-retrofit-okhttpcall-enqueue-parseresponse.jpg?raw=true" alt="source-code-analysis-retrofit-okhttpcall-enqueue-parseresponse"></p>
<h2 id="step6-通过回调器将代码执行从子线程拉回到主线程"><a href="#step6-通过回调器将代码执行从子线程拉回到主线程" class="headerlink" title="step6. 通过回调器将代码执行从子线程拉回到主线程"></a>step6. 通过回调器将代码执行从子线程拉回到主线程</h2><p>在得到目标数据结构之后，在OkHttpCall的enqueue中会通过如下回调函数将结果传到ExcutorCallback中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//这里的callback实例是在ExecutorCallbackCall中通过new Callback()传进去的，所以回调时回到ExcutorCallback中</span></span><br><span class="line">  callback.onResponse(OkHttpCall.<span class="built_in">this</span>, response);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">  t.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ExcutorCallback类中，会通过callbackExecutor对象将结果回调到主线程中，这里的callbackExecutor实际上就是step1中提到的MainThreadExecutor的实例对象，这样就回到了主线程中，然后再执行接下来的业务方法，demo中就是将结果展示了一下。源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实际执行的是OkHttpCall的enqueue()</span></span><br><span class="line">delegate.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;T&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> &#123;</span><br><span class="line">    <span class="comment">//回调执行器将运行流程从子线程拉到主线程</span></span><br><span class="line">    callbackExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">          <span class="comment">// Emulate OkHttp&#x27;s behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">          callback.onFailure(ExecutorCallbackCall.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//成功时的回调，此时response就是目标数据结构，将这份数据传回到业务调用发起的地方</span></span><br><span class="line">          callback.onResponse(ExecutorCallbackCall.<span class="built_in">this</span>, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> &#123;</span><br><span class="line">    callbackExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//失败时回调</span></span><br><span class="line">        callback.onFailure(ExecutorCallbackCall.<span class="built_in">this</span>, t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面debug截图是callback调用onResponse方法回到业务代码中的标示说明：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-retrofit-callack-onresponse.jpg?raw=true" alt="source-code-analysis-retrofit-callack-onresponse"></p>
<p>总结：在这一步中，主要是通过MainThreadExecutor将结果从子线程拉回到主线程，再接着执行后面的业务逻辑。</p>
<h2 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h2><p>为了便于自己有个完整的影响，画了一张Retrofit发送一个网络请求流程中所涉及的类的说明图：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-retrofit-outline.png?raw=true" alt="source-code-analysis-retrofit-outline"></p>
<p><strong>Retrofit本质上是遵循了RESTful风格、通过大量的设计模式封装OkHttp的HTTP网络请求框架，使用起来简洁而优雅。Retrofit将Http请求抽象成Java接口，在接口里用注解描述和配置网络请求参数，用动态代理的方式进行拦截，动态将网络请求接口的注解解析成HTTP请求，最后执行HTTP请求。</strong></p>
<p>Retrofit框架通过大量的设计模式使得代码高度内聚，少量耦合，灵活又轻巧，或许这是每位coder都该追求的一种境界。Retrofit中用到的设计模式有：<em>外观模式</em>、<em>代理模式</em>、<em>策略模式</em>、<em>单例模式思想</em>、<em>建造者模式</em>、<em>工厂方法模式</em>、<em>装饰模式</em>。所以想学习设计模式的你一定不能错过它。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手debug源码之RecyclerView</title>
    <url>/iBlogWebsite/2019/02/12/2019/2019-02-12-%E6%89%8B%E6%8A%8A%E6%89%8Bdebug%E6%BA%90%E7%A0%81%E4%B9%8BRecyclerView/</url>
    <content><![CDATA[<p>RecyclerView的使用场景非常丰富，而本篇的源码分析基于上下滑动一个列表的场景来观察它的复用-回收机制。本文基于27.0.0版本进行分析，如下是Demo展示：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-recyclerview-demo.gif?raw=true" alt="source-code-analysis-recyclerview-demo"></p>
<p>RecyclerView继承自ViewGroup，属于系统级别的自定义控件，而它的源码长达12000多行，还不包括抽取出去的其他辅助类、管理类等，可想而知其复杂性，本文的分析思路主要是集中在RecyclerView的缓存机制上，通过滑动事件结合源码分析它的复用-回收机制，而RecyclerView的绘制流程、ItemDecoration、LayoutManager、State、Recycler等会一笔带过。</p>
<p>自定义控件三部曲：<strong>onMeasure - onLayout - onDraw</strong>，RecyclerView也不例外。查看源码可以看到，RecyclerView测量的一部分逻辑委托给了LayoutManager，源码如下所示，进来判断是否存在LayoutManager实例，不存在则调用defaultOnMeasure进行默认测量。然后就是一个if…else…判断是否为AutoMeasure，LinearLayoutManager和GridLayoutManager使用这种模式，而StaggerLayoutManager在一定条件下会使用自定义测量这种模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthSpec, <span class="type">int</span> heightSpec)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="literal">null</span>) &#123;</span><br><span class="line">        defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LinearLayoutManager和GridLayoutManager使用这种模式</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout.mAutoMeasure) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHasFixedSize) &#123;</span><br><span class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//而StaggerLayoutManager在一定条件下会使用自定义测量这种模式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>测量之后会执行onLayout，这里我们分析采用垂直布局的LinearLayoutManager，在布局的逻辑中会经过如下三个方法：dispatchLayoutStep1 - dispatchLayoutStep2 - dispatchLayoutStep3，它们各司其职。</p>
<blockquote>
<p>dispatchLayoutStep1:处理Adapter的更新和动画相关<br>dispatchLayoutStep2:真正执行LayoutManager.onLayoutChildren，该函数的实现决定了ChildView将会怎样被布局(layout)<br>dispatchLayoutStep3:保存动画相关的信息并做必要的清理工作</p>
</blockquote>
<p>所以我们重点放到LayoutManager.onLayoutChildren上，直接进入LinearLayoutManager的onLayoutChildren，发现代码很长，里面也有注释信息，布局的逻辑如下：1 首先寻找锚点，2 从锚点开始，底部向上填充，顶部向下填充，3 如果再有剩余空间，再填充一次。下面的LinearLayoutManager配合垂直布局的onLayout代码段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ensureLayoutState();</span><br><span class="line">    mLayoutState.mRecycle = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 确定布局方向</span></span><br><span class="line">    resolveShouldLayoutReverse();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找锚点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">focused</span> <span class="operator">=</span> getFocusedChild();</span><br><span class="line">    <span class="keyword">if</span> (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION</span><br><span class="line">            || mPendingSavedState != <span class="literal">null</span>) &#123;</span><br><span class="line">        mAnchorInfo.reset();</span><br><span class="line">        mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class="line">        <span class="comment">// 计算锚点的位置和坐标</span></span><br><span class="line">        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">        mAnchorInfo.mValid = <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    detachAndScrapAttachedViews(recycler);<span class="comment">//回收view</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面是LinearLayoutManager配合垂直布局的代码</span></span><br><span class="line">    <span class="comment">// 先向下绘制</span></span><br><span class="line">    updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">    <span class="comment">// 填充view</span></span><br><span class="line">    fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再向上绘制</span></span><br><span class="line">    updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">    <span class="comment">// 填充view</span></span><br><span class="line">    fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还有可用空间</span></span><br><span class="line">    <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 再次填充view</span></span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此我们大致了解了布局的算法逻辑：先找锚点再多次不同方向上进行填充，而RecyclerView的复用流程和回收流程都在该方法里面发起，所以onLayout是我们分析缓存机制的入口。其中复用流程是fill，回收流程是detachAndScrapAttachedViews。到这里我们先总结下onMeasure和onLayout的内容：</p>
<blockquote>
<p>1.RecyclerView是将绘制流程交给LayoutManager处理，如果没有设置不会测量子View<br>2.绘制流程是区分正向和倒置的<br>3.绘制是先确定锚点，然后再多次不同方向上进行填充，fill()至少会执行两次，如果绘制完还有剩余空间，则会再执行一次fill()方法<br>4.LayoutManager获得View（也可理解为复用入口）是从RecyclerView中的onLayout开始的（fill），涉及到RecyclerView的缓存策略，如果没有拿到缓存，则走我们自己重写的onCreateView方法，再调用onBindViewHolder<br>5.LayoutManager回收View的入口也是RecyclerView中的onLayout开始的（detachAndScrapAttachedViews），涉及到RecyclerView的缓存策略</p>
</blockquote>
<p>下面就会详细分析复用流程和回收流程，这里先确定流程的入口是onLayout方法。onDraw的代码这里不再进行分析。这里根据源码的执行顺序会先进行回收再复用，所以下面先分析回收流程。</p>
<h1 id="1-回收流程"><a href="#1-回收流程" class="headerlink" title="1. 回收流程"></a>1. 回收流程</h1><p>回收流程的入口方法是 <strong>LinearLayoutManager - onLayoutChildren - detachAndScrapAttachedViews -scrapOrRecycleView</strong>，最后一个方法名翻译一下是：废弃或者回收view，在该方法中会根据一定的策略来决定是scrap还是recycle，下面是scrapOrRecycleView的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scrapOrRecycleView</span><span class="params">(Recycler recycler, <span class="type">int</span> index, View view)</span> &#123;</span><br><span class="line">    <span class="comment">//从指定的view中获取到对应的viewHolder</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> getChildViewHolderInt(view);</span><br><span class="line">    <span class="keyword">if</span> (viewHolder.shouldIgnore()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;ignoring view &quot;</span> + viewHolder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//viewHolder已经无效，并且还没有被remove，并且没有指定的stableId</span></span><br><span class="line">    <span class="keyword">if</span> (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()</span><br><span class="line">            &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) &#123;</span><br><span class="line">        <span class="comment">//remove该项</span></span><br><span class="line">        removeViewAt(index);</span><br><span class="line">        <span class="comment">//通过recycler执行内部回收流程，主要是将viewHolder放到RecycledViewPool中</span></span><br><span class="line">        recycler.recycleViewHolderInternal(viewHolder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//detach该项</span></span><br><span class="line">        detachViewAt(index);</span><br><span class="line">        <span class="comment">//通过recycler将view从scrap数组中移除</span></span><br><span class="line">        recycler.scrapView(view);</span><br><span class="line">        mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中牵出了两个比较重要的概念：remove和detach。</p>
<blockquote>
<p>detach: 在ViewGroup中的实现很简单，只是将ChildView从ParentView的ChildView数组中移除，ChildView的mParent设置为null，可以理解为轻量级的临时remove，因为View此时和View树还是藕断丝连，这个函数被经常用来改变ChildView在ChildView数组中的次序。View被detach一般是临时的，在后面会被重新attach。</p>
<p>remove: 真正的移除，不光被从ChildView数组中除名，其他和View树各项联系也会被彻底斩断(不考虑Animation/LayoutTransition这种特殊情况)，比如焦点被清除，从TouchTarget中被移除等。</p>
</blockquote>
<p>所以我们可以将scrapOrRecycleView对应起来：scrap-detach，recycler-remove。同时满足下面的3个条件会被recycler，其余情况下viewHolder都会被scrap：</p>
<p>1、viewHolder本身已经完全无效<br>2、viewHolder对应的项还没有被remove（这个判断是考虑到预加载的原因，先不具体说）<br>3、adapter没有指定stableId，因为如果指定，就不存在View绑定内容无效的可能了</p>
<p>Demo案例实操过程中，上下滑动时基本上都是触发recycler；当插入一个元素或者删除一个元素，或者本质上说调用notifyDataSetChanged后，就会触发scrap。</p>
<p>下面再看看recycler执行内部回收流程，大致逻辑是先判断viewHolder的一些标志位，达到回收条件后，<strong>先将viewHolder缓存到mCachedViews中，如果mCachedViews已满，则删除mCachedViews中最老的一个元素，并将该元素放到RecycledViewPool中；再接着将本次要回收的元素放到mCachedViews中。</strong> 如果未达到条件，则直接将viewHolder放到RecycledViewPool中。下面这段代码是整理之后的源码，描述了上述逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">recycleViewHolderInternal</span><span class="params">(ViewHolder holder)</span> &#123;</span><br><span class="line">    <span class="comment">//进行必要的校验，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (holder.isScrap() || holder.itemView.getParent() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;Scrapped or attached views may not be recycled. isScrap:&quot;</span></span><br><span class="line">                        + holder.isScrap() + <span class="string">&quot; isAttached:&quot;</span></span><br><span class="line">                        + (holder.itemView.getParent() != <span class="literal">null</span>) + exceptionLabel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行必要的校验，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (holder.isTmpDetached()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Tmp detached view should be removed &quot;</span></span><br><span class="line">                + <span class="string">&quot;from RecyclerView before it can be recycled: &quot;</span> + holder</span><br><span class="line">                + exceptionLabel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行必要的校验，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (holder.shouldIgnore()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Trying to recycle an ignored view holder. You&quot;</span></span><br><span class="line">                + <span class="string">&quot; should first call stopIgnoringView(view) before calling recycle.&quot;</span></span><br><span class="line">                + exceptionLabel());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forceRecycle || holder.isRecyclable()) &#123;</span><br><span class="line">        <span class="comment">//有效条件检查</span></span><br><span class="line">        <span class="keyword">if</span> (mViewCacheMax &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID</span><br><span class="line">                | ViewHolder.FLAG_REMOVED</span><br><span class="line">                | ViewHolder.FLAG_UPDATE</span><br><span class="line">                | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cachedViewSize</span> <span class="operator">=</span> mCachedViews.size();</span><br><span class="line">            <span class="comment">//判断cachedViewSize是否大于最大缓存数量</span></span><br><span class="line">            <span class="keyword">if</span> (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//回收最老的元素，即第0号元素</span></span><br><span class="line">                recycleCachedViewAt(<span class="number">0</span>);</span><br><span class="line">                cachedViewSize--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">targetCacheIndex</span> <span class="operator">=</span> cachedViewSize;</span><br><span class="line">            <span class="keyword">if</span> (ALLOW_THREAD_GAP_WORK</span><br><span class="line">                    &amp;&amp; cachedViewSize &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cacheIndex</span> <span class="operator">=</span> cachedViewSize - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (cacheIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">cachedPos</span> <span class="operator">=</span> mCachedViews.get(cacheIndex).mPosition;</span><br><span class="line">                    <span class="keyword">if</span> (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cacheIndex--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//计算出缓存元素的index值</span></span><br><span class="line">                targetCacheIndex = cacheIndex + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mCachedViews.add(targetCacheIndex, holder);</span><br><span class="line">            cached = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未到达条件，又没被缓存，则直接放到RecycledViewPool</span></span><br><span class="line">        <span class="keyword">if</span> (!cached) &#123;</span><br><span class="line">            addViewHolderToRecycledViewPool(holder, <span class="literal">true</span>);</span><br><span class="line">            recycled = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的源码，我们debug的方法调用路径是：recycleViewHolderInternal  - recycleCachedViewAt - addViewHolderToRecycledViewPool。下面就是addViewHolderToRecycledViewPool中最关键的源码，将元素放到RecycledViewPool中，可以看到这里区分了type，每个type对应一个ArrayList，同时进入到这里的viewHolder会被重置，主要是重置position以及flags。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putRecycledView</span><span class="params">(ViewHolder scrap)</span> &#123;</span><br><span class="line">    <span class="comment">//拿到type</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewType</span> <span class="operator">=</span> scrap.getItemViewType();</span><br><span class="line">    <span class="comment">//拿到type对应的ViewHolder集合</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = getScrapDataForType(viewType).mScrapHeap;</span><br><span class="line">    <span class="keyword">if</span> (mScrap.get(viewType).mMaxScrap &lt;= scrapHeap.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; scrapHeap.contains(scrap)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;this scrap item already exists&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重置viewHolder</span></span><br><span class="line">    scrap.resetInternal();</span><br><span class="line">    <span class="comment">//将viewHolder添加到集合中</span></span><br><span class="line">    scrapHeap.add(scrap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完recycler的流程之后，还有一种回收场景scrap，scrap的场景中会涉及到比较多的全局变量，如mChildHelper，mAttachedScrap，mChangedScrap。首先mAttachedScrap和mChangedScrap都是ArrayList类型的缓存viewHolder变量的。mChildHelper是ChildHelper的实例对象，RecyclerView尽管本身是一个ViewGroup，但是将ChildView管理职责全权委托给了ChildHelper，所有关于ChildView的操作都要通过ChildHelper来间接进行，ChildHelper成为了一个ChildView操作的中间层，getChildCount/getChildAt等函数经由ChildHelper的拦截处理再下发给RecyclerView的对应函数，其参数或者返回结果会根据实际的ChildView信息进行改写。了解了基本的概念之后，看看scrapOrRecycleView中的detach分支，下面是detach分支的关键源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//detach下标为index的view</span></span><br><span class="line">detachViewAt(index);</span><br><span class="line"><span class="comment">//在recycler中维护下这个scrapView</span></span><br><span class="line">recycler.scrapView(view);</span><br></pre></td></tr></table></figure>

<p>detachViewAt中是通过mChildHelper处理view和parentView的关系；而在scrapView中，则通过判断viewHolder是否被removed，是否invalid，是否canReuseUpdatedViewHolder条件来决定是放到mAttachedScrap中还是mChangedScrap中。源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scrapView</span><span class="params">(View view)</span> &#123;</span><br><span class="line">    <span class="comment">//拿到viewHolder</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> getChildViewHolderInt(view);</span><br><span class="line">    <span class="comment">//是否被removed，或者invalid，或者canReuseUpdatedViewHolder</span></span><br><span class="line">    <span class="keyword">if</span> (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)</span><br><span class="line">            || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        holder.setScrapContainer(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//放到mAttachedScrap中</span></span><br><span class="line">        mAttachedScrap.add(holder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mChangedScrap == <span class="literal">null</span>) &#123;</span><br><span class="line">            mChangedScrap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewHolder&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        holder.setScrapContainer(<span class="built_in">this</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//否则放到mChangedScrap中</span></span><br><span class="line">        mChangedScrap.add(holder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还需要<strong>对比下remove和scrap在复用性上的不同</strong>，只被detach的View要比被remove的View高，detach的View一般来说代表可以直接复用（其ViewHolder对应于Data的Position还是有效的，只需要重新绑定数据，如果数据也没变化的话，甚至都不用重新绑定数据；View还是有效的，View绑定的数据可能有效的, 比如一个列表有N项，现在删除了其中一项，那么在没有其他变化的前提下，剩余的N-1个项对应的ViewHolder是可以直接复用的），这一点非常关键，避免了不必要的绑定（和ListView等相比），项处理的粒度从整体细化到了单个项，即包含了对View的复用，也包含了对View当前绑定内容的复用。被remove的View复用性上则要差一些，其对应的Position已经无效，这种复用层级和Scrap相比只有View层级的复用（稍带可以复用ViewHolder,只不过里面的信息要重新设置，但起码不用new一个）。</p>
<p>至此回收机制的流程基本完成，回顾一下，首先在RecyclerView的onLayout方法中会在dispatchLayoutStep2中将布局的权利移交给LayoutManger，Demo中对应就是LinearLayoutManager。LinearLayoutManager接管之后，调用自身的onLayoutChildren，然后就会对view进行回收（detachAndScrapAttachedViews）和填充（fill）。detachAndScrapAttachedViews中会根据一定的条件决定该view是被scrap（对应detach）还是被recycler（对应remove）。被recycler的view会先经过mCachedViews再根据条件进入到RecyclerViewPool中，而被scrap的元素会根据具体条件看是放到mAttachedScrap还是mChangedScrap中缓存起来。</p>
<h1 id="2-复用流程"><a href="#2-复用流程" class="headerlink" title="2. 复用流程"></a>2. 复用流程</h1><p>上面根据LinearLayoutManager的onLayoutChildren中代码的执行顺序，先分析了回收机制的流程，接下来继续分析复用机制的流程，还是遵循上文的思路，先确定入口方法，再确定一条方法调用流程，然后再细细分析。上文提到过LinearLayoutManager配合垂直布局的onLayout代码段，找到锚点，先向下绘制-再填充-再向上绘制-再填充的流程，这里的fill方法便是我们分析复用机制的入口方法了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面是LinearLayoutManager配合垂直布局的代码</span></span><br><span class="line"><span class="comment">// 先向下绘制</span></span><br><span class="line">updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line"><span class="comment">// 填充view</span></span><br><span class="line">fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再向上绘制</span></span><br><span class="line">updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line"><span class="comment">// 填充view</span></span><br><span class="line">fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//还有可用空间</span></span><br><span class="line"><span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 再次填充view</span></span><br><span class="line">    fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入fill后，会根据layoutState是否还有更多项要填充，来循环调用layoutChunk方法，根据layoutChunk这个方法名猜测其作用就是布局块用的，一块一块对应就是一项一项的item。在layoutChunk中，先通过next方法找到view，然后对该view进行再测量和布局，以及边框的确定。这篇文章的重点是关注缓存机制，所以绘制布局这块一笔带过，我们将重点放到next方法上。下面是next方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View <span class="title function_">next</span><span class="params">(RecyclerView.Recycler recycler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrapList != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextViewFromScrapList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过recycler对象找到一个合适的view</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">    mCurrentPosition += mItemDirection;</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码最关键的一句是recycler.getViewForPosition(mCurrentPosition)，通过给定的position获取一个view的实例对象，最终会通过tryGetViewHolderForPositionByDeadline方法得到一个viewHolder，再通过viewHolder里面的itemView属性将view实例对象返回。如下源码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">getViewForPosition</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getViewForPosition(position, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">View <span class="title function_">getViewForPosition</span><span class="params">(<span class="type">int</span> position, <span class="type">boolean</span> dryRun)</span> &#123;</span><br><span class="line">    <span class="comment">//先获取viewHolder，再通过itemView属性得到view的实例</span></span><br><span class="line">    <span class="keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Recycler一般不会直接作用于View，其操作的对象一般是ViewHolder。如果你有自己debug代码，留意了view和viewHolder之间的关系，你会发现它们之间是双向绑定的，view中持有viewHolder是通过LayoutParams的mViewHolder属性；而viewHolder中持有view是通过itemView属性。在tryGetViewHolderForPositionByDeadline中总的思路是，依次经过RecyclerView中的四级缓存，一级一级找，找到了就返回viewHolder，没有的话，就回调用户的onCreateViewHolder和onBindViewHolder。RecyclerView中的四级缓存更细致的说应该是Recycler中的四级缓存，分别是：<strong>mAttachedScrap - mCachedViews - mViewCacheExtension - mRecyclerPool。</strong></p>
<blockquote>
<p>mAttachedScrap：对应上述回收机制中的Scrap View，保存在mAttachedScrap或者mChangedScrap中，用于屏幕内的itemView快速复用。</p>
<p>mCachedViews：对应上述回收机制中的remove view，默认上线为2个。</p>
<p>mViewCacheExtension：供使用者自行扩展，让使用者可以控制缓存。</p>
<p>mRecyclerPool：对应于上述回收机制中remove view放到mCachedViews后溢出的view，同时可以用与RecyclerView之间共享ViewHolder的缓存池。</p>
</blockquote>
<p>了解了上面四级缓存后，接着看tryGetViewHolderForPositionByDeadline的代码会轻松很多，如下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">ViewHolder <span class="title function_">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="type">int</span> position,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> dryRun, <span class="type">long</span> deadlineNs)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1) Find by position from scrap/hidden list/cache</span></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从scrap或hidden或cache中找viewHolder</span></span><br><span class="line">        holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">        <span class="keyword">if</span> (holder != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//检查找到的holder是不是能够被当前的位置使用，不行的话就要对该viewHolder进行回收</span></span><br><span class="line">            <span class="keyword">if</span> (!validateViewHolderForOffsetPosition(holder)) &#123;</span><br><span class="line">                <span class="comment">// dryRun一般为false，表示可以从scrap或者cache中移除</span></span><br><span class="line">                <span class="keyword">if</span> (!dryRun) &#123;</span><br><span class="line">                    holder.addFlags(ViewHolder.FLAG_INVALID);</span><br><span class="line">                    <span class="keyword">if</span> (holder.isScrap()) &#123;</span><br><span class="line">                        removeDetachedView(holder.itemView, <span class="literal">false</span>);</span><br><span class="line">                        holder.unScrap();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">                        holder.clearReturnedFromScrapFlag();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//执行内部回收逻辑</span></span><br><span class="line">                    recycleViewHolderInternal(holder);</span><br><span class="line">                &#125;</span><br><span class="line">                holder = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fromScrapOrHiddenOrCache = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//获取type</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">        <span class="comment">// 2) Find from scrap/cache via stable ids, if exists</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapter.hasStableIds()) &#123;</span><br><span class="line">            <span class="comment">//有设置stableId，则尝试从scrap或者cache中获取</span></span><br><span class="line">            holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                    type, dryRun);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// update position</span></span><br><span class="line">                holder.mPosition = offsetPosition;</span><br><span class="line">                fromScrapOrHiddenOrCache = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否设置了外部扩展</span></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="literal">null</span> &amp;&amp; mViewCacheExtension != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 从外部扩展中找</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mViewCacheExtension</span><br><span class="line">                    .getViewForPositionAndType(<span class="built_in">this</span>, position, type);</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">                holder = getChildViewHolder(view);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123; <span class="comment">// fallback to pool</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//根据tyep从RecycledViewPool中找</span></span><br><span class="line">            holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//回调用户的onCreateViewHolder方法</span></span><br><span class="line">            holder = mAdapter.createViewHolder(RecyclerView.<span class="built_in">this</span>, type);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">bound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">        <span class="comment">// do not update unless we absolutely have to.</span></span><br><span class="line">        holder.mPreLayoutPosition = position;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offsetPosition</span> <span class="operator">=</span> mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        <span class="comment">//回调用户的onBindViewHolder方法</span></span><br><span class="line">        bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取LayoutParams</span></span><br><span class="line">    <span class="keyword">final</span> ViewGroup.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> holder.itemView.getLayoutParams();</span><br><span class="line">    <span class="keyword">final</span> LayoutParams rvLayoutParams;</span><br><span class="line">    <span class="keyword">if</span> (lp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//转成RecyclerView所需类型的LayoutParams</span></span><br><span class="line">        rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();</span><br><span class="line">        holder.itemView.setLayoutParams(rvLayoutParams);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!checkLayoutParams(lp)) &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) generateLayoutParams(lp);</span><br><span class="line">        holder.itemView.setLayoutParams(rvLayoutParams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) lp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将viewHolder保存到mViewHolder属性中</span></span><br><span class="line">    rvLayoutParams.mViewHolder = holder;</span><br><span class="line">    rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound;</span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述源码我对其进行了删减，保留了核心流程代码，从上倒下就是从四级缓存中逐个查找，实在没有则创建一个，最后将viewHolder绑定到view上，完成最后的双向绑定。</p>
<p>至此复用机制的流程基本完成，总结一下，方法的调用流程是：LinearLayoutManager - onLayoutChildren - fill() - layoutChunk() - layoutState.next() - getViewForPosition() - tryGetViewHolderForPositionByDeadline() - 四级缓存 or onCreateViewHolder - onBindViewHolder（未绑定的情况下会触发绑定回调）。这套流程下来要关注两个地方，一个是fill方法，它会被调用多次；一个是tryGetViewHolderForPositionByDeadline方面，里面涉及到RecyclerView复用机制的核心逻辑：四级缓存。</p>
<h1 id="3-RecyclerView的优势"><a href="#3-RecyclerView的优势" class="headerlink" title="3. RecyclerView的优势"></a>3. RecyclerView的优势</h1><h2 id="3-1-RecyclerView与ListView对比"><a href="#3-1-RecyclerView与ListView对比" class="headerlink" title="3.1. RecyclerView与ListView对比"></a>3.1. RecyclerView与ListView对比</h2><p>RecyclerView强制使用ViewHolder，当然在使用ListView的时候都是自定义ViewHolder配合使用，避免每次createView时调用findViewById。但是RecyclerView在ViewHolder基础上定义了很多flag标识表明当前ViewHolder的可用性状态，这点比ListView中自定义ViewHolder要更加丰富。</p>
<p>在处理离屏缓存这一场景时，RecyclerView与ListView的处理也有很大的不同。RecyclerView会从mCachedViews中获取到一个viewHolder，然后会判断这个viewHolder是否已被绑定，是否不需要更新，是否有效，如果满足其中任何一个条件就不会触发onBindViewHolder。源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理预加载的情况</span></span><br><span class="line"><span class="keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">    <span class="comment">// do not update unless we absolutely have to.</span></span><br><span class="line">    holder.mPreLayoutPosition = position;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;<span class="comment">//如果已被绑定，或者不需要更新或者是有效的，就不会触发tryBindViewHolderByDeadline方法了</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offsetPosition</span> <span class="operator">=</span> mAdapterHelper.findPositionOffset(position);</span><br><span class="line">    bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而ListView的处理则是mRecycler得到一个缓存的view，然后重新getView，此处势必会调用onBind触发重新绑定的逻辑。AbsListView源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View <span class="title function_">obtainView</span><span class="params">(<span class="type">int</span> position, <span class="type">boolean</span>[] outMetadata)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到缓存的view</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">scrapView</span> <span class="operator">=</span> mRecycler.getScrapView(position);</span><br><span class="line">    <span class="comment">//每次都调用getView，也就意味着每次都调用onBind</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> mAdapter.getView(position, scrapView, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (scrapView != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child != scrapView) &#123;</span><br><span class="line">            <span class="comment">// Failed to re-bind the data, return scrap to the heap.</span></span><br><span class="line">            mRecycler.addScrapView(scrapView, position);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.isTemporarilyDetached()) &#123;</span><br><span class="line">            outMetadata[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Finish the temporary detach started in addScrapView().</span></span><br><span class="line">            child.dispatchFinishTemporaryDetach();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的gif动图展示了RecyclerView中处理离屏缓存时，onBind方法的执行情况，当用户轻微的来回滑入滑出item时，此时是从mCachedViews中拿到缓存的viewHolder直接复用，不会触发onBind操作。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-recyclerview-off-screen-cache-example.gif?raw=true" alt="source-code-analysis-recyclerview-off-screen-cache-example"></p>
<h2 id="3-2-局部刷新功能"><a href="#3-2-局部刷新功能" class="headerlink" title="3.2. 局部刷新功能"></a>3.2. 局部刷新功能</h2><p>处理局部刷新时，ListView是一锅端，将所有的mActiveViews都移入了二级缓存mScrapViews，而RecyclerView则是更加灵活地对每个View修改标志位，区分是否重新bindView。通过局部刷新能避免调用许多无用的bindView，下面的gif动图展示了局部刷新position位置为4的场景，我们可以观察第二个透明框中的onBind的情况。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-recyclerview-partial-refresh-example.gif?raw=true" alt="source-code-analysis-recyclerview-partial-refresh-example"></p>
<hr>
<p>参考：<br><a href="https://blog.csdn.net/fyfcauc/article/details/54342303">RecyclerView机制分析: Recycler</a><br><a href="https://www.jianshu.com/p/193fb966e954">Android ListView与RecyclerView对比浅析–缓存机制</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手debug源码之EventBus</title>
    <url>/iBlogWebsite/2019/01/30/2019/2019-01-30-%E6%89%8B%E6%8A%8A%E6%89%8Bdebug%E6%BA%90%E7%A0%81%E4%B9%8BEventBus/</url>
    <content><![CDATA[<p>本文基于EventBus3.1.1进行源码分析，以发送一个正常事件和粘性事件为例，探索EventBus工作的整个过程。你也可以直接下载<a href="https://github.com/Leeeyou/SourceCodeAnalysisEventbus">demo</a>同步运行调试，Gif示例如下：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-eventbus-demo.gif?raw=true" alt="source-code-analysis-eventbus-demo"></p>
<p>gif中首先展示了发送一个LoginSuccessEvent的正常事件，在MainActivity和SecondActivity中都有订阅，这里主要展示一对多的场景；接着分别以正常方式和粘性方式发送了一个RegisterSuccessEvent事件，看看在GoToLoginActivity中有怎样不同的表现。</p>
<p>本文的思路是先分析注册和注销的流程，也就是订阅和解订阅；再分析发布正常事件和发布粘性事件的流程。</p>
<h1 id="1-注册和注销的流程分析"><a href="#1-注册和注销的流程分析" class="headerlink" title="1. 注册和注销的流程分析"></a>1. 注册和注销的流程分析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="built_in">this</span>)</span><br><span class="line">EventBus.getDefault().unregister(<span class="built_in">this</span>)</span><br></pre></td></tr></table></figure>

<h2 id="1-1-register"><a href="#1-1-register" class="headerlink" title="1.1. register"></a>1.1. register</h2><p>首先通过EventBus.getDefault()拿到实例对象，源码如下所示，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title function_">getDefault</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (defaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (defaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                defaultInstance = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种双重校验的懒汉式单例，双重校验机制只会在第一次创建实例时有锁的介入，一旦实例创建成功，下次再获取实例就不会进入锁块了。还有一点需要注意务必要用volatile关键字修饰defaultInstance变量，保证在操作defaultInstance对象时，都是从内存中加载最新的状态。后续通过getDefault()拿到的都是defaultInstance这个实例对象了。接着看看regitster()干了什么，源码如下所示：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object subscriber)</span> &#123;</span><br><span class="line">    <span class="comment">//拿到订阅者的Class实例对象</span></span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    <span class="comment">//找到该订阅者的所有订阅方法</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            <span class="comment">//发起订阅，保存订阅者与订阅方法的关系</span></span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会拿到订阅者的Class实例对象，然后通过subscriberMethodFinder去查找该类所有的订阅方法，subscriberMethodFinder这个实例对象从命名就能看出是订阅方法查找器；最后利用synchronized保证线程安全，随即发起订阅，保存订阅者与订阅方法的之间的关系。下图是debug register()的截图标注说明：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-eventbus-register.jpg?raw=true" alt="source-code-analysis-eventbus-register"></p>
<p>接下来我们详细分析findSubscriberMethods(subscriberClass)和subscribe(subscriber, subscriberMethod)这两个方法。</p>
<h3 id="1-1-1-findSubscriberMethods-subscriberClass"><a href="#1-1-1-findSubscriberMethods-subscriberClass" class="headerlink" title="1.1.1. findSubscriberMethods(subscriberClass)"></a>1.1.1. findSubscriberMethods(subscriberClass)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; <span class="title function_">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line">    <span class="comment">//从缓存中拿取订阅者的所有订阅方法</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否忽略设置的索引，索引目的是把在注册时需要遍历订阅者所有方法的行为，提前到在编译时完成，</span></span><br><span class="line">    <span class="comment">//在编译时apt插件通过EventBusAnnotationProcessor分析注解，并利用注解标识的相关类的信息去生成相关的类</span></span><br><span class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">        <span class="comment">//通过反射查找</span></span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//通过索引查找</span></span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Subscriber &quot;</span> + subscriberClass</span><br><span class="line">                + <span class="string">&quot; and its super classes have no public methods with the @Subscribe annotation&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将订阅者和订阅方法放入缓存</span></span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入findSubscriberMethods方法，首先会去缓存中找，如找到则直接return subscriberMethods，否则接着往下看看是否忽略设置的索引，默认false，此时会进入到findUsingInfo通过索引查找，最后判断subscriberMethods是不是空，不空的话则将订阅者和订阅方法放入缓存中。整个逻辑非常简单：先在缓存中找订阅方法集合列表，找不到再通过反射或者索引找，最后还是没找到，则抛出EventBusException，否则将订阅者和订阅方法放入缓存供下次使用。接下来我们看下findUsingInfo的源码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title function_">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line">    <span class="comment">//FindState这个静态内部类中存放寻找方法时所需的临时变量</span></span><br><span class="line">    <span class="type">FindState</span> <span class="variable">findState</span> <span class="operator">=</span> prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="comment">//开启遍历</span></span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取订阅者信息，里面会通过索引方式去拿</span></span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        <span class="comment">//没有没有找到订阅者信息</span></span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                <span class="comment">//checkAdd是为了避免在父类中找到的方法是被子类重写的，此时应该保证回调时执行子类的方法</span></span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//则通过反射的方式查找订阅方法信息</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//findState移动到该类的父类中，准备下次便利父类的订阅方法信息</span></span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放findState并返回订阅者方法</span></span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入findUsingInfo方法，通过FindState存放临时变量，然后遍历子类及其父类的订阅方法集合列表，最后返回该集合列表。由于demo中没有采用索引预生成订阅方法信息，虽然上面的ignoreGeneratedIndex进入了索引查找分支，但最终还是会通过findUsingReflectionInSingleClass方法反射查找该类的所有订阅方法。下面是findUsingReflectionInSingleClass的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> &#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">        <span class="comment">//拿到所有声明的方法</span></span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">        methods = findState.clazz.getMethods();</span><br><span class="line">        findState.skipSuperClasses = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">//拿到方法修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> method.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//拿到方法参数类型数组</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//拿到方法的Subscribe注解</span></span><br><span class="line">                <span class="type">Subscribe</span> <span class="variable">subscribeAnnotation</span> <span class="operator">=</span> method.getAnnotation(Subscribe.class);</span><br><span class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//两层检查：1检查事件类型 2检查方法的完整签名</span></span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        <span class="comment">//拿到线程模型</span></span><br><span class="line">                        <span class="type">ThreadMode</span> <span class="variable">threadMode</span> <span class="operator">=</span> subscribeAnnotation.threadMode();</span><br><span class="line">                        <span class="comment">//创建SubscriberMethod，并放到findState.subscriberMethods中</span></span><br><span class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> <span class="title class_">SubscriberMethod</span>(method, eventType, threadMode,</span><br><span class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;@Subscribe method &quot;</span> + methodName +</span><br><span class="line">                        <span class="string">&quot;must have exactly 1 parameter but has &quot;</span> + parameterTypes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(methodName +</span><br><span class="line">                    <span class="string">&quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入findUsingReflectionInSingleClass方法，主要逻辑是通过反射拿到findState.clazz的所有声明方法methods，然后遍历methods，判断method的入参长度是否为1，判断method的注解是否为Subscribe，判断method的事件类型以及完整签名，最后创建SubscriberMethod放到findState中。</p>
<p><strong>至此查找订阅方法的流程完毕，不关注过多细节的话，流程就是：findSubscriberMethods方法代码段中的注释信息，即先从缓存中取订阅者的所有订阅方法，如没找到则通过反射或者索引方式继续找，找到了则更新缓存并返回，否则抛出异常。</strong></p>
<h3 id="1-1-2-subscribe-subscriber-subscriberMethod"><a href="#1-1-2-subscribe-subscriber-subscriberMethod" class="headerlink" title="1.1.2. subscribe(subscriber, subscriberMethod)"></a>1.1.2. subscribe(subscriber, subscriberMethod)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> &#123;</span><br><span class="line">    <span class="comment">//拿到事件类型，就是你自己定义的Event，比如LoginSuccessEvent</span></span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    <span class="comment">//用订阅者和订阅方法构造Subscription，即Subscription描述了订阅者和订阅方法之间的关系</span></span><br><span class="line">    <span class="type">Subscription</span> <span class="variable">newSubscription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subscription</span>(subscriber, subscriberMethod);</span><br><span class="line">    <span class="comment">//从subscriptionsByEventType这个Map中获取对应事件类型的subscriptions集合</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如未获取到，则创建一个新的</span></span><br><span class="line">        subscriptions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//用eventType为key，subscriptions为value存放到Map集合subscriptionsByEventType中</span></span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Subscriber &quot;</span> + subscriber.getClass() + <span class="string">&quot; already registered to event &quot;</span></span><br><span class="line">                    + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            <span class="comment">//按优先级排序</span></span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到订阅者订阅的所有事件</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="literal">null</span>) &#123;</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//用subscriber为key，subscribedEvents为value存放到Map集合typesBySubscriber中</span></span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为粘性事件</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">        <span class="comment">//事件是否继承标识</span></span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//有两个Class类型的类象，一个是调用isAssignableFrom方法的类对象（后称对象a），以及方法中作为参数的这个类对象（称之为对象b），这两个对象如果满足以下条件则返回true，否则返回false：</span></span><br><span class="line">                <span class="comment">//a对象所对应类信息是b对象所对应的类信息的父类或者是父接口，简单理解即a是b的父类或接口</span></span><br><span class="line">                <span class="comment">//a对象所对应类信息与b对象所对应的类信息相同，简单理解即a和b为同一个类或同一个接口</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断eventType是否与candidateEventType拥有一致的类型信息或者为继承关系</span></span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">stickyEvent</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//拿到粘性事件</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">stickyEvent</span> <span class="operator">=</span> stickyEvents.get(eventType);</span><br><span class="line">            <span class="comment">//执行粘性事件</span></span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到订阅方法后，用Subscription描述订阅者和订阅方法之间的关系，并构造出一个实例对象newSubscription，然后在subscriptionsByEventType这个Map集合中查找eventType对应的subscriptions集合。subscriptionsByEventType这个Map以eventType为key，subscriptions为value，它保存了事件类型与subscriptions集合之间的关系，通过查找这个集合，可以知道某个事件对应的所有订阅者以及订阅方法。然后对比newSubscription的优先级，再插入到subscriptions，这里可以保证优先级高的订阅方法先被执行。接着维护一个typesBySubscriber的Map集合，这个集合主要是用于判断某个订阅者是否已被注册，避免重复注册。最后判断该订阅方法是否为粘性方法，如果是的话，则直接发送粘性事件给到订阅者，而不必再等待外部调用post。</p>
<p>下面是debug跳到SecondActivity时，发起注册的图示，可以看到SecondActivity中订阅了LoginSuccessEvent事件，订阅方法是processLoginSuccessForNotify；而在MainActivity中也订阅了LoginSuccessEvent事件，订阅方法是processLoginSuccess，所以它们一同被维护到了subscriptionsByEventType集合中。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-eventbus-second-activity-register.png?raw=true" alt="source-code-analysis-eventbus-second-activity-register"></p>
<p>总结：注册事件时，先获取到EventBus的实例对象，然后调用register方法，先找到该订阅者里面的所有订阅方法（findSubscriberMethods），然后绑定事件类型、订阅者与订阅方法之间的关系，即维护好Map集合subscriptionsByEventType。</p>
<h2 id="1-2-unregister"><a href="#1-2-unregister" class="headerlink" title="1.2. unregister"></a>1.2. unregister</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(Object subscriber)</span> &#123;</span><br><span class="line">    <span class="comment">//根据订阅者拿到所有的事件</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//解绑订阅者的所有订阅事件</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移走该订阅者</span></span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.log(Level.WARNING, <span class="string">&quot;Subscriber to unregister was not registered before: &quot;</span> + subscriber.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注销的流程相对简单，通过unsubscribeByEventType方法维护下Map集合subscriptionsByEventType，遍历移除该订阅者下的订阅事件。下面是unsubscribeByEventType的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> &#123;</span><br><span class="line">    <span class="comment">//拿到该事件的subscriptions集合</span></span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">Subscription</span> <span class="variable">subscription</span> <span class="operator">=</span> subscriptions.get(i);</span><br><span class="line">            <span class="comment">//判断该subscription对应的订阅者是不是跟要注销的订阅者一致</span></span><br><span class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                subscription.active = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//移除该subscription</span></span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-发布事件"><a href="#2-发布事件" class="headerlink" title="2. 发布事件"></a>2. 发布事件</h1><p>发布事件时，并不需要你先去调用register方法注册，这点在新手中很容易出错。发布事件时，也需要先拿到EventBus实例，然后再调用post或者postSticky方法。</p>
<h2 id="2-1-post"><a href="#2-1-post" class="headerlink" title="2.1. post"></a>2.1. post</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//post方法源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    <span class="comment">//拿到PostingThreadState实例对象，用于存放发布时的一些变量</span></span><br><span class="line">    <span class="type">PostingThreadState</span> <span class="variable">postingState</span> <span class="operator">=</span> currentPostingThreadState.get();</span><br><span class="line">    <span class="comment">//拿到事件队列</span></span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    <span class="comment">//将事件加入到事件队列中</span></span><br><span class="line">    eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        postingState.isMainThread = isMainThread();</span><br><span class="line">        postingState.isPosting = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Internal error. Abort state was not reset&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//一个一个发布事件</span></span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="literal">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//postSingleEvent源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error &#123;</span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">subscriptionFound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//事件是否有继承关系，Java中都是继承自Object，所以这里通常是true</span></span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        <span class="comment">//找到eventClass所有的事件，包括其所有父类</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        <span class="type">int</span> <span class="variable">countTypes</span> <span class="operator">=</span> eventTypes.size();</span><br><span class="line">        <span class="comment">//遍历所有事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            <span class="comment">//发送事件</span></span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入post方法，主要就是将事件类型加入到事件队列中，然后遍历队列，调用postSingleEvent逐个发布事件。而在postSingleEvent中，会拿到事件的所有父类存放到eventTypes中，再遍历eventTypes逐个调用postSingleEventForEventType。这里的流程都非常简单，接着看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//postSingleEventForEventType源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> &#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//从Map集合subscriptionsByEventType中查找事件对应的subscriptions</span></span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="literal">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//遍历subscriptions</span></span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">aborted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//逐个发送事件</span></span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="literal">null</span>;</span><br><span class="line">                postingState.subscription = <span class="literal">null</span>;</span><br><span class="line">                postingState.canceled = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//postToSubscription源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="type">boolean</span> isMainThread)</span> &#123;</span><br><span class="line">    <span class="comment">//根据线程模型进入不同的分支</span></span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                <span class="comment">//反射调用订阅者中的方法</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postSingleEventForEventType中最主要的事情就是从subscriptionsByEventType这个Map集合中取出对应事件的subscriptions集合，然后遍历它再逐个发送事件。进入到postToSubscription后，根据subscriberMethod中的threadMode进入不同的分支，再反射调用订阅者中对应事件的对应订阅方法。invokeSubscriber中的关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//反射调用订阅者中对应事件的对应订阅方法</span></span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="comment">//反射失败，则在内部就处理掉这个异常</span></span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="comment">//否则抛出非法访问异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进入到SecondActivity页面，点击按钮时，会依次反射MainActivity中的processLoginSuccess，再反射SecondActivity中的processLoginSuccessForNotify，下面是debug按钮点击时invokeSubscriber的图示说明：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-eventbus-invoke-subscriber-1.jpg?raw=true" alt="source-code-analysis-eventbus-invoke-subscriber-1"></p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-eventbus-invoke-subscriber-2.jpg?raw=true" alt="source-code-analysis-eventbus-invoke-subscriber-2"></p>
<p>总结：post这一过程相比register的过程还要简单，主要就是从subscriptionsByEventType这个Map集合中查找事件的subscriptions集合，然后再反射执行订阅方法。是的，整个过程就是如此简单。</p>
<h2 id="2-2-postSticky"><a href="#2-2-postSticky" class="headerlink" title="2.2. postSticky"></a>2.2. postSticky</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postSticky</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    <span class="comment">//保存event到Map集合stickyEvents中</span></span><br><span class="line">    <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">        stickyEvents.put(event.getClass(), event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发布事件</span></span><br><span class="line">    post(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postSticky与post的区别在于postSticky中将事件保存到了Map集合stickyEvents中，然后再发布事件，仅此而已，就是这么“粗暴直接”。这里有两处入口会执行粘性事件，第一处是postSticky，这里会反射执行该粘性事件的所有订阅方法，第二处其实上面分析register时就提到过了，在注册订阅者时就会判断该订阅者下的订阅方法是否为粘性，是的话就会立即执行订阅方法。</p>
<h1 id="3-一点感想"><a href="#3-一点感想" class="headerlink" title="3. 一点感想"></a>3. 一点感想</h1><p>EventBus的原理其实是利用观察者模式，维护了一套观察者（订阅者）与被观察者（发布者所发布的事件）之间的Map集合。当发起订阅时（即register），就会以订阅者以及订阅方法为value，事件为key维护到Map中。当发布事件时，就会在Map集合中查找该事件对应的订阅者以及订阅方法，找到了就反射调用订阅方法，此时有可能某些订阅者是没有被创建或者被销毁了的，那么此时反射失败，EventBus框架就会内部消化掉这个异常。下面这张图我在官网图示的基础上增加了自己的一些理解和注释：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/source-code-analysis-eventbus-publish-subscribe.png?raw=true" alt="source-code-analysis-eventbus-publish-subscribe"></p>
<p>上面我只是分析了在主线程中发布，主线程中消费事件的流程，EventBus还有几个线程模型可供选择，分别是：POSTING、MAIN、MAIN_ORDERED、BACKGROUND、ASYNC，这里我不再一一赘述，有兴趣的可以自行debug调试。</p>
<p>当我们在维护自己的基础库供他人使用的时候，如果涉及到要实时通知功能的，可以借鉴EventBus的设计思路，EventBus的使用是非常简洁的，对外暴露的接口也异常简单，<strong>这对于设计框架供别人使用时很重要的一个技能</strong> ，如果提供的东西使用起来很复杂，务必会增加他们的学习成本，从而导致基础库难以推广。</p>
<p>还可以借鉴EventBus的单例模式控制好自己框架的实例数量，以及用FindState类这种保存临时变量这种思想来优雅的书写代码。</p>
<p>再有一个就是反射是很重要的一个技能，作为框架开发以及基础库开发，很有可能会要用到，所以掌握好反射是必须的。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin高级入门</title>
    <url>/iBlogWebsite/2019/10/21/2019/2019-10-21-Kotlin%E9%AB%98%E7%BA%A7%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>示例项目地址：<a href="https://github.com/Leeeyou/SampleOfKotlin-InDepth">https://github.com/Leeeyou/SampleOfKotlin-InDepth</a></p>
<h1 id="1-操作符"><a href="#1-操作符" class="headerlink" title="1. 操作符"></a>1. 操作符</h1><h2 id="1-1-集合操作符"><a href="#1-1-集合操作符" class="headerlink" title="1.1 集合操作符"></a>1.1 集合操作符</h2><p>元素相关的</p>
<ul>
<li>+ 、 - ：往集合中增加或者删除某元素</li>
<li>groupBy：按照闭包条件分组</li>
<li><a href="https://kotlinlang.org/docs/reference/collection-parts.html#slice">slice</a> ：按照入参将集合切分</li>
<li>take：从前往后拿取集合中的前n个元素，n是入参</li>
<li>takeLast：从后往前拿取集合中的前n个元素，n是入参</li>
<li>drop：从前往后丢弃集合中的前n个元素，n是入参</li>
<li>dropLast：从后往前丢弃集合中的前n个元素，n是入参</li>
<li>takeWhile：按照lambda表达式条件，从前往后拿取元素，直到第一个不符合条件的元素出现为止</li>
<li>takeLastWhile：按照lambda表达式条件，从后往前拿取元素，直到第一个不符合条件的元素出现为止</li>
<li>dropWhile：按照lambda表达式条件，从前往后丢弃元素，直到第一个不符合条件的元素出现为止</li>
<li>dropLastWhile：按照lambda表达式条件，从后往前丢弃元素，直到第一个不符合条件的元素出现为止</li>
<li>chunked：将集合按照n分块，n是入参，被分块的元素不在参与下一次分块</li>
<li>windowed：将集合按照n分块，n是入参，被分块的元素可能继续参与下一次分块，类似滑动窗口</li>
<li>zipWithNext：将集合两两一组切分</li>
<li>elementAt：返回对应的元素，越界会抛IndexOutOfBoundsException</li>
<li>first：返回符合条件的第一个元素，没有不返回任何内容</li>
<li>firstOrNull：返回符合条件的第一个元素，没有返回null</li>
<li>last：返回符合条件的最后一个元素，没有不返回任何内容</li>
<li>lastOrNull：返回符合条件的最后一个元素，没有返回null</li>
<li>elementAtOrNull：返回对应的元素，越界返回null</li>
<li>elementAtOrElse：返回对应的元素，越界则执行lambda表达式</li>
<li>find：同firstOrNull</li>
<li>findLast：同lastOrNull</li>
<li>contains：判断是否有指定元素</li>
<li>containsAll：判断是否包含指定的元素集</li>
</ul>
<p>排序相关的</p>
<ul>
<li>sortedWith：接受一个Comparator对象</li>
<li>sorted：升序</li>
<li>sortedDescending：降序</li>
<li>sortedBy：自定义顺序排列</li>
<li>sortedByDescending：自定义逆序排列</li>
<li>asReversed：反序</li>
<li>shuffled：随机排序</li>
</ul>
<span id="more"></span>

<p>过滤相关的</p>
<ul>
<li>filter：过滤掉所有满足条件的元素</li>
<li>filterNot：过滤所有不满足条件的元素</li>
<li>filterIndexed：与filter不同的是可以引入元素索引作为入参</li>
<li>filterNotNull：过滤null</li>
<li>filterIsInstance：过滤掉不是指定类型的元素</li>
<li><a href="https://kotlinlang.org/docs/reference/collection-filtering.html#partitioning">partition</a>：按照lambda表达式条件，将集合分成两部分</li>
<li><a href="https://kotlinlang.org/docs/reference/collection-filtering.html#testing-predicates">any 、none、all</a>：判断集合中是否有满足条件的元素、是否都不满足条件、是否都满足条件</li>
</ul>
<p>转换相关的</p>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/collection-transformations.html#mapping">map</a>：按照lambda表达式条件，作用于集合中的每个元素，并返回结果列表</li>
<li>mapIndexed：与map不同的是可以引入元素索引作为入参</li>
<li>mapNotNull：在map的基础上，结果列表中产生了null</li>
<li>mapIndexedNotNull：与mapNotNull不同的是可以引入元素索引作为入参</li>
<li>mapKeys：用于转换Map类型集合中的key</li>
<li>mapValues：用于转换Map类型集合中的value</li>
<li>zip：用于在两个集合中，构建相同位置的元素对，两个集合元素长度不一致以短的集合为基准</li>
<li>unzip：zip的反操作，将集合对展开为两个集合</li>
<li><a href="https://kotlinlang.org/docs/reference/collection-transformations.html#flattening">flatten</a>：将多个集合扁平化成一个集合，不关心每个集合的长度是否一致</li>
<li>flatMap：可以理解为map操作之后，再调用flatten，它的返回值是一个结果列表</li>
</ul>
<p>特定集合类型相关的</p>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/list-operations.html">getOrNull</a></li>
<li>getOrElse</li>
<li>subList</li>
<li>indexOf</li>
<li>lastIndexOf</li>
<li>indexOfFirst</li>
<li>indexOfLast</li>
<li><a href="https://kotlinlang.org/docs/reference/map-operations.html">filterKeys</a></li>
<li>filterValues</li>
</ul>
<h2 id="1-2-作用域函数"><a href="#1-2-作用域函数" class="headerlink" title="1.2 作用域函数"></a>1.2 作用域函数</h2><p>Kotlin内置的一系列可以对数据做变换的函数，与集合的操作符非常相似，但集合操作符只能用于集合，而作用域函数可以用于对所有对象做一系列操作。</p>
<ul>
<li>let {…}</li>
<li>run {…}</li>
<li>also {…}</li>
<li>apply {…}</li>
</ul>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">有闭包参数</th>
<th align="center">无闭包参数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">返回闭包结果</td>
<td align="center">let</td>
<td align="center">run</td>
</tr>
<tr>
<td align="center">不返回闭包结果</td>
<td align="center">also</td>
<td align="center">apply</td>
</tr>
</tbody></table>
<p>takeIf的闭包返回一个判断结果，为false时，takeIf函数会返回空；takeUnless 与 takeIf 刚好相反， 闭包的判断结果，为true时函数会返回空。</p>
<ul>
<li>takeIf {…}</li>
<li>takeUnless {…}</li>
</ul>
<p>with比较特殊，不是以扩展方法的形式存在的，而是一个顶级函数。</p>
<ul>
<li>with(T) {…}</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = UserInfo(<span class="number">9802830</span>, <span class="string">&quot;Rose&quot;</span>, <span class="string">&quot;http://oioe.i/23.png&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;17789876555&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> letResult = user.let &#123; <span class="string">&quot;let::<span class="subst">$&#123;it.nickname&#125;</span>&quot;</span> &#125;</span><br><span class="line">    println(letResult)</span><br><span class="line">    <span class="keyword">val</span> runResult = user.run &#123; <span class="string">&quot;run::<span class="subst">$&#123;this.mobile&#125;</span>&quot;</span> &#125;</span><br><span class="line">    println(runResult)</span><br><span class="line">    println(<span class="string">&quot;---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    user.also &#123;</span><br><span class="line">        println(<span class="string">&quot;also::<span class="subst">$&#123;it.uid&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;.apply &#123;</span><br><span class="line">        println(<span class="string">&quot;apply::<span class="subst">$&#123;this.gender&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;.nickname = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    println(user.nickname)</span><br><span class="line">    println(<span class="string">&quot;---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    user.nickname = <span class="string">&quot;Lily&quot;</span></span><br><span class="line">    user.takeIf &#123; it.nickname?.length!! &gt; <span class="number">0</span> &#125;?.also &#123; println(<span class="string">&quot;姓名为<span class="subst">$&#123;it.nickname&#125;</span>&quot;</span>) &#125; ?: println(<span class="string">&quot;姓名为空&quot;</span>)</span><br><span class="line">    user.takeUnless &#123; it.nickname?.length!! &gt; <span class="number">0</span> &#125;?.also &#123; println(<span class="string">&quot;姓名为空&quot;</span>) &#125; ?: println(<span class="string">&quot;姓名为<span class="subst">$&#123;user.nickname&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    with(user) &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="string">&quot;http://oioe.i/25.png&quot;</span></span><br><span class="line">        <span class="keyword">this</span>.mobile = <span class="string">&quot;17789876558&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(user)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-操作符的实现原理"><a href="#1-3-操作符的实现原理" class="headerlink" title="1.3 操作符的实现原理"></a>1.3 操作符的实现原理</h2><p>本质上都是扩展函数或者是扩展函数的形式为代码做一系列的扩展操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map操作示例</span></span><br><span class="line"><span class="keyword">public</span> inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(<span class="number">10</span>)), transform)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C &#123;</span><br><span class="line">    <span class="keyword">for</span> (item in <span class="built_in">this</span>)</span><br><span class="line">        destination.add(transform(item))</span><br><span class="line">    <span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//flatMap操作示例</span></span><br><span class="line"><span class="keyword">public</span> inline fun &lt;T, R&gt; Iterable&lt;T&gt;.flatMap(transform: (T) -&gt; Iterable&lt;R&gt;): List&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> flatMapTo(ArrayList&lt;R&gt;(), transform)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.flatMapTo(destination: C, transform: (T) -&gt; Iterable&lt;R&gt;): C &#123;</span><br><span class="line">    <span class="keyword">for</span> (element in <span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">list</span> <span class="operator">=</span> transform(element)</span><br><span class="line">        destination.addAll(list)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> destination</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-高级特性"><a href="#2-高级特性" class="headerlink" title="2. 高级特性"></a>2. 高级特性</h1><h2 id="2-1-解构声明"><a href="#2-1-解构声明" class="headerlink" title="2.1 解构声明"></a>2.1 解构声明</h2><p>就是将一个对象拆解成若干个变量，其本质将对象解析成一组属性，然后通过调用与之对应的component()方法得到属性的值，再赋值给各自的局部变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">map</span> <span class="operator">=</span> mapOf(<span class="string">&quot;深圳&quot;</span> to <span class="string">&quot;中国&quot;</span>, <span class="string">&quot;孟加拉&quot;</span> to <span class="string">&quot;印度&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> ((city, country) in map) &#123;</span><br><span class="line">        println(<span class="string">&quot;$city belongs $country&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val (uid2, nickname, _, _, _, mobile) = UserInfo(<span class="number">9802830</span>, <span class="string">&quot;Rose&quot;</span>, <span class="string">&quot;http://oioe.i/23.png&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;17789876555&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;My nickname is $nickname，uid is $uid2 ， my mobile phone is $mobile&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-中缀表达式"><a href="#2-2-中缀表达式" class="headerlink" title="2.2 中缀表达式"></a>2.2 中缀表达式</h2><p>所谓中缀表达式就是不需要点和括号的方法调用，其本质还是函数调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">class</span> CompareResult &#123;</span><br><span class="line">    MORE, LESS, EQUAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">infix fun Int.vs(num: Int): CompareResult =</span><br><span class="line">    when &#123;</span><br><span class="line">        <span class="built_in">this</span> - num &gt; <span class="number">0</span> -&gt; CompareResult.MORE</span><br><span class="line">        <span class="built_in">this</span> - num &lt; <span class="number">0</span> -&gt; CompareResult.LESS</span><br><span class="line">        <span class="keyword">else</span> -&gt; CompareResult.EQUAL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//自定义示例</span></span><br><span class="line">    println(<span class="number">1</span> vs <span class="number">6</span>)</span><br><span class="line">    println(<span class="number">9</span> vs <span class="number">6</span>)</span><br><span class="line">    println(<span class="number">6</span> vs <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//库自带中缀示例 to、step</span></span><br><span class="line">    mapOf(<span class="string">&quot;深圳&quot;</span> to <span class="string">&quot;中国&quot;</span>, <span class="string">&quot;孟加拉&quot;</span> to <span class="string">&quot;印度&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>中缀表达式实际上就是函数调用，如果把infix关键字去掉，那么跟纯粹函数调用方式没有任何区别。比如5.vs(6)、1.to(“A”)、element.into(list)等。只有加了infix关键字后，才可以使用中缀的调用方式：例如 1 to “A”, 5 vs 6。</li>
<li>中缀表达式让我们的代码更加接近自然语言，但不是所有的函数都能写成中缀调用，首先必须满足一个条件就是函数的参数只有一个。然后再看这个函数的参与者是不是只有两个元素，这两个元素可以是两个数，可以是两个对象，可以是集合等。</li>
</ul>
<h2 id="2-3-内联函数的特殊性"><a href="#2-3-内联函数的特殊性" class="headerlink" title="2.3 内联函数的特殊性"></a>2.3 <a href="http://kotlinlang.org/docs/reference/inline-functions.html">内联函数的特殊性</a></h2><p>Lambda 表达式最大的特点是可以作为参数传递。当定义一个闭包作为参数的函数，称这个函数为高阶函数。在使用高阶函数时，为了大幅提升高阶函数的性能，使用了内联函数，在编译阶段，编译器将会把内联函数拆分，直接插入到调用出。（ps：如果一个 inline 函数是很大的，那他会大幅增加调用它的那个函数的体积。）</p>
<ul>
<li>在Kotlin中，内部Lambda是不允许中断外部函数执行的</li>
<li>inline 的 Lambda 可以中断外部函数调用。（思考下为什么可以中断外部调用？）<ul>
<li>因为内联是将代码平铺，平铺以后就不存在Lambda内外代码块之分了</li>
</ul>
</li>
<li><a href="http://kotlinlang.org/docs/reference/inline-functions.html#non-local-returns">crossinline</a> 不允许 inline 的Lambda中断外部函数执行</li>
<li><a href="http://kotlinlang.org/docs/reference/inline-functions.html#noinline">noinline</a> 拒绝内联（思考下test2函数使用了inline后为什么还需要使用noinline来修饰第二个lambda表达式？）<ul>
<li>因为需要返回的lambda高阶函数是不能被平铺开的，当它被内联以后，平铺开后会修改外部函数的返回值类型</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> runnable = Runnable &#123;</span><br><span class="line">    println(<span class="string">&quot;runnable task...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> successCallback: () -&gt; <span class="built_in">Int</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;do something task...&quot;</span>)</span><br><span class="line">    <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//内部Lambda是不允许中断外部函数执行的</span></span><br><span class="line">    test4(runnable::run, runnable::run)</span><br><span class="line">    println(<span class="string">&quot;--- ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//inline函数的return直接中断了外部函数的调用</span></span><br><span class="line">    <span class="keyword">val</span> userInfo = UserInfo(<span class="number">9802830</span>, <span class="string">&quot;Rose&quot;</span>, <span class="string">&quot;http://oioe.i/23.png&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;17789876555&quot;</span>)</span><br><span class="line">    userInfo.let &#123;</span><br><span class="line">        it.mobile?.apply &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$this</span> do something background task...&quot;</span>)</span><br><span class="line">            <span class="comment">//return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;--- ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    test1 &#123;</span><br><span class="line">        println(<span class="string">&quot;hello 1-1&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@test1</span> <span class="comment">//可以根据实际的情况来决定是不是要执行后面的代码</span></span><br><span class="line">        println(<span class="string">&quot;hello 1-1-1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;--- ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    test2(successCallback) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        println(<span class="string">&quot;hello 2-1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;--- ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    test3(&#123;</span><br><span class="line">        println(<span class="string">&quot;hello 3-1&quot;</span>)</span><br><span class="line">    &#125;, runnable::run)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">(<span class="keyword">crossinline</span> block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test2</span><span class="params">(<span class="keyword">noinline</span> block1: () -&gt; <span class="type">Int</span>, block2: () -&gt; <span class="type">Unit</span>)</span></span>: () -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">    block1.invoke()</span><br><span class="line">    block2()</span><br><span class="line">    println(<span class="string">&quot;test 2&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> block1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test3</span><span class="params">(block: () -&gt; <span class="type">Unit</span>, block2: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    block.invoke()</span><br><span class="line">    block2.invoke()</span><br><span class="line">    println(<span class="string">&quot;test 3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test4</span><span class="params">(block: () -&gt; <span class="type">Unit</span>, block2: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    block.invoke()</span><br><span class="line">    block2.invoke()</span><br><span class="line">    println(<span class="string">&quot;test 4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-4-操作符重载"><a href="#2-4-操作符重载" class="headerlink" title="2.4 操作符重载"></a>2.4 <a href="https://kotlinlang.org/docs/reference/operator-overloading.html">操作符重载</a></h2><p>运算符重载需要使用关键字operator修饰，其余定义与函数相同。 运算符的数量毕竟是有限的，有时并不一定有合适的，此时可以考虑前面的中缀表达式，要是觉得麻烦，可以直接考虑扩展函数。</p>
<ul>
<li>一元前缀操作：+ - !</li>
<li>递增与递减：++ –</li>
<li>二元操作：+ - * / % ..</li>
<li>In操作：contains</li>
<li>索引访问操作：get/set</li>
<li>调用操作：invoke</li>
<li>广义赋值：+= -+ *= /= %=</li>
<li>相等与不等操作符：== !=</li>
<li>比较操作符：&gt; &lt; &gt;= &lt;=</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">unaryMinus</span><span class="params">()</span></span> = Point(-x, -y)</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">unaryPlus</span><span class="params">()</span></span> = Point(+x, +y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> point = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(-point)  <span class="comment">// prints &quot;Point(x=-10, y=-20)&quot;</span></span><br><span class="line">    println(+point)  <span class="comment">// prints &quot;Point(x=-10, y=-20)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> listOf = listOf(<span class="string">&quot;深圳&quot;</span>, <span class="string">&quot;孟加拉&quot;</span>, <span class="string">&quot;拉斯维加斯&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> myCity = <span class="string">&quot;拉斯维加斯&quot;</span></span><br><span class="line">    println(myCity <span class="keyword">in</span> listOf)</span><br><span class="line"></span><br><span class="line">    println(listOf.<span class="keyword">get</span>(<span class="number">0</span>))</span><br><span class="line">    println(listOf[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-必须掌握的命令"><a href="#3-必须掌握的命令" class="headerlink" title="3. 必须掌握的命令"></a>3. 必须掌握的命令</h1><p><strong>javap [option] xxx.class</strong></p>
<p>这个命令可以反编译一个class文件，可以方便的让我们知道Kt代码在编译以后处于怎样的状态，以及帮助我们分析自己的代码。</p>
<ul>
<li>-help  –help  -?        输出此用法消息</li>
<li>-version                 版本信息</li>
<li>-v  -verbose             输出附加信息</li>
<li>-l                       输出行号和本地变量表</li>
<li>-public                  仅显示公共类和成员</li>
<li>-protected               显示受保护的/公共类和成员</li>
<li>-package                 显示程序包/受保护的/公共类和成员 (默认)</li>
<li>-p  -private             显示所有类和成员</li>
<li><strong>-c</strong>                   对代码进行反汇编</li>
<li>-s                       输出内部类型签名</li>
<li>-sysinfo                 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列)</li>
<li>-constants               显示最终常量</li>
<li>-classpath <path>        指定查找用户类文件的位置</li>
<li>-cp <path>               指定查找用户类文件的位置</li>
<li>-bootclasspath <path>    覆盖引导类文件的位置</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>分享系列</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>疑难杂症记录1：关于Kotlin aar文件不能debug的问题</title>
    <url>/iBlogWebsite/2020/04/03/2020/2020-04-03-%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%AE%B0%E5%BD%951%EF%BC%9A%E5%85%B3%E4%BA%8EKotlin%20aar%E6%96%87%E4%BB%B6%E4%B8%8D%E8%83%BDdebug%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/wallpaper/2020-04-03.jpg?raw=true" alt="2020-04-03"></p>
<p>现在有个这样的场景，需要你编写一个基础库sdk供上层业务调用，同时考虑引入kotlin，于是你花了3分钟很快就把所有的代码写完了，然后assembleRelease输出aar，再引入aar到主工程中。此时你想在主工程中结合业务调试下刚写完的kt代码，发现没法debug，效果如下所示：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/record-kt-aar-source-code-decomplie-example.png?raw=true" alt="record-kt-aar-source-code-decomplie-example"></p>
<p>由于项目时间关系，在我遇到这个问题时由于代码量不大，立马就将kt编写改成java了。但java语法在某些场景下实在太罗嗦，同时为了引入kt的协程特性，如果我要继续在基础库中使用kt，前提条件是需要解决kt的aar包不能debug的问题。</p>
<p>解决问题的过程总是那么曲折不顺，解决问题后的感受总是那么神清气爽。先说结论，这个问题有两种解决方式：</p>
<ol>
<li>通过引入子模块的方式，配置一个开关，在你需要调试代码时引入子模块中的源代码，而发布时依赖aar</li>
<li>通过maven库的方式，不管是本地还是远程maven，在发布代码时附带源码</li>
</ol>
<h2 id="子模块方式"><a href="#子模块方式" class="headerlink" title="子模块方式"></a>子模块方式</h2><p>这种方式在操作上依赖一个开关变量，而我根本不想再多维护一个开关值，所以不推荐。下面还是简单说明下怎么操作，原本是aar方式依赖，现在改成子模块方式，如下图所示：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/record-kt-aar-source-code-submodule.png?raw=true" alt="record-kt-aar-source-code-submodule"></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">&#x27;basic-net&#x27;</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">&#x27;:basic-net&#x27;</span>).projectDir = <span class="keyword">new</span> <span class="keyword">File</span>(settingsDir, <span class="string">&#x27;../TestKtAarLib/basic-net&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这种方式明目张胆把源码依赖进来了，实在找不到借口不能debug了。说了这么多不好，其实还是有优点的，你可以及时修改源码来佐证自己的想法，但仅仅是佐证而已，如果这套基础库代码不是你维护的，或者你们有明确分工，不建议你修改后commit。</p>
<span id="more"></span>

<h2 id="maven库方式"><a href="#maven库方式" class="headerlink" title="maven库方式"></a>maven库方式</h2><p>推荐采用这种方式，原因很简单，发布完后不用管事了，上层业务使用的同学权限也仅仅是debug级别，不会由于一些莫名其妙的原因修改了你的代码而不自知。</p>
<p>下面我以线上maven库的方式为例，首先要弄个maven服务，去 <a href="%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://pan.baidu.com/s/1-t0SVQ865SSzBwO_jhbzlQ">这里下载，提取码：hcxu </a>，完事之后解压，cmd 进入到这个目录：**nexus-3.22.0-02-win64\nexus-3.22.0-02\bin&gt;**，windows系统下运行命令 <strong>nexus.exe /run</strong>，别着急等待一下，看到 <strong>Started Sonatype Nexus OSS 3.22.0-02</strong> 这句话就代表服务起好了，然后你就打开 <a href="http://localhost:8081/">http://localhost:8081/</a> </p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/record-kt-aar-source-code-startup-maven.png?raw=true" alt="record-kt-aar-source-code-startup-maven"></p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/record-kt-aar-source-code-startup-maven-success.png?raw=true" alt="record-kt-aar-source-code-startup-maven-success"></p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/record-kt-aar-source-code-config-maven.png?raw=true" alt="record-kt-aar-source-code-config-maven"></p>
<p>接着登录进去(admin/admin123)，然后拷贝maven-releases和maven-snapshots这两个仓库的地址：</p>
<ul>
<li><a href="http://localhost:8081/repository/maven-releases/">http://localhost:8081/repository/maven-releases/</a></li>
<li><a href="http://localhost:8081/repository/maven-snapshots/">http://localhost:8081/repository/maven-snapshots/</a></li>
</ul>
<p>maven服务这部分算是完事了，下面来看工程中怎么配置，在gradle.properties中配置maven的pom属性以及maven仓库地址和账密。maven的pom属性配置你也可以不写到gradle.properties中，而是放到每个module下分类管理更好。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#MAVEN需要的配置</span></span><br><span class="line"><span class="attr">PROJ_GROUP_ID</span> = <span class="string">com.leeeyou.testktaar.basic.net</span></span><br><span class="line"><span class="attr">PROJ_ARTIFACTID</span> = <span class="string">basic-net</span></span><br><span class="line"><span class="attr">PROJ_VERSION</span> = <span class="string">1.1.0</span></span><br><span class="line"><span class="attr">PROJ_DESCRIPTION</span> =<span class="string">test kt aar debug</span></span><br><span class="line"><span class="attr">PROJ_TYPE</span> = <span class="string">aar</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#这里是maven地址和账密</span></span><br><span class="line"><span class="attr">MAVEN_REPO_RELEASE_URL</span>=<span class="string">http://localhost:8081/repository/maven-releases/</span></span><br><span class="line"><span class="attr">MAVEN_REPO_SNAPSHOT_URL</span>=<span class="string">http://localhost:8081/repository/maven-snapshots/</span></span><br><span class="line"><span class="attr">NEXUS_USERNAME</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">NEXUS_PASSWORD</span>=<span class="string">oooo9999</span></span><br></pre></td></tr></table></figure>

<p>现在准备一个maven_push.gradle用于发布aar和源码到maven仓库中，同时在build.gradle中引入该文件：<strong>apply from: ‘maven_push.gradle’</strong></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;maven&#x27;</span></span><br><span class="line">apply plugin: <span class="string">&#x27;signing&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line">    deployerJars</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断版本是Release or Snapshots</span></span><br><span class="line"><span class="keyword">def</span> isReleaseBuild() &#123;</span><br><span class="line">    <span class="keyword">return</span> !PROJ_VERSION.contains(<span class="string">&quot;SNAPSHOT&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取仓库url</span></span><br><span class="line"><span class="keyword">def</span> getRepositoryUrl() &#123;</span><br><span class="line">    <span class="keyword">return</span> isReleaseBuild() ? MAVEN_REPO_RELEASE_URL : MAVEN_REPO_SNAPSHOT_URL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            beforeDeployment &#123;</span><br><span class="line">                MavenDeployment deployment -&gt; signing.signPom(deployment)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pom.version = PROJ_VERSION</span><br><span class="line">            pom.artifactId = PROJ_ARTIFACTID</span><br><span class="line">            pom.groupId = PROJ_GROUP_ID</span><br><span class="line"></span><br><span class="line">            repository(url: getRepositoryUrl()) &#123;</span><br><span class="line">                authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD) <span class="comment">// maven授权信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行数字签名</span></span><br><span class="line">signing &#123;</span><br><span class="line">    <span class="comment">// 当 发布版本 &amp; 存在&quot;uploadArchives&quot;任务时，才执行</span></span><br><span class="line">    required &#123; isReleaseBuild() &amp;&amp; gradle.taskGraph.hasTask(<span class="string">&quot;uploadArchives&quot;</span>) &#125;</span><br><span class="line">    sign <span class="keyword">configurations</span>.archives</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上传源码</span></span><br><span class="line"><span class="keyword">task</span> androidSourcesJar(type: Jar) &#123;</span><br><span class="line">    classifier = <span class="string">&#x27;sources&#x27;</span></span><br><span class="line">    <span class="keyword">from</span> android.<span class="keyword">sourceSets</span>.main.java.srcDirs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">artifacts</span> &#123;</span><br><span class="line">    archives androidSourcesJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后执行uploadArchives任务后，发现aar以及源码成功发布到了仓库中</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/record-kt-aar-source-code-upload-archive.png?raw=true" alt="record-kt-aar-source-code-upload-archive"></p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/record-kt-aar-source-code-upload-archive-success.png?raw=true" alt="record-kt-aar-source-code-upload-archive-success"></p>
<p>工程配置和发布到maven仓库这部分算是完事了，接下来就是使用刚发布的aar。首先在根build.gradle中配置仓库地址，然后在具体的module中引入basic-net依赖库，同步一下，正常情况下能成功拉下代码。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根build.gradle</span></span><br><span class="line">maven &#123;</span><br><span class="line">    url <span class="string">&#x27;http://localhost:8081/repository/maven-releases/&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//module的build.gradle</span></span><br><span class="line">implementation <span class="string">&#x27;com.leeeyou.testktaar.basic.net:basic-net:1.1.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>此时我已成功拉下了1.1.0版本的代码，测试是包含源码的，所以我可以随意debug NetRequest的post和get函数。久违的debug界面，真香</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/record-kt-aar-source-code-debug-success.png?raw=true" alt="record-kt-aar-source-code-debug-success"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我这套示例程序的环境如干净的贝加尔湖水，而你的工程环境如同你小区的垃圾堆脏乱不堪。这里没有贬低之意，只是环境的简单和复杂会在你引进依赖库后报很多奇怪的问题，比如重复引入的问题、依赖传递的问题等等，而这些就依赖我们自己解决问题的能力了。</p>
<p>上面sonatype的使用也是最简单的，它还有很多复杂的功能，比如权限、分组等，这些如果你要用到再找资料也不迟。多提一嘴，在拉仓库代码时，可能会失败报错：Repository does not allow updating assets，此时你就进入sonatype的配置页允许匿名访问就ok了。</p>
<p>总的来说，想要debug某个aar库，想办法搞到源码，源码在手，debug我有。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/adeng/p/7065717.html">maven使用nexus3.3在windows下搭建私服</a> </li>
<li><a href="https://www.jianshu.com/p/d6f6aec8903c">Android Studio 教你5分钟搭建和使用Maven仓库</a> </li>
<li><a href="https://discuss.kotlinlang.org/t/how-to-debug-koltin-aar-file-on-android/12987">关于debug kotlin aar的问题，kotlin官方论坛上的答复是建议引入源module</a></li>
<li><a href="https://blog.csdn.net/yaolong336/article/details/78264767">Repository does not allow updating assets 解决方法</a></li>
<li><a href="https://juejin.im/entry/59918304518825489151732d">build.gradle管理依赖的版本</a></li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>疑难杂症</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin基础入门</title>
    <url>/iBlogWebsite/2019/05/07/2019/2019-05-07-Kotlin%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-历史发展"><a href="#1-1-历史发展" class="headerlink" title="1.1. 历史发展"></a>1.1. 历史发展</h2><ul>
<li>2011年7月JetBrains推出Kotlin项目，这是一个面向JVM的新语言，它已被开发一年之久。</li>
<li>2012年2月JetBrains以Apache 2许可证开源此项目，Jetbrains希望这个新语言能够推动IntelliJ IDEA的销售。</li>
<li>2016年2月15日发布1.0版，被认为是第一个官方稳定版本，并且JetBrains已准备从该版本开始的长期向后兼容性。</li>
<li>2017年3月，JetBrains发布Kotlin 1.1版本，Kotlin在全球范围内成长显著。</li>
<li>2017年5月18日Google I/O大会上宣布Kotlin正式成为Android的官方一级开发语言，同时AS3.0默认集成Kotlin Plugin。</li>
<li>2017年11月，JetBrains发布了Kotlin 1.2版本，推出了多平台项目特性，可以将原始代码编译成多个平台的目标代码，目前支持JVM和JavaScript。</li>
<li>2018年2月，Google发布了Android KTX扩展库，目前已属于Android Jetpack系列中的一员，简单的说Android KTX旨在让我们利用Kotlin语言功能（例如扩展函数/属性、lambda、命名参数和参数默认值），以更简洁、更愉悦、更惯用的方式使用Kotlin进行Android开发。甚至可以简单理解为Google为Kotlin准备的适配Android的一系列xxxUtils工具。这个库由<a href="https://github.com/JakeWharton">Jake Wharton</a>负责维护。</li>
<li>2018年10月，JetBrains发布了Kotlin 1.3版本，这个版本最重要的特性就是协程，它使得非阻塞代码易于读写。此外在多平台方面，支持了支持 JVM、Android、JavaScript和Native。这意味着Kotlin能进行前端、移动端以及后端代码的开发了。</li>
<li>目前已有非常多的开源库推出Kotlin版本：<a href="https://github.com/ReactiveX/RxKotlin">RxKotlin</a>、<a href="https://github.com/JakeWharton/kotterknife">kotterknife</a>、<a href="https://github.com/square/leakcanary">leakcanary</a>、<a href="https://github.com/afollestad/material-dialogs">material-dialogs</a>、<a href="https://github.com/JetBrains/kotlin-web-site">kotlin-web-site</a>、<a href="https://github.com/gradle/kotlin-dsl">kotlin-dsl</a>、<a href="https://github.com/angelolloqui/SwiftKotlin">SwiftKotlin</a>、<a href="https://github.com/JetBrains/kotlinconf-app">kotlinconf-app</a>、<a href="https://github.com/dbacinski/Design-Patterns-In-Kotlin">Design-Patterns-In-Kotlin</a>、<a href="https://github.com/Kotlin/anko">anko</a>、<a href="https://github.com/wasabeef/recyclerview-animators">recyclerview-animators</a>、<a href="https://github.com/wasabeef/glide-transformations">glide-transformations</a>、<a href="https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter">retrofit2-kotlin-coroutines-adapter</a></li>
</ul>
<h2 id="1-2-APP集成现状"><a href="#1-2-APP集成现状" class="headerlink" title="1.2. APP集成现状"></a>1.2. APP集成现状</h2><table>
<thead>
<tr>
<th align="center">使用</th>
<th align="center">未使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://play.google.com/store/apps/details?id=com.pinterest&_branch_match_id=647609346855862845">Pinterest</a> &nbsp;&nbsp; <a href="https://play.google.com/store/apps/details?id=com.evernote">Evernote</a> &nbsp;&nbsp; <a href="https://play.google.com/store/apps/details?id=com.ubercab">Uber</a> &nbsp;&nbsp; <a href="https://www.facebook.com/android_upgrade">Facebook</a> &nbsp;&nbsp; <a href="https://play.google.com/store/apps/details?id=com.twitter.android">twitter</a> &nbsp;&nbsp; <a href="https://play.google.com/store/apps/details?id=com.tencent.weread">微信读书</a> &nbsp;&nbsp; <a href="https://play.google.com/store/apps/details?id=com.douban.frodo">豆瓣</a> &nbsp;&nbsp; <a href="https://play.google.com/store/apps/details?id=com.alibaba.android.rimet">钉钉</a> &nbsp;&nbsp; <a href="https://play.google.com/store/apps/details?id=com.jingdong.app.mall">京东</a> &nbsp;&nbsp; <a href="https://play.google.com/store/apps/details?id=com.baidu.searchbox">百度</a> &nbsp;&nbsp; <a href="https://sj.qq.com/myapp/detail.htm?apkName=com.ss.android.ugc.aweme">抖音</a> &nbsp;&nbsp; <a href="https://play.google.com/store/apps/details?id=com.ss.android.article.news">今日头条</a> &nbsp;&nbsp; <a href="https://play.google.com/store/apps/details?id=com.qiyi.video">爱奇艺</a></td>
<td align="center">YouTube &nbsp;&nbsp; Instagram &nbsp;&nbsp; 迅雷 &nbsp;&nbsp; 微信 &nbsp;&nbsp; 快手 &nbsp;&nbsp; 手机QQ &nbsp;&nbsp; 手机淘宝</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="1-3-优势"><a href="#1-3-优势" class="headerlink" title="1.3. 优势"></a>1.3. 优势</h2><ul>
<li><p>改变编程思维</p>
<p>  类似rx的集合操作符、自带的操作符，以及闭包、高阶函数形式跟传统java编程有一些区别。</p>
</li>
<li><p>能少则少</p>
<ul>
<li>Kotlin支持类型推断，不像Java那样啰嗦</li>
<li>用var表示变量，val表示不可变的变量</li>
<li>定义方法很简单，连function都缩写成了fun</li>
<li>类的继承和实现很简单，使用:即可</li>
<li>Kotlin每个句子都不需要加分号</li>
</ul>
</li>
<li><p>完美兼容Java</p>
<ul>
<li><a href="https://github.com/google/volley">volley</a></li>
<li><a href="https://github.com/square/okhttp">okhttp</a></li>
<li><a href="https://github.com/square/retrofit">retrofit</a></li>
<li><a href="https://github.com/greenrobot/EventBus">EventBus</a></li>
<li><a href="https://github.com/bumptech/glide">glide</a></li>
<li><a href="https://github.com/square/picasso">picasso</a></li>
<li><a href="https://github.com/PhilJay/MPAndroidChart">MPAndroidChart</a></li>
<li><a href="https://github.com/airbnb/lottie-android">lottie-android</a></li>
<li><a href="https://github.com/bilibili/ijkplayer">ijkplayer</a></li>
<li><a href="https://github.com/zxing/zxing">zxing</a></li>
<li><a href="https://github.com/facebook/fresco">fresco</a></li>
<li><a href="https://github.com/chrisbanes/PhotoView">PhotoView</a></li>
<li><a href="https://github.com/Tencent/tinker">tinker</a></li>
<li><a href="https://github.com/greenrobot/greenDAO">greenDAO</a></li>
<li><a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh">android-Ultra-Pull-To-Refresh</a></li>
<li>…</li>
</ul>
</li>
</ul>
<h2 id="1-4-学习资料"><a href="#1-4-学习资料" class="headerlink" title="1.4. 学习资料"></a>1.4. 学习资料</h2><ul>
<li>Kotlin Github地址：<a href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></li>
<li>Kotlin官方中文翻译站点：<a href="https://www.kotlincn.net/docs/reference/">https://www.kotlincn.net/docs/reference/</a></li>
<li>张涛的开源实验室：<a href="https://kymjs.com/column/kotlin.html">https://kymjs.com/column/kotlin.html</a></li>
<li>视频资料 [百度网盘]：<a href="https://pan.baidu.com/s/1nvGYAfB#list/path=%2F">https://pan.baidu.com/s/1nvGYAfB#list/path=%2F</a></li>
<li>极客时间快速上手Kotlin开发 [付费视频课]：<a href="https://time.geekbang.org/course/intro/105">https://time.geekbang.org/course/intro/105</a></li>
</ul>
<h1 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h1><p>下面介绍Kotlin的最重要的基础语法，里面的某些示例代码参考github上的仓库：<a href="https://github.com/Leeeyou/SampleOfKotlin-Basic">SampleOfKotlin-Basic</a></p>
<h2 id="2-1-Defining-functions"><a href="#2-1-Defining-functions" class="headerlink" title="2.1. Defining functions"></a>2.1. <a href="https://kotlinlang.org/docs/reference/functions.html#functions">Defining functions</a></h2><ul>
<li>调用的时候可以显式的标识参数名</li>
<li>可以提供默认参数值，减少重载有奇效</li>
<li>【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic.definingFunctions】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">double</span><span class="params">(x: Int = <span class="number">100</span>, y: Int = <span class="number">200</span>)</span>: Int &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> * x) + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Defining-variables"><a href="#2-2-Defining-variables" class="headerlink" title="2.2. Defining variables"></a>2.2. <a href="http://kotlinlang.org/docs/reference/basic-syntax.html#defining-variables">Defining variables</a></h2><ul>
<li>Kotlin具有可推倒特性</li>
<li>val：只读变量用val关键字，它仅能被赋值一次。val表示可读的变量（read-only，注意不是immutable）</li>
<li>var：可被重复赋值的变量用var关键字。var表示变量，是可变的（mutable）<ul>
<li>val与var的区别在于：val是无法提供set函数的，只有get函数</li>
</ul>
</li>
<li>const：用于定义常量，准确的说const所定义的常量叫<strong>编译时常量</strong><ul>
<li>如果它的值无法在编译时确定，则编译不过，这个常量跟Java的static final是有所区别的。这里就是说你定义的const val常量要即时赋值，而不能稍后再赋值</li>
<li>const无法定义局部变量，因为局部变量会存放在栈区，它会随着调用的结束而销毁，这点跟Java的static final一致</li>
<li>所以const的使用必须满足：1. 顶层属性或者object的成员，2.  String或者基本类型的值，3. 没有自定义 getter。</li>
<li>const的使用是一个容易出错的点，我们应该好好理解它的规则。</li>
</ul>
</li>
<li>【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic】</li>
</ul>
<h2 id="2-3-Using-string-templates"><a href="#2-3-Using-string-templates" class="headerlink" title="2.3. Using string templates"></a>2.3. <a href="http://kotlinlang.org/docs/reference/basic-syntax.html#using-string-templates">Using string templates</a></h2><ul>
<li>字符串模版配合表达式可以输出丰富的字符串</li>
<li>&quot;&quot;&quot; 中可以包含换行、反斜杠等等特殊字符</li>
<li>【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic.usingStringTemplates】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">println(<span class="string">&quot;i = $i&quot;</span>) <span class="comment">// prints &quot;i = 10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">val</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line">println(<span class="string">&quot;$s.length is $&#123;s.length&#125;&quot;</span>) <span class="comment">// prints &quot;abc.length is 3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">val</span> <span class="variable">price</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            $&#123;&#x27;$&#x27;&#125;9.99，</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            这里展示 / or // or \  or \\</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-Using-loop"><a href="#2-4-Using-loop" class="headerlink" title="2.4. Using loop"></a>2.4. Using loop</h2><ul>
<li><a href="https://kotlinlang.org/docs/reference/control-flow.html#for-loops">For Loops</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意这里Followers是集合类型</span></span><br><span class="line"><span class="keyword">for</span> (item in Followers) print(item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左开右开</span></span><br><span class="line"><span class="keyword">for</span> (i in <span class="number">1.</span><span class="number">.10</span>) println(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左开右闭</span></span><br><span class="line"><span class="keyword">for</span> (i in <span class="number">1</span> until <span class="number">10</span>) println(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i in <span class="number">10</span> downTo <span class="number">1</span>) println(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i in <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>) println(i)</span><br><span class="line"></span><br><span class="line">repeat(<span class="number">10</span>) &#123;</span><br><span class="line"> println(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((index, str) in list.withIndex()) &#123;</span><br><span class="line"> println(<span class="string">&quot;第$&#123;index&#125;个元素$str&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://kotlinlang.org/docs/reference/control-flow.html#while-loops">While Loops</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    x--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">y</span> <span class="operator">=</span> retrieveData()</span><br><span class="line">&#125; <span class="keyword">while</span> (y != <span class="literal">null</span>) <span class="comment">// y is visible here!</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-Operations"><a href="#2-5-Operations" class="headerlink" title="2.5. Operations"></a>2.5. <a href="https://kotlinlang.org/docs/reference/basic-types.html#operations">Operations</a></h2><ul>
<li><p>位运算符只可用在Int和Long类型上</p>
</li>
<li><p>左移(in java &lt;&lt;) → shl(bits)</p>
</li>
<li><p>右移(in java &gt;&gt;) → shr(bits)</p>
</li>
<li><p>无符号右移(in java &gt;&gt;&gt;) → ushr(bits)</p>
</li>
<li><p>按位与 → and(bits)</p>
</li>
<li><p>按位或 → or(bits)</p>
</li>
<li><p>按位异或 → xor(bits)</p>
</li>
<li><p>按位取反 → inv()</p>
<ul>
<li><p>原码：符号位加上真值的绝对值。</p>
</li>
<li><p>反码：正数的反码是其本身；负数的反码是在其原码的基础上，<strong>符号位不变</strong>，其余各个位取反。</p>
</li>
<li><p>补码：正数的补码就是其本身；负数的补码是在其原码的基础上，<strong>符号位不变</strong>，其余各位取反，最后+1。(即在反码的基础上+1)</p>
</li>
<li><p>求证~8的过程为什么是-9？</p>
</li>
<li><p>求证-8无符号右移2位后为什么是1073741822？</p>
<blockquote>
<p>~8的求证过程：<br>8原码：0000 0000 0000 0000 0000 0000 0000 1000<br>8反码：0000 0000 0000 0000 0000 0000 0000 1000<br>8补码：0000 0000 0000 0000 0000 0000 0000 1000<br>~后的补码：1111 1111 1111 1111 1111 1111 1111 0111<br>-1后转成反码：1111 1111 1111 1111 1111 1111 1111 0110<br>再转成原码：1000 0000 0000 0000 0000 0000 0000 1001<br>即十进制：-9</p>
</blockquote>
<blockquote>
<p>-8 &gt;&gt;&gt; 2的求证过程：<br>-8原码：1000 0000 0000 0000 0000 0000 0000 1000<br>-8反码：1111 1111 1111 1111 1111 1111 1111 0111<br>-8补码：1111 1111 1111 1111 1111 1111 1111 1000<br>右移两位后的补码：0011 1111 1111 1111 1111 1111 1111 1110<br>由于是正数，所以补码、反码、原码一直，所以上面的补码就是原码，<br>所以00111111111111111111111111111110转成十进制就是1073741822</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="2-6-Returns-and-Jumps"><a href="#2-6-Returns-and-Jumps" class="headerlink" title="2.6. Returns and Jumps"></a>2.6. <a href="https://kotlinlang.org/docs/reference/returns.html#returns-and-jumps">Returns and Jumps</a></h2><ul>
<li>return/break/continue。</li>
<li>可以根据需求，返回到指定的标签处。</li>
<li>【示例展示见官网链接】</li>
</ul>
<h2 id="2-7-Object-Expressions-and-Declarations"><a href="#2-7-Object-Expressions-and-Declarations" class="headerlink" title="2.7. Object Expressions and Declarations"></a>2.7. <a href="https://kotlinlang.org/docs/reference/object-declarations.html">Object Expressions and Declarations</a></h2><ul>
<li>可用于创建匿名类的对象</li>
<li>如果匿名类中包含构造函数，则必须传递合适的入参给它</li>
<li>可以创建一个临时对象，而不用声明data class（or javabean）</li>
<li>对象声明总是在object关键字后跟一个名称，就像变量声明一样，但对象声明不是一个表达式，不能用在赋值语句的右边。使用的时候直接通过该名称引用其中的函数即可</li>
<li>伴生对象（即著名的companion object），伴生对象的成员可通过只使用类名来调用其中的函数（类似Java中的静态方法）。<strong>尽管伴生对象看起来像静态成员，但实际上在运行时它仍然是真实对象的实例成员。</strong></li>
<li>【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic.object】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可用于创建匿名类的对象。</span></span><br><span class="line">window.addMouseListener(object : MouseAdapter() &#123;</span><br><span class="line">    override fun <span class="title function_">mouseClicked</span><span class="params">(e: MouseEvent)</span> &#123; …… &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">mouseEntered</span><span class="params">(e: MouseEvent)</span> &#123; …… &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果匿名类中包含构造函数，则必须传递合适的入参给它。</span></span><br><span class="line">open <span class="keyword">class</span> <span class="title class_">A</span>(x: Int) &#123;</span><br><span class="line">    <span class="keyword">public</span> open val y: Int = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">val ab: A = object : A(<span class="number">1</span>), B &#123;</span><br><span class="line">    override <span class="type">val</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象声明</span></span><br><span class="line">object DataProviderManager &#123;</span><br><span class="line">    fun <span class="title function_">registerDataProvider</span><span class="params">(provider: String)</span> &#123;</span><br><span class="line">        echo(<span class="string">&quot;$provider 注册成功&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DataProviderManager.registerDataProvider(<span class="string">&quot;1号数据源&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-8-Classes-and-Inheritance"><a href="#2-8-Classes-and-Inheritance" class="headerlink" title="2.8. Classes and Inheritance"></a>2.8. <a href="https://kotlinlang.org/docs/reference/classes.html">Classes and Inheritance</a></h2><ul>
<li>类及构造函数<ul>
<li>构造函数分主次： primary constructor、Secondary Constructors</li>
</ul>
</li>
<li>在Koltin中继承和实现都通过 :</li>
<li>静态函数的实现：【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic.staticMethod】<ul>
<li>在Kotlin中没有类似java的静态方法，想要使用可以考虑采用包级函数代替</li>
<li>还要一种便利的方式就是通过伴生对象：<a href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects">companion object</a></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类及构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(val firstName: String, val lastName: String, <span class="keyword">var</span> age: Int) &#123;</span><br><span class="line">    constructor(parent: Person) &#123;</span><br><span class="line">        parent.children.add(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承的实现</span></span><br><span class="line">open <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    open fun <span class="title function_">f</span><span class="params">()</span> &#123; println(<span class="string">&quot;Foo.f()&quot;</span>) &#125;</span><br><span class="line">    open val x: Int <span class="title function_">get</span><span class="params">()</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> : Foo() &#123;</span><br><span class="line">    override fun <span class="title function_">f</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>.f()</span><br><span class="line">        println(<span class="string">&quot;Bar.f()&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override val x: Int <span class="title function_">get</span><span class="params">()</span> = <span class="built_in">super</span>.x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line">open <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    open fun <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Derived</span> : Base() &#123;</span><br><span class="line">    override <span class="keyword">abstract</span> fun <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-9-Data-Classes"><a href="#2-9-Data-Classes" class="headerlink" title="2.9. Data Classes"></a>2.9. <a href="https://kotlinlang.org/docs/reference/data-classes.html#data-classes">Data Classes</a></h2><p>类似JavaBean，不过我们不需要再写get/set方法，还有equals()/hashCode()对以及toString()方法都会被自动生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">data <span class="keyword">class</span> <span class="title class_">Customer</span>(val name: String, val email: String)</span><br></pre></td></tr></table></figure>

<h2 id="2-10-Interfaces"><a href="#2-10-Interfaces" class="headerlink" title="2.10. Interfaces"></a>2.10. <a href="https://kotlinlang.org/docs/reference/interfaces.html#interfaces">Interfaces</a></h2><ul>
<li>实现多个父类，可以灵活解决方法覆盖的冲突问题</li>
<li>想要实现一个匿名内部类实例，需要通过object关键字</li>
<li>【示例见SampleOfKotlin-Basic → Interface】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多父类下，方法覆盖冲突问题</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    fun <span class="title function_">foo</span><span class="params">()</span> &#123; print(<span class="string">&quot;A&quot;</span>) &#125;</span><br><span class="line">    fun <span class="title function_">bar</span><span class="params">()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    fun <span class="title function_">foo</span><span class="params">()</span> &#123; print(<span class="string">&quot;B&quot;</span>) &#125;</span><br><span class="line">    fun <span class="title function_">bar</span><span class="params">()</span> &#123; print(<span class="string">&quot;bar&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : A &#123;</span><br><span class="line">    override fun <span class="title function_">bar</span><span class="params">()</span> &#123; print(<span class="string">&quot;bar&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : A, B &#123;</span><br><span class="line">    override fun <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>&lt;A&gt;.foo()</span><br><span class="line">        <span class="built_in">super</span>&lt;B&gt;.foo()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>&lt;B&gt;.bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">D().setClickListener(object : ClickListener &#123;</span><br><span class="line">    override fun <span class="title function_">countClick</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(<span class="built_in">this</span><span class="meta">@MainActivity</span>.localClassName, <span class="string">&quot;点击回调&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="2-11-Extensions"><a href="#2-11-Extensions" class="headerlink" title="2.11. Extensions"></a>2.11. <a href="https://kotlinlang.org/docs/reference/extensions.html#extensions">Extensions</a></h2><ul>
<li>扩展函数：<strong>Kotlin中的扩展函数是静态的给一个类添加方法的，不具备运行时的多态效应</strong><ul>
<li>String.lastChar()</li>
<li>Activity.hideKeyboard()</li>
</ul>
</li>
<li>扩展属性<ul>
<li>List<T>.lastIndex</li>
</ul>
</li>
<li>【示例见SampleOfKotlin-Basic → Extensions】</li>
</ul>
<h2 id="2-12-Generics-https-kotlinlang-org-docs-reference-generics-html-generics）"><a href="#2-12-Generics-https-kotlinlang-org-docs-reference-generics-html-generics）" class="headerlink" title="2.12. [Generics](https://kotlinlang.org/docs/reference/generics.html#generics）"></a>2.12. [Generics](<a href="https://kotlinlang.org/docs/reference/generics.html#generics%EF%BC%89">https://kotlinlang.org/docs/reference/generics.html#generics）</a></h2><ul>
<li><p><a href="https://leeeyou.github.io/2018/09/20/blog-2018-09-20-Java%E4%B9%8B%E6%B3%9B%E5%9E%8B/">Java中泛型的特点</a></p>
<ul>
<li><a href="https://leeeyou.github.io/2018/09/20/blog-2018-09-20-Java%E4%B9%8B%E6%B3%9B%E5%9E%8B/#2-1-%E6%93%A6%E9%99%A4%E6%9C%BA%E5%88%B6">类型擦除</a>（在编译期间擦掉类型信息）<ul>
<li>泛型类型参数之间没有继承关系（ArrayList&lt;Object&gt; arrayList1=new ArrayList&lt;String&gt;();  //编译错误）</li>
</ul>
</li>
<li>不可具体化的类型（运行时包含的信息比它的编译时包含的信息更少）</li>
<li><a href="https://leeeyou.github.io/2018/09/20/blog-2018-09-20-Java%E4%B9%8B%E6%B3%9B%E5%9E%8B/#2-3-%E9%80%9A%E9%85%8D%E7%AC%A6">通配符</a>（有界通配符和无界通配符）</li>
</ul>
</li>
<li><p>Kotlin中泛型特点</p>
<ul>
<li>声明处型变：out和in<ul>
<li>out：当一个类（List）的类型参数（E）被声明为out时，我们就可以将子类泛型的对象赋值给使用父类泛型的对象，即通常所说的类List是在参数E上是协变的。但是副作用是它只能出现在该类成员的输出位置上（对应下图的out箭头很好理解）</li>
<li>in：当一个类（Consumer）的类型参数（E）被声明为in时，我们就可以将父类泛型的对象赋值给使用子类泛型的对象，即通常所说的类Consumer在参数E上是逆变的。但副作用是它只能出现在该类成员的输入位置（对应下图的in箭头很好理解）</li>
<li>协变和逆变关系图：<img src="https://raw.githubusercontent.com/Leeeyou/iPictureRepository/master/leeeyou/kotlin/in-out%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="协变和逆变关系图"></li>
</ul>
</li>
<li>类型投影<ul>
<li>使用处型变<ul>
<li>Kotlin的使用处型变直接对应Java的有界通配符。Kotlin中的MutableList&lt;out T&gt;和Java中的MutableList&lt;? extends T&gt;是一个意思。in投影的MutableList&lt;in T&gt;对应到Java的MutableList&lt;? super T&gt;</li>
</ul>
</li>
<li>星号投影<ul>
<li>Kotlin的MyType&lt;*&gt;相当于Java中的MyType&lt;?&gt;</li>
</ul>
</li>
</ul>
</li>
<li>同时限定多个类型</li>
<li>Kotlin中可以获取泛型的实际类型<ul>
<li>inline（内联函数） + reified（实化类型）能处理方法级别的真泛型 <strong>（这里最好贴上代码说明）</strong><ul>
<li>我们都知道内联函数的原理，编译器把实现内联函数的字节码动态插入到每次的调用点。那么实化的原理正是基于这个机制，每次调用带实化类型参数的函数时，编译器都知道此次调用中作为泛型类型实参的具体类型。所以编译器只要在每次调用时生成对应不同类型实参调用的字节码插入到调用点即可。</li>
</ul>
</li>
<li>类级别的泛型需要自己改造<ul>
<li>通过伴生对象结合重载invoke调用操作符的方式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>对比Java与Kotlin中的使用对比</strong></p>
</li>
</ul>
<p> |协变|逆变|不型变<br>:-:|:-:|:-:|:-:<br>Java| ? extend E | ? super E | ArrayList<Apple><br>Kotlin| out E  | in E  | MutableList<Apple>  </p>
<p>Java中的泛型是不型变的，这意味着List&lt;RedApple&gt;并不是List&lt;Apple&gt;的子类型。而通过有界通配符extends关键字使得类型可以协变，即可以让Collection&lt;RedApple&gt;表示为Collection&lt;? extends Apple&gt;的子类型</p>
<ul>
<li>【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic.generic】</li>
</ul>
<h2 id="2-13-Null-Safety"><a href="#2-13-Null-Safety" class="headerlink" title="2.13. Null Safety"></a>2.13. <a href="https://kotlinlang.org/docs/reference/null-safety.html#null-safety">Null Safety</a></h2><ul>
<li>? 可为空，不会抛出NPE</li>
<li>!! 不可为空，会抛出NPE</li>
<li>String和String?是两种完全不同的数据类型，简单来说就是String?类型包含了String类型，使用的时候务必小心变量是否为空。</li>
<li><strong>Java代码与Kotlin代码互调注意点：在Kotlin代码中，接收一个Java对象的时候，如果你不确定是否可能空，务必将其赋值为可空类型的变量，这样才能保证代码是安全的，否则的话极有可能抛出NPE。</strong></li>
<li>【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic.nullSafe】</li>
</ul>
<h2 id="2-14-Lambda"><a href="#2-14-Lambda" class="headerlink" title="2.14. Lambda"></a>2.14. Lambda</h2><ul>
<li>如果Lambda没有参数，可以省略箭头符号</li>
<li>如果Lambda是函数的最后一个参数，可以将大括号放在小括号外面</li>
<li>如果函数只有一个参数且这个参数是Lambda，则可以省略小括号</li>
<li>【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic.lambda】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果Lambda没有参数，可以省略箭头符号</span></span><br><span class="line">fun <span class="title function_">main</span><span class="params">(args: Array&lt;String&gt;)</span>&#123;        </span><br><span class="line">    <span class="type">val</span> <span class="variable">thread</span> <span class="operator">=</span> Thread(&#123; &#125;)        </span><br><span class="line">    thread.start()    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果Lambda是函数的最后一个参数，可以将大括号放在小括号外面</span></span><br><span class="line">fun <span class="title function_">main</span><span class="params">(args: Array&lt;String&gt;)</span>&#123;        </span><br><span class="line">    <span class="type">val</span> <span class="variable">thread</span> <span class="operator">=</span> Thread()&#123; &#125;        </span><br><span class="line">    thread.start()    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数只有一个参数且这个参数是Lambda，则可以省略小括号</span></span><br><span class="line">fun <span class="title function_">main</span><span class="params">(args: Array&lt;String&gt;)</span>&#123;        </span><br><span class="line">    <span class="type">val</span> <span class="variable">thread</span> <span class="operator">=</span> Thread&#123; &#125;        </span><br><span class="line">    thread.start()    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-15-Lambda闭包声明"><a href="#2-15-Lambda闭包声明" class="headerlink" title="2.15. Lambda闭包声明"></a>2.15. Lambda闭包声明</h2><ul>
<li>Lambda+闭包</li>
<li>【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic.lambda】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">echo</span> <span class="operator">=</span> &#123; name: Any -&gt; println(name) &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">val</span> <span class="variable">lambdaA</span> <span class="operator">=</span> &#123; a: Int, b: Int, c: Int, d: Int, e: Int, f: Int, g: Int, h: Int,</span><br><span class="line">                i: Int, j: Int, k: Int, l: Int, m: Int, n: Int, o: Int, p: Int,</span><br><span class="line">                q: Int, r: Int, s: Int, t: Int, u: Int, v: Int, w: Int -&gt;</span><br><span class="line">    println(<span class="string">&quot;23个入参的闭包&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-16-Higher-Order-Functions"><a href="#2-16-Higher-Order-Functions" class="headerlink" title="2.16. Higher-Order Functions"></a>2.16. <a href="https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions">Higher-Order Functions</a></h2><ul>
<li>高阶函数指函数或者Lambda的参数又是一个函数或者Lambda</li>
<li>当Lambda作为函数参数的最后一个时，是可以写到小括号外面的</li>
<li>【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic.lambda】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">resultByOpt</span><span class="params">(num1: Int, num2: Int, result: (Int, Int)</span> -&gt; Int): Int &#123;</span><br><span class="line">    <span class="keyword">return</span> result(num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-17-Visibility-Modifiers"><a href="#2-17-Visibility-Modifiers" class="headerlink" title="2.17. Visibility Modifiers"></a>2.17. <a href="https://kotlinlang.org/docs/reference/visibility-modifiers.html#visibility-modifiers">Visibility Modifiers</a></h2><ul>
<li>Kotlin中的访问修饰符internal : 模块内可以调用，跨模块则不行。这里的模块指类似AS中的module</li>
<li>如果不特意声明，默认是public</li>
<li>classes, objects, interfaces, constructors, functions, properties and their setters can have visibility modifiers</li>
<li>【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic.visible】</li>
</ul>
<h2 id="2-18-Delegation"><a href="#2-18-Delegation" class="headerlink" title="2.18. Delegation"></a>2.18. <a href="https://kotlinlang.org/docs/reference/delegation.html">Delegation</a></h2><ul>
<li>Kotlin的动态代理本质上是通过静态代理去调用的</li>
<li>通过关键字by</li>
<li>【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic.delagation】</li>
</ul>
<h2 id="2-19-Sealed-Classes"><a href="#2-19-Sealed-Classes" class="headerlink" title="2.19. Sealed Classes"></a>2.19. <a href="https://kotlinlang.org/docs/reference/sealed-classes.html">Sealed Classes</a></h2><ul>
<li>超级枚举，可提高程序扩展性</li>
<li>【示例见SampleOfKotlin-Basic → com.leeeyou.sampleofkotlin.basic.seal】</li>
</ul>
<h1 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3. 扩展"></a>3. 扩展</h1><h2 id="3-1-为什么能实现扩展函数和属性这样的特性？"><a href="#3-1-为什么能实现扩展函数和属性这样的特性？" class="headerlink" title="3.1. 为什么能实现扩展函数和属性这样的特性？"></a>3.1. 为什么能实现扩展函数和属性这样的特性？</h2><h3 id="3-1-1-边界"><a href="#3-1-1-边界" class="headerlink" title="3.1.1. 边界"></a>3.1.1. 边界</h3><ul>
<li>Kotlin语言最后需要编译为class字节码，Java也是编译为class执行</li>
<li>可以理解为Kotlin需要转成Java一样的语法结构， Kotlin就是一种强大的语法糖而已</li>
<li>在虚拟机规范范围以内提供外界最便利的支持，虚拟机不具备的功能Kotlin也不能越界</li>
</ul>
<h3 id="3-1-2-Kotlin与Java互转"><a href="#3-1-2-Kotlin与Java互转" class="headerlink" title="3.1.2. Kotlin与Java互转"></a>3.1.2. Kotlin与Java互转</h3><ul>
<li>Kotlin转Java<ul>
<li><strong>Tools —&gt; Kotlin —&gt; Show Kotlin Bytecode</strong></li>
<li>Decompile</li>
</ul>
</li>
<li>Java转Kotlin<ul>
<li>Java代码 —&gt; 选择Code —&gt; Convert Java File to Kotlin File</li>
</ul>
</li>
</ul>
<h3 id="3-1-3-源码解析"><a href="#3-1-3-源码解析" class="headerlink" title="3.1.3. 源码解析"></a>3.1.3. 源码解析</h3><ul>
<li>对于扩展函数，转化为Java的时候其实就是一个静态的函数，同时这个静态函数的第一个参数就是该类的实例对象</li>
<li>扩展函数和扩展属性内只能访问到类的公有方法和属性，私有的和protected是访问不了的</li>
<li>扩展函数不是真的修改了原来的类，定义一个扩展函数不是将新成员函数插入到类中，扩展函数的类型是”静态的”，不是在运行时决定类型</li>
</ul>
<h2 id="3-2-kotlin-android-extensions插件原理介绍"><a href="#3-2-kotlin-android-extensions插件原理介绍" class="headerlink" title="3.2. kotlin-android-extensions插件原理介绍"></a>3.2. kotlin-android-extensions插件原理介绍</h2><ul>
<li>在示例项目中有使用到插件：apply plugin: ‘kotlin-android-extensions’</li>
<li>观察MainActivity这个页面中view的引用方式</li>
<li>public View _$_findCachedViewById(int var1){}</li>
<li>private HashMap _$_findViewCache;</li>
</ul>
<h2 id="3-3-Kotlin与Swift的对比"><a href="#3-3-Kotlin与Swift的对比" class="headerlink" title="3.3. Kotlin与Swift的对比"></a>3.3. Kotlin与Swift的对比</h2><p><img src="https://github.com/Leeeyou/blog/blob/master/images/2019/code/new-tech-kotlin-basic-kotlin-swift-compared.png?raw=true" alt="new-tech-kotlin-basic-kotlin-swift-compared"></p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><h2 id="4-1-Kotlin基础语法总结"><a href="#4-1-Kotlin基础语法总结" class="headerlink" title="4.1. Kotlin基础语法总结"></a>4.1. Kotlin基础语法总结</h2><ul>
<li>语法简单，不啰嗦</li>
<li>空指针安全</li>
<li>支持方法扩展和属性扩展</li>
<li>Lambda, 高阶函数，闭包支持，函数式编程支持</li>
<li>字符串模板，密闭类，代理模式，函数默认参数，data class</li>
<li>与Java交互性好</li>
</ul>
<h2 id="4-2-原理扩展以及与Swift对比"><a href="#4-2-原理扩展以及与Swift对比" class="headerlink" title="4.2. 原理扩展以及与Swift对比"></a>4.2. 原理扩展以及与Swift对比</h2><ul>
<li>利用好Kotlin与Java互转，掌握工具的使用</li>
<li>让你有种可以写swift app的“幻觉”</li>
</ul>
<h2 id="4-3-关于转向Kotlin"><a href="#4-3-关于转向Kotlin" class="headerlink" title="4.3. 关于转向Kotlin"></a>4.3. 关于转向Kotlin</h2><ul>
<li>对于个人的项目来转向Kotlin，通常不是很难的选择</li>
<li>让团队转用Kotlin，困难可能来自学习成本、历史包袱、编程思维的转变</li>
<li>目前Kotlin已推出稳定版1.3，大公司的许多app中也引入了Kotlin，在2019年04月编程语言排行榜中Kotlin排到35位，加上google的加持，引入Kotlin改写或重构代码，让团队成员自我提升，似乎无需置疑，好处多多</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>分享系列</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>疑难杂症记录2：在缓存好两个mtg插屏广告后，显示阶段报错isNotReady</title>
    <url>/iBlogWebsite/2020/07/08/2020/2020-07-08-%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%AE%B0%E5%BD%952%EF%BC%9A%E5%9C%A8%E7%BC%93%E5%AD%98%E5%A5%BD%E4%B8%A4%E4%B8%AAmtg%E6%8F%92%E5%B1%8F%E5%B9%BF%E5%91%8A%E5%90%8E%EF%BC%8C%E6%98%BE%E7%A4%BA%E9%98%B6%E6%AE%B5%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/wallpaper/2020-07-08.jpg?raw=true" alt="2020-07-08"></p>
<h1 id="1-现象"><a href="#1-现象" class="headerlink" title="1. 现象"></a>1. 现象</h1><p>成功缓存2个mtg广告，但显示第2个时失败报错：is not ready（can’t show because load fail），报错的详细日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">onShowFailure[mintegral_interstitial_ad] unitId is xxx, errorMessage is mtg interstitial video ad is not ready, errorCode is -2020007。</span><br></pre></td></tr></table></figure>

<h1 id="2-初步分析"><a href="#2-初步分析" class="headerlink" title="2. 初步分析"></a>2. 初步分析</h1><p>抓包+日志定位确定isNotReady有两种可能，①广告素材视频没下载完 ②广告间隔时间太长，offer过期。</p>
<ol>
<li>我这边只有等mtgSdk回调了onVideoLoadSuccess才会标记缓存成功，如果没有缓存成功都没有机会调用show，也就是没有机会调起isReady的判断。所以不存在已回调了onVideoLoadSuccess但是视频没下载完的情况，如若这样就是mtgSdk内部回调的重大bug</li>
<li>offer过期问题不存在，目前就是间隔几分钟</li>
</ol>
<span id="more"></span>

<h1 id="3-深入分析"><a href="#3-深入分析" class="headerlink" title="3. 深入分析"></a>3. 深入分析</h1><p>让mtg方提供日志，输出isReady为false的具体原因，此时输出了can’t show because load is failed。这个日志说明的是由于家在失败所以不能显示，跟我前面【现象】中描述的已成功缓存两个广告的事实冲突。经过多次沟通告知对方我们是一次缓存多个广告，分别是不同的广告对象发起loadAd。最终终于理清他们的内部逻辑。</p>
<ol>
<li>如果两个不同实例（A和B）请求到同一广告源（S），就会出现上面问题。因为在播放完一个广告（A）后，mtgSdk内部会在数据库中清除该广告源（S）。那么另一个广告实例（B）就showFailure</li>
<li>如果两个不同实例请求到不同广告源，就不会出现</li>
<li>mtgSdk没有处理多个实例缓存同一广告的功能</li>
</ol>
<h1 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h1><ol>
<li>接收目前这种方式并推进mtg处理这个问题 </li>
<li>缓存广告个数改为1</li>
</ol>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>针对一次发起两个缓存的场景，如果广告源是同一个，在展示完一个广告后，mtgSdk会在他们内部数据库中删掉该广告源的所有记录。这个操作会导致客户端展示第二个已缓存好的广告时找不到广告源数据，从而报错：can not show load fail。这个问题可以定为mtgSdk内部问题，他们提供了可以缓存多个广告的功能，但是内部却没有合适的处理缓存多个广告时拉到同一个广告源的情况，而简单粗暴的将广告源移除了。</p>
<p>其次站在使用者角度，既然能成功缓存到多个广告，那么期望就是都能展示成功，使用者不需要关心第1个，第2个，第n个广告是不是同源。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>疑难杂症</tag>
      </tags>
  </entry>
  <entry>
    <title>疑难杂症记录3：广告模块以及三方sdk同步升级androidx问题</title>
    <url>/iBlogWebsite/2020/07/10/2020/2020-07-10-%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%AE%B0%E5%BD%953%EF%BC%9A%E5%B9%BF%E5%91%8A%E6%A8%A1%E5%9D%97%E4%BB%A5%E5%8F%8A%E4%B8%89%E6%96%B9sdk%E5%90%8C%E6%AD%A5%E5%8D%87%E7%BA%A7androidx%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/wallpaper/2020-07-10.jpg?raw=true" alt="2020-07-10"></p>
<h1 id="1-现象"><a href="#1-现象" class="headerlink" title="1. 现象"></a>1. 现象</h1><p>广告模块引入了很多三方sdk，这里的问题体现在google的admob上，期望是将admob升级到18.3.0版本，结果主工程中由于引入了firebase，具体来讲就是admob和firebase都引入了google的基础服务gms，但版本没统一导致了Duplicate class的错误。</p>
<h1 id="2-解决过程"><a href="#2-解决过程" class="headerlink" title="2. 解决过程"></a>2. 解决过程</h1><h2 id="2-1-先处理广告SDK问题"><a href="#2-1-先处理广告SDK问题" class="headerlink" title="2.1 先处理广告SDK问题"></a>2.1 先处理广告SDK问题</h2><p>期望将admob升级到18.3.0版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">com.google.android.gms:play-services-ads:18.3.0</span><br></pre></td></tr></table></figure>
<p>这个版本里面使用了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">com.google.android.gms:play-services-measurement-base:17.1.0</span><br></pre></td></tr></table></figure>

<p>我们项目中还使用了两个google的服务框架，分别如下（已是最高版本了）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">com.google.android.gms:play-services-gcm:17.0.0</span><br><span class="line">com.google.firebase:firebase-core:17.0.0</span><br></pre></td></tr></table></figure>

<p>这两个包里面使用了com.google.android.gms:play-services-measurement-base:17.0.0，导致工程现在编译时报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Duplicate class com.google.android.gms.internal.measurement.zzio found <span class="keyword">in</span> modules classes.jar (com.google.android.gms:play-services-measurement-base:17.1.0) and classes.jar (com.google.android.gms:play-services-measurement:17.0.0)</span><br></pre></td></tr></table></figure>

<p>解决方法：将admob18.3.0降到18.0.0，因为这个版本里面是play-services-measurement-base:17.0.0</p>
<span id="more"></span>

<h2 id="2-2-再处理主工程中的问题"><a href="#2-2-再处理主工程中的问题" class="headerlink" title="2.2 再处理主工程中的问题"></a>2.2 再处理主工程中的问题</h2><p>上面已经定调了admob使用18.0.0，内部的play-services-measurement-base是17.0.0，更内部的firebase-iid是19.0.0。这个依赖是确定下来的了。</p>
<p>而在主工程中报错日志如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">In project <span class="string">&#x27;app&#x27;</span> a resolved Google Play services library dependency depends on another at an exact version (e.g. <span class="string">&quot;[17.0.4]&quot;</span>, but isn<span class="string">&#x27;t being resolved to that version. Behavior exhibited by the library will be unknown.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Dependency failing: com.google.firebase:firebase-messaging:17.3.4 -&gt; com.google.firebase:firebase-iid@[17.0.4], but firebase-iid version was 19.0.0.</span></span><br></pre></td></tr></table></figure>

<p>日志中说的也很清楚了，要将firebase-iid 17.0.4 升级到 19.0.0。下面要解决的问题是将com.google.firebase:firebase-messaging:17.3.4这个升级到内部依赖了firebase-iid version19.0.0的版本，通过在 <a href="https://mvnrepository.com/">https://mvnrepository.com/</a> 上查询搜索关键词：firebase-messaging，定位到firebase-messaging:19.0.0内部依赖了firebase-iid version19.0.0，那么在主工程中将firebase-messaging升级到19.0.0就将问题解决了。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/record-ad-androidx-synchronization-third-sdk.png?raw=true" alt="record-ad-androidx-synchronization-third-sdk"></p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>说实话，google下面的各类服务框架包纷繁复杂，版本又不统一，在同时引入多个google的服务框架时势必会遇到这种问题，那么后续解决该类问题的思路是怎样呢？<strong>总的思路是：先定一个核心服务的目标版本，然后其他服务适配该核心服务版本。</strong>比如确定了要将admob升级到18.3.0，那么非核心的服务就需要将其内部依赖的paly-service-base保持一致，基本上就不出现Duplicate class的问题。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>疑难杂症</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记之《Kotlin核心编程》</title>
    <url>/iBlogWebsite/2020/07/12/2020/2020-07-12-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8BKotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/readnote-kotlin-core-programming-cover.webp?raw=true" alt="readnote-kotlin-core-programming-cover"></p>
<h1 id="1-重点理解val的使用规则"><a href="#1-重点理解val的使用规则" class="headerlink" title="1. 重点理解val的使用规则"></a>1. 重点理解val的使用规则</h1><h2 id="1-1-引用1"><a href="#1-1-引用1" class="headerlink" title="1.1 引用1"></a>1.1 引用1</h2><ul>
<li>如果说var代表了varible（变量），那么val可看成value（值）的缩写。但也有人觉得这样并不直观或准确，而是把val解释成varible+final，即通过val声明的变量具有Java中的final关键字的效果，也就是引用不可变。</li>
<li>val声明的变量是只读变量，它的引用不可更改，但并不代表其引用对象也不可变。事实上，我们依然可以修改引用对象的可变成员。</li>
</ul>
<h2 id="1-2-引用2"><a href="#1-2-引用2" class="headerlink" title="1.2 引用2"></a>1.2 引用2</h2><ul>
<li>优先使用val来避免副作用</li>
<li>在很多Kotlin的学习资料中，都会传递一个原则：优先使用val来声明变量。这相当正确，但更好的理解可以是：<strong>尽可能采用val、不可变对象及纯函数(其实就是没有副作用的函数，具备引用透明性)来设计程序</strong>。</li>
</ul>
<span id="more"></span>

<h2 id="1-3-引用3"><a href="#1-3-引用3" class="headerlink" title="1.3 引用3"></a>1.3 引用3</h2><ul>
<li>然而，在Kotlin编程中，我们推荐优先使用val来声明一个本身不可变的变量，这在大部分情况下更具有优势：<ul>
<li>这是一种<strong>防御性的编码思维模式</strong>，更加安全和可靠，因为变量的值永远不会在其他地方被修改（一些框架采用反射技术的情况除外）；</li>
<li>不可变的变量意味着更加容易推理，越是复杂的业务逻辑，它的优势就越大。</li>
</ul>
</li>
</ul>
<h2 id="1-4-点评"><a href="#1-4-点评" class="headerlink" title="1.4 点评"></a>1.4 点评</h2><p>上面说的其实非常明确了，val声明的变量具有Java中的final关键字的效果，也就是引用不可变，但其引用的内容是可变的。其实这里扯出了两个概念对我来说更重要，一个是变量或函数的副作用，一个是防御性编程思维。</p>
<p>在后续编程中，会注意到变量副作用这块，尽量避免。而防御性思维其实一直都有，对于外部输入的参数，总是站在不可靠的角度上对待，从而写出可靠的代码。</p>
<h1 id="2-关于函数和Lambda"><a href="#2-关于函数和Lambda" class="headerlink" title="2. 关于函数和Lambda"></a>2. 关于函数和Lambda</h1><h2 id="2-1-引用1"><a href="#2-1-引用1" class="headerlink" title="2.1 引用1"></a>2.1 引用1</h2><ul>
<li>Kotlin天然支持了部分函数式特性。函数式语言一个典型的特征就在于<strong>函数是头等公民</strong>——我们不仅可以像类一样在顶层直接定义一个函数，也可以在一个函数内部定义一个局部函数。</li>
</ul>
<h2 id="2-2-引用2"><a href="#2-2-引用2" class="headerlink" title="2.2 引用2"></a>2.2 引用2</h2><p>所谓的高阶函数，你可以把它理解成“以其他函数作为参数或返回值的函数”。高阶函数是一种更加高级的抽象机制，它极大地增强了语言的表达能力。</p>
<h2 id="2-3-引用3"><a href="#2-3-引用3" class="headerlink" title="2.3 引用3"></a>2.3 引用3</h2><ul>
<li>Kotlin存在一种特殊的语法，通过两个冒号来实现对于某个类的方法进行引用。</li>
<li>为什么使用双冒号的语法？<ul>
<li>如果你了解C#，会知道它也有类似的方法引用特性，只是语法上不同，是通过点号来实现的。然而，C#的这种方式存在二义性，容易让人混淆方法引用表达式与成员表达式，所以Kotlin采用::（沿袭了Java 8的习惯），能够让我们更加清晰地认识这种语法。</li>
</ul>
</li>
</ul>
<h2 id="2-4-Lambda表达式，你可以把它理解成简化表达后的匿名函数，实质上它就是一种语法糖。"><a href="#2-4-Lambda表达式，你可以把它理解成简化表达后的匿名函数，实质上它就是一种语法糖。" class="headerlink" title="2.4 Lambda表达式，你可以把它理解成简化表达后的匿名函数，实质上它就是一种语法糖。"></a>2.4 Lambda表达式，你可以把它理解成简化表达后的匿名函数，实质上它就是一种语法糖。</h2><ul>
<li>一个Lambda表达式必须通过{}来包裹；</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -<span class="built_in">Int</span> = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -x + y &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果Lambda声明了参数部分的类型，且返回值类型支持类型推导，那么Lambda变量就可以省略函数类型声明；</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -x + y &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果Lambda变量声明了函数类型，那么Lambda的参数部分的类型就可以省略。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -<span class="built_in">Int</span> = &#123; x, y -x + y &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-区分函数、Lambda"><a href="#2-5-区分函数、Lambda" class="headerlink" title="2.5 区分函数、Lambda"></a>2.5 区分函数、Lambda</h2><ul>
<li>fun在没有等号、只有花括号的情况下，是我们最常见的代码块函数体，如果返回非Unit值，必须带return。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">foo</span><span class="params">(x: Int)</span> &#123; print(x) &#125;</span><br><span class="line">fun <span class="title function_">foo</span><span class="params">(x: Int, y: Int)</span>: Int &#123; <span class="keyword">return</span> x ＊ y &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>fun带有等号，是单表达式函数体。该情况下可以省略return。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">foo</span><span class="params">(x: Int, y: Int)</span> = x + y</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>不管是用val还是fun，如果是等号加花括号的语法，那么构建的就是一个Lambda表达式</strong>，Lambda的参数在花括号内部声明。所以，如果左侧是fun，那么就是Lambda表达式函数体，也必须通过()或invoke来调用Lambda。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">foo</span> <span class="operator">=</span> &#123; x: Int, y: Int -x + y &#125; <span class="comment">// foo.invoke(1, 2)或foo(1, 2)</span></span><br><span class="line">fun <span class="title function_">foo</span><span class="params">(x: Int)</span> = &#123; y: Int -x + y &#125; <span class="comment">// foo(1).invoke(2)或foo(1)(2)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-点评"><a href="#2-6-点评" class="headerlink" title="2.6 点评"></a>2.6 点评</h2><p>这部分内容对我个人而言，是区分函数和lambda。之前没有仔细思考扩这个问题，一直是凭着感觉来。这次算是理清楚了：如果是等号加花括号的语法，那么构建的就是一个Lambda表达式。那么调用时就必须通过()或invoke来实现。</p>
<p>还有一点是对<strong>函数是头等公民</strong>的理解，之前也听过这句话，但是具体体现在哪不得而知。你见过在Java中，函数里面在定义一个函数吗？你见过在Java类外部定义一个函数吗？没有吧，因为Java中对象是头等公民。而Kt中你可以在函数中再定义函数，再类顶层定义函数，这就是区别。</p>
<h1 id="3-表达式"><a href="#3-表达式" class="headerlink" title="3. 表达式"></a>3. 表达式</h1><h2 id="3-1-闭区间和半开区间"><a href="#3-1-闭区间和半开区间" class="headerlink" title="3.1 闭区间和半开区间"></a>3.1 闭区间和半开区间</h2><ul>
<li>.. 表示闭区间</li>
<li>until 表示半开区间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i in <span class="number">1</span> until <span class="number">10</span>)&#123;</span><br><span class="line">    print(i) <span class="comment">// 123456789</span></span><br><span class="line">&#125;</span><br><span class="line">println()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i in <span class="number">1.</span><span class="number">.10</span>)&#123;</span><br><span class="line">    print(i) <span class="comment">// 12345678910</span></span><br><span class="line">&#125;</span><br><span class="line">println()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i in <span class="number">0.</span><span class="number">.0</span>)&#123;</span><br><span class="line">    print(i) <span class="comment">// output 0</span></span><br><span class="line">&#125;</span><br><span class="line">println()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i in <span class="number">0</span> until <span class="number">0</span>)&#123;</span><br><span class="line">    print(i) <span class="comment">// nothing </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-点评"><a href="#3-2-点评" class="headerlink" title="3.2 点评"></a>3.2 点评</h2><p>关于until半开区间的特性，自己还在工作过程中犯过一个错误，需求其实很简单，就是在一个范围内获取一个随机数，但是当你写出这句时 *(0 until 0).random()*，就有bug在等着你了。</p>
<p>上面实例代码中其实做了实验，打印 <em>0 until 0</em> 是没有任何内容输出的，再去向无任何输出内容的表达式要一个随机数，编译器不报错能干嘛呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">print((<span class="number">0</span> until <span class="number">0</span>).random()) <span class="comment">// Exception in thread &quot;main&quot; java.util.NoSuchElementException: Cannot get random in empty range: 0..-1</span></span><br><span class="line">print((<span class="number">0.</span><span class="number">.0</span>).random()) <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure>

<h1 id="4-init语句块"><a href="#4-init语句块" class="headerlink" title="4. init语句块"></a>4. init语句块</h1><h2 id="4-1-语句块中没有val、var"><a href="#4-1-语句块中没有val、var" class="headerlink" title="4.1 语句块中没有val、var"></a>4.1 语句块中没有val、var</h2><p>Kotlin引入了一种叫作init语句块的语法，它属于构造方法的一部分，两者在表现形式上却是分离的。Bird类的构造方法在类的外部，它只能对参数进行赋值。如果我们需要在初始化时进行其他的额外操作，那么我们就可以使用init语句块来执行。</p>
<p>当没有val或var的时候，构造方法的参数可以在init语句块被直接调用。其实它们还可以用于初始化类内部的属性成员的情况。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(weight: <span class="built_in">Double</span> = <span class="number">0.00</span>, age: <span class="built_in">Int</span> = <span class="number">0</span>,color: String = <span class="string">&quot;blue&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> weight: <span class="built_in">Double</span> = weight <span class="comment">//在初始化属性成员时调用weight</span></span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> = age</span><br><span class="line">    <span class="keyword">val</span> color: String = color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，我们并不能在其他地方使用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(weight: <span class="built_in">Double</span>, age: <span class="built_in">Int</span>, color: String) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printWeight</span><span class="params">()</span></span> &#123;</span><br><span class="line">        print(weight) <span class="comment">// Unresolved reference: weight</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，我们的构造方法还可以拥有多个init，它们会在对象被创建时按照类中从上到下的顺序先后执行。多个init语句块有利于我们进一步对初始化的操作进行职能分离，这在复杂的业务开发（如Android）中显得特别有用。</p>
<h2 id="4-2-语句块中有val、var"><a href="#4-2-语句块中有val、var" class="headerlink" title="4.2 语句块中有val、var"></a>4.2 语句块中有val、var</h2><p>我们在Bird类中可以用val或者var来声明构造方法的参数。这一方面代表了参数的引用可变性，另一方面它也使得我们在构造类的语法上得到了简化。</p>
<p>为什么这么说呢？事实上，构造方法的参数名前当然可以没有val和var，然而带上它们之后就等价于在Bird类内部声明了一个同名的属性，我们可以用this来进行调用。比如我们前面定义的Bird类就类似于以下的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(weight: Double = <span class="number">0.00</span>, <span class="comment">// 参数名前没有val</span></span><br><span class="line">        age: Int = <span class="number">0</span>,</span><br><span class="line">        color: String = <span class="string">&quot;blue&quot;</span>) &#123;</span><br><span class="line">    val weight: Double</span><br><span class="line">    val age: Int</span><br><span class="line">    val color: String</span><br><span class="line">    init &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight <span class="comment">// 构造方法参数可以在init语句块被调用</span></span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">        <span class="built_in">this</span>.color = color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-点评"><a href="#4-3-点评" class="headerlink" title="4.3 点评"></a>4.3 点评</h2><p>这一部分的内容对我个人而言是知识盲区，这次算是补上了。用val或var修饰的构造方法参数，实际上等价于在类内部声明了一个同名属性，可以用this进行调用。</p>
<h1 id="5-关于延迟初始化"><a href="#5-关于延迟初始化" class="headerlink" title="5. 关于延迟初始化"></a>5. 关于延迟初始化</h1><h2 id="5-1-总结by-lazy语法的特点如下"><a href="#5-1-总结by-lazy语法的特点如下" class="headerlink" title="5.1 总结by lazy语法的特点如下"></a>5.1 总结by lazy语法的特点如下</h2><ul>
<li>该变量必须是引用不可变的，而不能通过var来声明。</li>
<li>在被首次调用时，才会进行赋值操作。一旦被赋值，后续它将不能被更改。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(val weight: Double, val age: Int, val color: String) &#123;</span><br><span class="line">    val sex: String by lazy &#123;</span><br><span class="line">        <span class="keyword">if</span> (color == <span class="string">&quot;yellow&quot;</span>) <span class="string">&quot;male&quot;</span> <span class="keyword">else</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外系统会给lazy属性默认加上同步锁，也就是LazyThreadSafetyMode.SYNCHRONIZED，它在同一时刻只允许一个线程对lazy属性进行初始化，所以它是线程安全的。但若你能确认该属性可以并行执行，没有线程安全问题，那么可以给lazy传递LazyThreadSafetyMode.PUBLICATION参数。你还可以给lazy传递LazyThreadSafetyMode. NONE参数，这将不会有任何线程方面的开销，当然也不会有任何线程安全的保证。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val sex: String by <span class="title function_">lazy</span><span class="params">(LazyThreadSafetyMode.PUBLICATION)</span> &#123;</span><br><span class="line">    <span class="comment">//并行模式</span></span><br><span class="line">    <span class="keyword">if</span> (color == <span class="string">&quot;yellow&quot;</span>) <span class="string">&quot;male&quot;</span> <span class="keyword">else</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val sex: String by <span class="title function_">lazy</span><span class="params">(LazyThreadSafetyMode.NONE)</span> &#123;</span><br><span class="line">    <span class="comment">//不做任何线程保证也不会有任何线程开销</span></span><br><span class="line">    <span class="keyword">if</span> (color == <span class="string">&quot;yellow&quot;</span>) <span class="string">&quot;male&quot;</span> <span class="keyword">else</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-总结lateinit语法特点如下"><a href="#5-2-总结lateinit语法特点如下" class="headerlink" title="5.2 总结lateinit语法特点如下"></a>5.2 总结lateinit语法特点如下</h2><ul>
<li>主要用于var声明的变量，然而它不能用于基本数据类型，如Int、Long等，我们需要用Integer这种包装类作为替代。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(val weight: Double, val age: Int, val color: String) &#123;</span><br><span class="line">    lateinit <span class="keyword">var</span> sex: String <span class="comment">// sex可以延迟初始化</span></span><br><span class="line">    fun <span class="title function_">printSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = <span class="keyword">if</span> (<span class="built_in">this</span>.color == <span class="string">&quot;yellow&quot;</span>) <span class="string">&quot;male&quot;</span> <span class="keyword">else</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">        println(<span class="built_in">this</span>.sex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun <span class="title function_">main</span><span class="params">(args: Array&lt;String&gt;)</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">bird</span> <span class="operator">=</span> Bird(<span class="number">1000.0</span>, <span class="number">2</span>, <span class="string">&quot;bule&quot;</span>)</span><br><span class="line">    bird.printSex()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">female</span><br></pre></td></tr></table></figure>

<h2 id="5-3-var基本数据类型也具有延迟初始化的效果"><a href="#5-3-var基本数据类型也具有延迟初始化的效果" class="headerlink" title="5.3 var基本数据类型也具有延迟初始化的效果"></a>5.3 var基本数据类型也具有延迟初始化的效果</h2><p>你可能比较好奇，如何让用var声明的基本数据类型变量也具有延迟初始化的效果，一种可参考的解决方案是通过Delegates.notNull<T>，这是利用Kotlin中委托的语法来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test by Delegates.notNull&lt;Int&gt;()</span><br><span class="line">fun <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    test = <span class="number">1</span></span><br><span class="line">    println(<span class="string">&quot;test value is $&#123;test&#125;&quot;</span>)</span><br><span class="line">    test = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-点评"><a href="#5-4-点评" class="headerlink" title="5.4 点评"></a>5.4 点评</h2><p>这块主要是总结by lazy和lateinit的区别，根据两者的区别选择合适的延迟方案很重要。简单粗暴一点就是by lazy对应val，lateint对应var。</p>
<h1 id="6-可见性修饰符"><a href="#6-可见性修饰符" class="headerlink" title="6. 可见性修饰符"></a>6. 可见性修饰符</h1><h2 id="6-1-4种可见行修饰符"><a href="#6-1-4种可见行修饰符" class="headerlink" title="6.1 4种可见行修饰符"></a>6.1 4种可见行修饰符</h2><p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/readnote-kotlin-core-programming-6-visibility-modifier.png?raw=true" alt="readnote-kotlin-core-programming-6-visibility-modifier"></p>
<p>Kotlin中的可见性修饰符也与Java中的很类似。但也有不一样的地方，主要有以下几点：</p>
<ul>
<li>Kotlin与Java的默认修饰符不同，Kotlin中是public，而Java中是default，它只允许包内访问。</li>
<li>Kotlin中有一个独特的修饰符internal。</li>
<li>Kotlin可以在一个文件内单独声明方法及常量，同样支持可见性修饰符。</li>
<li>Java中除了内部类可以用private修饰以外，其他类都不允许private修饰，而Kotlin可以。</li>
<li>Kotlin和Java中的protected的访问范围不同，Java中是包、类及子类可访问，而Kotlin只允许类及子类。</li>
</ul>
<h3 id="关于internal"><a href="#关于internal" class="headerlink" title="关于internal"></a><strong>关于internal</strong></h3><p>Kotlin中有一个独特的修饰符internal，和default有点像但也有所区别。internal在Kotlin中的作用域可以被称作“模块内访问”。那么到底什么算是模块呢？以下几种情况可以算作一个模块</p>
<ul>
<li>一个Eclipse项目</li>
<li>一个Intellij IDEA项目</li>
<li>一个Maven项目</li>
<li>一个Grandle项目</li>
<li>一组由一次Ant任务执行编译的代码</li>
</ul>
<p>总的来说，一个模块可以看作一起编译的Kotlin文件组成的集合。那么，Kotlin中为什么要诞生这么一种新的修饰符呢？Java的包内访问不好吗？</p>
<p>Java的包内访问中确实存在一些问题。举个例子，假如你在Java项目中定义了一个类，使用了默认修饰符，那么现在这个类是包私有，其他地方将无法访问它。然后，你把它打包成一个类库，并提供给其他项目使用，这时候如果有个开发者想使用这个类，<strong>除了copy源代码以外，还有一个方式就是在程序中创建一个与该类相同名字的包</strong>，那么这个包下面的其他类就可以直接使用我们前面的定义的类。这样我们便可以直接访问该类了。</p>
<p>而Kotlin默认并没有采用这种包内可见的作用域，而是使用了模块内可见，<strong>模块内可见指的是该类只对一起编译的其他Kotlin文件可见。开发工程与第三方类库不属于同一个模块，这时如果还想使用该类的话只有复制源码一种方式了</strong>。这便是Kotlin中internal修饰符的一个作用体现。</p>
<h3 id="关于private"><a href="#关于private" class="headerlink" title="关于private"></a><strong>关于private</strong></h3><p>在Java程序中，我们很少见到用private修饰的类，因为Java中的类或方法没有单独属于某个文件的概念。比如，我们创建了Rectangle.java这个文件，那么它里面的类要么是public，要么是包私有，而没有只属于这个文件的概念。若要用private修饰，那么这个只能是其他类的内部类。而Kotlin中则可以用private给单独的类修饰，它的作用域就是当前这个Kotlin文件。</p>
<h3 id="关于protected"><a href="#关于protected" class="headerlink" title="关于protected"></a><strong>关于protected</strong></h3><p>Java中的protected修饰的内容作用域是包内、类及子类可访问，而在Kotlin中，由于没有包作用域的概念，所以protected修饰符在Kotlin中的作用域只有类及子类。</p>
<p>在了解了Kotlin中的可见修饰符后，我们来思考一个问题：前面已经讲解了为什么要诞生internal这个修饰符，那么为什么Kotlin中默认的可见性修饰符是public，而不是internal呢？</p>
<p>关于这一点，Kotlin的开发人员在官方论坛进行了说明，这里我做一个总结：Kotlin通过分析以往的大众开发的代码，发现使用public修饰的内容比其他修饰符的内容多得多，所以Kotlin为了保持语言的简洁性，考虑多数情况，最终决定将public当作默认修饰符。</p>
<h2 id="6-2-点评"><a href="#6-2-点评" class="headerlink" title="6.2 点评"></a>6.2 点评</h2><p>Kotlin与Java的可见性修饰符比较这一部分是我强烈推荐仔细阅读的部分，可见性修饰符虽然简单但却非常重要，kotlin的internal、private、protected修饰符都有自身独特的特点，跟你原本掌握的Java有很大的不同。</p>
<p>对比学习可能会让我们对两门语言的理解层次更深。</p>
<p>Kotlin中没有包内可见这种作用域，转而代之的是模块内可见，这种方式对比Java中的包内可见在某种意义上可能会更加“安全”。</p>
<p>另一边Java中某个类或方法没有单独属于某个文件的概念，而Kotlin中则可以用private单独修饰某个类，它的作用域就是当前这个kotlin文件，这种设计在我看来可能会让你更加能精准控制某个类的访问权限。</p>
<h1 id="7-getter和setter"><a href="#7-getter和setter" class="headerlink" title="7. getter和setter"></a>7. getter和setter</h1><ul>
<li>用val声明的属性将只有getter方法，因为它不可修改；而用var修饰的属性将同时拥有getter和setter方法。</li>
<li>用private修饰的属性编译器将会省略getter和setter方法，因为在类外部已经无法访问它了，这两个方法的存在也就没有意义了。</li>
</ul>
<h1 id="8-内部类vs嵌套类"><a href="#8-内部类vs嵌套类" class="headerlink" title="8. 内部类vs嵌套类"></a>8. 内部类vs嵌套类</h1><p>众所周知，在Java中，我们通过在内部类的语法上增加一个static关键词，把它变成一个嵌套类。然而，Kotlin则是相反的思路，默认是一个嵌套类，必须加上inner关键字才是一个内部类，也就是说可以把静态的内部类看成嵌套类。</p>
<p>内部类和嵌套类有明显的差别，具体体现在：内部类包含着对其外部类实例的引用，在内部类中我们可以使用外部类中的属性；而嵌套类不包含对其外部类实例的引用，所以它无法调用其外部类的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">open <span class="keyword">class</span> <span class="title class_">Horse</span> &#123; <span class="comment">//马</span></span><br><span class="line">    fun <span class="title function_">runFast</span><span class="params">()</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I can run fast&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">open <span class="keyword">class</span> <span class="title class_">Donkey</span> &#123; <span class="comment">//驴</span></span><br><span class="line">    fun <span class="title function_">doLongTimeThing</span><span class="params">()</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I can do some thing long time&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mule</span> &#123;  <span class="comment">//骡子</span></span><br><span class="line">    fun <span class="title function_">runFast</span><span class="params">()</span> &#123;</span><br><span class="line">        HorseC().runFast()</span><br><span class="line">    &#125;</span><br><span class="line">    fun <span class="title function_">doLongTimeThing</span><span class="params">()</span> &#123;</span><br><span class="line">        DonkeyC().doLongTimeThing()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> inner <span class="keyword">class</span> <span class="title class_">HorseC</span> : Horse()</span><br><span class="line">    <span class="keyword">private</span> inner <span class="keyword">class</span> <span class="title class_">DonkeyC</span> : Donkey()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-数据类的约定与使用"><a href="#9-数据类的约定与使用" class="headerlink" title="9. 数据类的约定与使用"></a>9. 数据类的约定与使用</h1><p>如果你要在Kotlin声明一个数据类，必须满足以下几点条件：</p>
<ul>
<li>数据类必须拥有一个构造方法，该方法至少包含一个参数，一个没有数据的数据类是没有任何用处的；</li>
<li>与普通的类不同，数据类构造方法的参数强制使用var或者val进行声明；</li>
<li><strong>data class之前不能用abstract、open、sealed或者inner进行修饰；</strong></li>
<li>在Kotlin1.1版本前数据类只允许实现接口，之后的版本既可以实现接口也可以继承类。</li>
</ul>
<h1 id="10-何谓伴生"><a href="#10-何谓伴生" class="headerlink" title="10. 何谓伴生"></a>10. 何谓伴生</h1><p>顾名思义，“伴生”是相较于一个类而言的，意为伴随某个类的对象，它属于这个类所有，因此伴生对象跟Java中static修饰效果性质一样，全局只有一个单例。它需要声明在类的内部，在类被装载时会被初始化。</p>
<h1 id="11-关于泛型"><a href="#11-关于泛型" class="headerlink" title="11. 关于泛型"></a>11. 关于泛型</h1><h2 id="11-1-关于协变"><a href="#11-1-关于协变" class="headerlink" title="11.1 关于协变"></a>11.1 <strong>关于协变</strong></h2><p>普通方式定义的泛型是不变的，简单来说就是不管类型A和类型B是什么关系，Generic&lt;A&gt;与Generic&lt;B&gt;（其中Generic代表泛型类）都没有任何关系。比如，在Java中String是Oject的子类型，但List&lt;String&gt;并不是List&lt;Object&gt;的子类型，在Kotlin中泛型的原理也是一样的。但是，Kotlin的List为什么允许List&lt;String&gt;赋值给List&lt;Any&gt;呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;<span class="type">Eextends Collection&lt;E</span>&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;<span class="type">out E: Collection&lt;E</span>&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键在于这两个List并不是同一种类型。<strong>如果在定义的泛型类和泛型方法的泛型参数前面加上out关键词，说明这个泛型类及泛型方法是协变，简单来说类型A是类型B的子类型，那么Generic&lt;A&gt;也是Generic&lt;B&gt;的子类型</strong>，比如在Kotlin中String是Any的子类型，那么List&lt;String&gt;也是List&lt;Any&gt;的子类型，所以List&lt;String&gt;可以赋值给List&lt;Any&gt;。</p>
<p>List协变的特点是它将无法添加元素，只能从里面读取内容。假如支持协变的List允许插入新对象，那么它就不再是类型安全的了，也就违背了泛型的初衷。</p>
<p>所以我们可以得出结论：支持协变的List只可以读取，而不可以添加。其实从out这个关键词也可以看出，out就是出的意思，可以理解为List是一个只读列表。在Java中也可以声明泛型协变，用通配符及泛型上界来实现协变：&lt;? extends Object&gt;，其中Object可以是任意类。</p>
<h2 id="11-2-关于逆变"><a href="#11-2-关于逆变" class="headerlink" title="11.2 关于逆变"></a>11.2 <strong>关于逆变</strong></h2><p><strong>简单来说，假若类型A是类型B的子类型，那么Generic&lt;B&gt;反过来是Generic&lt;A&gt;的子类型。</strong></p>
<p>前面我们说过，用out关键字声明的泛型参数类型将不能作为方法的参数类型，但可以作为方法的返回值类型，而in刚好相反。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">WirteableList</span>&lt;in T&gt;&#123;</span><br><span class="line">    fun <span class="title function_">get</span><span class="params">(index: Int)</span>: T    <span class="comment">//Type parameter T is declared as &#x27;in&#x27; but occurs in &#x27;out&#x27; position in type T</span></span><br><span class="line"></span><br><span class="line">    fun <span class="title function_">get</span><span class="params">(index: Int)</span>: Any   <span class="comment">//允许</span></span><br><span class="line"></span><br><span class="line">    fun <span class="title function_">add</span><span class="params">(t: T)</span>: Int <span class="comment">//允许</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不能将泛型参数类型当作方法返回值的类型，但是作为方法的参数类型没有任何限制，其实从in这个关键词也可以看出，in就是入的意思，可以理解为消费内容，所以我们可以将这个列表看作一个可写、可读功能受限的列表，获取的值只能为Any类型。在Java中使用&lt;? super T&gt;可以达到相同效果。</p>
<p>Kotlin与Java的型变比较<br><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/readnote-kotlin-core-programming-11-comparison-of-kotlin-and-java-type-changes.jpeg?raw=true" alt="readnote-kotlin-core-programming-11-comparison-of-kotlin-and-java-type-changes"></p>
<h2 id="11-3-关于通配符"><a href="#11-3-关于通配符" class="headerlink" title="11.3 关于通配符"></a>11.3 <strong>关于通配符</strong></h2><p>MutableList&lt;*&gt;与MutableList&lt;Any?&gt;不是同一种列表，后者可以添加任意元素，而前者只是通配某一种类型，但是编译器却不知道这是一种什么类型，所以它不允许向这个列表中添加元素，因为这样会导致类型不安全。</p>
<p>不过细心的读者应该发现前面所说的协变也是不能添加元素，那么它们两者之间有什么关系呢？其实通配符只是一种语法糖，背后上也是用协变来实现的。所以MutableList&lt;*&gt;本质上就是MutableList&lt;out Any?&gt;，使用通配符与协变有着一样的特性。</p>
<h2 id="11-4-点评"><a href="#11-4-点评" class="headerlink" title="11.4 点评"></a>11.4 点评</h2><p>这一小节对于理解泛型的型变有很大的帮助，不过前提是你需要先理解Java中的PECS原则（Producer Extends Consumer Super），再阅读下面的协变和逆变就会轻松不少，其中的示例代码好评。</p>
<p>协变和逆变描述的就是在集合中，子类与父类之间的转换关系。协变即子类集合可赋值给父类集合，逆变即父类集合可赋值给子类集合，这是他们最大的特点。只是由于Java本身泛型的擦除特性，整出了一些副作用，如：协变不可添加元素，逆变读取元素不安全；协变不可作为入参，逆变不可作为返回值等副作用。</p>
<p>Java泛型是高阶知识，对于开发框架有很大的帮助，属于进阶必备技能。泛型的详细知识可参考 <a href="https://www.jianshu.com/p/716e941b3128">https://www.jianshu.com/p/716e941b3128</a> 里面的2.12小节。</p>
<h1 id="12-关于惰性求值"><a href="#12-关于惰性求值" class="headerlink" title="12. 关于惰性求值"></a>12. 关于惰性求值</h1><h2 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h2><p>在编程语言理论中，惰性求值（Lazy Evaluation）表示一种在需要时才进行求值的计算方式。在使用惰性求值的时候，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用时才去求值。通过这种方式，不仅能得到性能上的提升，还有一个最重要的好处就是它可以构造出一个无限的数据类型。</p>
<p>通过上面的定义我们可以简单归纳出惰性求值的两个好处，一个是优化性能，另一个就是能够构造出无限的数据类型。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list.asSequence().filter &#123;it <span class="number">2</span>&#125;.map &#123;it ＊ <span class="number">2</span>&#125;.toList()</span><br></pre></td></tr></table></figure>

<p>其实，Kotlin中序列的操作就分为两类，一类是中间操作，另一类则为末端操作。</p>
<h2 id="12-2-中间操作"><a href="#12-2-中间操作" class="headerlink" title="12.2 中间操作"></a>12.2 中间操作</h2><p>在对普通集合进行链式操作的时候，有些操作会产生中间集合，当用这类操作来对序列进行求值的时候，它们就被称为中间操作，比如上面的filter和map。每一次中间操作返回的都是一个序列，产生的新序列内部知道如何去变换原来序列中的元素。中间操作都是采用惰性求值的</p>
<h2 id="12-3-末端操作"><a href="#12-3-末端操作" class="headerlink" title="12.3 末端操作"></a>12.3 末端操作</h2><p>在对集合进行操作的时候，大部分情况下，我们在意的只是结果，而不是中间过程。末端操作就是一个返回结果的操作，它的返回值不能是序列，必须是一个明确的结果，比如列表、数字、对象等表意明确的结果。末端操作一般都放在链式操作的末尾，在执行末端操作的时候，会去触发中间操作的延迟计算，也就是将“被需要”这个状态打开了。</p>
<p><strong>普通集合在进行链式操作的时候会先在list上调用filter，然后产生一个结果列表，接下来map就在这个结果列表上进行操作。而序列则不一样，序列在执行链式操作的时候，会将所有的操作都应用在一个元素上，也就是说，第1个元素执行完所有的操作之后，第2个元素再去执行所有的操作，以此类推。</strong></p>
<h1 id="13-内联函数简化抽象工厂"><a href="#13-内联函数简化抽象工厂" class="headerlink" title="13. 内联函数简化抽象工厂"></a>13. 内联函数简化抽象工厂</h1><h2 id="13-1-抽象工厂示例"><a href="#13-1-抽象工厂示例" class="headerlink" title="13.1 抽象工厂示例"></a>13.1 抽象工厂示例</h2><p>何为抽象工厂模式？即为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Computer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dell</span> : <span class="type">Computer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Asus</span> : <span class="type">Computer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Acer</span> : <span class="type">Computer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: Computer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(factory: <span class="type">AbstractFactory</span>)</span></span>: AbstractFactory &#123;</span><br><span class="line">            <span class="keyword">return</span> factory</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DellFactory</span> : <span class="type">AbstractFactory</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> = Dell()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsusFactory</span> : <span class="type">AbstractFactory</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> = Asus()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AcerFactory</span> : <span class="type">AbstractFactory</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> = Acer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory2</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: Computer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span>: <span class="title">Computerinvoke</span><span class="params">()</span></span>: AbstractFactory2 =</span><br><span class="line">                <span class="keyword">when</span> (T::<span class="keyword">class</span>) &#123;</span><br><span class="line">                    Dell::<span class="keyword">class</span> -DellFactory2()</span><br><span class="line">                    Asus::<span class="keyword">class</span> -AsusFactory2()</span><br><span class="line">                    Acer::<span class="keyword">class</span> -AcerFactory2()</span><br><span class="line">                    <span class="keyword">else</span> -<span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DellFactory2</span> : <span class="type">AbstractFactory2</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> = Dell()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsusFactory2</span> : <span class="type">AbstractFactory2</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> = Asus()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AcerFactory2</span> : <span class="type">AbstractFactory2</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> = Acer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testAbsFactory()</span><br><span class="line">    testAbsFactory2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testAbsFactory2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Kotlin中的内联函数来改善每次都要传入工厂类对象的做法</span></span><br><span class="line">    <span class="keyword">val</span> dellFactory = AbstractFactory2&lt;Dell&gt;()</span><br><span class="line">    <span class="keyword">val</span> dell = dellFactory.produce()</span><br><span class="line">    println(dell)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testAbsFactory</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当你每次创建具体的工厂类时，都需要传入一个具体的工厂类对象作为参数进行构造，这个在语法上显然不是很优雅</span></span><br><span class="line">    <span class="keyword">val</span> dellFactory = AbstractFactory(DellFactory())</span><br><span class="line">    <span class="keyword">val</span> dell = dellFactory.produce()</span><br><span class="line">    println(dell)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Kotlin语法的简洁，以上例子的抽象工厂类的设计也比较直观。然而，当你每次创建具体的工厂类时(AbstractFactory)，都需要传入一个具体的工厂类对象作为参数进行构造，这个在语法上显然不是很优雅。而AbstractFactory2就是利用Kotlin中的内联函数来改善这一情况。我们所需要做的，就是用inline+reified重新实现AbstractFactory2类中的invoke方法。</p>
<p>这下我们的AbstractFactory2类中的invoke方法定义的前缀变长了很多，但是不要害怕，如果你已经掌握了内联函数的具体应用，应该会很容易理解它。我们来分析下这段代码：</p>
<ol>
<li>通过将invoke方法用inline定义为内联函数，我们就可以引入reified关键字，使用具体化参数类型的语法特性；</li>
<li>要具体化的参数类型为Computer，在invoke方法中我们通过判断它的具体类型，来返回对应的工厂类对象。</li>
</ol>
<p>现在我们终于可以用类似创建一个泛型类对象的方式，来构建一个抽象工厂具体对象了。不管是工厂方法还是抽象工厂，利用Kotlin的语言特性，我们在一定程度上改进、简化了Java中设计模式的实现。</p>
<h2 id="13-2-点评"><a href="#13-2-点评" class="headerlink" title="13.2 点评"></a>13.2 点评</h2><p>这一节的知识点在实际工作中有很大的用处，inline结合reified，实现具体化类型参数。对比Java，kt在这块确实抗打，代码写出来又进一步优雅了呢。</p>
<h1 id="14-构建者模式的不足"><a href="#14-构建者模式的不足" class="headerlink" title="14. 构建者模式的不足"></a>14. 构建者模式的不足</h1><ul>
<li>如果业务需求的参数很多，代码依然会显得比较冗长；</li>
<li>你可能会在使用Builder的时候忘记在最后调用build方法；</li>
<li>由于在创建对象的时候，必须先创建它的构造器，因此额外增加了多余的开销，在某些十分注重性能的情况下，可能就存在一定的问题。</li>
</ul>
<h1 id="15-by关键字简化装饰者模式"><a href="#15-by关键字简化装饰者模式" class="headerlink" title="15. by关键字简化装饰者模式"></a>15. by关键字简化装饰者模式</h1><h2 id="15-1-装饰者模式概念"><a href="#15-1-装饰者模式概念" class="headerlink" title="15.1 装饰者模式概念"></a>15.1 装饰者模式概念</h2><p>装饰者模式，在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。该模式通过创建一个包装对象，来包裹真实的对象。</p>
<p>总结来说，装饰者模式做的是以下几件事情：</p>
<ul>
<li>创建一个装饰类，包含一个需要被装饰类的实例；</li>
<li>装饰类重写所有被装饰类的方法；</li>
<li>在装饰类中对需要增强的功能进行扩展。</li>
</ul>
<p>可以发现，装饰者模式很大的优势在于符合“组合优于继承”的设计原则，规避了某些场景下继承所带来的问题。然而，它有时候也会显得比较啰唆，因为要重写所有的装饰对象方法，所以可能存在大量的样板代码。</p>
<p>在Kotlin中，我们可以让装饰者模式的实现变得更加优雅。猜想你已经想到了它的类委托特性，我们可以利用by关键字，将装饰类的所有方法委托给一个被装饰的类对象，然后只需覆写需要装饰的方法即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MacBook</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCost</span><span class="params">()</span></span>: <span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getDesc</span><span class="params">()</span></span>: String</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getProdDate</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacBookPro</span> : <span class="type">MacBook</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCost</span><span class="params">()</span></span> = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDesc</span><span class="params">()</span></span> = <span class="string">&quot;Macbook Pro&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getProdDate</span><span class="params">()</span></span> = <span class="string">&quot;Late 2019&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProcessorUpgradeMacBookPro</span>(<span class="keyword">private</span> <span class="keyword">val</span> macBook: MacBook) : MacBook <span class="keyword">by</span> macBook &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCost</span><span class="params">()</span></span> = macBook.getCost() + <span class="number">219</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDesc</span><span class="params">()</span></span> = macBook.getDesc() + <span class="string">&quot;, +1G Memory&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> macBookPro = MacBookPro()</span><br><span class="line">    <span class="keyword">val</span> processorUpgradeMacBookPro = ProcessorUpgradeMacBookPro(macBookPro)</span><br><span class="line">    println(processorUpgradeMacBookPro.getCost())</span><br><span class="line">    println(processorUpgradeMacBookPro.getDesc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码所示，我们创建一个代表MacBook Pro的类，它实现了MacBook的接口的3个方法，分别表示它的预算、机型信息，以及生产的年份。当你觉得原装MacBook的内存配置不够的时候，希望再加入一条1G的内存，这时候配置信息和预算方法都会受到影响。</p>
<p>所以通过Kotlin的类委托语法，我们实现了一个ProcessorUpgradeMacbookPro类，该类会把MacBook接口所有的方法都委托给构造参数对象macbook。因此，我们只需通过覆写的语法来重写需要变更的cost和getDesc方法。由于生产年份是不会改变的，所以不需重写，ProcessorUpgradeMacbookPro类会自动调用装饰对象的getProdDate方法。</p>
<p>总的来说，Kotlin通过类委托的方式减少了装饰者模式中的样板代码，否则在不继承Macbook类的前提下，我们得创建一个装饰类和被装饰类的公共父抽象类。</p>
<h2 id="15-2"><a href="#15-2" class="headerlink" title="15.2"></a>15.2</h2><p>装饰者模式问题所在：要重写所有的装饰对象的方法。这也就极大的限制了其使用场景，有时候还不如继承来的实在。但kt中，通过by关键字委托给一个对象，完全化解了这波尴尬，只能说kt语法实在是高。</p>
<h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><p>看完书以后整理的笔记大纲</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2020/code/readnote-kotlin-core-programming-16-easter-eggs.jpeg?raw=true" alt="readnote-kotlin-core-programming-16-easter-eggs"></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之性能优化整理</title>
    <url>/iBlogWebsite/2017/01/04/2017/2017-01-04-Android%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>2017年第一篇日志：【性能优化】知识汇总新鲜出炉，包括UI和组件的优化、图片的优化、线程优化、内存优化以及响应速度及卡顿优化，知道内存泄漏和内存溢出的区别吗？知道图片放错drawable文件夹导致失真的问题吗？赶紧瞅一瞅吧。</p>
<h1 id="1-UI和组件的优化"><a href="#1-UI和组件的优化" class="headerlink" title="1. UI和组件的优化"></a>1. UI和组件的优化</h1><h2 id="1-1-Android中常见的度量单位"><a href="#1-1-Android中常见的度量单位" class="headerlink" title="1.1. Android中常见的度量单位"></a>1.1. Android中常见的度量单位</h2><h3 id="1-1-1-inch"><a href="#1-1-1-inch" class="headerlink" title="1.1.1. inch"></a>1.1.1. inch</h3><p>它表示设备的物理屏幕的对角线长度，其中1 inch = 2.54 cm。</p>
<h3 id="1-1-2-px"><a href="#1-1-2-px" class="headerlink" title="1.1.2. px"></a>1.1.2. px</h3><p>表示屏幕的像素。如分辨率为1920*1080，它表示屏幕的X方向上有1080个像素，Y方向上有1920个像素。</p>
<h3 id="1-1-3-dpi和densityDpi"><a href="#1-1-3-dpi和densityDpi" class="headerlink" title="1.1.3. dpi和densityDpi"></a>1.1.3. dpi和densityDpi</h3><p>dot per inch简称为dpi，它表示每英寸上的像素点个数，所以它也常为屏幕密度。</p>
<p>在Android中使用DisplayMetrics中的densityDpi字段表示该值，并且不少文档中常用dpi来简化或者指代densityDpi。</p>
<p>如下屏幕密度对照表</p>
<p><img src="../../../../images/githubpages/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6%E5%AF%B9%E7%85%A7%E8%A1%A8.png" alt="屏幕密度对照表"></p>
<p>问题：通过代码获取到的densityDpi和我们计算出来的屏幕实际密度值440.582不一样，为什么？</p>
<ul>
<li><p>在每部手机出厂时都会为该手机设置屏幕密度，若其屏幕的实际密度是440dpi那么就会将其屏幕密度设置为与之接近的480dpi；如果实际密度为325dpi那么就会将其屏幕密度设置为与之接近的20dpi。这也就是说常见的屏幕密度是与每个显示级别的最大值相对应的，比如：120、160、240、320、480、640等。</p>
</li>
<li><p>有的手机不一定会选择120、160、240、320、480、640中的值作为屏幕密度，而是选择实际的dpi作为屏幕密度。比如小米手机，它的某些机型的densityDpi就是个非常规的值。</p>
</li>
</ul>
<h3 id="1-1-4-dp"><a href="#1-1-4-dp" class="headerlink" title="1.1.4. dp"></a>1.1.4. dp</h3><p>density-independent pixel简称为dip或者dp,它表示与密度无关的像素。如果使用dp作为长度单位，那么该长度在不同密度的屏幕中显示的比例将保持一致。</p>
<p>如下密度无关像素与屏幕密度对照表</p>
<p><img src="../../../../images/githubpages/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%AF%86%E5%BA%A6%E6%97%A0%E5%85%B3%E5%83%8F%E7%B4%A0%E4%B8%8E%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6%E5%AF%B9%E7%85%A7%E8%A1%A8.png" alt="密度无关像素与屏幕密度对照表"></p>
<h3 id="1-1-5-sp"><a href="#1-1-5-sp" class="headerlink" title="1.1.5. sp"></a>1.1.5. sp</h3><p>scale-independent pixel简称为sp，它类似于dp，但主要用于表示字体的大小。</p>
<h2 id="1-2-屏幕适配的问题"><a href="#1-2-屏幕适配的问题" class="headerlink" title="1.2. 屏幕适配的问题"></a>1.2. 屏幕适配的问题</h2><ol>
<li>采用主流的分辨率设计UI(xhdpi或者xxhdpi)</li>
<li>放在正确的drawable文件夹中</li>
<li>统一使用dp和sp作为尺寸单位，利用dimens.xml自动切换</li>
<li>利用开源项目：SupportMultipleScreensUtil、com.android.support:percent:22.2.0<ul>
<li>PercentRelativeLayout</li>
<li>PercentFrameLayout</li>
<li>支持宽高以及margin</li>
</ul>
</li>
</ol>
<h2 id="1-3-布局优化"><a href="#1-3-布局优化" class="headerlink" title="1.3. 布局优化"></a>1.3. 布局优化</h2><ol>
<li>删除布局中无用的控件和层级</li>
<li>有选择的使用性能较低的ViewGroup：优先LinearLayout,FrameLayout</li>
<li>采用<include>标签、<merge>标签和ViewStub。其中ViewStub的意义在于按需加载所需的布局文件</li>
</ol>
<h2 id="1-4-绘制优化"><a href="#1-4-绘制优化" class="headerlink" title="1.4. 绘制优化"></a>1.4. 绘制优化</h2><ol>
<li>View的onDraw方法要避免执行大量的操作</li>
</ol>
<ul>
<li>onDraw中不要创建新的局部对象</li>
<li>onDraw方法中不要做耗时的任务，也不能执行成千上万次的循环操作。</li>
</ul>
<ol>
<li>尽管每次循环都很轻量级，但是大量的循环仍然十分抢占CPU的时间片，这样会造成View的绘制过程不流畅</li>
</ol>
<h2 id="1-5-ListView优化"><a href="#1-5-ListView优化" class="headerlink" title="1.5. ListView优化"></a>1.5. ListView优化</h2><h3 id="1-5-1-重用converView"><a href="#1-5-1-重用converView" class="headerlink" title="1.5.1. 重用converView"></a>1.5.1. 重用converView</h3><p>通过复用converview来减少不必要的view的创建，另外Infalte操作会把xml文件实例化成相应的View实例，属于IO操作，是耗时操作。</p>
<h3 id="1-5-2-减少findViewById-操作"><a href="#1-5-2-减少findViewById-操作" class="headerlink" title="1.5.2. 减少findViewById()操作"></a>1.5.2. 减少findViewById()操作</h3><p>将xml文件中的元素封装成viewholder静态类，通过converview的setTag和getTag方法将view与相应的holder对象绑定在一起，避免不必要的findviewbyid操作。</p>
<h3 id="1-5-3-避免在-getView-方法中做耗时的操作"><a href="#1-5-3-避免在-getView-方法中做耗时的操作" class="headerlink" title="1.5.3. 避免在 getView 方法中做耗时的操作"></a>1.5.3. 避免在 getView 方法中做耗时的操作</h3><p>例如加载本地 Image 需要载入内存以及解析 Bitmap ，都是比较耗时的操作，如果用户快速滑动listview，会因为getview逻辑过于复杂耗时而造成滑动卡顿现象。用户滑动时候不要加载图片，待滑动完成再加载，可以使用这个第三方库glide</p>
<h3 id="1-5-4-Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘"><a href="#1-5-4-Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘" class="headerlink" title="1.5.4. Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘"></a>1.5.4. Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘</h3><h3 id="1-5-5-尽量能保证Adapter的hasStableIds-返回-true"><a href="#1-5-5-尽量能保证Adapter的hasStableIds-返回-true" class="headerlink" title="1.5.5. 尽量能保证Adapter的hasStableIds() 返回 true"></a>1.5.5. 尽量能保证Adapter的hasStableIds() 返回 true</h3><p>这样在 notifyDataSetChanged() 的时候，如果item内容并没有变化，ListView 将不会重新绘制这个 View，达到优化的目的。</p>
<p>在一些场景中，ScollView内会包含多个ListView，可以把listview的高度写死固定下来。由于ScollView在快速滑动过程中需要大量计算每一个listview的高度，阻塞了UI线程导致卡顿现象出现，如果我们每一个item的高度都是均匀的，可以通过计算把listview的高度确定下来，避免卡顿现象出现。</p>
<h3 id="1-5-6-使用-RecycleView-代替listview"><a href="#1-5-6-使用-RecycleView-代替listview" class="headerlink" title="1.5.6. 使用 RecycleView 代替listview"></a>1.5.6. 使用 RecycleView 代替listview</h3><p>每个item内容的变动，listview都需要去调用notifyDataSetChanged来更新全部的item，太浪费性能了。RecycleView可以实现当个item的局部刷新，并且引入了增加和删除的动态效果，在性能上和定制上都有很大的改善。</p>
<h3 id="1-5-7-ListView中元素避免半透明"><a href="#1-5-7-ListView中元素避免半透明" class="headerlink" title="1.5.7. ListView中元素避免半透明"></a>1.5.7. ListView中元素避免半透明</h3><p>半透明绘制需要大量乘法计算，在滑动时不停重绘会造成大量的计算，在比较差的机子上会比较卡。在设计上能不半透明就不不半透明。实在要弄就把在滑动的时候把半透明设置成不透明，滑动完再重新设置成半透明。根据列表的滑动状态来控制任务的执行频率，比如当列表滑动时显然不太适合开启大量的异步任务。</p>
<h3 id="1-5-8-尽量开启硬件加速"><a href="#1-5-8-尽量开启硬件加速" class="headerlink" title="1.5.8. 尽量开启硬件加速"></a>1.5.8. 尽量开启硬件加速</h3><p>硬件加速提升巨大，避免使用一些不支持的函数导致含泪关闭某个地方的硬件加速。当然这一条不只是对 ListView。</p>
<h1 id="2-图片的优化"><a href="#2-图片的优化" class="headerlink" title="2. 图片的优化"></a>2. 图片的优化</h1><h2 id="2-1-Bitmap优化"><a href="#2-1-Bitmap优化" class="headerlink" title="2.1. Bitmap优化"></a>2.1. Bitmap优化</h2><ol>
<li>及时的销毁</li>
</ol>
<ul>
<li>recycle并不能确定立即就会将Bitmap释放掉，但是会给虚拟机一个暗示：“该图片可以释放了”,还有就是， 虽然recycle()从源码上看，调用它应该能立即释放Bitmap的主要内存，但是测试表明它并没能立即释放内存。故我们还需手动设置为NULL这样还能大大的加速Bitmap的主要内存的释放。</li>
</ul>
<ol>
<li>设置一定的采样率</li>
<li>使用缓存LruCache 以及本地缓存</li>
</ol>
<h2 id="2-2-drawable图片的加载导致失真的问题"><a href="#2-2-drawable图片的加载导致失真的问题" class="headerlink" title="2.2. drawable图片的加载导致失真的问题"></a>2.2. drawable图片的加载导致失真的问题</h2><p><img src="../../../../images/githubpages/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%9B%BE%E7%89%87%E7%9A%84%E5%AE%BD%E4%B8%BA144%EF%BC%8C%E9%AB%98%E4%B8%BA180%E6%94%BE%E5%9C%A8%E4%B8%8D%E5%90%8Cdrawable%E4%B8%AD%E5%86%85%E5%AD%98%E7%9A%84%E6%B6%88%E8%80%97%E6%83%85%E5%86%B5.png" alt="图片的宽为144，高为180放在不同drawable中内存的消耗情况"></p>
<p>假设手机的dpi值为480，把有一张图片放到drawable-xxhdpi里在手机上显示出来是不失真的，非常合适；但是错放到了drawable-xhdpi(其TypedValue的value值为320)后再次显示时发现图片被放大了，而且放大了480/320=1.5倍。既然图片被放大了那么该图片所占的内存当然也变大了。</p>
<p>这也就解释了我们有时遇到的类似困惑：为什么图片放在drawable-xxhdpi是正常的，但是放到drawable-mdpi后图片不仅仅放大失真而且所占内存也大幅增加了。</p>
<p>图片放在drawable-nodpi中，那么该图片不会被缩放；也就是说该图片在不同分辨率的手机上都只显示原图的大小。例如，把刚才这张图片放到drawable-nodpi中，那么它在各个手机上显示时它的宽均为144，高均为180。</p>
<h1 id="3-线程优化"><a href="#3-线程优化" class="headerlink" title="3. 线程优化"></a>3. 线程优化</h1><h2 id="3-1-采用线程池"><a href="#3-1-采用线程池" class="headerlink" title="3.1. 采用线程池"></a>3.1. 采用线程池</h2><p>线程池可以重用内部的线程，从而避免了线程的创建和销毁所带来的性能开销</p>
<p>同时线程池还能有效的控制线程池的最大并发数，避免大量的线程因互相抢占系统资源而导致阻塞现象的发生</p>
<h1 id="4-内存优化"><a href="#4-内存优化" class="headerlink" title="4. 内存优化"></a>4. 内存优化</h1><h2 id="4-1-内存管理"><a href="#4-1-内存管理" class="headerlink" title="4.1. 内存管理"></a>4.1. 内存管理</h2><h3 id="4-1-1-分配机制"><a href="#4-1-1-分配机制" class="headerlink" title="4.1.1. 分配机制"></a>4.1.1. 分配机制</h3><p>Android采用弹性的分配方式，也就是刚开始并不会一下分配很多内存给每个进程，而是给每一个进程分配一个“够用”的量。这个量是根据每一个设备实际的物理内存大小来决定的。</p>
<p>当前的内存可能不够使用了，这时候Android又会为每个进程分配一些额外的内存大小。</p>
<p>Android系统的宗旨是最大限度的让更多的进程存活在内存中，因为这样的话，下一次用户再启动应用，不需要重新创建进程，只需要恢复已有的进程就可以了，减少了应用的启动时间，提高了用户体验。</p>
<h3 id="4-1-2-回收机制"><a href="#4-1-2-回收机制" class="headerlink" title="4.1.2. 回收机制"></a>4.1.2. 回收机制</h3><p>Android对内存的使用方式是“尽最大限度的使用”，这一点继承了Linux的优点。Android会在内存中保存尽可能多的数据，即使有些进程不再使用了，但是它的数据还被存储在内存中，所以Android现在不推荐显式的“退出”应用。</p>
<p>当用户下次再启动应用的时候，只需要恢复当前进程就可以了，不需要重新创建进程，这样就可以减少应用的启动时间。</p>
<p>只有当Android系统发现内存不够使用，需要回收内存的时候，Android系统就会需要杀死其他进程，来回收足够的内存。所以Android会有限清理那些已经不再使用的进程，以保证最小的副作用。</p>
<p>Android杀死进程有两个参考条件</p>
<ol>
<li><p>进程优先级</p>
<ul>
<li>前台进程</li>
<li>可见进程</li>
<li>服务进程</li>
<li>后台进程</li>
<li>存放于一个LRU缓存列表中，先杀死处于列表尾部的进程</li>
<li>空进程</li>
<li>正常情况下，为了平衡系统整体性能，Android不保存这些进程</li>
</ul>
</li>
<li><p>回收收益</p>
<ul>
<li>当Android系统开始杀死LRU缓存中的进程时，系统会判断每个进程杀死后带来的回收收益。因为Android总是倾向于杀死一个能回收更多内存的进程，从而可以杀死更少的进程，来获取更多的内存。杀死的进程越少，对用户体验的影响就越小。</li>
</ul>
</li>
</ol>
<h3 id="4-1-3-官方推荐的App内存使用方式"><a href="#4-1-3-官方推荐的App内存使用方式" class="headerlink" title="4.1.3. 官方推荐的App内存使用方式"></a>4.1.3. 官方推荐的App内存使用方式</h3><ol>
<li>当Service完成任务后，尽量停止它</li>
<li>在UI不可见的时候，释放掉一些只有UI使用的资源</li>
<li>在系统内存紧张的时候，尽可能多的释放掉一些非重要资源</li>
<li>检查自己最大可用的内存大小</li>
<li>避免滥用Bitmap导致的内存浪费</li>
<li>使用针对内存优化过的数据容器</li>
<li>意识到内存的过度消耗<ul>
<li>避免创建不必要的对象。</li>
<li>在合适的生命周期中，合理的管理资源。</li>
<li>在系统内存不足时，主动释放更多的资源。</li>
</ul>
</li>
<li>抽象代码也会带来更多的内存消耗</li>
<li>避免使用依赖注入的框架</li>
<li>使用多进程<ul>
<li>把消耗内存过大的模块，或者需要长期在后台运行的模块，移入到单独的进程中运行。Android会为每一个进程单独分配内存，所以理论上App就可以使用到更多的内存。但是多进程是一把双刃剑，错误的使用，会带来其他很多的问题。</li>
</ul>
</li>
</ol>
<h2 id="4-2-内存泄漏"><a href="#4-2-内存泄漏" class="headerlink" title="4.2. 内存泄漏"></a>4.2. 内存泄漏</h2><p>指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p>
<h3 id="4-2-1-Activity引起内存泄漏"><a href="#4-2-1-Activity引起内存泄漏" class="headerlink" title="4.2.1. Activity引起内存泄漏"></a>4.2.1. Activity引起内存泄漏</h3><p>在 Java 中，非静态匿名内部类会持有其外部类的隐式引用，如果你没有考虑过这一点，那么存储该引用会导致 Activity 被保留，而不是被垃圾回收机制回收。</p>
<p>如果你的内存泄漏发生在 Activity 中，那么你将损失大量的内存空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  示例向我们展示了在 Activity 的配置改变时（配置改变会导致其下的 Activity 实例被销</span></span><br><span class="line"><span class="comment">    *  毁）存活。此外，Activity 的 context 也是内存泄漏的一部分，因为每一个线程都被初始</span></span><br><span class="line"><span class="comment">    *  化为匿名内部类，使得每一个线程都持有一个外部 Activity 实例的隐式引用，使得</span></span><br><span class="line"><span class="comment">    *  Activity 不会被 Java 的垃圾回收机制回收。</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    exampleOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exampleOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例来说，在使用应用的时候，你执行了10次横屏/竖屏操作，每一次方向的改变都会执行下面的代码，每一次配置的改变都会使 Android 系统新建一个 Activity 并把改变前的 Activity 交给垃圾回收机制回收。但因为线程持有旧 Activity 的隐式引用，使该 Activity 没有被垃圾回收机制回收。这样的问题会导致每一个新建的 Activity 都将发生内存泄漏，与 Activity 相关的所有资源文件也不会被回收，其中的内存泄漏有多严重可想而知。（该线程类声明为私有的静态内部类就可以解决这个问题）</p>
<h3 id="4-2-2-AsyncTask导致的内存泄漏"><a href="#4-2-2-AsyncTask导致的内存泄漏" class="headerlink" title="4.2.2. AsyncTask导致的内存泄漏"></a>4.2.2. AsyncTask导致的内存泄漏</h3><p>问题点</p>
<ul>
<li>持有外部context强引用</li>
<li>持有外部UI组件强引用</li>
</ul>
<p>解决办法</p>
<ul>
<li>对context采用WeakRefrence,在使用之前判断是否为空。</li>
<li>在Activity生命周期结束前，去cancel AsyncTask，因为Activity都要销毁了，这个时候再跑线程，绘UI显然已经没什么意义了。</li>
</ul>
<h3 id="4-2-3-线程引起内存泄漏"><a href="#4-2-3-线程引起内存泄漏" class="headerlink" title="4.2.3. 线程引起内存泄漏"></a>4.2.3. 线程引起内存泄漏</h3><p>在Java中线程是垃圾回收机制的根源，也就是说，在运行系统中DVM虚拟机总会使硬件持有所有运行状态的进程的引用，结果导致处于运行状态的线程将永远不会被回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 除了我们需要实现销毁逻辑以保证线程不会发生内存泄漏，其他代码和示例2相同。在退出当前</span></span><br><span class="line"><span class="comment">* Activity 前使用 onDestroy() 方法结束你的运行中线程是个不错的选择</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyThread mThread;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        exampleThree();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exampleThree</span><span class="params">()</span> &#123;</span><br><span class="line">        mThread = <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        mThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 私有的静态内部类不会持有其外部类的引用，使得 Activity 实例不会在配置改变时发生内</span></span><br><span class="line"><span class="comment">    * 存泄漏</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mRunning</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            mRunning = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (mRunning) &#123;</span><br><span class="line">            SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">            mRunning = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        mThread.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-结论"><a href="#4-2-4-结论" class="headerlink" title="4.2.4. 结论"></a>4.2.4. 结论</h3><ol>
<li>避免写出内存泄露的代码<ul>
<li>静态变量导致的内存泄露</li>
<li>单例模式导致的内存泄露，单例模式的特点是其生命周期和Application保持一致，因此Activity对象无法被及时释放</li>
<li>属性动画导致的内存泄露，在Activity的onDestroy中调用animator.cancel()来停止动画</li>
<li>创建过多对象导致内存在短时间内快速被消耗掉了</li>
</ul>
</li>
<li>通过TraceView、MAT等工具找出潜在的内存泄露</li>
<li>适当的使用WeakReference</li>
<li>尽可能使用静态内部类而不是非静态内部类</li>
<li>不要总想着 Java 的垃圾回收机制会帮你解决所有内存回收问题<ul>
<li>为你的后台线程实现销毁逻辑是你在使用线程时必须时刻铭记的细节，此外，你在设计销毁逻辑时要根据 Activity 的生命周期去设计，避免出现 Bug。</li>
</ul>
</li>
<li>考虑你是否真的需要使用线程</li>
</ol>
<h2 id="4-3-内存溢出"><a href="#4-3-内存溢出" class="headerlink" title="4.3. 内存溢出"></a>4.3. 内存溢出</h2><p>指程序在申请内存时，没有足够的内存空间供其使用，出现OOM。memory leak会最终会导致out of memory。比如申请了一个integer，但给它存了long才能存下的数，那就是内存溢出</p>
<p>解决办法</p>
<ul>
<li>减少每个对象占用的内存，比如压缩图片</li>
<li>申请大内存</li>
</ul>
<h2 id="4-4-APK大小优化"><a href="#4-4-APK大小优化" class="headerlink" title="4.4. APK大小优化"></a>4.4. APK大小优化</h2><p>不必过度优化你的代码，要优化你的选择。</p>
<h3 id="4-4-1-优点"><a href="#4-4-1-优点" class="headerlink" title="4.4.1. 优点"></a>4.4.1. 优点</h3><ol>
<li>减少APP下载和安装的时间</li>
<li>减少APP安装后占用的存储空间</li>
<li>理论上更少的字节码也意味着需要执行的指令更少，需要加载进内存的代码页发生缺页的情况也更少，这些显然对于资源密集型使用场景例如应用冷启动起到很好的性能优化作用。</li>
</ol>
<h3 id="4-4-2-具体实施"><a href="#4-4-2-具体实施" class="headerlink" title="4.4.2. 具体实施"></a>4.4.2. 具体实施</h3><ol>
<li>压缩图片<ul>
<li>没有alpha通道的png图，可压缩成jpg减少体积；</li>
<li>对于体积特别大(超过50k)的图片资源可以考虑有损压缩，jpg采用优图压缩，png尝试采用pngquant压缩，输出视觉判断是否可行；</li>
<li>采用webp格式的图片</li>
<li>采用 ImageOptim压缩图片</li>
</ul>
</li>
<li>删除无用资源</li>
</ol>
<h1 id="5-响应速度及卡顿优化"><a href="#5-响应速度及卡顿优化" class="headerlink" title="5. 响应速度及卡顿优化"></a>5. 响应速度及卡顿优化</h1><p>大多数手机的屏幕刷新频率是60hz，如果在1000/60=16.67ms内没有办法把这一帧的任务执行完毕，就会发生丢帧的现象。丢帧越多，用户感受到的卡顿情况就越严重。</p>
<p>渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。CPU通常存在的问题的原因是存在非必需的视图组件，它不仅仅会带来重复的计算操作，而且还会占用额外的GPU资源。</p>
<p>针对原理来作出解释如何优化</p>
<ul>
<li>减少视图的层级结构</li>
<li>移除Window默认的Background</li>
<li>移除XML布局文件中非必需的Background</li>
<li>按需显示占位背景图片</li>
<li>优化自定义view的ondraw方法</li>
<li>listview滑动取消图片加载</li>
<li>listview采用viewholder</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>知识汇总</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>加解密算法，了解一下</title>
    <url>/iBlogWebsite/2017/01/16/2017/2017-01-16-%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<h1 id="1-Base64编码算法"><a href="#1-Base64编码算法" class="headerlink" title="1. Base64编码算法"></a>1. Base64编码算法</h1><p>Base64只是一种编码方式，并不是一种加密算法，不要使用Base64来加密数据。</p>
<p>Base64编码算法是一种用64个字符，在计算机网络发展的早期，由于“历史原因”，电子邮件不支持非ASCII码字符，如果要传送的电子邮件带有非ASCII码字符（诸如中文）或者图片，用户收到的电子邮件将会是一堆乱码，因此发明了Base64编码算法。</p>
<p>在加解密算法中，原始的数据和加密后的数据一般也是二进制数据，为了不传输出错，方便保存或者调试代码，一般需要对加密后的数据进行base64编码。</p>
<p>Android提供了Base64编码的工具类android.util.Base64</p>
<p><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//base64.jpg" alt="Base64编码"></p>
<h1 id="2-随机数生成器"><a href="#2-随机数生成器" class="headerlink" title="2. 随机数生成器"></a>2. 随机数生成器</h1><p>在Android加密算法中需要随机数时要使用SecureRandom来获取随机数，如下图示：</p>
<p><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8.jpg" alt="随机数生成器"></p>
<p>注意不要给SecureRandom设置种子。调用seeded constructor或者setSeed(byte[])是不安全的。SecureRandom()默认使用的是dev/urandom作为种子产生器，这个种子是不可预测的。</p>
<p>开发者建议</p>
<ul>
<li>不要使用Random类来获取随机数</li>
<li>在使用SecureRandom时候，不要设置种子。使用以下函数设置种子都是有风险的</li>
</ul>
<p><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//SecureRandom.jpg" alt="SecureRandom"></p>
<h1 id="3-Hash算法"><a href="#3-Hash算法" class="headerlink" title="3. Hash算法"></a>3. Hash算法</h1><p>Hash算法是指任意长度的字符串输入，此算法能给出固定n比特的字符串输出，输出的字符串一般称为Hash值。</p>
<p>两个特点</p>
<ol>
<li><p>抗碰撞性</p>
<p> 抗碰撞性使Hash算法对原始输入的任意一点更改，都会导致产生不同的Hash值，因此Hash算法可以用来检验数据的完整性。</p>
</li>
<li><p>不可逆性</p>
<p> 不可逆的特性使Hash算法成为一种单向密码体制，只能加密不能解密，可以用来加密用户的登录密码等凭证。</p>
</li>
</ol>
<p>开发者建议</p>
<ol>
<li>建议使用SHA-256、SHA-3算法，不建议使用MD2、MD4、MD5、SHA-1、RIPEMD算法来加密用户密码等敏感信息。这一类算法已经有很多破解办法，例如md5算法，网上有很多查询的字典库，给出md5值，可以查到加密前的数据。</li>
<li>不要使用哈希函数做为对称加密算法的签名，当多个字符串串接后再做hash，要非常当心。实际开发过程中经常会对url的各个参数，做词典排序，然后取参数名和值串接后加上某个SECRET字符串，计算出hash值，作为此URL的签名。</li>
</ol>
<h1 id="4-消息认证算法"><a href="#4-消息认证算法" class="headerlink" title="4. 消息认证算法"></a>4. 消息认证算法</h1><p>要确保加密的消息不是别人伪造的，需要提供一个消息认证码（MAC，Message authentication code）。消息认证码是带密钥的hash函数，基于密钥和hash函数。消息发送者使用MAC算法计算出消息的MAC值，追加到消息后面一起发送给接收者。接收者收到消息后，用相同的MAC算法计算接收到消息MAC值，并与接收到的MAC值对比是否一样。</p>
<h1 id="5-对称加密算法"><a href="#5-对称加密算法" class="headerlink" title="5. 对称加密算法"></a>5. 对称加密算法</h1><p>在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，<br>这就要求解密方事先必须知道加密密钥。该算法的缺点是，如果一旦密钥泄漏，那么加密的内容将都不可信了。</p>
<p>开发者建议</p>
<p>建议使用AES算法，DES默认的是56位的加密密钥，已经不安全，不建议使用。</p>
<p><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//ECB.png" alt="ECB"></p>
<p>注意加密模式不要使用ECB模式。ECB模式不安全，说明问题的经典的三张图片。</p>
<p><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//AndroidAES.jpg" alt="AndroidAES"></p>
<p>Android 提供的AES加密算法API默认使用的是ECB模式，所以要显式指定加密算法为：CBC或CFB模式，可带上PKCS5Padding填充。AES密钥长度最少是128位，推荐使用256位。</p>
<h1 id="6-非对称加密"><a href="#6-非对称加密" class="headerlink" title="6. 非对称加密"></a>6. 非对称加密</h1><p>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密（这个过程可以做数字签名）。非对称加密主要使用的是RSA算法</p>
<p>开发者建议</p>
<ol>
<li>注意密钥长度不要低于512位，建议使用2048位的密钥长度。 使用RSA进行数字签名的算法。<br><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//RSA.jpg" alt="RSA"></li>
<li>使用RSA算法做加密，RSA加密算法应使用Cipher.getInstanceRSA/ECB/OAEPWithSHA256AndMGF1Padding)，否则会存在重放攻击的风险。<br><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//RSA2.jpg" alt="RSA2"></li>
</ol>
<h1 id="7-加密算法PBE"><a href="#7-加密算法PBE" class="headerlink" title="7. 加密算法PBE"></a>7. 加密算法PBE</h1><p>PBE是一种基于口令的加密算法，其特点是使用口令代替了密钥，而口令由用户自己掌管，采用随机数杂凑多重加密等方法保证数据的安全性。</p>
<p>开发者建议</p>
<ol>
<li>使用基于口令的加密算法PBE时，生成密钥时要加盐，盐的取值最好来自SecureRandom，并指定迭代次数。<br><img src="../../../../images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86//PBE.jpg" alt="PBE"></li>
</ol>
<h1 id="8-加密和解密"><a href="#8-加密和解密" class="headerlink" title="8. 加密和解密"></a>8. 加密和解密</h1><p>加密要用公钥 (n,e)</p>
<ul>
<li>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</li>
<li>所谓”加密”，就是算出下式的c：me ≡ c (mod n),于是，c等于2790，鲍勃就把2790发给了爱丽丝。</li>
</ul>
<p>解密要用私钥(n,d)</p>
<ul>
<li>爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：cd ≡ m (mod n)</li>
<li>也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出：27902753 ≡ 65 (mod 3233)</li>
<li>因此，爱丽丝知道了鲍勃加密前的原文就是65。</li>
</ul>
<p>公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？</p>
<ul>
<li>一种是把长信息分割成若干段短消息，每段分别加密；</li>
<li>另一种是先选择一种”对称性加密算法”（比如DES），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>签名机制</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记之月亮与六便士</title>
    <url>/iBlogWebsite/2017/03/14/2017/2017-03-14-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB/</url>
    <content><![CDATA[<p><img src="../../../../images/readingNotes/%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB/%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB.jpg" alt="月亮与六便士"></p>
<p>忘了何时开始关注《月亮与六便士》，可能是看了某篇荐书类的文章，直到前两天看完，最大的感受便是惊叹作者叙述技法的娴熟，读来行云流水，自有一气呵成之快感。</p>
<p>看到很多人喷译者的导读过长，甚是不能理解。难道不看导读的你真能看懂作者想要表达的现实主义吗？你能理解作者为何取名为《月亮与六便士》？你能明白小说的结尾说的那段话又有什么深意？</p>
<p>起初读起前几章，似乎乏味到想弃读；转折点大概是在斯特里克兰突然离开伦敦之时，此时才明白他是故事的主人公，故而随着作者叙事技法的高超，越来越精彩，一切似乎都是水到渠成，至少在阅读量有限的我来说是这样的。</p>
<p>作者对于人物的刻画相当擅长，如第十一章中：“我发现她的举手投足颇有自相矛盾之处，这让我感到大惑不解。她确实非常悲伤，但为了激起我的同情，她竟然会将悲伤表演给我看。她的痛哭流涕显然是经过精心准备的，因为她在身边放了大量的手帕，我特别佩服她的深谋远虑，但回想起来，这也许会让她的眼泪没有那么动人。我无法确定她希望她的丈夫回家，是因为还爱着她丈夫，还是因为害怕人言物议。我忍不住怀疑在她支离破碎的心里，除了夫妻反目造成的酸楚，是否也混杂着虚荣心受损带来的痛苦——这种动机在年轻的我看来是很可耻的。那时候我尚未明白人性是多么的悖谬，我还不知道真挚诚恳底下也许埋藏着矫揉造作，高风亮节背后可能隐匿着卑鄙无耻，也不知道无赖恶棍心里或许存留着良善之意。”本来还对她怀有同情心，在作者的一段心里刻画之后，让人对她的遭遇有种“丑人多作怪”的“愉悦”。</p>
<p>书中金句不断，有的犀利，有的则直戳心底，如：“我们胃口都很好，我是因为年纪尚轻，他则是因为毫无良心。”这里表面上展现了斯特里克兰的“毫无良心”，其实看到最后时并非是这样。</p>
<p>再比如：“有的人也号称他们不在意别人的看法，但他们多半是在自己骗自己。总的来说，这些人只有在相信没人能发现他们的逾规越矩之处时才敢为所欲为。他们顶多就是因为有了几个亲朋好友的赞许，愿意去做一些与大多数人的观点相悖的事情。假如你的离经叛道无非是你这类人的惯用伎俩，那么在世人面前表现得离经叛道并不是很困难的事情。这会让你对自己肃然起敬。你既可以标榜自己勇气过人，又无须冒什么实际的危险。但渴望得到认可也许是文明人最根深蒂固的本能。哪怕是最不守妇道的女人，若是舆论纷纷指责她伤风败俗，她也会赶紧跑去求某个德高望重的人士为她主持公道。如果有人告诉我他们完全无视别人的看法，那我是不相信的。这是一种无知的虚张声势。这些人的意思无非是，他们不怕由于一些微不足道的过失而受到指责，因为他们自信没有人能发现。”这时我们来思考一个问题：人们嘴上说不在意别人的看法，还是在窃喜那些逾规越矩的行为没有被发现而已?</p>
<p>再比如：“现在我清楚地认识到，卑鄙和高尚、凶恶和仁慈、憎恨和爱恋是能够并存于同一颗人类的心灵的。”人是多么复杂的生物，在某种情况下是那么的卑鄙、丑陋；而在另一种处境下又是那么的善良和仁慈…</p>
<p>最后我想聊聊书名《月亮与六便士》，一开始并不理解它的含义，通过导读了解作者的时代背景后才明白，毛姆开始的著作总是受到同行的排挤和批评，对热爱文学创作的他来说，经济的困窘或可一笑置之，心血长久无人问津却会造成致命的信心动摇。但优秀的作品总不会一直黯淡下去，转机很快在大西洋彼岸出现：其美国版在同年7月推出，首印五千本旋即售罄，到年底竟然卖掉将近十万册，进而让沉寂数年的《人性的枷锁》重见天日，并最终在文学史上奠定了无可撼动的经典地位。就我个人而言，了解到上面的背景之后，不经起了一身鸡皮疙瘩，或许是为了优秀作品的光芒再现，或许是同情毛姆的创作经历。《月亮与六便士》中的月亮象征着崇高的理想追求和美妙的精神境界，六便士这种小面额的硬币代表着世俗的鸡虫得失与蝇头小利。至于精神与物质之间如何取舍，作者并没有给出一个结论，其实也并不需要什么结论，这完全取决于你如何看待生活的意义，取决于你认为你应该对社会做出什么贡献，应该对自己有什么要求。</p>
<p>所以小说的最后作者突兀的提到自己的叔叔亨利当牧师是说的一句话：魔鬼总是随心所欲的引用经文，他记得从前一个先令就能买到十三只上等的牡蛎。这里暂且不谈其引申的含义，就那句经文而言，最有可能的就是“你们不要论断人，免得你们被论断”，也就是不要轻易的judge别人，因为人和人的相互了解往往肤浅、局限而片面，能够做出公正的评判只有全知全能的上帝——假如这样的上帝果真存在的话。</p>
]]></content>
      <categories>
        <category>opinion</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据摘要、签名和证书，了解一下</title>
    <url>/iBlogWebsite/2017/01/06/2017/2017-01-06-%E6%95%B0%E6%8D%AE%E6%91%98%E8%A6%81%E3%80%81%E7%AD%BE%E5%90%8D%E5%92%8C%E8%AF%81%E4%B9%A6%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<h1 id="1-密码学的三大作用"><a href="#1-密码学的三大作用" class="headerlink" title="1. 密码学的三大作用"></a>1. 密码学的三大作用</h1><ol>
<li>加密：防止坏人获取你的数据</li>
<li>认证：防止坏人修改了你的数据而你却并没有发现</li>
<li>鉴权：防止坏人假冒你的身份</li>
</ol>
<h1 id="2-数据摘要"><a href="#2-数据摘要" class="headerlink" title="2. 数据摘要"></a>2. 数据摘要</h1><p>一个数据源进行一个算法之后得到一个摘要，也叫作数据指纹。著名的摘要算法有RSA公司的MD5算法和SHA-1算法及其大量的变体。</p>
<p>消息摘要的主要特点</p>
<ul>
<li>无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。例如应用MD5算法摘要的消息有128个比特位，用SHA-1算法摘要的消息最终有160比特位的输出。</li>
<li>一般来说（不考虑碰撞的情况下），只要输入的原始数据不同，对其进行摘要以后产生的消息摘要也必不相同，即使原始数据稍有改变，输出的消息摘要便完全不同。但是，相同的输入必会产生相同的输出。</li>
<li>具有不可逆性，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的原始消息。</li>
</ul>
<p>下面是Java中采用MD5和SHA-1进行摘要计算的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.other;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDigitalSummary</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;curriculum&quot;</span>;</span><br><span class="line"></span><br><span class="line">        md5(<span class="literal">null</span>);</span><br><span class="line">        md5(s1);</span><br><span class="line">        md5(s2);</span><br><span class="line"></span><br><span class="line">        sha1(<span class="literal">null</span>);</span><br><span class="line">        sha1(s1);</span><br><span class="line">        sha1(s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">md5</span><span class="params">(String plainText)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (plainText == <span class="literal">null</span> || plainText.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md5</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">            md5.reset();</span><br><span class="line">            md5.update(plainText.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="type">byte</span>[] digestByteArray = md5.digest();</span><br><span class="line">            System.out.println(<span class="string">&quot;the plain text is : &quot;</span> + plainText);</span><br><span class="line">            System.out.println(<span class="string">&quot;the length is : &quot;</span> + digestByteArray.length);<span class="comment">//16 bytes represent 128 bits</span></span><br><span class="line">            System.out.println(<span class="string">&quot;the plain byte array is : &quot;</span> + Arrays.toString(digestByteArray));</span><br><span class="line">            System.out.println(<span class="string">&quot;the digital summary after md5 is : &quot;</span> + byteArrayTo32Md5String(digestByteArray));</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteArrayTo32Md5String</span><span class="params">(<span class="type">byte</span>[] byteArray)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (byteArray == <span class="literal">null</span> || byteArray.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="number">1</span>, byteArray);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(bigInteger.toString(<span class="number">16</span>));</span><br><span class="line">        <span class="keyword">while</span> (s.length() &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            s.append(<span class="string">&quot;0&quot;</span>).append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sha1</span><span class="params">(String plainText)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (plainText == <span class="literal">null</span> || plainText.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">sha1</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">            sha1.reset();</span><br><span class="line">            sha1.update(plainText.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="type">byte</span>[] digestByteArray = sha1.digest();</span><br><span class="line">            System.out.println(<span class="string">&quot;the plain text is : &quot;</span> + plainText);</span><br><span class="line">            System.out.println(<span class="string">&quot;the length is : &quot;</span> + digestByteArray.length);<span class="comment">//20 bytes represent 128 bits</span></span><br><span class="line">            System.out.println(<span class="string">&quot;the plain byte array is : &quot;</span> + Arrays.toString(digestByteArray));</span><br><span class="line">            System.out.println(<span class="string">&quot;the digital summary after SHA-1 is : &quot;</span> + byteArrayToSha1String(digestByteArray));</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteArrayToSha1String</span><span class="params">(<span class="type">byte</span>[] byteArray)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (byteArray == <span class="literal">null</span> || byteArray.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="number">1</span>, byteArray);</span><br><span class="line">        <span class="keyword">return</span> bigInteger.toString(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其结果如下所示，可以看到md5之后得到了一个长度为32的字符串，而byte数组的长度是16，即128比特。而SHA-1之后得到了一个长度为40的字符串，而byte数组的长度为20，即160比特。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">the plain text is : abc</span><br><span class="line">the length is : <span class="number">16</span></span><br><span class="line">the plain <span class="type">byte</span> array is : [-<span class="number">112</span>, <span class="number">1</span>, <span class="number">80</span>, -<span class="number">104</span>, <span class="number">60</span>, -<span class="number">46</span>, <span class="number">79</span>, -<span class="number">80</span>, -<span class="number">42</span>, -<span class="number">106</span>, <span class="number">63</span>, <span class="number">125</span>, <span class="number">40</span>, -<span class="number">31</span>, <span class="number">127</span>, <span class="number">114</span>]</span><br><span class="line">the digital summary after md5 is : 900150983cd24fb0d6963f7d28e17f72</span><br><span class="line"></span><br><span class="line">the plain text is : curriculum</span><br><span class="line">the length is : <span class="number">16</span></span><br><span class="line">the plain <span class="type">byte</span> array is : [-<span class="number">69</span>, <span class="number">99</span>, <span class="number">119</span>, <span class="number">60</span>, -<span class="number">83</span>, -<span class="number">105</span>, -<span class="number">1</span>, -<span class="number">49</span>, -<span class="number">45</span>, -<span class="number">97</span>, <span class="number">92</span>, -<span class="number">4</span>, <span class="number">102</span>, -<span class="number">19</span>, <span class="number">18</span>, -<span class="number">26</span>]</span><br><span class="line">the digital summary after md5 is : bb63773cad97ffcfd39f5cfc66ed12e6</span><br><span class="line"></span><br><span class="line">the plain text is : abc</span><br><span class="line">the length is : <span class="number">20</span></span><br><span class="line">the plain <span class="type">byte</span> array is : [-<span class="number">87</span>, -<span class="number">103</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">71</span>, <span class="number">6</span>, -<span class="number">127</span>, <span class="number">106</span>, -<span class="number">70</span>, <span class="number">62</span>, <span class="number">37</span>, <span class="number">113</span>, <span class="number">120</span>, <span class="number">80</span>, -<span class="number">62</span>, <span class="number">108</span>, -<span class="number">100</span>, -<span class="number">48</span>, -<span class="number">40</span>, -<span class="number">99</span>]</span><br><span class="line">the digital summary after SHA-<span class="number">1</span> is : a9993e364706816aba3e25717850c26c9cd0d89d</span><br><span class="line"></span><br><span class="line">the plain text is : curriculum</span><br><span class="line">the length is : <span class="number">20</span></span><br><span class="line">the plain <span class="type">byte</span> array is : [<span class="number">74</span>, <span class="number">19</span>, <span class="number">10</span>, -<span class="number">20</span>, <span class="number">7</span>, <span class="number">4</span>, -<span class="number">59</span>, -<span class="number">94</span>, -<span class="number">113</span>, -<span class="number">70</span>, <span class="number">8</span>, -<span class="number">111</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">40</span>, <span class="number">21</span>, -<span class="number">54</span>, -<span class="number">35</span>, -<span class="number">85</span>, -<span class="number">14</span>]</span><br><span class="line">the digital summary after SHA-<span class="number">1</span> is : 4a130aec0704c5a28fba08917f032815caddabf2</span><br></pre></td></tr></table></figure>

<h1 id="3-签名文件和证书"><a href="#3-签名文件和证书" class="headerlink" title="3. 签名文件和证书"></a>3. 签名文件和证书</h1><p>要确保通信安全，需要确保两个问题：① 要确定<strong>消息的来源</strong>确实是其申明的那个人，② 要保证信息在传递的过程中<strong>不被第三方篡改，即使被篡改了，也可以发觉出来</strong>。</p>
<p>对于消息的发送者来说，先要生成一对公私钥对，将公钥给消息的接收者。</p>
<p>发送方：发送者发消息给接收者，对要发送的原始消息提取<strong>消息摘要</strong>，对提取的<strong>消息摘要</strong>用自己的私钥加密，这里就是原始信息的<strong>数字签名</strong>。<br>接收方：对原始消息部分提取<strong>消息摘要</strong>，注意这里使用的消息摘要算法要和发送方使用的一致；对附加上的那段<strong>数字签名</strong>，使用预先得到的公钥解密；比较前两步所得到的两段消息是否一致。如果一致，则表明消息确实是期望的发送者发的，且内容没有被篡改过；相反，如果不一致，则表明传送的过程中一定出了问题，消息不可信。</p>
<p>通过这种所谓的数字签名技术，确实可以有效解决可靠通信的问题。如果原始消息在传送的过程中被篡改了，那么在接收者那里，对被篡改的消息提取的<strong>消息摘要</strong>肯定和原始的不一样。并且，由于篡改者没有消息发送方的私钥，即使他可以重新算出被篡改消息的摘要，也不能伪造出<strong>数字签名</strong>。</p>
<p>数字签名和签名验证的大体流程</p>
<p><img src="/images/githubpages/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E7%9A%84%E5%A4%A7%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="数字签名和签名验证的大体流程"></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>签名机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown模板</title>
    <url>/iBlogWebsite/2017/03/28/2017/2017-03-28-%20%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="一级标题示例"><a href="#一级标题示例" class="headerlink" title="一级标题示例"></a>一级标题示例</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>这里是二级标题正文这里是二级标题正文这里是二级标题正文这里是二级标题正文这里是二级标题正文这里是二级标题正文这里是二级标题正文这里是二级标题正文这里是二级标题正文这里是二级标题正文这里是二级标题正文</p>
<p>这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是二级标题正文这里是二级标题正文这里是二级标题正文这里是二级标题正文这里是二级标题正文这里是二级标题正文</p>
<p><img src="https://github.com/LeeeYou/Img/blob/master/leeeyou/getScrollX.png?raw=true" alt="getScrollX"></p>
<h1 id="加载代码示例"><a href="#加载代码示例" class="headerlink" title="加载代码示例"></a>加载代码示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.leeeyou.fixmyproblem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapShader;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="注释用法示例"><a href="#注释用法示例" class="headerlink" title="注释用法示例"></a>注释用法示例</h1><p>有两个方法可以设置控件的上下左右图标，分别是：<br><strong>第一个方法</strong>：setCompoundDrawablesWithIntrinsicBounds(Drawable left, Drawable top, Drawable right, Drawable bottom)<br><strong>第二种方法</strong>：setCompoundDrawables(Drawable left, Drawable top, Drawable right, Drawable bottom)  </p>
<p>它们的区别是使用第二种方法之前必须已经setBound(Rect)了，api原文如下</p>
<blockquote>
<p>Sets the Drawables (if any) to appear to the left of, above, to the right of, and below the text. Use null if you do not want a Drawable there. The Drawables must already have had setBounds(Rect) called.</p>
</blockquote>
<h1 id="引用网址示例"><a href="#引用网址示例" class="headerlink" title="引用网址示例"></a>引用网址示例</h1><p><strong>场景</strong>：官方比赛数据页签 - 淘汰赛和积分赛数据 → viewpager(水平) + scrollView(垂直) + HorizontalScrollView(水平) / ListView(垂直)<br><strong>分析</strong>：这里的冲突在于水平事件里面嵌套垂直，再嵌套水平和垂直事件<br><strong>解决</strong>：采用内部拦截法配合getParent().requestDisallowInterceptTouchEvent(false);  </p>
<p>这篇日志也记录了<a href="https://leeeyou.github.io/2016/02/29/blog-2016-02-29-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC3%E7%AB%A0-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/">Android艺术探索 第3章 View的事件体系</a></p>
<h1 id="表格示例"><a href="#表格示例" class="headerlink" title="表格示例"></a>表格示例</h1><table>
<thead>
<tr>
<th>Tables</th>
<th align="center">Are</th>
<th align="right">Cool</th>
</tr>
</thead>
<tbody><tr>
<td>col 3 is</td>
<td align="center">right-aligned</td>
<td align="right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td align="center">centered</td>
<td align="right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td align="center">are neat</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>dog</th>
<th>bird</th>
<th>cat</th>
</tr>
</thead>
<tbody><tr>
<td>foo</td>
<td>foo</td>
<td>foo</td>
</tr>
<tr>
<td>bar</td>
<td>bar</td>
<td>bar</td>
</tr>
<tr>
<td>baz</td>
<td>baz</td>
<td>baz</td>
</tr>
</tbody></table>
<h1 id="代办和清单"><a href="#代办和清单" class="headerlink" title="代办和清单"></a>代办和清单</h1><ul>
<li><input disabled="" type="checkbox"> 表示未完成</li>
<li><input checked="" disabled="" type="checkbox"> 表示已完成</li>
</ul>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>2016 Lark V2.0版App开发过程问题整理</title>
    <url>/iBlogWebsite/2017/03/28/2017/2017-03-28-2016LarkV2.0%E7%89%88App%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-ImageView的background和src的不同"><a href="#1-ImageView的background和src的不同" class="headerlink" title="1. ImageView的background和src的不同"></a>1. ImageView的background和src的不同</h1><p>如果两个属性同时存在,用户会看到 src 属性中设置的背景. 但同时 background 设置的背景也存在, 只是被 src 属性挡住了,在后面. src 等于是前景, background 等于是背景.background 会根据 ImageView 组件给定的长宽进行拉伸, 而 src 就存放的是原图的大小, 不会进行拉伸。src 是图片内容（前景）, bg 是背景, 可以同时使用.此外: scaleType 只对 src 起作用,比如在 ImageView 中就可以用 android:scaleType 控制图片的缩放方式 ; bg 可设置透明度.<br><img src="https://github.com/LeeeYou/Img/blob/master/fixmyproblem/01_img_src.png?raw=true"><br><img src="https://github.com/LeeeYou/Img/blob/master/fixmyproblem/01_img_background.png?raw=true"></p>
<h1 id="2-Glide加载圆形图和圆角图"><a href="#2-Glide加载圆形图和圆角图" class="headerlink" title="2. Glide加载圆形图和圆角图"></a>2. Glide加载圆形图和圆角图</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.leeeyou.fixmyproblem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.Resources;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapShader;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint;</span><br><span class="line"><span class="keyword">import</span> android.graphics.RectF;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.Glide;</span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;</span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.load.resource.bitmap.BitmapTransformation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Problem02_GlideActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_glide);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">imageUrl</span> <span class="operator">=</span> <span class="string">&quot;http://7xptzi.com1.z0.glb.clouddn.com/19%E4%BA%91%E8%AF%BE%E5%A0%82_06.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">img01</span> <span class="operator">=</span> (ImageView) findViewById(R.id.img01);</span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">img02</span> <span class="operator">=</span> (ImageView) findViewById(R.id.img02);</span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">img03</span> <span class="operator">=</span> (ImageView) findViewById(R.id.img03);</span><br><span class="line">        <span class="comment">//Glide.with(this).load(imageUrl).thumbnail(0.1f).into(img01);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// play gif</span></span><br><span class="line">        Glide.with(<span class="built_in">this</span>).load(R.mipmap.pkq).into(img01);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// round image</span></span><br><span class="line">        Glide.with(<span class="built_in">this</span>)</span><br><span class="line">                .load(imageUrl)</span><br><span class="line">                .crossFade()</span><br><span class="line">                .transform(<span class="keyword">new</span> <span class="title class_">GlideRoundTransform</span>(<span class="built_in">this</span>))</span><br><span class="line">                .into(img02);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// circle image</span></span><br><span class="line">        Glide.with(<span class="built_in">this</span>)</span><br><span class="line">                .load(imageUrl)</span><br><span class="line">                .crossFade()</span><br><span class="line">                .transform(<span class="keyword">new</span> <span class="title class_">GlideCircleTransform</span>(<span class="built_in">this</span>))</span><br><span class="line">                .into(img03);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlideCircleTransform</span> <span class="keyword">extends</span> <span class="title class_">BitmapTransformation</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">GlideCircleTransform</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Bitmap <span class="title function_">transform</span><span class="params">(BitmapPool pool, Bitmap toTransform, <span class="type">int</span> outWidth, <span class="type">int</span> outHeight)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> circleCrop(pool, toTransform);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Bitmap <span class="title function_">circleCrop</span><span class="params">(BitmapPool pool, Bitmap source)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (source == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.min(source.getWidth(), source.getHeight());</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (source.getWidth() - size) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (source.getHeight() - size) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">Bitmap</span> <span class="variable">squared</span> <span class="operator">=</span> Bitmap.createBitmap(source, x, y, size, size);</span><br><span class="line"></span><br><span class="line">            <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> pool.get(size, size, Bitmap.Config.ARGB_8888);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Canvas</span>(result);</span><br><span class="line">            <span class="type">Paint</span> <span class="variable">paint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line"></span><br><span class="line">            paint.setShader(<span class="keyword">new</span> <span class="title class_">BitmapShader</span>(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));</span><br><span class="line">            paint.setAntiAlias(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> <span class="variable">radius</span> <span class="operator">=</span> size / <span class="number">2f</span>;</span><br><span class="line">            canvas.drawCircle(radius, radius, radius, paint);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getClass().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlideRoundTransform</span> <span class="keyword">extends</span> <span class="title class_">BitmapTransformation</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">float</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">GlideRoundTransform</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>(context, <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">GlideRoundTransform</span><span class="params">(Context context, <span class="type">int</span> dp)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(context);</span><br><span class="line">            <span class="built_in">this</span>.radius = Resources.getSystem().getDisplayMetrics().density * dp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Bitmap <span class="title function_">transform</span><span class="params">(BitmapPool pool, Bitmap toTransform, <span class="type">int</span> outWidth, <span class="type">int</span> outHeight)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> roundCrop(pool, toTransform);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Bitmap <span class="title function_">roundCrop</span><span class="params">(BitmapPool pool, Bitmap source)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (source == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Canvas</span>(result);</span><br><span class="line">            <span class="type">Paint</span> <span class="variable">paint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">            paint.setShader(<span class="keyword">new</span> <span class="title class_">BitmapShader</span>(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));</span><br><span class="line">            paint.setAntiAlias(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">RectF</span> <span class="variable">rectF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectF</span>(<span class="number">0f</span>, <span class="number">0f</span>, source.getWidth(), source.getHeight());</span><br><span class="line">            canvas.drawRoundRect(rectF, radius, radius, paint);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getClass().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-setCompoundDrawablesWithIntrinsicBounds的优势"><a href="#3-setCompoundDrawablesWithIntrinsicBounds的优势" class="headerlink" title="3. setCompoundDrawablesWithIntrinsicBounds的优势"></a>3. setCompoundDrawablesWithIntrinsicBounds的优势</h1><p>有两个方法可以设置控件的上下左右图标，分别是：<br><strong>第一个方法</strong>：setCompoundDrawablesWithIntrinsicBounds(Drawable left, Drawable top, Drawable right, Drawable bottom)<br><strong>第二种方法</strong>：setCompoundDrawables(Drawable left, Drawable top, Drawable right, Drawable bottom)  </p>
<p>它们的区别是使用第二种方法之前必须已经setBound(Rect)了，api原文如下</p>
<blockquote>
<p>Sets the Drawables (if any) to appear to the left of, above, to the right of, and below the text. Use null if you do not want a Drawable there. The Drawables must already have had setBounds(Rect) called.</p>
</blockquote>
<p>所以：<br>如果想手动设置大小的话就要用setCompoundDrawables，事先要给Drawable设置setBounds；<br>如果按照原有比例大小显示图片就使用setCompoundDrawablesWithIntrinsicBounds  </p>
<h1 id="4-滑动事件冲突的处理"><a href="#4-滑动事件冲突的处理" class="headerlink" title="4. 滑动事件冲突的处理"></a>4. 滑动事件冲突的处理</h1><p><strong>场景</strong>：官方比赛数据页签 - 淘汰赛和积分赛数据 → viewpager(水平) + scrollView(垂直) + HorizontalScrollView(水平) / ListView(垂直)<br><strong>分析</strong>：这里的冲突在于水平事件里面嵌套垂直，再嵌套水平和垂直事件<br><strong>解决</strong>：采用内部拦截法配合getParent().requestDisallowInterceptTouchEvent(false);  </p>
<p>效果图如下：<br><img src="https://github.com/LeeeYou/Img/blob/master/fixmyproblem/04_event.png?raw=true"></p>
<p>这篇日志也记录了<a href="https://leeeyou.github.io/2016/02/29/blog-2016-02-29-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC3%E7%AB%A0-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/">Android艺术探索 第3章 View的事件体系</a></p>
<h1 id="5-shape资源整理"><a href="#5-shape资源整理" class="headerlink" title="5. shape资源整理"></a>5. shape资源整理</h1><p><img src="https://github.com/LeeeYou/Img/blob/master/fixmyproblem/05_shape.png?raw=true"></p>
<p><strong>android:shape=[“rectangle” | “oval” | “line” | “ring”]</strong><br>shape的形状，默认为矩形，可以设置为矩形（rectangle）、椭圆形(oval)、线性形状(line)、环形(ring)下面的属性只有在android:shape=”ring时可用：<br>android:innerRadius    尺寸，内环的半径。<br>android:innerRadiusRatio    浮点型，以环的宽度比率来表示内环的半径，例如，如果android:innerRadiusRatio，表示内环半径等于环的宽度除以5，这个值是可以被覆盖的，默认为9.<br>android:thickness    尺寸，环的厚度<br>android:thicknessRatio    浮点型，以环的宽度比率来表示环的厚度，例如，如果android:thicknessRatio=”2”， 那么环的厚度就等于环的宽度除以2。这个值是可以被android:thickness覆盖的，默认值是3.<br>android:useLevel    boolean值，如果当做是LevelListDrawable使用时值为true，否则为false.  </p>
<p><strong>corners</strong><br>android:radius                                 整型半径<br>android:topLeftRadius                    整型左上角半径<br>android:topRightRadius                  整型右上角半径<br>android:bottomLeftRadius              整型左下角半径<br>android:bottomRightRadius            整型右下角半径  </p>
<p><strong>渐变色</strong><br>android:startColor         颜色值 起始颜色<br>android:endColor          颜色值结束颜色<br>android:centerColor      整型渐变中间颜色，即开始颜色与结束颜色之间的颜色<br>android:angle                整型渐变角度(PS:当angle=0时，渐变色是从左向右。 然后逆时针方向转，当angle=90时为从下往上。angle必须为45的整数倍)<br>android:type             [“linear” | “radial” | “sweep”] 渐变类型(取值：linear、radial、sweep)<br>                         linear 线性渐变，这是默认设置<br>                         radial 放射性渐变，以开始色为中心。<br>                         sweep 扫描线式的渐变。<br>android:useLevel             [“true” | “false”]如果要使用LevelListDrawable对象，就要设置为true。设置为true无渐变。false有渐变色<br>android:gradientRadius   整型渐变色半径.当 android:type=”radial” 时才使用。单独使用 android:type=”radial”会报错。<br>android:centerX               整型渐变中心X点坐标的相对位置<br>android:centerY               整型渐变中心Y点坐标的相对位置  </p>
<p><strong>描边</strong><br>android:width                   整型描边的宽度<br>android:color                    颜色值描边的颜色<br>android:dashWidth           整型表示描边的样式是虚线的宽度， 值为0时，表示为实线。值大于0则为虚线。<br>android:dashGap              整型表示描边为虚线时，虚线之间的间隔 即“ - - - - ”  </p>
<h1 id="6-记录bug-Manifest-merger-failed-error"><a href="#6-记录bug-Manifest-merger-failed-error" class="headerlink" title="6. 记录bug:Manifest merger failed error"></a>6. 记录bug:Manifest merger failed error</h1><p>由于build.gradle文件中的defaultConfig中的信息和其他module中的不同。检查minSdkVersion、targetSdkVersion是否和其他module一致</p>
<h1 id="7-整理ripple"><a href="#7-整理ripple" class="headerlink" title="7. 整理ripple"></a>7. 整理ripple</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:color</span>=<span class="string">&quot;@color/txt_ed4d4d&quot;</span>&gt;</span><span class="comment">&lt;!-- 波纹颜色 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个带圆角的背景 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span> <span class="attr">android:shape</span>=<span class="string">&quot;rectangle&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 正常状态下的颜色 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">&quot;@color/txt_blue&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">stroke</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:width</span>=<span class="string">&quot;2dp&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:color</span>=<span class="string">&quot;@color/txt_ed4d4d&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">corners</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:bottomLeftRadius</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:bottomRightRadius</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:topLeftRadius</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:topRightRadius</span>=<span class="string">&quot;8dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="8-整理fragment-universalAdapter-notify不成功的原因"><a href="#8-整理fragment-universalAdapter-notify不成功的原因" class="headerlink" title="8. 整理fragment universalAdapter notify不成功的原因"></a>8. 整理fragment universalAdapter notify不成功的原因</h1><p>nofityDataSetChange不成功的原因：<br>1、数据源没有更新，调用notifyDataSetChanged无效。<br>2、数据源更新了，但是它指向新的引用，调用notifyDataSetChanged无效。<br>3、数据源更新了，但是adpter没有收到消息通知，无法动态更新列表。  </p>
<p>由于在Fragment中调用notifyDataSetChange老是不成功，所以决定好好的研究研究为何UniversalAdapter会引起此问题。</p>
<p>其实好好的理解上面三条之后，解决ListView刷新不显示的问题，肯定妥妥的。</p>
<p><strong>总结起来就是：数据源的引用一定不能变，但是塞到数据源中的数据一定要更新。牢牢地掌握好这一条之后，ListView刷新不显示的问题就迎刃而解了。</strong></p>
<p><strong>解决“数据源的引用一定不能变”的问题</strong>，可以提前创建一个List对象， mData = new ArrayList&lt;&gt;(); 之后一直对这个mData倒腾即可，不要再引入新的数据源，也就是不要再改变mData的引用地址。</p>
<p><strong>解决“但是塞到数据源中的数据一定要更新”的问题</strong>，可以通过更新数据完成，万一数据源就是没有更新，又想要塞到数据源中，可以通过<br>mData.clear();<br>mData.addAll(data);<br>方法实现。</p>
<p>这次bug的产生就是由于没有事先创建一个mData的对象，直接将入参赋值给mData，导致执行<br>mData.clear();<br>mData.addAll(data);<br>时，先清空了数据集，然后将空数据集添加到了mData中，此时再去调用notifyDataSetChanged()时，其实生效了，但是数据为0，当然就展示了空白页。</p>
<p>同时需要再次调用setAdapter()方法。</p>
<p>通过这次的bug解决，自己认识到遇到问题时，最好追根究底的去解决它。因为你一定会不止一次遇到这个问题。当你彻底理解和掌握了之后，下次再遇到同样的问题时，显然就不是问题了。</p>
<p>解决方法截图：</p>
<p><img src="https://github.com/LeeeYou/Img/blob/master/fixmyproblem/08_adapter_1.png?raw=true"><br><img src="https://github.com/LeeeYou/Img/blob/master/fixmyproblem/08_adapter_2.png?raw=true"></p>
<h1 id="9-记录bug：recyclerView在fragment中-notifyDataSetChange不起作用的问题"><a href="#9-记录bug：recyclerView在fragment中-notifyDataSetChange不起作用的问题" class="headerlink" title="9. 记录bug：recyclerView在fragment中 notifyDataSetChange不起作用的问题"></a>9. 记录bug：recyclerView在fragment中 notifyDataSetChange不起作用的问题</h1><p><strong>现象</strong>：在创建一口价时，activity中放置了两个fragment，选择图片时，跳转到另外一个界面，返回时，又重新创建了fragment<br><strong>分析</strong>：由于采用ViewPager放置两个fragment，在每次切换的是否都创建了新的fragment，导致每次选好照片之后回到viewpager时，又重新创建了新的fragment，所以notifyDataSetChange无效。<br><strong>解决</strong>：两个fragment用全局变量记录保存，不要每次创建新的。<br><strong>后续</strong>：在adapter.getlist.size 返回0时，就应该联想到是否fragment被重新创建了。以此记录  </p>
<h1 id="10-EventBus粘性事件"><a href="#10-EventBus粘性事件" class="headerlink" title="10. EventBus粘性事件"></a>10. EventBus粘性事件</h1><p>EventBus默认支持一条事件总线，通常是通过getDefault()方法获取EventBus实例，但也能通过直接new EventBus这种最简单的方式获取多条事件总线，彼此之间完全分开。例子见com.example.leeeyou.fixmyproblem.Problem05_EventBusActivity</p>
<p>EventBus#Register()其实只做了三件事：  </p>
<ol>
<li>查找订阅者所有的订阅事件  </li>
<li>将订阅事件作为key，所有订阅了此订阅事件的订阅者作为value存放进subscriptionsByEventType  </li>
<li>将订阅者作为key，订阅者的所有订阅事件作为value存放进typesBySubscriber  </li>
</ol>
<p>EventBus#Post()也只做了三件事:  </p>
<ol>
<li>根据订阅事件在subscriptionsByEventType中查找相应的订阅者  </li>
<li>分发订阅者的订阅事件调用线程  </li>
<li>通过反射调用订阅者的订阅事件  </li>
</ol>
<p>粘性事件：发送事件之后再订阅该事件也能收到该事件，跟粘性广播类似。简单来说就是能够收到订阅之前发送的消息。</p>
<h1 id="11-事件传递机制"><a href="#11-事件传递机制" class="headerlink" title="11. 事件传递机制"></a>11. 事件传递机制</h1><p>① 假设最高层View叫OuterLayout，中间层View叫InnerLayout，最底层View叫MyVIew。调用顺序是这样的（假设各个函数返回的都是false）<br>OuterLayout.onInterceptTouchEvent-&gt;InnerLayout.onInterceptTouchEvent-&gt;MyView.onTouchEvent-&gt;InnerLayout.onTouchEvent-&gt;OuterLayout.onTouchEvent。<br><img src="https://github.com/LeeeYou/Img/blob/master/fixmyproblem/11_event_dispatch.png?raw=true"></p>
<p>② 内部拦截法，子控件拦截父控件事件<br><img src="https://github.com/LeeeYou/Img/blob/master/fixmyproblem/11_event_dispatch_2.png?raw=true"></p>
<p>③ 注意点<br>一个view一旦拦截一个某个事件，当前事件所在的完整事件序列将都会由这个view去处理，反应在真实的代码中，就是一旦view拦截了down事件，那么此后的move和up事件都将不调用onInterceptTouchEvent，而直接由它处理，这就也意味着在onInterceptTouchEvent处理事件是不合适的，因为有可能来了事件，却直接跳过onInterceptTouchEvent方法。这个也意味着，一旦一个ViewGroup没有拦截ACTION_DOWN，那么这个事件序列的其他Action，它都将收不到，所以在处理ACTION_DOWN的时候，尤其需要谨慎。</p>
<p>④ 注意点<br>onTouchEvent中是要判断MotionEvent的Action，因为一次点击操作就会调用两次onTouchEvent方法，一次是ACTION_DOWN，一次是ACTION_UP，如果手滑一下，还会有若干个ACTION_MOVE</p>
<p>⑤问题：TextView的onTouchEvent的返回值也是True吗？<br>是的，那为什么点在TextView上面还是能触发它的父视图的onTouchEvent，理论上应该是TextView消耗掉这次的事件，不回传。理论上确实是这样，但是因为TextView的clickable和longClickable属性都是false，当这两个属性都为false的时候，是不会消耗事件的，所以TextView不会消耗事件，这也就可以解释为什么把一个TextView放在一个Button上面，然后点击TextView还是能触发Button的点击事件</p>
<p>⑥问题：view的enable状态和onTouchEvent之间的关系<br>它们之间没有关系，只有clickable状态才对onTouchEvent有影响的，还有一点 ，设置 view的enable为false确实也会把view的clickable设成false，但是设置view的onclickListener就又把view的clickable变成了true，所以最后的解决方案就是把那两行代码换下先后顺序，问题就迎刃而解了。</p>
<p>⑦问题：onTouchListener OnTouchEvent OnClickListener<br>onTouchListener是在onTouch方法中生效，而且onTouch要先于onTouchEvent，就是说一旦设置了onTouchListener并且最后onTouch方法返回了True，那onTouchEvent将不会再被执行。而onClickListener和onTouchEvent有些关系，onTouchEvent的默认实现里会调用onClickListener的onClick方法，如果重写了onTouchEvent，因为onClickListener接受不到ACTION_DOWN和ACTION_UP，那么再设置onClickListener也就不会再生效了，这个时候的单击或者长按处理只能在onTouchEvent中自己处理。</p>
<h1 id="12-patch"><a href="#12-patch" class="headerlink" title="12. patch"></a>12. patch</h1><p>为什么叫9patch呢？Patch的中文意思是”片，块”的意思，那这里按中文的意思来说就是9片或9块.因此可想而知这个图片会被分为9片，如下图片所示:<br><img src="https://github.com/LeeeYou/Img/blob/master/fixmyproblem/12_9patch_1.png?raw=true"><br>工具栏中的Show patches选中，中间紫色的区域就是拉伸区域。<br>工具栏中的Show content选中，看见蓝色的区域，这片区域就是显示内容的区域；比如说：这个图片宽有30px,我们把下面的那一条线的横向的第20px到25px画上了黑点，那么这个图片设置成某个组件的背景后，这个组件的paddingleft就会设置成20dp,paddingRight就会设置成5dp,如果再在布局文件里面设置这两个值，那个这里画的黑点就不起作用了。</p>
<p>工具栏中的Show bad patches选中，可能会出现下图效果：<br><img src="https://github.com/LeeeYou/Img/blob/master/fixmyproblem/12_9patch_2.png?raw=true"><br>其中被选中的3块不符合要求。这里它是根据什么来判断这个绘制的结果不符合要求呢？怎么就认为这三块不符合要求呢？它是根据左侧的黑色的小点所对过来的部分里面的每一个像素点的颜色是否一样。如果像素存在差异，当背景变大的时候就有两种颜色要被重复的绘制，系统就不知道到底绘制这两种颜色哪一种多一点，因此这个工具建议被拉伸的区域只能选择一种颜色。  </p>
<p>如果对结果要求比较高的,右下角坐标显示区域就起作用了。</p>
<h1 id="13-Fragment的使用总结"><a href="#13-Fragment的使用总结" class="headerlink" title="13. Fragment的使用总结"></a>13. Fragment的使用总结</h1><p>1、replace和add方式的区别</p>
<p>replace 是先remove掉相同containerViewId的所有fragment，然后在add当前的这个fragment。  </p>
<blockquote>
<p>Replace an existing fragment that was added to a container. This is essentially the same as calling remove(Fragment) for all currently added fragments that were added with the same containerViewId and then add(int, Fragment, String) with the same arguments given here.</p>
</blockquote>
<p>add 是把一个fragment添加到一个容器 container 里。  </p>
<blockquote>
<p>Add a fragment to the activity state. This fragment may optionally also have its view (if Fragment.onCreateView returns non-null) into a container view of the activity.</p>
</blockquote>
<p>而至于返回键，这个跟事务有关，跟使用add还是replace没有任何关系。</p>
<p>2、采用replace时的生命周期流转</p>
<p>加载fragment<br>09-09 17:17:40.906 E: LifeCycle01Fragment onAttach<br>09-09 17:17:40.906 E: LifeCycle01Fragment onCreate<br>09-09 17:17:40.911 E: LifeCycle01Fragment onCreateView<br>09-09 17:17:40.912 E: LifeCycle01Fragment onViewCreated<br>09-09 17:17:40.912 E: LifeCycle01Fragment onActivityCreated<br>09-09 17:17:40.912 E: LifeCycle01Fragment onStart<br>09-09 17:17:40.912 E: LifeCycle01Fragment onResume  </p>
<p>屏幕灭掉<br>09-09 16:37:30.910 E: LifeCycle01Fragment onPause<br>09-09 16:37:30.953 E: LifeCycle01Fragment onSaveInstanceState<br>09-09 16:37:30.953 E: LifeCycle01Fragment onStop  </p>
<p>点亮屏幕<br>09-09 16:38:05.967 E: LifeCycle01Fragment onStart<br>09-09 16:38:05.976 E: LifeCycle01Fragment onResume  </p>
<p>切换到其他的fragment<br>09-09 16:38:30.691 E: LifeCycle01Fragment onPause<br>09-09 16:38:30.691 E: LifeCycle01Fragment onStop<br>09-09 16:38:30.691 E: LifeCycle01Fragment onDestroyView<br>09-09 16:38:30.691 E: LifeCycle01Fragment onDestroy<br>09-09 16:38:30.691 E: LifeCycle01Fragment onDetach  </p>
<p>切换回本身（相当于重新加载fragment）<br>09-09 17:19:19.368 E: LifeCycle01Fragment onAttach<br>09-09 17:19:19.368 E: LifeCycle01Fragment onCreate<br>09-09 17:19:19.371 E: LifeCycle01Fragment onCreateView<br>09-09 17:19:19.372 E: LifeCycle01Fragment onViewCreated<br>09-09 17:19:19.372 E: LifeCycle01Fragment onActivityCreated<br>09-09 17:19:19.372 E: LifeCycle01Fragment onStart<br>09-09 17:19:19.372 E: LifeCycle01Fragment onResume  </p>
<p>回到桌面<br>09-09 16:39:49.689 E: LifeCycle01Fragment onPause<br>09-09 16:39:49.803 E: LifeCycle01Fragment onSaveInstanceState<br>09-09 16:39:49.803 E: LifeCycle01Fragment onStop  </p>
<p>回到应用<br>09-09 16:40:10.743 E: LifeCycle01Fragment onStart<br>09-09 16:40:10.743 E: LifeCycle01Fragment onResume  </p>
<p>退出应用<br>09-09 16:44:06.357 E: LifeCycle01Fragment onPause<br>09-09 16:44:06.662 E: LifeCycle01Fragment onStop<br>09-09 16:44:06.663 E: LifeCycle01Fragment onDestroyView<br>09-09 16:44:06.663 E: LifeCycle01Fragment onDestroy<br>09-09 16:44:06.663 E: LifeCycle01Fragment onDetach  </p>
<p>采用replace方式的生命周期相对比较简单，因为replace的机制是remove掉相同containerViewId的fragment，再重新加载一把fragment。</p>
<p>3、采用add - show - hide方式的生命周期流转</p>
<p>加载fragment<br>09-09 17:14:04.440 E: LifeCycle01Fragment onAttach<br>09-09 17:14:04.440 E: LifeCycle01Fragment onCreate<br>09-09 17:14:04.445 E: LifeCycle01Fragment onCreateView<br>09-09 17:14:04.446 E: LifeCycle01Fragment onViewCreated<br>09-09 17:14:04.446 E: LifeCycle01Fragment onActivityCreated<br>09-09 17:14:04.446 E: LifeCycle01Fragment onStart<br>09-09 17:14:04.446 E: LifeCycle01Fragment onResume  </p>
<p>屏幕灭掉<br>09-09 16:37:30.910 E: LifeCycle01Fragment onPause<br>09-09 16:37:30.953 E: LifeCycle01Fragment onSaveInstanceState<br>09-09 16:37:30.953 E: LifeCycle01Fragment onStop  </p>
<p>点亮屏幕<br>09-09 16:38:05.967 E: LifeCycle01Fragment onStart<br>09-09 16:38:05.976 E: LifeCycle01Fragment onResume  </p>
<p>切换到其他的fragment<br>没有执行到生命周期方法  </p>
<p>切回本身（addToBackStack的情况下）<br>09-09 17:14:53.309 E: LifeCycle01Fragment onPause<br>09-09 17:14:53.309 E: LifeCycle01Fragment onStop<br>09-09 17:14:53.309 E: LifeCycle01Fragment onDestroyView<br>09-09 17:14:53.310 E: LifeCycle01Fragment onDestroy<br>09-09 17:14:53.310 E: LifeCycle01Fragment onDetach  </p>
<p>回到桌面<br>09-09 17:15:50.753 E: LifeCycle01Fragment onPause<br>09-09 17:15:50.855 E: LifeCycle01Fragment onSaveInstanceState<br>09-09 17:15:50.855 E: LifeCycle01Fragment onStop  </p>
<p>回到应用<br>09-09 17:16:12.903 E: LifeCycle01Fragment onStart<br>09-09 17:16:12.903 E: LifeCycle01Fragment onResume  </p>
<p>退出应用<br>09-09 17:16:30.815 E: LifeCycle01Fragment onPause<br>09-09 17:16:30.815 E: LifeCycle01Fragment onStop<br>09-09 17:16:30.815 E: LifeCycle01Fragment onDestroyView<br>09-09 17:16:30.816 E: LifeCycle01Fragment onDestroy<br>09-09 17:16:30.816 E: LifeCycle01Fragment onDetach  </p>
<p>这种方式有个值得注意的地方是切换到其他framgent时，并没有执行生命周期。❓</p>
<p>与Activity生命周期的对比<br><img src="https://github.com/LeeeYou/Img/blob/master/fixmyproblem//13_fragment_lifecycle.png?raw=true"></p>
<p>对于replace和add方式的选择，官方文档解释说：replace()这个方法只是在上一个Fragment不再需要时采用的简便方法。正确的切换方式是add()，切换时hide()，add()另一个Fragment；再次切换时，只需hide()当前，show()另一个。这样就能做到多个Fragment切换不重新实例化。</p>
<p>fragment的生命周期与activity的生命周期的一个关键区别就在于：fragment的生命周期方法是由托管acitivity而不是操作系统调用的。操作系统无从知晓activity用来管理视图的fragment。fragment的使用是activity自己内部的使用。</p>
<p>4、addToBackStack<br>对于是否要加transaction.addToBackStack(null);也就是将Fragment加入到回退栈。官方的说法是取决于你是否要在回退的时候显示上一个Fragment。</p>
<h1 id="14-Math中对于小数的处理"><a href="#14-Math中对于小数的处理" class="headerlink" title="14. Math中对于小数的处理"></a>14. Math中对于小数的处理</h1><p>09-11 10:18:14.193 I: Math.ceil(109.82934) = 110.0<br>09-11 10:18:14.193 I: Math.floor(109.82934) = 109.0<br>09-11 10:18:14.193 I: Math.round(109.82934) = 110<br>09-11 10:18:14.194 I: DecimalFormat 0.00 会四舍五入小数部分, 109.82964 约等于 109.83<br>09-11 10:18:14.194 I: DecimalFormat #.00 会四舍五入小数部分, 109.82964 约等于 109.83<br>09-11 10:18:14.195 I: String format %.2f 会四舍五入小数部分, 109.82964 约等于 109.83<br>09-11 10:18:14.196 I: BigDecimal  3位小数 BigDecimal.ROUND_HALF_UP 会四舍五入小数部分, 109.82964 约等于 109.830<br>09-11 10:18:14.196 I: BigDecimal  3位小数 BigDecimal.ROUND_DOWN 直接舍弃小数部分, 109.82964 约等于 109.829<br>09-11 10:18:14.209 I: float型转json  : {“name”:”Jack”,”score”:0.01}  </p>
<h1 id="15-开发经验整理"><a href="#15-开发经验整理" class="headerlink" title="15. 开发经验整理"></a>15. 开发经验整理</h1><p>① 对于图片的处理，务必考虑使用缩略图<br>② 类似订单状态和货架状态的需求，在有很多个状态的情况下，在开发之前最好整理各个状态对应的操作和文案；同时尽量做成一个Activity，避免跳转的时候跳转多界面的处理，同时对外的入参最好也只依赖一个orderId或者goodsId之类的，不要传递完整的对象，因为有可能其他模块提供不了完整对象。<br>③ 订单的多个状态下，写了多个activity去匹配，这样的缺点是当有消息推送时，不能根据一个orderId准确的知道需要跳转到哪个界面去。  </p>
<h1 id="16-ExpandableListView"><a href="#16-ExpandableListView" class="headerlink" title="16. ExpandableListView"></a>16. ExpandableListView</h1><p>① 更改箭头的位置<br>调用setGroupIndicator(null);可以隐藏指示器  </p>
<p>可以在getGroupView中根据isExpanded来动态显示上箭头和下箭头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">getGroupView</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> groupPosition, <span class="type">boolean</span> isExpanded, View convertView, ViewGroup parent)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isExpanded) &#123;</span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeResource(context.getResources(), R.mipmap.icon_arrow_down_grey);</span><br><span class="line">        <span class="type">BitmapDrawable</span> <span class="variable">bitmapDrawable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapDrawable</span>(context.getResources(), bitmap);</span><br><span class="line">        groupViewHolder.tv_game_schedule_num.setCompoundDrawablesWithIntrinsicBounds(<span class="literal">null</span>, <span class="literal">null</span>, bitmapDrawable, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeResource(context.getResources(), R.mipmap.icon_arrow_up_grey);</span><br><span class="line">        <span class="type">BitmapDrawable</span> <span class="variable">bitmapDrawable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapDrawable</span>(context.getResources(), bitmap);</span><br><span class="line">        groupViewHolder.tv_game_schedule_num.setCompoundDrawablesWithIntrinsicBounds(<span class="literal">null</span>, <span class="literal">null</span>, bitmapDrawable, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> convertView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>② BaseExpandableListAdapter点击时，影响其他item的问题<br><strong>问题</strong>：造成此问题的原因是setGroupViewListener方法中先去获取了ExpandableListView当前的收起/展开状态，然后根据此状态再去调用collapseGroup或expandGroup，最后立即通过ExpandableListView.isGroupExpanded获取此时的收起/展开状态，此时的状态是不准确的。  </p>
<p><strong>解决方案</strong>：在调用collapseGroup或expandGroup方法之后，监听onGroupExpanded和onGroupCollapsed方法，在其中调用notifyDataSetChanged();去刷新界面，然后在getGroupView中根据isExpanded去动态改变UI的上箭头还是下箭头。  </p>
<p>③ BaseExpandableListAdapter notifyDataSetChange()的问题<br><strong>问题</strong>：调用notifyDataSetChange()无效  </p>
<p><strong>分析</strong>：开始以为是notifyDataSetChange没有刷新造成的，后台debug跟进到Adapter的getGroupView时，发现调用了getGroupView方法，也就是系统API执行了刷新操作，只是getGroupView中自己的逻辑处理有问题。当前如果是没有数据的情况，getGroupView展示的是item_no_data_layout布局，但是如果有数据进来，调用notifyDataSetChange时，会执行到getGroupView，此时会复用item_no_data_layout布局，但是此布局并不是我们的数据展示布局，所以要再加一层判断，如viewHolder==null，需要再加载一次item_offical_game布局到convertView  </p>
<p><strong>解决方案</strong>：双层判断viewHolder==null，如果为null，需要再加载一次item_offical_game布局到convertView  </p>
<p><img src="https://github.com/LeeeYou/Img/blob/master/fixmyproblem/16_expandlistview.png?raw=true"></p>
<h1 id="17-JSONArray-，JSONObject-json相互转换"><a href="#17-JSONArray-，JSONObject-json相互转换" class="headerlink" title="17. JSONArray ，JSONObject , json相互转换"></a>17. JSONArray ，JSONObject , json相互转换</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jsonobject , jsonarray , json 互转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Problem10_JSONArray_Activity</span> <span class="keyword">extends</span> <span class="title class_">BaseActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_jsonarray);</span><br><span class="line"></span><br><span class="line">        jsonStringTojsonObj();</span><br><span class="line">        jsonArrayTojsonObj();</span><br><span class="line">        jsonObjTojsonObj();</span><br><span class="line">        listobjTojsonArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">listobjTojsonArray</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; imageList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        imageList.add(<span class="string">&quot;http://quncao-app.b0.upaiyun.com/51c1e24b6b821c916f732c2aa5b1dc9f.jpg&quot;</span>);</span><br><span class="line">        imageList.add(<span class="string">&quot;http://quncao-app.b0.upaiyun.com/8ad331112d30453d2ace4c31903c5c55.jpg&quot;</span>);</span><br><span class="line">        imageList.add(<span class="string">&quot;http://quncao-app.b0.upaiyun.com/839f7a8407047bab2d7a721c114912df.jpg&quot;</span>);</span><br><span class="line">        imageList.add(<span class="string">&quot;http://quncao-app.b0.upaiyun.com/369ca74245ebc32d512eae501e7de807.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">JSONArray</span> <span class="variable">jsonArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONArray</span>(<span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(imageList));</span><br><span class="line"></span><br><span class="line">            Log.e(<span class="string">&quot;com.jsonarray&quot;</span>, <span class="string">&quot;listobjTojsonArray Gson ---- &quot;</span> + jsonArray.toString());</span><br><span class="line"></span><br><span class="line">            <span class="type">JSONArray</span> <span class="variable">jsonArray2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONArray</span>(imageList);</span><br><span class="line">            Log.e(<span class="string">&quot;com.jsonarray&quot;</span>, <span class="string">&quot;listobjTojsonArray 直接转换 ---- &quot;</span> + jsonArray2.toString());</span><br><span class="line"></span><br><span class="line">            Log.e(<span class="string">&quot;com.jsonarray&quot;</span>, <span class="string">&quot;-------------------- &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">jsonObjTojsonObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JSONArray</span> <span class="variable">jsonArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONArray</span>();</span><br><span class="line">        jsonArray.put(<span class="string">&quot;http://quncao-app.b0.upaiyun.com/51c1e24b6b821c916f732c2aa5b1dc9f.jpg&quot;</span>);</span><br><span class="line">        jsonArray.put(<span class="string">&quot;http://quncao-app.b0.upaiyun.com/8ad331112d30453d2ace4c31903c5c55.jpg&quot;</span>);</span><br><span class="line">        jsonArray.put(<span class="string">&quot;http://quncao-app.b0.upaiyun.com/839f7a8407047bab2d7a721c114912df.jpg&quot;</span>);</span><br><span class="line">        jsonArray.put(<span class="string">&quot;http://quncao-app.b0.upaiyun.com/369ca74245ebc32d512eae501e7de807.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jsonObject.put(<span class="string">&quot;imageList&quot;</span>, jsonArray);</span><br><span class="line">            jsonObject.put(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>);</span><br><span class="line">            jsonObject.put(<span class="string">&quot;nickName&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接调用toString可以将JSONObject转换成json字符串</span></span><br><span class="line">        Log.e(<span class="string">&quot;com.jsonarray&quot;</span>, <span class="string">&quot;jsonObjTojsonObj ---- &quot;</span> + jsonObject.toString());</span><br><span class="line"></span><br><span class="line">        Log.e(<span class="string">&quot;com.jsonarray&quot;</span>, <span class="string">&quot;jsonObjTojsonObj Gson ---- &quot;</span> + <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(jsonObject));</span><br><span class="line"></span><br><span class="line">        Log.e(<span class="string">&quot;com.jsonarray&quot;</span>, <span class="string">&quot;-------------------- &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">jsonArrayTojsonObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JSONArray</span> <span class="variable">jsonArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONArray</span>();</span><br><span class="line">        jsonArray.put(<span class="string">&quot;http://quncao-app.b0.upaiyun.com/51c1e24b6b821c916f732c2aa5b1dc9f.jpg&quot;</span>);</span><br><span class="line">        jsonArray.put(<span class="string">&quot;http://quncao-app.b0.upaiyun.com/8ad331112d30453d2ace4c31903c5c55.jpg&quot;</span>);</span><br><span class="line">        jsonArray.put(<span class="string">&quot;http://quncao-app.b0.upaiyun.com/839f7a8407047bab2d7a721c114912df.jpg&quot;</span>);</span><br><span class="line">        jsonArray.put(<span class="string">&quot;http://quncao-app.b0.upaiyun.com/369ca74245ebc32d512eae501e7de807.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接调用toString可以将JSONArray转换成json字符串</span></span><br><span class="line">        Log.e(<span class="string">&quot;com.jsonarray&quot;</span>, <span class="string">&quot;jsonArrayTojsonObj ---- &quot;</span> + jsonArray.toString());</span><br><span class="line"></span><br><span class="line">        Log.e(<span class="string">&quot;com.jsonarray&quot;</span>, <span class="string">&quot;-------------------- &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">jsonStringTojsonObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">imageObject</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;imageList\&quot;:[&#123;\&quot;id\&quot;: 292,\&quot;imageUrl\&quot;: \&quot;http://quncao-app.b0.upaiyun.com/51c1e24b6b821c916f732c2aa5b1dc9f.jpg\&quot;&#125;,&#123;\&quot;id\&quot;: 289,\&quot;imageUrl\&quot;: \&quot;http://quncao-app.b0.upaiyun.com/8ad331112d30453d2ace4c31903c5c55.jpg\&quot;&#125;,&#123;\&quot;id\&quot;: 288,\&quot;imageUrl\&quot;: \&quot;http://quncao-app.b0.upaiyun.com/839f7a8407047bab2d7a721c114912df.jpg\&quot;&#125;,&#123;\&quot;id\&quot;: 291,\&quot;imageUrl\&quot;: \&quot;http://quncao-app.b0.upaiyun.com/369ca74245ebc32d512eae501e7de807.jpg\&quot;&#125;]&#125;&quot;</span>;</span><br><span class="line">        <span class="type">FixedPrice</span> <span class="variable">fixedPrice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(imageObject, FixedPrice.class);</span><br><span class="line">        Log.e(<span class="string">&quot;com.jsonarray&quot;</span>, <span class="string">&quot;jsonStringTojsonObj ---- &quot;</span> + fixedPrice.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">imageArray</span> <span class="operator">=</span> <span class="string">&quot;[&#123;\&quot;id\&quot;: 292,\&quot;imageUrl\&quot;: \&quot;http://quncao-app.b0.upaiyun.com/51c1e24b6b821c916f732c2aa5b1dc9f.jpg\&quot;&#125;,&#123;\&quot;id\&quot;: 289,\&quot;imageUrl\&quot;: \&quot;http://quncao-app.b0.upaiyun.com/8ad331112d30453d2ace4c31903c5c55.jpg\&quot;&#125;,&#123;\&quot;id\&quot;: 288,\&quot;imageUrl\&quot;: \&quot;http://quncao-app.b0.upaiyun.com/839f7a8407047bab2d7a721c114912df.jpg\&quot;&#125;,&#123;\&quot;id\&quot;: 291,\&quot;imageUrl\&quot;: \&quot;http://quncao-app.b0.upaiyun.com/369ca74245ebc32d512eae501e7de807.jpg\&quot;&#125;]&quot;</span>;</span><br><span class="line">        List&lt;Image&gt; imageList = <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(imageArray, <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;List&lt;Image&gt;&gt;() &#123;</span><br><span class="line">        &#125;.getType());</span><br><span class="line"></span><br><span class="line">        Log.e(<span class="string">&quot;com.jsonarray&quot;</span>, <span class="string">&quot;jsonStringTojsonObj gson fromJson ---- &quot;</span> + fixedPrice.toString());</span><br><span class="line">        Log.e(<span class="string">&quot;com.jsonarray&quot;</span>, <span class="string">&quot;jsonStringTojsonObj TypeToken ---- &quot;</span> + imageList.toString());</span><br><span class="line"></span><br><span class="line">        Log.e(<span class="string">&quot;com.jsonarray&quot;</span>, <span class="string">&quot;-------------------- &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String imageUrl;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FixedPrice</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;Image&gt; imageList;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="18-记录bug-Fragment-already-active"><a href="#18-记录bug-Fragment-already-active" class="headerlink" title="18. 记录bug:Fragment already active"></a>18. 记录bug:Fragment already active</h1><p><strong>现象</strong>：<br>反复进入退出进入退出某一个fragment界面导致<br><strong>分析</strong>：<br>在 Fragment 没有被添加到 FragmentManager 之前，我们可以通过 Fragment.setArguments() 来设置参数，并在 Fragment 中，使用 getArguments() 来取得参数。在 Fragment 被添加到 FragmentManager 后，一旦被使用，我们再次调用 setArguments() 将会导致 java.lang.IllegalStateException: Fragment already active 异常。<br><strong>解决</strong>：<br>1、可以在add()方法时候,先判断currentFragment.isAdded();<br>2、可以使用setter和getter Fragment的属性方法进行数据的存储和获取;  </p>
<h1 id="19-记录bug-调用fragment的replace加载显示异常的问题"><a href="#19-记录bug-调用fragment的replace加载显示异常的问题" class="headerlink" title="19. 记录bug:调用fragment的replace加载显示异常的问题"></a>19. 记录bug:调用fragment的replace加载显示异常的问题</h1><p><strong>现象</strong>：<br>现有FragmentA和FragmentB，当前显示FragmentA，用fragmentTransaction调用replace加载FragmentB时，可能会出现加载不成功的情况，显示的还是FragmentA<br><strong>分析</strong>：<br>使用replace会带来一个问题，FragmentA在replace后会被销毁，会调用其生命周期函数(onDestoryView()、onPause()、onDestory())。如果频繁地replace Fragment会不断创建新实例并销毁旧的，无法重用。经过多次切换后，会导致Fragment上的View无法加载的问题，此时就会出现点击切换图标，还是显示FragmentA<br><strong>解决</strong>：<br>可以利用add()方法配合show()和hide()来弥补replace带来的低效问题  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">hideFragments</span><span class="params">(FragmentTransaction transaction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (indexFragment != <span class="literal">null</span>) &#123;</span><br><span class="line">            transaction.hide(indexFragment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newVenueFragment != <span class="literal">null</span>) &#123;</span><br><span class="line">            transaction.hide(newVenueFragment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sportVenueFragment != <span class="literal">null</span>) &#123;</span><br><span class="line">            transaction.hide(sportVenueFragment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (messageMainFragment != <span class="literal">null</span>) &#123;</span><br><span class="line">            transaction.hide(messageMainFragment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mineFragment != <span class="literal">null</span>) &#123;</span><br><span class="line">            transaction.hide(mineFragment);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再调用如下方法来显示你要替换的fragment</span></span><br><span class="line">fragmentTransaction.show(indexFragment);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="20-ScrollView中嵌套ListView时，ListView抢夺焦点问题"><a href="#20-ScrollView中嵌套ListView时，ListView抢夺焦点问题" class="headerlink" title="20. ScrollView中嵌套ListView时，ListView抢夺焦点问题"></a>20. ScrollView中嵌套ListView时，ListView抢夺焦点问题</h1><p>ListView嵌入到可滚动的控件中时，ListView会抢夺页面的焦点。对于此类问题的终极解决方案是：使用属性 <strong>descendantFocusabilit</strong>。<br>android:descendantFocusability属性共有三个取值<br>1 beforeDescendants：viewgroup 会优先其子类控件而获取到焦点<br>2 afterDescendants： viewgroup 只有当其子类控件不需要获取焦点时才获取焦点<br>3 blocksDescendants：viewgroup 会覆盖子类控件而直接获得焦点   </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.quncao.pulltorefreshlib.PullToRefreshScrollView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/pullToRefreshScrollView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#e8e8e8&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:descendantFocusability</span>=<span class="string">&quot;blocksDescendants&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="21-ScrollView-MATCH-PARENT-无法填满屏幕"><a href="#21-ScrollView-MATCH-PARENT-无法填满屏幕" class="headerlink" title="21. ScrollView MATCH_PARENT 无法填满屏幕"></a>21. ScrollView MATCH_PARENT 无法填满屏幕</h1><p>在ScrollView中嵌套一个RelativeLayout,并设置MATCH_PARENT给RelativeLayout。此时想在屏幕底部放置一个Button会出现无法正确的固定到底部。<br>通过设置ScrollView的android:fillViewport为true可以解决此问题。</p>
<p>当ScrollView未设置fillViewport=“true”时, 里面的元素(比如LinearLayout)会按照wrap_content来计算(不论它是否设了”match_parent”),而如果LinearLayout的元素设置了match_parent,那么也是不管用的。因为LinearLayout依赖里面的元素，而里面的元素又依赖LinearLayout,这样自相矛盾。所以里面元素设置了match_parent，也会当做wrap_content来计算。</p>
<h1 id="22-判断RecyclerView是否可以垂直滚动"><a href="#22-判断RecyclerView是否可以垂直滚动" class="headerlink" title="22. 判断RecyclerView是否可以垂直滚动"></a>22. 判断RecyclerView是否可以垂直滚动</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">RecyclerView.canScrollVertically(<span class="number">1</span>)的值表示是否能向上滚动，<span class="literal">false</span>表示已经滚动到底部</span><br><span class="line">RecyclerView.canScrollVertically(-<span class="number">1</span>)的值表示是否能向下滚动，<span class="literal">false</span>表示已经滚动到顶部</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面这段代码是在PtrFrameLayout中嵌套RecyclerView的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ptrFrame.setPtrHandler(<span class="keyword">new</span> <span class="title class_">PtrHandler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRefreshBegin</span><span class="params">(PtrFrameLayout frame)</span> &#123;</span><br><span class="line">        onRefreshBefore();</span><br><span class="line"></span><br><span class="line">        fetchDataFromServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkCanDoRefresh</span><span class="params">(PtrFrameLayout frame, View content, View header)</span> &#123;</span><br><span class="line">        <span class="comment">// 默认实现，根据实际情况做改动</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !mRecyclerView.canScrollVertically(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="23-LoaderManager的使用"><a href="#23-LoaderManager的使用" class="headerlink" title="23. LoaderManager的使用"></a>23. LoaderManager的使用</h1><p>1.Loader特性：<br>(1).对于每个Activity或者Fragment都可用<br>(2).提供异步加载数据<br>(3).监视数据资源，当内容改变时重新更新<br>(4).当配置改变时，自动重新连接最新的cursor，故不需要重新查询数据  </p>
<p>2.Loader相关类接口<br>(1).LoaderManager<br>对于每个activity或者fragment只存在一个与之相关的LoaderManager对象,该LoaderManager对象可以存在多个可供管理loader对象。<br>(2).LoaderManager.LoaderCallbacks<br>LoaderManager.LoaderCallbacks是个回掉接口，用于客户端与LoaderManager的交互，loader对象就是在其接口的onCreateLoader()方法中得到，在使用时需要覆盖其方法。<br>(3).CursorLoader<br>CursorLoader是AsyncTaskLoader的子类，通过它可以查询ContentResolver并返回一个Cursor对象，并使用该cursor对象在后台线程执行查询操作，以不至于会阻塞主线程，从一个内容提供者去异步加载数据是CursorLoader对象最大用处。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GalleryFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> <span class="keyword">implements</span> <span class="title class_">LoaderManager</span>.LoaderCallbacks&lt;Cursor&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> GalleryAdapter mGalleryAdapter;</span><br><span class="line">    <span class="keyword">private</span> ImageLoader imageLoader;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换目录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dirId   目录id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dirName 目录名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">switchDir</span><span class="params">(<span class="type">int</span> dirId, String dirName)</span> &#123;</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        bundle.putInt(<span class="string">&quot;dirId&quot;</span>, dirId);</span><br><span class="line">        getLoaderManager().restartLoader(<span class="number">0</span>, bundle, <span class="built_in">this</span>);</span><br><span class="line">        title.setText(dirName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStop();</span><br><span class="line">        imageLoader.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Loader&lt;Cursor&gt; <span class="title function_">onCreateLoader</span><span class="params">(<span class="type">int</span> id, Bundle args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">select</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">            dirId = args.getInt(<span class="string">&quot;dirId&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (dirId != <span class="number">0</span>) &#123;</span><br><span class="line">                select = String.format(<span class="string">&quot;%s == %s&quot;</span>, MediaStore.Images.Media.BUCKET_ID, dirId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Uri</span> <span class="variable">baseUri</span> <span class="operator">=</span> MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CursorLoader</span>(getActivity(),</span><br><span class="line">                baseUri,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;MediaStore.Images.Media._ID, MediaStore.Images.Media.DATA,&#125;,</span><br><span class="line">                select,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                MediaStore.Images.Media.DATE_TAKEN + <span class="string">&quot; DESC&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadFinished</span><span class="params">(Loader&lt;Cursor&gt; loader, Cursor data)</span> &#123;</span><br><span class="line">        mGalleryAdapter.swapCursor(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoaderReset</span><span class="params">(Loader&lt;Cursor&gt; loader)</span> &#123;</span><br><span class="line">        mGalleryAdapter.swapCursor(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="24-不透明度16进制值"><a href="#24-不透明度16进制值" class="headerlink" title="24. 不透明度16进制值"></a>24. 不透明度16进制值</h1><table>
<thead>
<tr>
<th align="center">不透明度</th>
<th align="center">16进制值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100%</td>
<td align="center">FF</td>
</tr>
<tr>
<td align="center">95%</td>
<td align="center">F2</td>
</tr>
<tr>
<td align="center">90%</td>
<td align="center">E6</td>
</tr>
<tr>
<td align="center">85%</td>
<td align="center">D9</td>
</tr>
<tr>
<td align="center">80%</td>
<td align="center">CC</td>
</tr>
<tr>
<td align="center">75%</td>
<td align="center">BF</td>
</tr>
<tr>
<td align="center">70%</td>
<td align="center">B3</td>
</tr>
<tr>
<td align="center">65%</td>
<td align="center">A6</td>
</tr>
<tr>
<td align="center">60%</td>
<td align="center">99</td>
</tr>
<tr>
<td align="center">55%</td>
<td align="center">8C</td>
</tr>
<tr>
<td align="center">50%</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">45%</td>
<td align="center">73</td>
</tr>
<tr>
<td align="center">40%</td>
<td align="center">66</td>
</tr>
<tr>
<td align="center">35%</td>
<td align="center">59</td>
</tr>
<tr>
<td align="center">30%</td>
<td align="center">4D</td>
</tr>
<tr>
<td align="center">25%</td>
<td align="center">40</td>
</tr>
<tr>
<td align="center">20%</td>
<td align="center">33</td>
</tr>
<tr>
<td align="center">15%</td>
<td align="center">26</td>
</tr>
<tr>
<td align="center">10%</td>
<td align="center">1A</td>
</tr>
<tr>
<td align="center">5%</td>
<td align="center">0D</td>
</tr>
<tr>
<td align="center">0%</td>
<td align="center">00</td>
</tr>
</tbody></table>
<h1 id="25-髙扇入低扇出"><a href="#25-髙扇入低扇出" class="headerlink" title="25. 髙扇入低扇出"></a>25. 髙扇入低扇出</h1><p>在软件设计中，扇入和扇出的概念是指应用程序模块之间的层次调用情况。按照结构化设计方法，一个应用程序是由多个功能相对独立的模块所组成。扇入：是指直接调用该模块的上级模块的个数。扇入大表示模块的复用程序高。</p>
<p>扇出：是指该模块直接调用的下级模块的个数。扇出大表示模块的复杂度高，需要控制和协调过多的下级模块；但扇出过小（例如总是1）也不好。扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的模块。扇出太小时可以把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。</p>
<p>设计良好的软件结构，通常顶层扇出比较大，中间扇出小，底层模块则有大扇入。</p>
<h1 id="26-What-How-Why"><a href="#26-What-How-Why" class="headerlink" title="26. What-How-Why"></a>26. What-How-Why</h1><ul>
<li>What - “What is it?” 你要搞清楚某个东东是【什么】样子的？有【什么】用处？有【什么】特性？有【什么】语法？</li>
<li>How - “How to do?” 你要搞清楚某个东西，其内部是【如何】运作的？【如何】实现的？</li>
<li>Why - 就是搞清楚某个东西【为什么】设计成这样？【为什么】不是另外的样子？这样的设计有什么讲究？</li>
</ul>
<h1 id="27-网络框架应具备的功能"><a href="#27-网络框架应具备的功能" class="headerlink" title="27. 网络框架应具备的功能"></a>27. 网络框架应具备的功能</h1><h2 id="27-1-OkHttp"><a href="#27-1-OkHttp" class="headerlink" title="27.1. OkHttp"></a>27.1. OkHttp</h2><p><a href="http://blog.csdn.net/sunshine2050_csdn/article/details/50819261">OkHttp3升级实践与之前2.0对比</a></p>
<ul>
<li>提供一个合适的辅助类</li>
<li>基本的get，post请求</li>
<li>基本的同步和异步请求</li>
<li>下载文件以及进度回调<ul>
<li>对于超过1MB的响应body，应使用流的方式来处理body。</li>
</ul>
</li>
<li>取消某个网络请求</li>
<li>OkHttp参数配置</li>
<li>配置日志打印拦截器</li>
<li>配置网络连接拦截器</li>
<li>参考 <a href="https://github.com/hongyangAndroid/okhttp-utils">https://github.com/hongyangAndroid/okhttp-utils</a></li>
<li>单例方式提供OkHttpClient</li>
</ul>
<h2 id="27-2-Retrofit"><a href="#27-2-Retrofit" class="headerlink" title="27.2. Retrofit"></a>27.2. Retrofit</h2><ul>
<li>使用原生的Call类型处理返回结果</li>
<li>使用RxJava方式处理返回结果</li>
<li>解决Https访问的问题，SSLSocketFactory</li>
<li>解决直接返回String类型数据的问题，StringConverterFactory <a href="http://www.jianshu.com/p/308f3c54abdd">http://www.jianshu.com/p/308f3c54abdd</a></li>
<li>配置统一的OkHttpClient给Retrofit</li>
<li>处理先后访问两个网络请求的情况[需求：获取某人的某个项目下所有关注者自己的所有项目列表]</li>
<li>下载jar包</li>
<li>配置网络连接拦截器</li>
<li>对返回结果再封装</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>知识汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之自定义控件整理</title>
    <url>/iBlogWebsite/2017/04/01/2017/2017-04-01-Android%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-view的绘制过程"><a href="#1-view的绘制过程" class="headerlink" title="1. view的绘制过程"></a>1. view的绘制过程</h1><p>首先还是有必要谈下view的绘制过程，这里不得不提ViewRoot，ViewRoot对应ViewRootImpl类，是连接WindowManager和DecorView的纽带。View的三大流程均是通过ViewRoot来完成的。</p>
<p>同时View的绘制流程从ViewRoot的performTraversals开始，经过measure，layout，draw三个过程才能最终将一个View绘制出来。简单来说measure用来测量View的宽和高，layout用来确定View在父容器中放置的位置，而draw则负责将View绘制在屏幕上。</p>
<p>总体绘制流程如下：</p>
<ul>
<li>measure过程决定了View的宽/高，measure完成以后，可以通过getMeasureWidth和getMeasureHeight方法来获取到View测量后的宽/高，<strong>在几乎所有情况下它都等同于View的最终宽高</strong>，但是特殊情况下后面讨论。  </li>
<li>layout过程决定了view的四个顶点的坐标和实际的view的宽高，完成以后，可以通过getTop，getBottom,getLeft,getRight来拿到view的四个顶点的位置，并可以通过getWidth和getHeight方法来拿到view的最终宽高。</li>
<li>draw过程则决定了view的显示，只有draw方法完成以后view的内容才能呈现在屏幕上。</li>
</ul>
<p>上面提及的特殊情况如下：</p>
<ul>
<li>重写view的onLayout方法，就能使测量宽高不等于最终宽高</li>
<li>另一种情况，view需要多次measure才能确定自己的测量宽高，在前几次的测量过程中，其得出的测量宽高有可能和最终宽高不一致，但最终来说，测量宽高还是和最终宽高一致</li>
</ul>
<h1 id="2-measure过程"><a href="#2-measure过程" class="headerlink" title="2. measure过程"></a>2. measure过程</h1><p>几乎所有情况下view的测量大小和最终大小相等</p>
<h2 id="2-1-View的measure"><a href="#2-1-View的measure" class="headerlink" title="2.1. View的measure"></a>2.1. View的measure</h2><p>需重写onMeasure同时设置wrap_content时自身的大小，否则在布局中wrap_content相当于match_parent。同时考虑paddig的影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    <span class="type">int</span> resultWidth;</span><br><span class="line">    <span class="type">int</span> <span class="variable">modeWidth</span> <span class="operator">=</span> MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeWidth</span> <span class="operator">=</span> MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (modeWidth == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        resultWidth = sizeWidth;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resultWidth = mBitmap.getWidth() + getPaddingLeft() + getPaddingRight();</span><br><span class="line">        <span class="keyword">if</span> (modeWidth == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            resultWidth = Math.min(resultWidth, sizeWidth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> resultHeight;</span><br><span class="line">    <span class="type">int</span> <span class="variable">modeHeight</span> <span class="operator">=</span> MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeHeight</span> <span class="operator">=</span> MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (modeHeight == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        resultHeight = sizeHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resultHeight = mBitmap.getHeight() + getPaddingTop() + getPaddingBottom();</span><br><span class="line">        <span class="keyword">if</span> (modeHeight == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            resultHeight = Math.min(resultHeight, sizeHeight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimension(resultWidth, resultHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-ViewGroup的measure"><a href="#2-2-ViewGroup的measure" class="headerlink" title="2.2. ViewGroup的measure"></a>2.2. ViewGroup的measure</h2><p>1 由于不同的viewgroup子类有不同的布局特性，所以交由子类实现测量细节<br>2 measureChildren();<br>3 自定义ViewGroup时，需要考虑测量以及布局子View，同时需要考虑ViewGroup的margin</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">parentDesireWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parentDesireHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">            <span class="type">View</span> <span class="variable">childAt</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="type">CustomLayoutParams</span> <span class="variable">layoutParams</span> <span class="operator">=</span> (CustomLayoutParams) childAt.getLayoutParams();</span><br><span class="line">            measureChildWithMargins(childAt, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">            parentDesireWidth += childAt.getMeasuredWidth()</span><br><span class="line">                    + layoutParams.leftMargin</span><br><span class="line">                    + layoutParams.rightMargin;</span><br><span class="line">            parentDesireHeight += childAt.getMeasuredHeight()</span><br><span class="line">                    + layoutParams.topMargin</span><br><span class="line">                    + layoutParams.bottomMargin;</span><br><span class="line">        &#125;</span><br><span class="line">        parentDesireWidth += getPaddingLeft() + getPaddingRight();</span><br><span class="line">        parentDesireHeight += getPaddingTop() + getPaddingBottom();</span><br><span class="line">        parentDesireWidth = Math.max(parentDesireWidth, getSuggestedMinimumWidth());</span><br><span class="line">        parentDesireHeight = Math.max(parentDesireHeight, getSuggestedMinimumHeight());</span><br><span class="line">        setMeasuredDimension(resolveSize(parentDesireWidth, widthMeasureSpec),</span><br><span class="line">                resolveSize(parentDesireHeight, heightMeasureSpec));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parentPaddingTop</span> <span class="operator">=</span> getPaddingTop();</span><br><span class="line">    <span class="type">int</span> <span class="variable">parentPaddingLeft</span> <span class="operator">=</span> getPaddingLeft();</span><br><span class="line">    <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mutilHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">            <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="type">CustomLayoutParams</span> <span class="variable">childLayoutParams</span> <span class="operator">=</span> (CustomLayoutParams) child.getLayoutParams();</span><br><span class="line">            child.layout(parentPaddingLeft + childLayoutParams.leftMargin,</span><br><span class="line">                    mutilHeight + parentPaddingTop + childLayoutParams.topMargin,</span><br><span class="line">                    child.getMeasuredWidth() + parentPaddingLeft + childLayoutParams.leftMargin,</span><br><span class="line">                    child.getMeasuredHeight() + mutilHeight + parentPaddingTop + childLayoutParams.topMargin);</span><br><span class="line">            mutilHeight += child.getMeasuredHeight()</span><br><span class="line">                    + childLayoutParams.topMargin</span><br><span class="line">                    + childLayoutParams.bottomMargin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时需要注意的是在处理margin时，可以自己定义一个CustomLayoutParams类继承LayoutParams，此后在onMeasure和onLayout中都强制转换成CustomLayoutParams。</p>
<h2 id="2-3-view的mearsure过程和activity的生命周期不是同步执行的！"><a href="#2-3-view的mearsure过程和activity的生命周期不是同步执行的！" class="headerlink" title="2.3. view的mearsure过程和activity的生命周期不是同步执行的！"></a>2.3. view的mearsure过程和activity的生命周期不是同步执行的！</h2><p>1 onWindowFocusChanged()<br>2 view.post(Runnable)<br>3 ViewTreeObserver</p>
<h1 id="3-layout过程"><a href="#3-layout过程" class="headerlink" title="3. layout过程"></a>3. layout过程</h1><p>1 通过setFrame设定view的l、t、r、b；四点确定，则view在父容器中的位置也确定了<br>2 调用onLayout，是父容器确定子容器的位置<br>3 onLayout具体实现同样和具体布局有关，所以view和viewgroup均没有真正实现onlayout</p>
<h1 id="4-draw过程"><a href="#4-draw过程" class="headerlink" title="4. draw过程"></a>4. draw过程</h1><p>1 绘制背景 background.draw(canvas)<br>2 绘制自己 onDraw<br>3 绘制children dispatchDraw<br>4 绘制装饰 onDrawScrollBars<br>5 setWillNotDraw设置为true，系统会进行相应优化。view默认不启用，viewgroup默认启用</p>
<h1 id="5-自定义View须知"><a href="#5-自定义View须知" class="headerlink" title="5. 自定义View须知"></a>5. 自定义View须知</h1><p>1 处理好滑动冲突<br>2 处理好线程和动画，当view不可见时停止线程和动画<br>3 不要在View中使用handler，用post<br>4 让view支持padding和wrap_content</p>
<h1 id="6-自定义view实践"><a href="#6-自定义view实践" class="headerlink" title="6. 自定义view实践"></a>6. 自定义view实践</h1><p>以下是自己过去两年内写过的关于自定义控件的日志，方便以后查阅。每当Android提供的控件不能满足你的需求时，首先你应该想想是否可以在现有控件的基础上修改一下来达到你的目的，而不是盲目地直接重写View或ViewGroup类，你可以提供不同的接口方法来修改你复合控件中的各类元素。</p>
<p><a href="https://leeeyou.github.io/2016/01/22/blog-2016-01-22-Android%E4%B9%8B%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BF%85%E5%A4%87%E7%9A%84%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86/">Android之开发中必备的坐标体系知识</a></p>
<p><a href="https://leeeyou.github.io/2016/04/29/blog-2016-04-29-Android%E4%B9%8BPaint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">Android之Paint的使用总结</a><br><a href="https://leeeyou.github.io/2016/01/04/blog-2016-01-04-Android%E4%B9%8BDrawable%E3%80%81Bitmap%E3%80%81Canvas%E3%80%81Paint%E4%B9%8B%E9%97%B4%E5%8C%BA%E5%88%AB/">Android之Drawable、Bitmap、Canvas、Paint之间区别</a><br><a href="https://leeeyou.github.io/2016/01/20/blog-2016-01-20-Android%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%94%BB%E7%AC%94/">Android之自定义控件之画笔</a><br><a href="https://leeeyou.github.io/2016/01/11/blog-2016-01-11-Android%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80Path%E7%B1%BB/">Android之绘图基础Path类</a><br><a href="https://leeeyou.github.io/2016/01/01/blog-2016-01-01-Android%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%9A%84%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/">Android之图像的色彩变换</a></p>
<p><a href="https://leeeyou.github.io/2016/02/29/blog-2016-02-29-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC3%E7%AB%A0-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/">Android艺术探索 第3章 View的事件体系</a><br><a href="https://leeeyou.github.io/2016/03/01/blog-2016-03-01-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC4%E7%AB%A0-View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">Android艺术探索 第4章 View的工作原理</a><br><a href="https://leeeyou.github.io/2016/03/02/blog-2016-03-02-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC5%E7%AB%A0-%E7%90%86%E8%A7%A3RemoteViews/">Android艺术探索 第5章 理解RemoteViews</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>知识汇总</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之启动一个Activity引发的思考</title>
    <url>/iBlogWebsite/2017/04/20/2017/2017-04-20-Android%E4%B9%8B%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AAActivity%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>在Android中Activity和Service是应用程序的核心组件，它们以松藕合的方式组合在一起构成了一个完整的应用程序，首先这得益于framework层提供了一套完整的机制来协助应用程序启动这些Activity和Service，其次得益于系统提供Binder机制实现进程间通信。这篇日志目的主要是梳理启动一个Activity的核心流程，涉及到哪些进程等。阅读之前需要先了解ActivityManagerServic、ActivityStack、ApplicationThread、ActivityThread以及Binder等概念才不至于一头雾水。</p>
<blockquote>
<p>ActivityRecord：描述了一个Activity所需要的全部信息。<br>TaskRecord：用来记录Activity的任务栈。<br>ActivityStack：用于管理一系列的TaskRecord。<br>ActivityManagerServic：Android系统中最核心的系统服务，主要负责四大组件的启动、切换和调度，以及应用进程的管理和调度工作。<br>ActivityThread：应用程序的主线程，负责主线程Handler的启动以及四大组件的调度和管理。<br>ApplicationThread：ActivityThread的内部类，继承自IApplicationThread.Stub，用于其它进程与它所属应用进程的交互。<br>Binder：Android平台上用于实现IPC的一种机制。</p>
</blockquote>
<h2 id="Activity启动过程的大致步骤"><a href="#Activity启动过程的大致步骤" class="headerlink" title="Activity启动过程的大致步骤"></a>Activity启动过程的大致步骤</h2><ol>
<li><p>无论是通过Launcher来启动Activity，还是通过Activity内部调用startActivity接口来启动新的Activity，<strong>都通过Binder进程间通信进入到ActivityManagerService进程中，并且调用ActivityManagerService.startActivity接口；</strong></p>
</li>
<li><p>ActivityManagerService调用ActivityStack.startActivityMayWait来做准备要启动的Activity的相关信息；</p>
</li>
<li><p>ActivityStack通知ApplicationThread要进行Activity启动调度了，<strong>这里的ApplicationThread代表的是调用ActivityManagerService.startActivity接口的进程，对于通过点击应用程序图标的情景来说，这个进程就是Launcher了，而对于通过在Activity内部调用startActivity的情景来说，这个进程就是这个Activity所在的进程了；</strong></p>
</li>
<li><p>ApplicationThread不执行真正的启动操作，它通过调用ActivityManagerService.activityPaused接口进入到ActivityManagerService进程中，看看是否需要创建新的进程来启动Activity；</p>
</li>
<li><p>对于通过点击应用程序图标来启动Activity的情景来说，ActivityManagerService在这一步中，会调用startProcessLocked来创建一个新的进程，而对于通过在Activity内部调用startActivity来启动新的Activity来说，这一步是不需要执行的，因为新的Activity就在原来的Activity所在的进程中进行启动；</p>
</li>
<li><p>ActivityManagerService调用ApplicationThread.scheduleLaunchActivity接口，通知相应的进程执行启动Activity的操作；</p>
</li>
<li><p>ApplicationThread把这个启动Activity的操作转发给ActivityThread，ActivityThread通过ClassLoader导入相应的Activity类，然后把它启动起来。</p>
</li>
</ol>
<h2 id="7-0系统上AMS启动Activity的核心流程"><a href="#7-0系统上AMS启动Activity的核心流程" class="headerlink" title="7.0系统上AMS启动Activity的核心流程"></a>7.0系统上AMS启动Activity的核心流程</h2><h2 id="8-0系统上AMS启动Activity的核心流程"><a href="#8-0系统上AMS启动Activity的核心流程" class="headerlink" title="8.0系统上AMS启动Activity的核心流程"></a>8.0系统上AMS启动Activity的核心流程</h2><h2 id="从Launcher启动一个应用程序"><a href="#从Launcher启动一个应用程序" class="headerlink" title="从Launcher启动一个应用程序"></a>从Launcher启动一个应用程序</h2><p>下面以启动MainActivity为例来说明Android应用程序的启动过程。从Launcher启动一个应用程序的时序图如下：<br><img src="https://github.com/LeeeYou/Img/blob/master/leeeyou/%E6%A0%B9Activity%E7%9A%84%E5%AE%8C%E6%95%B4%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%9B%BE.gif?raw=true" alt="从Launcher启动一个应用程序"></p>
<p>整个应用程序的启动过程要执行很多步骤，但是整体来看，主要分为以下五个阶段：<br>1、Step1 - Step 11：<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android-apps/5.1.1_r1/com/android/launcher2/Launcher.java#Launcher.onClick%28android.view.View%29">Launcher</a>通过Binder进程间通信机制通知<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/com/android/server/am/ActivityManagerService.java#ActivityManagerService">ActivityManagerService</a>，它要启动一个<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/app/Activity.java#Activity">Activity</a>；</p>
<p>2、Step 12 - Step 16：ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；</p>
<p>3、Step 17 - Step 24：Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，<strong>于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；</strong></p>
<p>4、Step 25 - Step 27：ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；</p>
<p>5、Step 28 - Step 35：ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。</p>
<p>具体的Step步骤详情可参考：<a href="http://blog.csdn.net/luoshengyang/article/details/6689748">http://blog.csdn.net/luoshengyang/article/details/6689748</a></p>
<p>ActivityManagerService启动Activity的大致过程</p>
<p><img src="https://github.com/LeeeYou/Img/blob/master/leeeyou/Android%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E5%B1%82%E4%B8%AD%E7%9A%84ActivityManagerService%E5%90%AF%E5%8A%A8Activity%E7%9A%84%E8%BF%87%E7%A8%8B.gif?raw=true" alt="Android应用程序框架层中的ActivityManagerService启动Activity的过程"></p>
<p><strong>在上面图中，ActivityManagerService和ActivityStack位于同一个进程（SystemServer进程），而ApplicationThread和ActivityThread位于另一个进程中（应用进程）。其中ActivityManagerService负责管理Activity的生命周期，它还借助ActivityStack把所有的Activity按照后进先出的顺序放在一个堆栈中；对每一个应用程序而言都有一个ActivityThread表示应用程序的主线程，而每一个ActivityThread都包含有一个ApplicationThread实例，它是一个Binder对象，负责和其它进程（如SystemServer进程）进行通信。</strong></p>
<h2 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h2><hr>
<p>参考：</p>
<ol>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6685853">Android应用程序的Activity启动过程简要介绍和学习计划</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6689748">Android应用程序启动过程源代码分析</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6703247">Android应用程序内部启动Activity过程（startActivity）的源代码分析</a></li>
<li><a href="https://developer.android.com/guide/components/tasks-and-back-stack.html">任务与后退栈</a>  </li>
<li><a href="https://developer.android.com/guide/topics/manifest/activity-element.html">activity</a>  </li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/8923485">那两年炼就的Android内功修养</a>  </li>
<li><a href="https://leeeyou.github.io/2016/03/05/blog-2016-03-05-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC9%E7%AB%A0-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/">Android艺术探索 第9章 四大组件的工作过程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35519585">写给 Android 应用工程师的 Binder 原理剖析</a></li>
</ol>
<p>最后感谢大神中的大神<a href="http://blog.csdn.net/luoshengyang">罗升阳的博客</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记之一万小时天才理论</title>
    <url>/iBlogWebsite/2017/05/11/2017/2017-05-11-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E4%B8%87%E5%B0%8F%E6%97%B6%E5%A4%A9%E6%89%8D%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p><img src="../../../../images/readingNotes/%E4%B8%80%E4%B8%87%E5%B0%8F%E6%97%B6%E5%A4%A9%E6%89%8D%E7%90%86%E8%AE%BA/%E4%B8%80%E4%B8%87%E5%B0%8F%E6%97%B6%E5%A4%A9%E6%89%8D%E7%90%86%E8%AE%BA.jpg" alt="一万小时天才理论"></p>
<p>断断续续看完了这本书，印象最深的一个词是髓鞘质，然后就是感觉这本书有点啰嗦，大量的采访素材堆砌。总得来说用一句话就能概括本书：【激情+伯乐+精深练习一万小时 = 天才】。当然还是有些细节部分是很出彩的，至少在我没接触这本书之前，对于精深练习这个词是没有任何概念的。</p>
<p>本书传递的一个价值观可能是：我们口中的“天才”其实就处在我们的周围，或者是你的邻居，或者是你镇上的某个同学，在经过上面公式的“摧残”后成名。请务必不要说什么一夜成名，哪有什么一夜成名的事情发生，鬼知道别人经历的什么。</p>
<p>关于精深练习的部分，作者用的笔墨是最多的，就是想要告诉读者：朝着既定目标挣扎前进，挑战自己的能力极限，不断犯错，汲取经验，不断犯错，汲取经验，然后你以为自己快要成功的时候，成功却与你失之交臂，此时应该给自己一些掌声，生活哪有随随便便的成功，当然会一波好几折。其实此时有个东西在潜移默化的进化着，是的，它是髓鞘质，通过你不断重复的练习和刺激，形成了一个绝缘的神经回路。当你的髓鞘质生长到足够强大，其实就是练习的次数足够多的时候，在你的领域距离“专家”就越近。</p>
<p>为什么目标明确、重视错误的练习如此有效呢？因为构建一条好的神经回路，最佳的方法就是开启电流，处理错误，然后重启，就这样一遍遍重复这个过程。努力拼搏不是无关紧要的过程，而是生理上的必经之路。所以人才和技能的故事就是髓鞘质的故事，看到这里你是不是有点失望呢？</p>
<p>精深练习需要时间，时刻保持激情就显示尤为重要。当然在你精深练习的时候，没个好的教练怎么能行呢，所以赶紧去找个伯乐吧，他会在自身拥有了强大知识库和深厚的认识后，灵活的根据你的自身情况调整施教策略。所以想成为天才的你准备好了吗？</p>
<p>下面是摘录内容：</p>
<h2 id="第一部分-精深"><a href="#第一部分-精深" class="headerlink" title="第一部分 精深"></a>第一部分 精深</h2><ul>
<li><p>谁也不能随随便便成功，它来自彻底的自我管理和毅力。——哈佛图书馆训言</p>
</li>
<li><p>精深练习是建立在一个悖论之上的：朝着既定目标挣扎前进，挑战自己的能力极限，不断犯错，会让你更聪明。类似的说法是，做那些不得不放慢节奏的事情，犯错并加以改正——就像爬冰山，刚开始的时候会滑倒，会跌跌撞撞，最后不知不觉中就变得敏捷自如。</p>
</li>
<li><p>林克的训练器可以让飞行员的练习更加深入：停下，犹豫，犯错，并从中吸取经验。在林克训练器里坐上几小时，飞行员可以在操作面板上“起飞”、“降落”十几次。可以俯冲、失速，再调节恢复正常，可以在那个挑战自己能力极限的最佳位置上停留数小时，而在真正的飞机上是不可能冒这个险的。</p>
</li>
<li><p>那些用林克训练器训练出来的航空队飞行员并非比那些失事的飞行员更勇敢、更聪明，而只是多了一个精深练习的机会。</p>
</li>
<li><p>我一直认为，除了傻子，人在智力上差别不大，不同的只是热情和努力。——查尔斯·达尔文</p>
</li>
<li><p>目标明确的练习能够将学习速度提高10倍，这听起来就像那个神话故事，一小把种子长成了一根有魔力的长藤，长藤通往成才的天堂。</p>
</li>
<li><p>神经元完成的每一个动作都非常迅速，就在开关的一开一合之间。”菲尔茨谈及突触时说，“但是一开一关不是我们学习大多数事物的方法。弹好钢琴，下好象棋，打好棒球都非一日之功，但都是髓鞘质所擅长的。</p>
</li>
<li><p>人才和技能的故事就是髓鞘质的故事。</p>
</li>
<li><p> 问：为什么目标明确、重视错误的练习如此有效呢？答：因为构建一条好的神经回路，最佳的方法就是开启电流，处理错误，然后重启，就这样一遍遍重复这个过程。努力拼搏不是无关紧要的过程，而是生理上的必经之路。</p>
</li>
<li><p>犯错绝不是可有可无的——从神经学的角度来说，这是必须的：要想使技能回路达到最佳状态，必须先找到次佳位置；你必须犯错误，并关注这些错误；你得慢慢地锻炼自己的回路。你还必须持续开启那个回路（练习）以保持髓鞘质运作正常。毕竟，髓鞘质是活体组织。</p>
</li>
<li><p>任何领域的任何专家都要经过10000小时专心致志地练习。</p>
</li>
<li><p>它意味着所有的技能都可以通过同一套基本生理机制获得，并且进一步指出该生理机制有其生理极限，无人能幸免。</p>
</li>
<li><p>精深练习×一万小时=世界级技能</p>
</li>
<li><p>哇塞效应（Holy Shit Effect，缩写HSE），意思是当人才突然从天而降时，人们产生的一种强烈而复杂的情感：怀疑、崇拜以及妒忌（顺序不分先后）。</p>
</li>
<li><p>哇塞效应是那种人们在看到跟自己一样的普通人拥有盖世才华时产生的感受。</p>
</li>
<li><p>看见邻街那个傻孩子突然成了著名摇滚乐队的主吉他手，或是看见自家孩子对微分学熟练到令人费解时，心底产生的那种讶异，同时还有点隐隐作痛。</p>
</li>
<li><p>秘技第一式：组块化</p>
</li>
<li><p>精深练习就是构建神经回路，并使之裹上绝缘体。</p>
</li>
<li><p>为什么放慢节奏如此有效呢？首先，放慢练习节奏使你更加关注错误，每一次都提高了精确度——而对于髓鞘质的生长而言，精确就是一切。</p>
</li>
<li><p>第二，放慢练习给了练习者更重要的东西：技能的形状和节奏。</p>
</li>
<li><p>重复练习是无可替代且千金难求的，然而，要补充解释几点。常规练习是练得越多越好，但是，精深练习并不适用这道等式。投入更多的时间练习是有用的，但前提是你必须处于最佳位置。更重要的是，一个人每天能进行多久的精深练习似乎是有普遍限制的。</p>
</li>
<li><p>练习就是每天弹奏同样的音符，人类基本的姿态——为一个想法努力，为你渴望的伟大成就努力争取，然后感觉它与你失之交臂。</p>
</li>
<li><p>正是这种感觉，精深练习不是简单的挣扎，而是有目的的奋斗：选定目标、努力争取、评估差距、回到初始步骤。而且那种感觉同其他东西一样，是可以习得的。髓鞘质的其中一个进化优势是，它能够使任何回路绝缘化，甚至是那些一开始我们不喜欢的。在草山，指导员看着学生们体会精深练习的感觉。起初他们并不喜欢。但是很快学生们开始忍受，甚至享受这样的体验。</p>
</li>
</ul>
<h2 id="第二部分-激情"><a href="#第二部分-激情" class="headerlink" title="第二部分 激情"></a>第二部分 激情</h2><ul>
<li><p>精深练习需要时间</p>
</li>
<li><p>这就是激情的工作原理，是那些让我们意识到“我就想成为那样的人”的时刻。人们通常认为激情是一种内心品质。但是我探访的人才温床越多，就越坚信激情首先来自外部世界。在人才温床，正确的蝴蝶拍打翅膀卷起了人才飓风。</p>
</li>
<li><p>他看到这个图表时震惊了。“我不敢相信自己的眼睛。”他说。进步不取决于任何可衡量的天赋或者性格，而是一个微不足道的念头。一个小小的念头却产生了无穷的力量，孩子甚至在学习开始之前就打定了主意，这决定了进步的快慢。不同孩子之间的表现有着惊人的差异。同样的练习时间，给出长期承诺的那组孩子表现得比给出短期承诺的孩子好4倍。</p>
</li>
<li><p>每个信号都与身份和群体有关。每个信号都相当于一盏闪烁的灯，指引人们前进：那些人在做超级有意义的事情。总之，每个信号都针对未来的归属感。</p>
</li>
<li><p>人们都会因为自己与一个成就非凡的群体有联系而感到心潮澎湃。</p>
</li>
<li><p>“如果身处轻松愉快的环境，我们自然而然就会停止努力。”巴特克斯说，“为什么会这样呢？如果人们发现环境很艰苦，马上受到激励。一座管理完善的豪华网球学校给了学员一种豪华未来的体验——学习动机当然也就被压抑了，那是无法避免的。”</p>
</li>
<li><p>丧父或者丧母是一个原始信号：生活不再安全。你不必成为心理学家，也会发现由于缺乏安全感而激发出来的能量储备；你也不必是达尔文主义理论家，也会看到这种反应是如何进化而来的。这个信号可以改变孩子与世界的关系，重新给自己定位，激发和引导自己的大脑去解决危险，处理生命中的可能性。正如基思·西门顿（Keith Simonton）在《天才起源》（Origins of Genius）中提到的，对于父母死亡，“如此不利的事件造就了人格的健全发展，剽悍到使他们足以克服拦在成功道路上的种种障碍和挫折。”</p>
</li>
<li><p>艾森斯塔德名单上的超级名人并非天赋异禀，并非人类中的统计异常值，而是统治所有人的普遍原则的逻辑外延：（1）才能需要精深练习；（2）精深练习需要充分的能量；（3）某些信号会触发巨大能量的迸发。</p>
</li>
<li><p>也不是说，在一个大家庭里出生较晚就必然跑得快，更不是说有位家长在孩子年幼时过世就必然使其能够当上英国首相。但这确实说明，跑得快如同其他才能，受到一堆主要因素的影响，超越基因这个因素，直接相关的是对激励信号强烈的潜意识反应，这种激励信号提供了精深练习所需的能量，从而促进髓鞘质生长。</p>
</li>
<li><p>短短几句话，他成功地点燃了排他性（“我只知道，它很适合汤姆·索亚……我看一千个孩子里面都没有……”）和稀缺性（“男孩子每天都可以刷围栏吗？……波莉姨妈对这围栏的要求太可怕了”）这些原始信号。他的手势以及其他身体语言传达着同样的讯息“盯着他看了一番”以及“一会走远看看效果，随意地在某个地方加上一刷子，又评论一下粉刷效果”——仿佛是在从事最最重要的工作。</p>
</li>
<li><p>精深练习需要深入认真的工作以及热情的劲头。当你开始练习，你不是“打”网球；你在挣扎、在反抗，你需要集中精力，然后慢慢进步。我们的学习像婴儿的蹒跚学步。赞其勤奋的语句之所以有效，是因为它直达学习的核心，而想要点燃激情，没有比这更强大的了。</p>
</li>
</ul>
<h2 id="第三部分-伯乐"><a href="#第三部分-伯乐" class="headerlink" title="第三部分 伯乐"></a>第三部分 伯乐</h2><ul>
<li><p>他们的个性——核心才能的回路——更像农民；如汉斯·詹森那样认真细致的髓鞘质培育者。他们脚踏实地，而且严格自律。拥有广泛而且深刻的知识框架。他们将之应用于培养逐步提升的技能回路，却不掌控最终结果。詹森无法回答我的问题，因为这个问题的核心不符合逻辑。仅仅看见两棵幼苗，就能知道哪一棵会长得更高，这可能吗？唯一的答案是，判断孰优孰劣还为时尚早，他们都还在成长。</p>
</li>
<li><p>优势一：知识矩阵——伯乐的杀手锏</p>
</li>
<li><p>这些深厚的认识，并非与生俱来。同任何技能一样，那是随着时间，通过激情和精深练习逐渐掌握的。[插图]伟大的教练绝不能一蹴而就。我遇到的多数教练拥有类似的人生轨迹：他们曾经在各自的领域意气风发，却不幸受挫，但是他们能够积极寻找原因。</p>
</li>
<li><p>优势二：洞察力——鹰的视力</p>
</li>
<li><p>优势三：简明的指示——神奇的教鞭</p>
</li>
<li><p>优势四：气质与诚信——不可阻挡的魅力</p>
</li>
<li><p>诸如踢足球、写作、喜剧表演这样的技能，需要建立灵活性神经回路，即需要学习者在脑中形成数千条回路，这样就可以轻松地找到一条回路，可以让他绕过变化无常的障碍物。拉小提琴、打高尔夫、体操、花样滑冰这些技能，需要建立一致性神经回路，全靠扎实的技术基础，重现一场完美表演所遵循的基本法则。这就是为什么自学的高尔夫球员、滑冰运动员，还有体操运动员达到世界级水平的鲜有案例，而自学成才的小说家、喜剧演员，还有足球运动员却层出不穷的原因。</p>
</li>
</ul>
<h2 id="后记-一万小时的世界"><a href="#后记-一万小时的世界" class="headerlink" title="后记 一万小时的世界"></a>后记 一万小时的世界</h2><ul>
<li>但是实际上，正如所有的精深练习，一个人首先要克服那种“大事化小，小事化了”的自然倾向——这在企业中尤其困难。</li>
</ul>
<h2 id="译者后记"><a href="#译者后记" class="headerlink" title="译者后记"></a>译者后记</h2><ul>
<li>所以，这不是为那些天生有异象的人写的书，而是送给那些没被上帝的骰子掷中的人的一份补偿。</li>
</ul>
]]></content>
      <categories>
        <category>opinion</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android项目整合RN说明文档</title>
    <url>/iBlogWebsite/2017/07/04/2017/2017-07-04-Android%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88RN%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="step1-native项目准备工作"><a href="#step1-native项目准备工作" class="headerlink" title="step1: native项目准备工作"></a>step1: native项目准备工作</h1><p>在app module下的build.gradle文件的dependencies中添加React Native 依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">compile <span class="string">&quot;com.facebook.react:react-native:+&quot;</span></span><br></pre></td></tr></table></figure>

<p>com.android.support:appcompat的版本号用23.0.1，同时修改compileSdkVersion和buildToolsVersion</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">compileSdkVersion <span class="number">23</span></span><br><span class="line">buildToolsVersion <span class="string">&quot;23.0.1&quot;</span></span><br><span class="line">defaultConfig &#123;</span><br><span class="line">    applicationId <span class="string">&quot;com.quncao.testsize&quot;</span></span><br><span class="line">    minSdkVersion <span class="number">16</span></span><br><span class="line">    targetSdkVersion <span class="number">22</span></span><br><span class="line">    versionCode <span class="number">1</span></span><br><span class="line">    versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">    ndk&#123;</span><br><span class="line">        abiFilters <span class="string">&quot;armeabi-v7a&quot;</span>, <span class="string">&quot;x86&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改清单文件，增加如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">&quot;com.facebook.react.devsupport.DevSettingsActivity&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h1 id="step2-将android工程改造成react-native工程"><a href="#step2-将android工程改造成react-native工程" class="headerlink" title="step2: 将android工程改造成react-native工程"></a>step2: 将android工程改造成react-native工程</h1><p>引入或者创建package.json文件  </p>
<ul>
<li>可以通过命令<code>npm init</code>创建，也可以复制一个空RN工程中的package.json</li>
</ul>
<p>引入或者创建node_modules文件  </p>
<ul>
<li>可以通过命令<code>npm install --save react react-native</code>创建，也可以复制一个空RN工程中的node_modules文件夹</li>
</ul>
<p>引入或者创建.flowconfig文件   </p>
<ul>
<li>可以通过<code>curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig</code>创建，也可以复制一个空RN工程中的.flowconfig文件</li>
</ul>
<p>引入或者创建index.android.js文件</p>
<p>在项目根目录的build.gradle中(注意：不是app模块中的build.gradle文件)添加依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123;</span><br><span class="line">            <span class="comment">// All of React Native (JS, Obj-C sources, Android binaries) is installed from npm</span></span><br><span class="line">            url <span class="string">&quot;$projectDir/../node_modules/react-native/android&quot;</span></span><br><span class="line"><span class="comment">//            url &quot;$rootDir/../node_modules/react-native/android&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意url的值，上面是指向了当前工程中的node_modules文件夹，而<code>$rootDir/../node_modules/react-native/android</code>这句会引用默认的react-native的版本，通常会是0.21.0</p>
<h1 id="step3-改造Applicatioin"><a href="#step3-改造Applicatioin" class="headerlink" title="step3: 改造Applicatioin"></a>step3: 改造Applicatioin</h1><p>实现ReactApplication类，并修改清单文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> <span class="keyword">implements</span> <span class="title class_">ReactApplication</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReactNativeHost</span> <span class="variable">mReactNativeHost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReactNativeHost</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getUseDeveloperSupport</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> BuildConfig.DEBUG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title function_">getPackages</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.&lt;ReactPackage&gt;asList(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">MainReactPackage</span>()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReactNativeHost <span class="title function_">getReactNativeHost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mReactNativeHost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="step4-编写Activity，返回RN页面"><a href="#step4-编写Activity，返回RN页面" class="headerlink" title="step4: 编写Activity，返回RN页面"></a>step4: 编写Activity，返回RN页面</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.quncao.testsize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.facebook.react.ReactActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SettingActivity</span> <span class="keyword">extends</span> <span class="title class_">ReactActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getMainComponentName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;TestSize&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意getMainComponentName的值和index.android.js这个文件中的registerComponent值保持一致</p>
<p>Demo工程：链接: <a href="https://pan.baidu.com/s/1eSL4P7k">https://pan.baidu.com/s/1eSL4P7k</a> 密码: ggav</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之图像的色彩变换</title>
    <url>/iBlogWebsite/2016/01/01/2016/2016-01-01-Android%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%9A%84%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>本文主要讲了通过ColorMatrix和Bitmap的setPixels来改变图片的色彩。ColorMatrix可以实现基本变换和矩阵变换，官方文档地址：<a href="https://developer.android.com/reference/android/graphics/ColorMatrix.html%EF%BC%9B%E8%80%8CBitmap%E7%9A%84setPixels%E4%B8%BB%E8%A6%81%E8%AE%A8%E8%AE%BA%E7%9A%84%E6%98%AF%E5%83%8F%E7%B4%A0%E5%8F%98%E6%8D%A2%EF%BC%8C%E5%B0%B1%E6%98%AF%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%83%8F%E7%B4%A0%E7%82%B9%E7%9A%84%E5%80%BC%E6%9D%A5%E6%94%B9%E5%8F%98%E5%9B%BE%E7%89%87%E7%9A%84%E8%89%B2%E5%BD%A9%E3%80%82">https://developer.android.com/reference/android/graphics/ColorMatrix.html；而Bitmap的setPixels主要讨论的是像素变换，就是设置图片中每个像素点的值来改变图片的色彩。</a></p>
<h2 id="色彩基本变换"><a href="#色彩基本变换" class="headerlink" title="色彩基本变换"></a>色彩基本变换</h2><p>色彩的基本变换主要包括三个方面：灰度、饱和度、亮度，可通过ColorMatrix提供的API实现，参考如下代码块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title function_">handleImageEffect</span><span class="params">(Bitmap bm, <span class="type">float</span> hue, <span class="type">float</span> saturation, <span class="type">float</span> lum)</span> &#123;</span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">        <span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Canvas</span>(bmp);</span><br><span class="line">        <span class="type">Paint</span> <span class="variable">paint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line"></span><br><span class="line">        <span class="type">ColorMatrix</span> <span class="variable">hueMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorMatrix</span>();</span><br><span class="line">        hueMatrix.setRotate(<span class="number">0</span>, hue);<span class="comment">//灰度</span></span><br><span class="line">        hueMatrix.setRotate(<span class="number">1</span>, hue);</span><br><span class="line">        hueMatrix.setRotate(<span class="number">2</span>, hue);</span><br><span class="line"></span><br><span class="line">        <span class="type">ColorMatrix</span> <span class="variable">saturationMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorMatrix</span>();</span><br><span class="line">        saturationMatrix.setSaturation(saturation);<span class="comment">//饱和度</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ColorMatrix</span> <span class="variable">lumMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorMatrix</span>();</span><br><span class="line">        lumMatrix.setScale(lum, lum, lum, <span class="number">1</span>);<span class="comment">//亮度</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ColorMatrix</span> <span class="variable">imageMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorMatrix</span>();</span><br><span class="line">        imageMatrix.postConcat(hueMatrix);</span><br><span class="line">        imageMatrix.postConcat(saturationMatrix);</span><br><span class="line">        imageMatrix.postConcat(lumMatrix);</span><br><span class="line"></span><br><span class="line">        paint.setColorFilter(<span class="keyword">new</span> <span class="title class_">ColorMatrixColorFilter</span>(imageMatrix));</span><br><span class="line">        canvas.drawBitmap(bm, <span class="number">0</span>, <span class="number">0</span>, paint);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="色彩矩阵变换"><a href="#色彩矩阵变换" class="headerlink" title="色彩矩阵变换"></a>色彩矩阵变换</h2><p>一张位图可以转换为一个5*4的矩阵，涉及到颜色和透明度，如下所示，在Android中颜色矩阵是以一维数组M=[a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t]的方式进行存储的。</p>
<p><img src="../../../../images/githubpages/%E5%9B%BE%E5%83%8F%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/ColorMatrix.png" alt="色彩矩阵变换">  </p>
<p>在一张图片中，图像的RGBA值决定了该图片所呈现出来的颜色效果，而其RGBA值则存储在一个5*1的颜色分量矩阵C中，用于调整三原色和透明度，颜色分量矩阵C如下所示：</p>
<p><img src="../../../../images/githubpages/%E5%9B%BE%E5%83%8F%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/ComponentMatrix.png" alt="分量矩阵">  </p>
<p>要想改变一张图片的颜色效果，只需要改变图像的颜色分量矩阵即可。通过颜色矩阵可以很方便的修改图像的颜色分量矩阵。假设修改后的图像颜色分量矩阵为C1，则有如下所示的颜色分量矩阵计算公式。</p>
<blockquote>
<p> R’ = a<em>R + b</em>G + c<em>B + d</em>A + e;<br><br>   G’ = f<em>R + g</em>G + h<em>B + i</em>A + j;<br><br>   B’ = k<em>R + l</em>G + m<em>B + n</em>A + o;<br><br>   A’ = p<em>R + q</em>G + r<em>B + s</em>A + t;<br></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getMatrix</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        mColorMatrix[i] = Float.valueOf(mEts[i].getText().toString());<span class="comment">//mEts是一个5*4的浮点数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setImageMatrix</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(),</span><br><span class="line">            Bitmap.Config.ARGB_8888);</span><br><span class="line">    android.graphics.<span class="type">ColorMatrix</span> <span class="variable">colorMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">android</span>.graphics.ColorMatrix();</span><br><span class="line">    colorMatrix.set(mColorMatrix);</span><br><span class="line"></span><br><span class="line">    <span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Canvas</span>(bmp);</span><br><span class="line">    <span class="type">Paint</span> <span class="variable">paint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    paint.setColorFilter(<span class="keyword">new</span> <span class="title class_">ColorMatrixColorFilter</span>(colorMatrix));</span><br><span class="line">    canvas.drawBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, paint);</span><br><span class="line">    mImageView.setImageBitmap(bmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图像的像素变换"><a href="#图像的像素变换" class="headerlink" title="图像的像素变换"></a>图像的像素变换</h2><p>像素变换是通过调用Bitmap提供的API <strong>[public void setPixels (int[] pixels, int offset, int stride, int x, int y, int width, int height)](<a href="http://developer.android.com/reference/android/graphics/Bitmap.html#setPixels">http://developer.android.com/reference/android/graphics/Bitmap.html#setPixels</a>(int[], int, int, int, int, int, int))</strong> ，结合某些经验值，设置到数组中的不同位置上来变换RGBA的值，从而达到各种效果。下面列出了反转色效果、老照片效果、浮雕效果等示例代码。<br><img src="../../../../images/githubpages/%E5%9B%BE%E5%83%8F%E8%89%B2%E5%BD%A9%E5%8F%98%E6%8D%A2/bitmap_setPixels.png" alt="图像的像素变换">  </p>
<p>反转色效果的代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title function_">handleImageNegative</span><span class="params">(Bitmap bm)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> bm.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> bm.getHeight();</span><br><span class="line">        <span class="type">int</span> color;</span><br><span class="line">        <span class="type">int</span> r, g, b, a;</span><br><span class="line"></span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> Bitmap.createBitmap(width, height</span><br><span class="line">                , Bitmap.Config.ARGB_8888);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] oldPx = <span class="keyword">new</span> <span class="title class_">int</span>[width * height];</span><br><span class="line">        <span class="type">int</span>[] newPx = <span class="keyword">new</span> <span class="title class_">int</span>[width * height];</span><br><span class="line">        bm.getPixels(oldPx, <span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; width * height; i++) &#123;</span><br><span class="line">            color = oldPx[i];</span><br><span class="line">            r = Color.red(color);</span><br><span class="line">            g = Color.green(color);</span><br><span class="line">            b = Color.blue(color);</span><br><span class="line">            a = Color.alpha(color);</span><br><span class="line"></span><br><span class="line">            r = <span class="number">255</span> - r;</span><br><span class="line">            g = <span class="number">255</span> - g;</span><br><span class="line">            b = <span class="number">255</span> - b;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                r = <span class="number">255</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                r = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                g = <span class="number">255</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                g = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                b = <span class="number">255</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            newPx[i] = Color.argb(a, r, g, b);</span><br><span class="line">        &#125;</span><br><span class="line">        bmp.setPixels(newPx, <span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        <span class="keyword">return</span> bmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>老照片效果的代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title function_">handleImagePixelsOldPhoto</span><span class="params">(Bitmap bm)</span> &#123;</span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> Bitmap.createBitmap(bm.getWidth(), bm.getHeight(),</span><br><span class="line">                Bitmap.Config.ARGB_8888);</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> bm.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> bm.getHeight();</span><br><span class="line">        <span class="type">int</span> <span class="variable">color</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r, g, b, a, r1, g1, b1;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] oldPx = <span class="keyword">new</span> <span class="title class_">int</span>[width * height];</span><br><span class="line">        <span class="type">int</span>[] newPx = <span class="keyword">new</span> <span class="title class_">int</span>[width * height];</span><br><span class="line"></span><br><span class="line">        bm.getPixels(oldPx, <span class="number">0</span>, bm.getWidth(), <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; width * height; i++) &#123;</span><br><span class="line">            color = oldPx[i];</span><br><span class="line">            a = Color.alpha(color);</span><br><span class="line">            r = Color.red(color);</span><br><span class="line">            g = Color.green(color);</span><br><span class="line">            b = Color.blue(color);</span><br><span class="line"></span><br><span class="line">            r1 = (<span class="type">int</span>) (<span class="number">0.393</span> * r + <span class="number">0.769</span> * g + <span class="number">0.189</span> * b);</span><br><span class="line">            g1 = (<span class="type">int</span>) (<span class="number">0.349</span> * r + <span class="number">0.686</span> * g + <span class="number">0.168</span> * b);</span><br><span class="line">            b1 = (<span class="type">int</span>) (<span class="number">0.272</span> * r + <span class="number">0.534</span> * g + <span class="number">0.131</span> * b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r1 &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                r1 = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g1 &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                g1 = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b1 &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                b1 = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            newPx[i] = Color.argb(a, r1, g1, b1);</span><br><span class="line">        &#125;</span><br><span class="line">        bmp.setPixels(newPx, <span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        <span class="keyword">return</span> bmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>浮雕效果的代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title function_">handleImagePixelsRelief</span><span class="params">(Bitmap bm)</span> &#123;</span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> Bitmap.createBitmap(bm.getWidth(), bm.getHeight(),</span><br><span class="line">                Bitmap.Config.ARGB_8888);</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> bm.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> bm.getHeight();</span><br><span class="line">        <span class="type">int</span> <span class="variable">color</span> <span class="operator">=</span> <span class="number">0</span>, colorBefore = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> a, r, g, b;</span><br><span class="line">        <span class="type">int</span> r1, g1, b1;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] oldPx = <span class="keyword">new</span> <span class="title class_">int</span>[width * height];</span><br><span class="line">        <span class="type">int</span>[] newPx = <span class="keyword">new</span> <span class="title class_">int</span>[width * height];</span><br><span class="line"></span><br><span class="line">        bm.getPixels(oldPx, <span class="number">0</span>, bm.getWidth(), <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; width * height; i++) &#123;</span><br><span class="line">            colorBefore = oldPx[i - <span class="number">1</span>];</span><br><span class="line">            a = Color.alpha(colorBefore);</span><br><span class="line">            r = Color.red(colorBefore);</span><br><span class="line">            g = Color.green(colorBefore);</span><br><span class="line">            b = Color.blue(colorBefore);</span><br><span class="line"></span><br><span class="line">            color = oldPx[i];</span><br><span class="line">            r1 = Color.red(color);</span><br><span class="line">            g1 = Color.green(color);</span><br><span class="line">            b1 = Color.blue(color);</span><br><span class="line"></span><br><span class="line">            r = (r - r1 + <span class="number">127</span>);</span><br><span class="line">            g = (g - g1 + <span class="number">127</span>);</span><br><span class="line">            b = (b - b1 + <span class="number">127</span>);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                r = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                g = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                b = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            newPx[i] = Color.argb(a, r, g, b);</span><br><span class="line">        &#125;</span><br><span class="line">        bmp.setPixels(newPx, <span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        <span class="keyword">return</span> bmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
        <tag>色彩变换</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之Lambda表达式</title>
    <url>/iBlogWebsite/2016/01/03/2016/2016-01-03-Java%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>Lambda表达式的引入给开发者带来了不少优点：在Java8之前，匿名内部类，监听器和事件处理器的使用都显得很冗长，代码可读性差，Lambda表达式的应用使代码变得紧凑，可读性增强，同时 <strong>Lambda表达式使并行操作大集合变得很方便，可以充分发挥多核 CPU 的优势，更易于为多核处理器编写代码。</strong><br>官方文档：<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html#overview">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html#overview</a></p>
<h2 id="Lambda表达式的基本组成"><a href="#Lambda表达式的基本组成" class="headerlink" title="Lambda表达式的基本组成"></a>Lambda表达式的基本组成</h2><p>Lambda表达式由三个部分组成：<br>第一部分为一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数<br>第二部分为一个箭头符号：-&gt;<br>第三部分为方法体，可以是表达式和代码块  </p>
<blockquote>
<ol>
<li>方法体为表达式，该表达式的值作为返回值返回。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li>方法体为代码块，必须用 {} 来包裹起来，且需要一个 return 返回值，如果函数式接口里面方法返回值是 void，则无需返回值。  </li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式通用接口"><a href="#函数式通用接口" class="headerlink" title="函数式通用接口"></a>函数式通用接口</h2><p>下面是用匿名内部类的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;Helllo Lambda in actionPerformed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面是使用 Lambda 表达式后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.addActionListener((ActionEvent e)-&gt;</span><br><span class="line">    System.out.print(<span class="string">&quot;Helllo Lambda in actionPerformed&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>从上面两段代码可以看出，要使用Lambda表达式，需要定义一个函数式接口(类似ActionListener)，这样往往会让程序充斥着过量的仅为Lambda表达式服务的函数式接口。为了减少这样过量的函数式接口，Java8在 <strong><a href="https://developer.android.com/reference/java/util/function/package-summary.html">java.util.function</a></strong> 中增加了不少新的函数式通用接口。  </p>
<blockquote>
<p>Function&lt;T, R&gt;：将 T 作为输入，返回 R 作为输出，他还包含了和其他函数组合的默认方法。<br>Predicate<T> ：将 T 作为输入，返回一个布尔值作为输出，该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（与、或、非）。<br>Consumer<T> ：将 T 作为输入，不返回任何内容，表示在单个参数上的操作。  </p>
</blockquote>
<p>例如 People 类中有一个方法 getMaleList 需要获取男性的列表，这里需要定义一个函数式接口 PersonInterface：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonInterface</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Person person)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> List&lt;Person&gt; persons= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line"> <span class="keyword">public</span> List&lt;Person&gt; <span class="title function_">getMaleList</span><span class="params">(PersonInterface filter)</span> &#123;</span><br><span class="line"></span><br><span class="line"> List&lt;Person&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line"> persons.forEach(</span><br><span class="line"> (Person person) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span> (filter.test(person)) &#123;<span class="comment">//调用 PersonInterface 的方法</span></span><br><span class="line">     res.add(person);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为了去除 PersonInterface 这个函数式接口，可以用通用函数式接口 Predicate 替代如下：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People2</span>&#123;</span><br><span class="line"> <span class="keyword">private</span> List&lt;Person&gt; persons= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line"> <span class="keyword">public</span> List&lt;Person&gt; <span class="title function_">getMaleList</span><span class="params">(Predicate&lt;Person&gt; predicate)</span> &#123;</span><br><span class="line"> List&lt;Person&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line"> persons.forEach(</span><br><span class="line"></span><br><span class="line"> person -&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (predicate.test(person)) &#123;<span class="comment">//调用 Predicate 的抽象方法 test</span></span><br><span class="line">     res.add(person);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合的流式操作"><a href="#集合的流式操作" class="headerlink" title="集合的流式操作"></a>集合的流式操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPredicate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; mPerson = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">            p.setAge(i);</span><br><span class="line">            p.setName(<span class="string">&quot;person num&quot;</span> + i);</span><br><span class="line">            mPerson.add(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Predicate&lt;Person&gt; mPredicate = person -&gt; person.getAge()&gt;25;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//过滤年龄大于25岁，姓名包含&quot;8&quot;的用户，并且按照姓名降序排列，将符合条件的每个用户打印出来</span></span><br><span class="line">        mPerson.stream()</span><br><span class="line">                .filter(person -&gt; person.getAge() &gt; <span class="number">25</span>)</span><br><span class="line">                .filter(person -&gt; person.getName().contains(<span class="string">&quot;8&quot;</span>))</span><br><span class="line">                .sorted((Person p1, Person p2) -&gt; p2.getName().compareTo(p1.getName()))<span class="comment">//name Desc</span></span><br><span class="line">                .forEach(p -&gt; System.out.println(<span class="string">&quot;年龄：&quot;</span> + p.getAge() + <span class="string">&quot; \t姓名：&quot;</span> + p.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集合的流式操作和函数式编程非常相似，配合上面讲到的Lambda表达式以及其中的Predicate和Consumer，可以用简短的几行代码写出复杂的过滤条件来过滤集合数据。<br>感觉使用过之后，一个字：真爽！  </p>
<p>Java8引入了流式操作（Stream），通过该操作可以实现对集合（Collection）的并行处理和函数式操作。<strong>根据操作返回的结果不同，流式操作分为中间操作和最终操作两种。</strong> 最终操作返回特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。根据流的并发性，流又可以分为串行和并行两种。流式操作实现了集合的过滤、排序、映射等功能。<br></p>
<p>另外，Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。<br></p>
<h3 id="串行和并行的流"><a href="#串行和并行的流" class="headerlink" title="串行和并行的流"></a>串行和并行的流</h3><p>流有串行和并行两种，串行流上的操作在一个线程中依次完成，而并行流则是在多个线程上同时执行。并行与串行的流可以相互切换：通过stream.sequential()返回串行的流，通过stream.parallel()返回并行的流。<strong>相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</strong> 下面是分别用串行和并行的方式对集合进行排序。  </p>
<h4 id="串行排序"><a href="#串行排序" class="headerlink" title="串行排序"></a>串行排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Math.random()*<span class="number">1000</span>;</span><br><span class="line">  list.add(d+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();<span class="comment">//获取系统开始排序的时间点</span></span><br><span class="line"><span class="type">int</span> count= (<span class="type">int</span>) ((Stream) list.stream().sequential()).sorted().count();</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();<span class="comment">//获取系统结束排序的时间点</span></span><br><span class="line"><span class="type">long</span> <span class="variable">ms</span> <span class="operator">=</span> TimeUnit.NANOSECONDS.toMillis(end-start);<span class="comment">//得到串行排序所用的时间</span></span><br><span class="line">System.out.println(ms+”ms”);</span><br></pre></td></tr></table></figure>

<h4 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Math.random()*<span class="number">1000</span>;</span><br><span class="line">  list.add(d+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();<span class="comment">//获取系统开始排序的时间点</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (<span class="type">int</span>)((Stream) list.stream().parallel()).sorted().count();</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();<span class="comment">//获取系统结束排序的时间点</span></span><br><span class="line"><span class="type">long</span> <span class="variable">ms</span> <span class="operator">=</span> TimeUnit.NANOSECONDS.toMillis(end-start);<span class="comment">//得到并行排序所用的时间</span></span><br><span class="line">System.out.println(ms+”ms”);</span><br></pre></td></tr></table></figure>
<p>串行输出为 1200ms，并行输出为 800ms,可见并行排序的时间相比较串行排序时间要少很多。</p>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>该操作会保持stream处于中间状态，允许做进一步的操作。它返回的还是的Stream，允许更多的链式操作。常见的中间操作有：<br>filter()：对元素进行过滤<br>sorted()：对元素排序<br>map()：元素的映射<br>distinct()：去除重复元素<br>subStream()：获取子 Stream 等  </p>
<h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><p>该操作必须是流的最后一个操作，一旦被调用，Stream 就到了一个终止状态，而且不能再使用了。常见的终止操作有：<br>forEach()：对每个元素做处理<br>toArray()：把元素导出到数组<br>findFirst()：返回第一个匹配的元素<br>anyMatch()：是否有匹配的元素等  </p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之Drawable、Bitmap、Canvas、Paint之间区别</title>
    <url>/iBlogWebsite/2016/01/04/2016/2016-01-04-Android%E4%B9%8BDrawable%E3%80%81Bitmap%E3%80%81Canvas%E3%80%81Paint%E4%B9%8B%E9%97%B4%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><h3 id="1-1-Bitmap"><a href="#1-1-Bitmap" class="headerlink" title="1.1 Bitmap"></a>1.1 Bitmap</h3><ul>
<li>称作位图，一般位图的文件格式后缀为bmp，当然编码器也有很多如RGB565、RGB888。作为一种逐像素的显示对象其优点是执行效率高，但缺点是存储效率低。</li>
<li>bitmap继承了Parcelable，可以跨进程传输</li>
</ul>
<h3 id="1-2-Drawable"><a href="#1-2-Drawable" class="headerlink" title="1.2 Drawable"></a>1.2 Drawable</h3><ul>
<li>drawable：图形对象，它可以装载常用格式的图像 gif、png、jpg、bmp，有以下多种表现形式<ul>
<li>Bitmap</li>
<li>Nine Patch</li>
<li>Vector</li>
<li>Shape</li>
<li>Layers</li>
<li>States</li>
<li>Levels</li>
<li>Scale</li>
</ul>
</li>
</ul>
<h3 id="1-3-Canvas"><a href="#1-3-Canvas" class="headerlink" title="1.3 Canvas"></a>1.3 Canvas</h3><ul>
<li>画布，可以理解为一种对图像处理的过程，通过使用各种方法来管理Bitmap、GL或者Path路径，同时它可以配合Matrix矩阵类给图像做旋转、缩放等操作，同时Canvas类还提供了裁剪、选取等操作。</li>
<li>Canvas主要用于2D绘图，它提供了很多相应的drawXxx()方法，方便我们在Canvas对象上画画，drawXxx()具有多种类型，可以画出：点、线、矩形、圆形、椭圆、文字、位图等的图形</li>
<li>下面介绍几个Canvas中常用的方法：<ul>
<li>void drawBitmap(Bitmap bitmap,float left,float top,Paint paint)：在指定坐标绘制位图</li>
<li>void drawLine(float startX,float startY,float stopX,float stopY,Paint paint)：根据给定的起始点和结束点之间绘制连线</li>
<li>void drawPath(Path path,Paint paint)：根据给定的path，绘制连线</li>
<li>void drawPoint(float x,float y,Paint paint)：根据给定的坐标，绘制点</li>
<li>void drawText(String text,int start,int end,Paint paint)：根据给定的坐标，绘制文字</li>
<li>int getHeight()：得到Canvas的高度</li>
<li>int getWidth()：得到Canvas的宽度</li>
</ul>
</li>
</ul>
<h3 id="1-4-Paint"><a href="#1-4-Paint" class="headerlink" title="1.4 Paint"></a>1.4 Paint</h3><ul>
<li>可以把它看做一个画图工具，比如画笔、画刷。</li>
<li>它管理了每个画图工具的字体、颜色、样式，主要用于设置绘图风格，包括画笔颜色、画笔粗细、填充风格等。</li>
<li>这里仅列出一些常用的：<ul>
<li>setARGB(int a,int r,int g,int b)：设置ARGB颜色。</li>
<li>setColor(int color)：设置颜色。</li>
<li>setAlpha(int a)：设置透明度。</li>
<li>setPathEffect(PathEffect effect)：设置绘制路径时的路径效果。</li>
<li>setShader(Shader shader)：设置Paint的填充效果。</li>
<li>setAntiAlias(boolean aa)：设置是否抗锯齿。</li>
<li>setStrokeWidth(float width)：设置Paint的笔触宽度。</li>
<li>setStyle(Paint.Style style)：设置Paint的填充风格。</li>
<li>setTextSize(float textSize)：设置绘制文本时的文字大小。</li>
<li>setXfermode(Xfermode xfermode)：设置绘制的渲染模式</li>
</ul>
</li>
</ul>
<h2 id="2-转换方法"><a href="#2-转换方法" class="headerlink" title="2. 转换方法"></a>2. 转换方法</h2><h3 id="2-1-Bitmap-转化为-byte"><a href="#2-1-Bitmap-转化为-byte" class="headerlink" title="2.1 Bitmap 转化为 byte"></a>2.1 Bitmap 转化为 byte</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">bitmap.compress(Bitmap.CompressFormat.PNG, <span class="number">100</span>, out);</span><br><span class="line"><span class="type">byte</span>[] array= out.toByteArray();</span><br></pre></td></tr></table></figure>

<h3 id="2-2-byte转化为bitmap"><a href="#2-2-byte转化为bitmap" class="headerlink" title="2.2 byte转化为bitmap"></a>2.2 byte转化为bitmap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Bitmap <span class="title function_">Bytes2Bimap</span><span class="params">(<span class="type">byte</span>[] b)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(b.length!=<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> BitmapFactory.decodeByteArray(b, <span class="number">0</span>, b.length);</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-bitmap-转换-drawable"><a href="#2-3-bitmap-转换-drawable" class="headerlink" title="2.3 bitmap 转换 drawable"></a>2.3 bitmap 转换 drawable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bitmap</span>(...);</span><br><span class="line"><span class="type">Drawable</span> <span class="variable">drawable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapDrawable</span>(bitmap);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Drawable-to-Bitmap"><a href="#2-4-Drawable-to-Bitmap" class="headerlink" title="2.4 Drawable to Bitmap"></a>2.4 Drawable to Bitmap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// method 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title function_">drawableToBitmap</span><span class="params">(Drawable drawable)</span> &#123;</span><br><span class="line">     <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> Bitmap.createBitmap(</span><br><span class="line">          drawable.getIntrinsicWidth(),</span><br><span class="line">          drawable.getIntrinsicHeight(),</span><br><span class="line">          drawable.getOpacity() != PixelFormat.OPAQUE ?Bitmap.Config.ARGB_8888: Bitmap.Config.RGB_565);</span><br><span class="line"></span><br><span class="line">     <span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Canvas</span>(bitmap);</span><br><span class="line">     drawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());</span><br><span class="line">     drawable.draw(canvas);</span><br><span class="line">     <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// method 2</span></span><br><span class="line">BitmapFactory.decodeResource</span><br></pre></td></tr></table></figure>

<hr>
<p>参考 <a href="http://bingtian.iteye.com/blog/642128">http://bingtian.iteye.com/blog/642128</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Drawable</tag>
        <tag>Bitmap</tag>
        <tag>Canvas</tag>
        <tag>Paint</tag>
      </tags>
  </entry>
  <entry>
    <title>位、字节、进制的关系</title>
    <url>/iBlogWebsite/2016/01/02/2016/2016-01-02-%E4%BD%8D%E3%80%81%E5%AD%97%E8%8A%82%E3%80%81%E8%BF%9B%E5%88%B6%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>我们最常听到：在计算机中存储数据以字节为单位，即8位二进制表示一个字节，一个字节可以是一个英文字母、阿拉伯数字或半个汉字所占的空间（一个汉字占2个字节）。<br>位（bit）就是一个二进制位，可表示0和1；字节(Byte)是计算机更通用的计算单位，1字节等于8位，可以代表256个数字，int类型一般为4字节，即32位。  </p>
<h2 id="按位与运算符（-amp-）"><a href="#按位与运算符（-amp-）" class="headerlink" title="按位与运算符（&amp;）"></a>按位与运算符（&amp;）</h2><p>参加运算的两个数据，按二进制位进行 <strong>与</strong> 运算。运算规则：<strong>0&amp;0=0;   0&amp;1=0;    1&amp;0=0;     1&amp;1=1;</strong> 即两位同时为 1 ，结果才为 1 ，否则为0。另负数按补码形式参加按位与运算。<br>例如：3&amp;5  即 0000 0011 &amp; 0000 0101 = 0000 0001   因此，3&amp;5的值得1。<br></p>
<p>与运算的特殊用途：<br>（1）清零。如果想将一个单元清零，只要与一个各位都为零的数值相与，结果为零<br>（2）取一个数中指定位  </p>
<blockquote>
<p>方法：找一个数，对应X要取的位，该数的对应位为1，其余位为零，此数与X进行与运算可以得到X中的指定位。<br>例：设X=10101110，<br>    取X的低4位，用 X &amp; 0000 1111 = 0000 1110 即可得到；<br>    还可用来取X的2、4、6位。  </p>
</blockquote>
<h2 id="按位或运算符（-）"><a href="#按位或运算符（-）" class="headerlink" title="按位或运算符（|）"></a>按位或运算符（|）</h2><p>参加运算的两个对象，按二进制位进行 <strong>或</strong> 运算。<br>运算规则：<strong>0|0=0；   0|1=1；   1|0=1；    1|1=1；</strong> 即参加运算的两个对象只要有一个为 1，其值为 1。另，负数按补码形式参加按位或运算。<br>例如:3|5　即 0000 0011 | 0000 0101 = 0000 0111   因此，3|5的值得7。  </p>
<p>或运算特殊作用：常用来对一个数据的某位置1。  </p>
<blockquote>
<p>方法：找到一个数，对应X要置1的位，该数的对应位为1，其余位为零。此数与X相或可使X中的某些位置1。<br>例：将X=10100000的低4位置1 ，用 X | 0000 1111 = 1010 1111即可得到</p>
</blockquote>
<h2 id="异或运算符（-）"><a href="#异或运算符（-）" class="headerlink" title="异或运算符（^）"></a>异或运算符（^）</h2><p>参加运算的两个数据，按二进制位进行 <strong>异或</strong> 运算。运算规则：<strong>0^0=0；   0^1=1；   1^0=1；   1^1=0；</strong> 即参加运算的两个对象，如果两个相应位为异（值不同），则该位结果为 1，否则为 0 。    </p>
<p>异或运算的特殊作用：<br>（1）使特定位翻转找一个数，对应X要翻转的各位，该数的对应位为1，其余位为零，此数与X对应位异或即可。  </p>
<blockquote>
<p>例：X=10101110，使X低4位翻转，用X ^ 0000 1111 = 1010 0001即可得到。  </p>
</blockquote>
<p>（2）与0相异或保留原值 ，X ^ 0000 0000 = 1010 1110</p>
<h2 id="取反运算符（-）"><a href="#取反运算符（-）" class="headerlink" title="取反运算符（~）"></a>取反运算符（~）</h2><p>参加运算的一个数据，按二进制位进行 <strong>取反</strong> 运算。运算规则：**~1=0；   ~0=1；** 即对一个二进制数按位取反，将0变1，1变0。  </p>
<p>取反运算的特殊作用：<br>使一个数的最低位为零，可以表示为：a&amp;~1。  </p>
<blockquote>
<p><del>1的值为1111111111111110，再按与运算，最低位一定为0。因为“</del>”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。</p>
</blockquote>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>编程基础</tag>
        <tag>位与字节</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之Socket编程</title>
    <url>/iBlogWebsite/2016/01/05/2016/2016-01-05-Java%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="网络编程中两个主要的问题"><a href="#网络编程中两个主要的问题" class="headerlink" title="网络编程中两个主要的问题"></a>网络编程中两个主要的问题</h2><p>一个是如何准确的定位网络上一台或多台主机，另一个就是找到主机后如何可靠高效的进行数据传输。  </p>
<p>在TCP/IP协议中IP层主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定Internet上的一台主机。而TCP层则提供面向应用的可靠(TCP)或非可靠(UDP)的数据传输机制，这是网络编程的主要对象，一般不需要关心IP层是如何处理数据的。</p>
<p>目前较为流行的网络编程模型是客户机/服务器(C/S)结构。即通信双方一方作为服务器等待客户提出请求并予以响应，客户则在需要服务时向服务器提出申请。服务器一般作为守护进程始终运行监听网络端口，一旦有客户请求就会启动一个服务进程来响应该客户，同时自己继续监听服务端口使后来的客户也能及时得到服务。</p>
<h2 id="两类传输协议：TCP-UDP"><a href="#两类传输协议：TCP-UDP" class="headerlink" title="两类传输协议：TCP/UDP"></a>两类传输协议：TCP/UDP</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>Tranfer Control Protocol的简称，是一种面向连接的保证可靠传输的协议。通过TCP协议传输得到的是一个顺序的无差错的数据流。发送方和接收方成对的两个socket之间必须建立连接，以便在TCP协议的基础上进行通信，当一个socket(通常都是server socket)等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>User Datagram Protocol的简称，是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>UDP的特点</p>
<blockquote>
<p>每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。<br>UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。<br>UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。</p>
</blockquote>
<p>TCP的特点</p>
<blockquote>
<p>面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中需要连接时间。<br>TCP传输数据大小限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大的数据。<br>TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。  </p>
</blockquote>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>TCP在网络通信上有极强的生命力，例如远程连接(Telnet)和文件传输(FTP)都需要不定长度的数据被可靠地传输。但可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高。</li>
<li>UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些。</li>
</ol>
<h2 id="基于Socket的java网络编程"><a href="#基于Socket的java网络编程" class="headerlink" title="基于Socket的java网络编程"></a>基于Socket的java网络编程</h2><h3 id="什么是Socket"><a href="#什么是Socket" class="headerlink" title="什么是Socket"></a>什么是Socket</h3><p><strong>网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket。</strong> Socket通常用来实现客户方和服务方的连接，Socket是TCP/IP协议的一个十分流行的编程界面，<strong>一个Socket由一个IP地址和一个端口号唯一确定。</strong> 但Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。</p>
<h3 id="Socket通讯的过程"><a href="#Socket通讯的过程" class="headerlink" title="Socket通讯的过程"></a>Socket通讯的过程</h3><ol>
<li>Server端Listener(监听)某个端口是否有连接请求</li>
<li>Client端向Server端发出Connect(连接)请求</li>
<li>Server端向Client端发回Accept(接受)消息</li>
</ol>
<p>一个连接就建立起来了，Server端和Client端都可以通过Send、Write等方法与对方通信。对于一个功能齐全的Socket，都要包含以下基本结构，其工作过程包含以下四个基本的步骤：</p>
<blockquote>
<p>1.创建Socket<br>2.打开连接到Socket的输入/出流<br>3.按照一定的协议对Socket进行读/写操作<br>4.关闭Socket</p>
</blockquote>
<h3 id="创建Socket"><a href="#创建Socket" class="headerlink" title="创建Socket"></a>创建Socket</h3><p>java在包java.net中提供了两个类Socket和ServerSocket，分别用来表示双向连接的客户端和服务端，其构造方法如下：</p>
<blockquote>
<p>Socket(InetAddress address, int port);<br>Socket(InetAddress address, int port, boolean stream);<br>Socket(String host, int prot);<br>Socket(String host, int prot, boolean stream);<br>Socket(SocketImpl impl)<br>Socket(String host, int port, InetAddress localAddr, int localPort)<br>Socket(InetAddress address, int port, InetAddress localAddr, int localPort)<br>ServerSocket(int port);<br>ServerSocket(int port, int backlog);<br>ServerSocket(int port, int backlog, InetAddress bindAddr)</p>
</blockquote>
<p><strong>其中address、host和port分别是双向连接中另一方的IP地址、主机名和端 口号，stream指明socket是流socket还是数据报socket，localPort表示本地主机的端口号，localAddr和 bindAddr是本地机器的地址(ServerSocket的主机地址)，impl是socket的父类，既可以用来创建serverSocket又可 以用来创建Socket。count则表示服务端所能支持的最大连接数。</strong> 代码实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">80</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注意，在选择端口时必须小心。每一个端口提供一种特定的服务，只有给出正确的端口才能获得相应的服务。0~1023的端口号是系统保留用，例如http服务的端口号为80，telnet服务的端口号为21，ftp服务的端口号为23，所以我们在选择端口号时，最好选择一个大于1023的数以防止发生冲突。</strong> 在创建socket时如果发生错误，将产生IOException，在程序中必须对之作出处理。因此在创建Socket或ServerSocket是必须捕获或抛出例外。</p>
<h3 id="简单的Client-Server程序"><a href="#简单的Client-Server程序" class="headerlink" title="简单的Client/Server程序"></a>简单的Client/Server程序</h3><p>客户端程序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TalkClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向本机的4700端口发出客户请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4700</span>);</span><br><span class="line">            <span class="comment">//由系统标准输入设备构造BufferedReader对象</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">sin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            <span class="comment">//由Socket对象得到输出流，并构造PrintWriter对象</span></span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">//由Socket对象得到输入流，并构造相应的BufferedReader对象</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String readline;</span><br><span class="line">            <span class="comment">//从系统标准输入读入一字符串</span></span><br><span class="line">            readline = sin.readLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若从标准输入读入的字符串为 &quot;bye&quot;则停止循环</span></span><br><span class="line">            <span class="keyword">while</span> (!readline.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//将从系统标准输入读入的字符串输出到Server</span></span><br><span class="line">                os.println(readline);</span><br><span class="line">                <span class="comment">//刷新输出流，使Server马上收到该字符串</span></span><br><span class="line">                os.flush();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;Client:&quot;</span> + readline);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//在系统标准输出上打印读入的字符串</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Server:&quot;</span> + is.readLine());</span><br><span class="line"></span><br><span class="line">                readline = sin.readLine(); <span class="comment">//从系统标准输入读入一字符串</span></span><br><span class="line">            &#125; <span class="comment">//继续循环</span></span><br><span class="line"></span><br><span class="line">            os.close(); <span class="comment">//关闭Socket输出流</span></span><br><span class="line">            is.close(); <span class="comment">//关闭Socket输入流</span></span><br><span class="line">            socket.close(); <span class="comment">//关闭Socket</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error&quot;</span> + e); <span class="comment">//出错，则打印出错信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端程序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TalkServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建一个ServerSocket在端口4700监听客户请求</span></span><br><span class="line">                server = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">4700</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//出错，打印出错信息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;can not listen to:&quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//使用accept()阻塞等待客户请求，有客户</span></span><br><span class="line">                socket = server.accept();</span><br><span class="line">                <span class="comment">//请求到来则产生一个Socket对象，并继续执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//出错，打印出错信息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Error.&quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由Socket对象得到输入流，并构造相应的BufferedReader对象</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">            <span class="comment">//由Socket对象得到输出流，并构造PrintWriter对象</span></span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">//由系统标准输入设备构造BufferedReader对象</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">sin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            <span class="comment">//在标准输出上打印从客户端读入的字符串</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Client:&quot;</span> + is.readLine());</span><br><span class="line">            <span class="comment">//从标准输入读入一字符串</span></span><br><span class="line">            line = sin.readLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!line.equals(<span class="string">&quot;bye&quot;</span>)) &#123;<span class="comment">//如果该字符串为 &quot;bye&quot;，则停止循环</span></span><br><span class="line">                os.println(line);<span class="comment">//向客户端输出该字符串</span></span><br><span class="line">                os.flush();<span class="comment">//刷新输出流，使Client马上收到该字符串</span></span><br><span class="line">                <span class="comment">//在系统标准输出上打印读入的字符串</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Server:&quot;</span> + line);</span><br><span class="line">                <span class="comment">//从Client读入一字符串，并打印到标准输出上</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Client:&quot;</span> + is.readLine());</span><br><span class="line">                <span class="comment">//从系统标准输入读入一字符串</span></span><br><span class="line">                line = sin.readLine();</span><br><span class="line">            &#125; <span class="comment">//继续循环</span></span><br><span class="line"></span><br><span class="line">            os.close(); <span class="comment">//关闭Socket输出流</span></span><br><span class="line">            is.close(); <span class="comment">//关闭Socket输入流</span></span><br><span class="line">            socket.close(); <span class="comment">//关闭Socket</span></span><br><span class="line">            server.close(); <span class="comment">//关闭ServerSocket</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//出错，打印出错信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Error:&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="支持多客户的client-server程序"><a href="#支持多客户的client-server程序" class="headerlink" title="支持多客户的client/server程序"></a>支持多客户的client/server程序</h3><p>前面的Client/Server程序只能实现Server和一个客户的对话。在实际应用中，往往是在服务器上运行一个永久的程序，它可以接收来自其他多个客户端的请求，提供相应的服务。为了实现在服务器方给多个客户提供服务的功能，需要对上面的程序进行改造，利用多线程实现多客户机制。服务器总是在指定的端口上监听是否有客户请求，一旦监听到客户请求，服务器就会启动一个专门的服务线程来响应该客户的请求，而服务器本身在启动完线程之后马上又进入监听状态，等待下一个客户的到来。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之基础知识汇总</title>
    <url>/iBlogWebsite/2017/04/14/2017/2017-04-14-Java%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="1-Java基本数据类型及其封装类"><a href="#1-Java基本数据类型及其封装类" class="headerlink" title="1. Java基本数据类型及其封装类"></a>1. Java基本数据类型及其封装类</h1><table>
<thead>
<tr>
<th>简单类型</th>
<th>字节数</th>
<th>封装器</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td></td>
<td>void</td>
</tr>
<tr>
<td>boolean</td>
<td>1/8</td>
<td>Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
<td>Byte</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>Character</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>Double</td>
</tr>
</tbody></table>
<h1 id="2-Switch能否用string做参数"><a href="#2-Switch能否用string做参数" class="headerlink" title="2. Switch能否用string做参数"></a>2. Switch能否用string做参数</h1><p>在switch(args)中，args只能是一个整数表达式或者枚举常量Enum，整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐含转换为int，所以这些类型及其包装类型也是可以的。显然long、float、double类型不符合switch的语法规定，并且不能被隐式转换成int类型，所以它们不能作用于swtich语句中。<strong>注意：String类型是Java7开始支持的。</strong></p>
<h1 id="3-Object有哪些公用方法"><a href="#3-Object有哪些公用方法" class="headerlink" title="3. Object有哪些公用方法"></a>3. Object有哪些公用方法</h1><table>
<thead>
<tr>
<th>方法名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>equals()</td>
<td>测试的是两个对象是否相等</td>
</tr>
<tr>
<td>hashCode()</td>
<td>返回当前对象的哈希值</td>
</tr>
<tr>
<td>toString()</td>
<td>返回对象的String代表串</td>
</tr>
<tr>
<td>clone()</td>
<td>进行对象拷贝</td>
</tr>
<tr>
<td>getClass()</td>
<td>返回和当前对象相关的Class对象</td>
</tr>
<tr>
<td>notify()、notifyall()、wait()</td>
<td>都是用来对给定对象进行线程同步的</td>
</tr>
<tr>
<td>finalize()</td>
<td>当GC检测到没有引用到此对象时调用</td>
</tr>
</tbody></table>
<h1 id="4-equals-与-的区别"><a href="#4-equals-与-的区别" class="headerlink" title="4. equals 与 == 的区别"></a>4. equals 与 == 的区别</h1><p><strong><a href="https://developer.android.google.cn/reference/java/lang/Object.html#equals(java.lang.Object)">Object类中的equals方法和 “==” 是一样的</a></strong> 没有区别，比较内存中存放的对象的堆内存地址，通俗一点说就是比较两个对象是否为同一对象；而String、Integer等一些类是重写了equals方法，加入了自己所需的 “逻辑比较”，才使得equals和 “==” 不同，一个呈现的是逻辑上是否相等，一个呈现的是是否为同一对象。所以当我们创建类时自动继承了Object的equals方法，要想实现不同的等于比较必须重写equals方法。以下是Object类中的equals源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.test.basic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by leeeyou on 2017/4/13.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEquals</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// -128 ~ 127 之间</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> -<span class="number">129</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> -<span class="number">129</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(i1 == i2); <span class="comment">//false, 但在 -128 ~ 127 之间是true</span></span><br><span class="line">        System.out.println(i1.intValue());</span><br><span class="line">        System.out.println(i1.equals(i2));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">.5f</span>;</span><br><span class="line">        <span class="type">Float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">.5f</span>;</span><br><span class="line">        System.out.println(f1 == f2); <span class="comment">//false</span></span><br><span class="line">        System.out.println(Float.floatToIntBits(f1));</span><br><span class="line">        System.out.println(f1.equals(f2));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object类中的equals方法和&quot;==&quot;是一样的,比较内存中存放的对象的(堆)内存地址</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o3</span> <span class="operator">=</span> o1;</span><br><span class="line">        System.out.println(o1.equals(o2));<span class="comment">//false</span></span><br><span class="line">        System.out.println(o1 == o2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(o1 == o3);<span class="comment">//true</span></span><br><span class="line">        System.out.println(o1.equals(o3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line">-<span class="number">129</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">---</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="number">1056964608</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">---</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="5-改写equals为什么要改写hashCode"><a href="#5-改写equals为什么要改写hashCode" class="headerlink" title="5. 改写equals为什么要改写hashCode"></a>5. 改写equals为什么要改写hashCode</h1><p>如果不这样的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和HashTable。</p>
<p>下面是约定的内容，摘自Obejct规范[Java SE6]：</p>
<ul>
<li><p>在应用程序执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</p>
</li>
<li><p>如果两个对象根据equals(Object)方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。即保证在equals相同的情况下hashcode值必定相同。</p>
</li>
<li><p>如果两个对象根据equals(Object)方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生不同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。</p>
</li>
</ul>
<p>参考：<a href="https://book.douban.com/subject/3360807/">Effective java 中文版（第2版）</a></p>
<h1 id="6-Java的四种引用"><a href="#6-Java的四种引用" class="headerlink" title="6. Java的四种引用"></a>6. Java的四种引用</h1><h2 id="6-1-强引用（StrongReference）"><a href="#6-1-强引用（StrongReference）" class="headerlink" title="6.1. 强引用（StrongReference）"></a>6.1. 强引用（StrongReference）</h2><p>强引用是使用最普遍的引用。<strong>如果一个对象具有强引用那GC绝不会回收它。当内存空间不足，JVM宁愿抛出OutOfMemoryError使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</strong></p>
<p>Tips：强引用其实也就是我们平时 A a = new A() 这个意思。</p>
<h2 id="6-2-软引用（SoftReference）"><a href="#6-2-软引用（SoftReference）" class="headerlink" title="6.2. 软引用（SoftReference）"></a>6.2. 软引用（SoftReference）</h2><p>如果一个对象只具有软引用，则内存空间足够GC就不会回收它；如果内存空间不足了，就会回收这些对象的内存。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被GC回收，JVM就会把这个软引用加入到与之关联的引用队列中。</p>
<h2 id="6-3-弱引用（WeakReference）"><a href="#6-3-弱引用（WeakReference）" class="headerlink" title="6.3. 弱引用（WeakReference）"></a>6.3. 弱引用（WeakReference）</h2><p>弱引用与软引用的区别在于：<strong>只具有弱引用的对象拥有更短暂的生命周期。</strong> 在GC线程扫描它所管辖的内存区域时，一旦发现弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过由于 <strong>GC是一个优先级很低的线程</strong>，因此不一定会很快发现那些只具有弱引用的对象。</p>
<h2 id="6-4-虚引用（PhantomReference）"><a href="#6-4-虚引用（PhantomReference）" class="headerlink" title="6.4. 虚引用（PhantomReference）"></a>6.4. 虚引用（PhantomReference）</h2><p>与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被GC回收。虚引用主要用来跟踪对象被GC回收。</p>
<p>虚引用与软引用和弱引用的一个区别在于：<strong>虚引用必须和引用队列 （ReferenceQueue）联合使用。</strong> 当GC准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span> ();</span><br><span class="line"><span class="type">PhantomReference</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span> (object, queue);</span><br></pre></td></tr></table></figure>

<p>程序员可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否为将要被垃圾回收。如果发现某个虚引用已经被加入到引用队列，就可以在所引用对象的内存被回收之前采取必要的行动。</p>
<p>Tips：利用软引用和弱引用解决OOM问题。<br>用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题</p>
<p>Tips：更多关于对象引用的知识，参考 <a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-4-jiang-qiang-yin-yong-3001-ruan-yin-yong-3001-ruo-yin-yong-3001-huan-xiang-yin-yong-you-shi-yao-qu-bie-ff1f.md">第4讲 | 强引用、软引用、弱引用、幻象引用有什么区别？</a>。</p>
<h1 id="7-ArrayList、LinkedList、Vector的区别"><a href="#7-ArrayList、LinkedList、Vector的区别" class="headerlink" title="7. ArrayList、LinkedList、Vector的区别"></a>7. ArrayList、LinkedList、Vector的区别</h1><p>下面这张是Collection框架图，主要包含List、Set和Queue集合。<br><img src="../../../../images/githubpages/Java%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/Collection%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="Collection框架图">  </p>
<p>参考 <a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-8-jiang-dui-bi-vector-arraylist-linkedlist-you-he-qu-bie-ff1f.md">第8讲 | 对比Vector、ArrayList、LinkedList有何区别？</a></p>
<h1 id="8-HashMap和ConcurrentHashMap的区别"><a href="#8-HashMap和ConcurrentHashMap的区别" class="headerlink" title="8. HashMap和ConcurrentHashMap的区别"></a>8. HashMap和ConcurrentHashMap的区别</h1><p>下面这张是Map集合框架图。<br><img src="../../../../images/githubpages/Java%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/Map%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="Map集合框架图"><br>参考 <a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-9-jiang-dui-bi-hashtable-hashmap-treemap-you-shi-yao-bu-tong-ff1f.md">第9讲 | 对比Hashtable、HashMap、TreeMap有什么不同？</a><br>参考 <a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-10-jiang-ru-he-baozheng-ji-he-shi-xian-cheng-an-quan-76843f-concurrenthashmap-ru-he-shi-xian-gao-xiao-di-xian-cheng-an-quan-ff1f.md">第10讲 | 如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全？</a></p>
<h1 id="9-String、StringBuffer与StringBuilder的区别"><a href="#9-String、StringBuffer与StringBuilder的区别" class="headerlink" title="9. String、StringBuffer与StringBuilder的区别"></a>9. String、StringBuffer与StringBuilder的区别</h1><p>String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p>
<p>StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，它是 Java 1.5 中新增的，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。</p>
<p>StringBuilder 在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p>
<p>Tips：更多知识，参考 <a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-5-jiang-string-stringbuffer-stringbuilder-you-shi-yao-qu-bie-ff1f.md">第5讲 | String、StringBuffer、StringBuilder有什么区别？</a></p>
<h1 id="10-try-catch-finally"><a href="#10-try-catch-finally" class="headerlink" title="10. try catch finally"></a>10. try catch finally</h1><p>在不抛出异常的情况下，程序执行完try里面的代码块之后，该方法并不会立即结束，而是继续试图去寻找该方法有没有finally的代码块。</p>
<p>如果没有finally代码块，整个方法在执行完try代码块后返回相应的值来结束整个方法。<br>如果有finally代码块，此时程序执行到try代码块里的return语句之时并不会立即执行return，而是先去执行finally代码块里的代码。</p>
<p>若finally代码块里没有return或没有能够终止程序的代码，程序将在执行完finally代码块代码之后再返回try代码块执行return语句来结束整个方法。<br>若finally代码块里有return或含有能够终止程序的代码，方法将在执行完finally之后被结束，不再跳回try代码块执行return。</p>
<p>在抛出异常的情况下，原理也是和上面的一样的，你把上面说到的try换成catch去理解就OK了。</p>
<h1 id="11-Excption与Error包结构"><a href="#11-Excption与Error包结构" class="headerlink" title="11. Excption与Error包结构"></a>11. Excption与Error包结构</h1><p><img src="https://github.com/LeeeYou/Img/blob/master/leeeyou/Excption.png?raw=true" alt="Throwable"></p>
<p>参考 <a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-2-jiang-exception-he-error-you-shi-yao-qu-bie-ff1f.md">第2讲 | Exception和Error有什么区别？</a></p>
<h1 id="12-锁的等级"><a href="#12-锁的等级" class="headerlink" title="12. 锁的等级"></a>12. 锁的等级</h1><h2 id="12-1-分类"><a href="#12-1-分类" class="headerlink" title="12.1. 分类"></a>12.1. 分类</h2><p>类锁：在代码中的方法上加了static和synchronized的锁，或者synchronized(xxx.class）的代码段。<br>对象锁：在代码中的方法上加上synchronized锁或者synchronized(this）的代码段，二者的加锁方法构成竞争关系，同一时刻只能有一个方法能执行。<br>私有锁：在类内部声明一个私有属性如private Object lock，在需要加锁的代码段synchronized(lock）。      </p>
<p>类锁和对象锁不会产生竞争，二者的加锁方法不会相互影响。<br>私有锁和对象锁也不会产生竞争，二者的加锁方法不会相互影响。</p>
<h2 id="12-2-synchronized和lock区别"><a href="#12-2-synchronized和lock区别" class="headerlink" title="12.2. synchronized和lock区别"></a>12.2. synchronized和lock区别</h2><p>Lock是Java SE5中新引入的用于提高性能的类，类似的还有Atomic类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> ...;</span><br><span class="line">l.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// access the resource protected by this lock</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  l.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要考虑两个因素：1 互斥方法体的大小问题。<strong>只互斥那些绝对必须互斥的部分</strong> ，但实际情况中，被互斥部分可能非常大，相对于进入和退出互斥的时间比来说，Lock提升的互斥速度优势基本就湮灭了； 2 synchronized的可读性高，维护成本较低，通常是开发人员的惯用手法。建议以synchronized入手，只有在性能调优时或者 <strong>有明确的证据表明</strong> 在同步下synchronized遇到性能瓶颈才替换为Lock这种做法具有实际意义。</p>
<p>Tips：更多知识，参考 <a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-15-jiang-synchronized-he-reentrantlock-you-shi-yao-qu-bie-ni-ff1f.md">第15讲 | synchronized和ReentrantLock有什么区别呢？</a></p>
<h1 id="13-生产者消费者模式"><a href="#13-生产者消费者模式" class="headerlink" title="13. 生产者消费者模式"></a>13. 生产者消费者模式</h1><p>下面这段代码的实现方式比较复杂，需要人为控制轮询和条件判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12.proCus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决了&quot;重复消费和未消费&quot;的问题(if改成while)，同时利用JDK5.0新特性Lock和Condition 处理了同步时上锁解锁和等待唤醒的的问题</span></span><br><span class="line"><span class="comment"> * Lock最大的一个特点是：&quot;可以支持多个相关的 Condition 对象&quot;，也就是说一把锁上可以绑定多个&quot;状态条件&quot;对象，详见API</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kongbei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerCustomerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Res2</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Res2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer2</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer2</span>(r);</span><br><span class="line">        <span class="type">Customer2</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer2</span>(r);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Res2 r;</span><br><span class="line"></span><br><span class="line">    Producer2(Res2 r) &#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        r.set(<span class="string">&quot;iPhone5s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Res2 r;</span><br><span class="line"></span><br><span class="line">    Customer2(Res2 r) &#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        r.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Res2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">5588</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//当前仓库是不是满的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditon_pro</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition_cus</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock(); <span class="comment">//上锁</span></span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conditon_pro.await(); <span class="comment">//让生产线程等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.name = name + <span class="string">&quot;..编号&quot;</span> + count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;- 生产 -&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            condition_cus.signal(); <span class="comment">//唤醒消费线程</span></span><br><span class="line">            lock.unlock();<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock(); <span class="comment">//上锁</span></span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition_cus.await();<span class="comment">//让消费线程等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;	&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;-消费-&quot;</span> + name);</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            conditon_pro.signal();<span class="comment">//唤醒生成线程</span></span><br><span class="line">            lock.unlock();<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面利用 BlockingQueue 来实现，由于其提供的等待机制，我们可以少操心很多协调工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXIT_MSG</span> <span class="operator">=</span> <span class="string">&quot;Good bye!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用较小的队列，以更好地在输出中展示其影响</span></span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(queue);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;String&gt; q)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.queue = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5L</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Message&quot;</span> + i;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced new item: &quot;</span> + msg);</span><br><span class="line">                    queue.put(msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Time to say good bye!&quot;</span>);</span><br><span class="line">                queue.put(EXIT_MSG);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; q)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.queue = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String msg;</span><br><span class="line">                <span class="keyword">while</span> (!EXIT_MSG.equalsIgnoreCase((msg = queue.take()))) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;    Consumed item: &quot;</span> + msg);</span><br><span class="line">                    Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Got exit message, bye!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips：更多知识，参考 <a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-20-jiang-bing-fa-bao-zhong-de-concurrentlinkedqueue-he-linkedblockingqueue-you-shi-yao-qu-bie-ff1f.md#%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%85%B8%E5%9E%8B%E7%94%A8%E4%BE%8B">第20讲 | 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</a></p>
<h1 id="14-写一个死锁程序"><a href="#14-写一个死锁程序" class="headerlink" title="14. 写一个死锁程序"></a>14. 写一个死锁程序</h1><p>出现原因：同步中嵌套同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day11.deadLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeadLock2</span>(<span class="literal">false</span>));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeadLock2</span>(<span class="literal">true</span>));</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeadLock2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  DeadLock2(<span class="type">boolean</span> flag)&#123;</span><br><span class="line">    <span class="built_in">this</span>.flag = flag;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (LockObject.lo1) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;if lo1&quot;</span>);</span><br><span class="line">       <span class="keyword">synchronized</span> (LockObject.lo2) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;if lo2&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (LockObject.lo2) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;else lo2&quot;</span>);</span><br><span class="line">       <span class="keyword">synchronized</span> (LockObject.lo1) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;else lo1&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockObject</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">LockObject</span> <span class="variable">lo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockObject</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">LockObject</span> <span class="variable">lo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockObject</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips：更多知识，参考 <a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-18-jiang-shi-yao-qing-kuang-xia-java-cheng-xu-hui-chan-sheng-si-suo-ff1f-ru-he-ding-wei-3001-xiu-fu-ff1f.md">第18讲 | 什么情况下Java程序会产生死锁？如何定位、修复？</a></p>
<h1 id="15-ThreadLocal"><a href="#15-ThreadLocal" class="headerlink" title="15. ThreadLocal"></a>15. ThreadLocal</h1><p><strong>ThreadLocal是一个数据结构，用于隔离其他线程，提供线程内的局部变量；这种变量在线程的生命周期内起作用，能减少同一个线程内多个函数或者组件之间一些公共变量传递的复杂度。</strong></p>
<p>先看看JDK8的ThreadLocal-set/get方法的源码：</p>
<p><a href="https://cs.android.com/android/platform/superproject/+/master:libcore/ojluni/src/main/java/java/lang/ThreadLocal.java;l=455;drc=master?q=ThreadLocalMap&ss=android/platform/superproject"><strong>libcore/ojluni/src/main/java/java/lang/ThreadLocal.java</strong></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//拿到当前线程的ThreadLocalMap，实际上就是Thread类的threadLocals属性</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//key是ThreadLocal本身</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//在ThreadLocalMap中找到对应的Entry</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">//得到Entry的value</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocal.ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，每个线程中都有一个ThreadLocalMap数据结构。当执行set方法时，其值是保存在当前线程的threadLocals变量中；而执行get方法中是从当前线程的threadLocals变量获取。通过下面的例子可以更好的理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; cityName = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line"></span><br><span class="line">在Thread1中cityName.set(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">在Thread2中cityName.set(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread1 - ThreadLocalMap1(key,value) - key就是ThreadLocal实例，value就是深圳</span><br><span class="line">Thread2 - ThreadLocalMap2(key,value) - key就是ThreadLocal实例，value就是北京</span><br></pre></td></tr></table></figure>

<p>总结一下ThreadLocal的设计思路：每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。所以在Thread1中set的值，对Thread2来说是摸不到的，而且在Thread2中重新set的话，也不会影响到Thread1中的值，保证了线程之间不会相互干扰。</p>
<h2 id="15-1-Android中ThreadLocal唯一性验证"><a href="#15-1-Android中ThreadLocal唯一性验证" class="headerlink" title="15.1 Android中ThreadLocal唯一性验证"></a>15.1 <a href="https://github.com/Leeeyou/SampleHandler/blob/master/app/src/main/java/com/leeeyou123/samplehandler/MainActivity.kt">Android中ThreadLocal唯一性验证</a></h2><p>结合Android中的Handler机制中的Looper是如何保证线程唯一性的，下面代码分别在主线程和子线程中反射获取sThreadLocal和mQueue，然后观察它们是否一致。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 验证ThreadLocal全局唯一性，分别在主线程和子线程中反射获取sThreadLocal和mQueue，然后观察它们是否一致</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 期望：sThreadLocal一致，完全是同一个实例对象，因为它是static final的，隶属于类</span></span><br><span class="line"><span class="comment">*      而mQueue是final的，是跟线程实例对象对应的，不同线程是不同的实例对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">verifyThreadLocal</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;请查看logcat&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> looperClazz = Class.forName(<span class="string">&quot;android.os.Looper&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中反射获取sThreadLocal和mQueue对象</span></span><br><span class="line">    Looper.getMainLooper()?.also &#123;</span><br><span class="line">        Handler(it).post &#123;</span><br><span class="line">            <span class="keyword">val</span> threadLocalField = looperClazz.getDeclaredField(<span class="string">&quot;sThreadLocal&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> mqField = looperClazz.getDeclaredField(<span class="string">&quot;mQueue&quot;</span>)</span><br><span class="line">            threadLocalField.isAccessible = <span class="literal">true</span></span><br><span class="line">            mqField.isAccessible = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">val</span> threadLocalObj = threadLocalField.<span class="keyword">get</span>(<span class="literal">null</span>) <span class="comment">// 获取静态类型的实例对象</span></span><br><span class="line">            <span class="keyword">val</span> mqObj = mqField.<span class="keyword">get</span>(it)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> msg =</span><br><span class="line">                <span class="string">&quot;ThreadName [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>], sThreadLocal is [<span class="subst">$&#123;threadLocalObj&#125;</span>], mQueue is [<span class="subst">$&#123;mqObj&#125;</span>]&quot;</span></span><br><span class="line">            Log.e(TAG, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在子线程中反射获取sThreadLocal和mQueue对象</span></span><br><span class="line">    Thread &#123;</span><br><span class="line">        Looper.prepare() <span class="comment">// 子线程中prepare looper</span></span><br><span class="line">        Looper.myLooper()?.also &#123;</span><br><span class="line">            Handler(it).post &#123; <span class="comment">// 在子线程中创建Handler并post msg</span></span><br><span class="line">                <span class="keyword">val</span> threadLocalField = looperClazz.getDeclaredField(<span class="string">&quot;sThreadLocal&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> mqField = looperClazz.getDeclaredField(<span class="string">&quot;mQueue&quot;</span>)</span><br><span class="line">                threadLocalField.isAccessible = <span class="literal">true</span></span><br><span class="line">                mqField.isAccessible = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">val</span> threadLocalObj = threadLocalField.<span class="keyword">get</span>(<span class="literal">null</span>) <span class="comment">// 获取静态类型的实例对象</span></span><br><span class="line">                <span class="keyword">val</span> mqObj = mqField.<span class="keyword">get</span>(it)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> msg =</span><br><span class="line">                    <span class="string">&quot;ThreadName [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>], sThreadLocal is [<span class="subst">$&#123;threadLocalObj&#125;</span>], mQueue is [<span class="subst">$&#123;mqObj&#125;</span>]&quot;</span></span><br><span class="line">                Log.e(TAG, msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Looper.loop() <span class="comment">// 开启子线程的loop循环</span></span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的日志如下所示，可以看到不管是主线程还是子线程，sThreadLocal是同一个实例对象，而mQueue是跟线程实例对象对应的，不同线程是不同的实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">12</span>-<span class="number">16</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">38.550</span> <span class="number">8100</span>-<span class="number">8100</span>/com.leeeyou123.samplehandler E/MainActivity: ThreadName [main], sThreadLocal is [java.lang.ThreadLocal@8a18755], mQueue is [android.os.MessageQueue@74fba5b]</span><br><span class="line"><span class="number">2021</span>-<span class="number">12</span>-<span class="number">16</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">38.550</span> <span class="number">8100</span>-<span class="number">11638</span>/com.leeeyou123.samplehandler E/MainActivity: ThreadName [Thread-<span class="number">12</span>], sThreadLocal is [java.lang.ThreadLocal@8a18755], mQueue is [android.os.MessageQueue@51c42f8]</span><br></pre></td></tr></table></figure>

<h2 id="15-2-ThreadLocalMap"><a href="#15-2-ThreadLocalMap" class="headerlink" title="15.2. ThreadLocalMap"></a>15.2. <a href="https://cs.android.com/android/platform/superproject/+/master:libcore/ojluni/src/main/java/java/lang/ThreadLocal.java;drc=master;bpv=1;bpt=1;l=298?q=ThreadLocalMap&ss=android/platform/superproject">ThreadLocalMap</a></h2><p>从名字上看可以猜到它也是一个类似HashMap的数据结构，但是在ThreadLocal中并没实现Map接口。在ThreadLoalMap中初始化一个大小16的Entry数组，Entry对象用来保存每一个key-value键值对，只不过这里的key永远都是ThreadLocal对象，是不是很神奇，通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中。</p>
<p>ThreadLoalMap的Entry继承了WeakReference，和HashMap很大的区别是，Entry中没有next字段，所以就不存在链表的情况了。</p>
<p>ThreadLocalMap是使用ThreadLocal的弱引用作为Key的，源码如下所示：</p>
<p><strong>libcore/ojluni/src/main/java/java/lang/ThreadLocal.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a><a href="https://cs.android.com/android/platform/superproject/+/master:libcore/ojluni/src/main/java/java/lang/ThreadLocal.java;drc=master;bpv=1;bpt=1;l=455?q=ThreadLocalMap&ss=android/platform/superproject">hash冲突</a></h3><p>没有链表结构，那发生hash冲突了怎么办？先看看ThreadLoalMap中插入一个key-value的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    <span class="comment">//拿到Entry数组</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">//通过ThreadLocal对象的hash值计算出下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环数组，起点是i所在的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">            e != <span class="literal">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//位置i已经有Entry对象了，如果这个Entry对象的key正好是即将设置的key，那么重新设置Entry中的value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//位置i的key是null，则替换掉陈旧的Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前i的位置是null，正在就初始化一个Entry放在i位置上</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个ThreadLocal对象都有一个hash值threadLocalHashCode，每初始化一个ThreadLocal对象，hash值就增加一个固定的大小0x61c88647(即十进制1640531527)。上面的set代码展示了插入过程中的定位逻辑，在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该位置Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。</p>
<h2 id="15-3-ThreadLocal和Synchronized"><a href="#15-3-ThreadLocal和Synchronized" class="headerlink" title="15.3. ThreadLocal和Synchronized"></a>15.3. ThreadLocal和Synchronized</h2><p>一个是锁机制进行时间换空间，一个是存储拷贝进行空间换时间。</p>
<h1 id="16-守护线程和非守护线程的区别以及用法"><a href="#16-守护线程和非守护线程的区别以及用法" class="headerlink" title="16. 守护线程和非守护线程的区别以及用法"></a>16. 守护线程和非守护线程的区别以及用法</h1><p>调用时机：在启动线程前调用。<br>特点一：开启后，和前台线程共同抢夺CPU执行权并运行。<br>特点二：结束时，当所有前台线程都结束后，后台线程会自动结束（JAVA VM退出）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12.deamonThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeamonThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeamonThread</span> <span class="variable">dt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeamonThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dt);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dt);</span><br><span class="line"></span><br><span class="line">        t1.setDaemon(<span class="literal">true</span>);<span class="comment">//设置为后台线程</span></span><br><span class="line">        t2.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;..&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeamonThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;..&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="17-ThreadPool用法与优势"><a href="#17-ThreadPool用法与优势" class="headerlink" title="17. ThreadPool用法与优势"></a>17. ThreadPool用法与优势</h1><h2 id="17-1-优势"><a href="#17-1-优势" class="headerlink" title="17.1. 优势"></a>17.1. 优势</h2><p>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h2 id="17-2-newCachedThreadPool"><a href="#17-2-newCachedThreadPool" class="headerlink" title="17.2. newCachedThreadPool"></a>17.2. newCachedThreadPool</h2><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>只有非核心线程；线程数量不固定的线程池；有超时机制，超过60s，闲置线程就会被回收；适合执行大量的耗时较少的任务。</p>
<h2 id="17-3-newFixedThreadPool"><a href="#17-3-newFixedThreadPool" class="headerlink" title="17.3. newFixedThreadPool"></a>17.3. newFixedThreadPool</h2><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br>只有核心线程；线程数量固定的线程池；线程处于空闲状态，不会被回收。</p>
<h2 id="17-4-newScheduledThreadPool"><a href="#17-4-newScheduledThreadPool" class="headerlink" title="17.4. newScheduledThreadPool"></a>17.4. newScheduledThreadPool</h2><p>创建一个定长线程池，支持定时及周期性任务执行。<br>核心线程有固定数，非核心线程没有限制的线程池；非核心线程闲置时会被回收；主要用于执行定时任务和具有固定周期的重复任务。</p>
<h2 id="17-5-newSingleThreadExecutor"><a href="#17-5-newSingleThreadExecutor" class="headerlink" title="17.5. newSingleThreadExecutor"></a>17.5. newSingleThreadExecutor</h2><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<br>只有一个核心线程；确保所有的任务都在同一个线程中按顺序执行；其意义在于统一外界任务到一个线程中，使得这些任务之间不需要处理线程同步问题。</p>
<p>Tips：更多知识，参考 <a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-21-jiang-java-bing-fa-lei-ku-ti-gong-de-xian-cheng-chi-you-na-ji-zhong-ff1f-fen-bie-you-shi-yao-te-dian-ff1f.md">第21讲 | Java并发类库提供的线程池有哪几种？ 分别有什么特点？</a></p>
<h1 id="18-Java-IO与NIO"><a href="#18-Java-IO与NIO" class="headerlink" title="18. Java IO与NIO"></a>18. Java IO与NIO</h1><table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流</td>
<td>面向缓冲</td>
</tr>
<tr>
<td>阻塞IO</td>
<td>非阻塞IO</td>
</tr>
<tr>
<td>无</td>
<td>选择器</td>
</tr>
</tbody></table>
<h2 id="18-1-面向流-vs-面向缓冲"><a href="#18-1-面向流-vs-面向缓冲" class="headerlink" title="18.1. 面向流 vs 面向缓冲"></a>18.1. 面向流 vs 面向缓冲</h2><p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。</p>
<p>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外它不能前后移动流中的数据，如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。</p>
<p>Java NIO的缓冲导向方法略有不同，数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性，但还需要检查是否该缓冲区中包含所有您需要处理的数据，而且需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<h2 id="18-2-阻塞-vs-非阻塞"><a href="#18-2-阻塞-vs-非阻塞" class="headerlink" title="18.2. 阻塞 vs 非阻塞"></a>18.2. 阻塞 vs 非阻塞</h2><p>Java IO的各种流是阻塞的。这意味着当一个线程调用read()或write()时，该线程被阻塞直到有一些数据被读取或数据完全写入。该线程在此期间不能再干任何事情了。</p>
<p>Java NIO的非阻塞模式，一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h2 id="18-3-事件监听器"><a href="#18-3-事件监听器" class="headerlink" title="18.3. 事件监听器"></a>18.3. 事件监听器</h2><p>Java NIO的选择器(Selector)允许一个单独的线程来监视多个输入通道(Channel)，我们在Selector上声明我们关心哪一个Channel的什么事件， Selector会监控这些Channels，并在事件发生时通知我们。</p>
<p>Tips：更多知识，参考 <a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-11-jiang-java-ti-gong-le-na-xie-io-fang-shi-ff1f-nio-ru-he-shi-xian-duo-lu-fu-yong-ff1f.md">第11讲 | Java提供了哪些IO方式？ NIO如何实现多路复用？</a></p>
<h1 id="19-接口和抽象类的区别"><a href="#19-接口和抽象类的区别" class="headerlink" title="19. 接口和抽象类的区别"></a>19. 接口和抽象类的区别</h1><p>Tips：更多知识，参考 <a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-13-jiang-tan-tan-jie-kou-he-chou-xiang-lei-you-shi-yao-qu-bie-ff1f.md">第13讲 | 谈谈接口和抽象类有什么区别？</a></p>
<h1 id="20-静态类和非静态类的区别"><a href="#20-静态类和非静态类的区别" class="headerlink" title="20. 静态类和非静态类的区别"></a>20. 静态类和非静态类的区别</h1><p>静态类不能实例化，非静态类在使用时必须要实例化。</p>
<p>静态类中不能创建非静态的方法，即静态类中只能创建静态方法，但在非静态类中可以调用静态方法。</p>
<p>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。</p>
<p>静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。</p>
<p>实例化一个非静态的内部类的方法 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.先生成一个外部类对象实例</span><br><span class="line"><span class="type">OutClassTest</span> <span class="variable">oc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutClassTest</span>();</span><br><span class="line"></span><br><span class="line">b.通过外部类的对象实例生成内部类对象</span><br><span class="line">OutClassTest.<span class="type">InnerClass</span> <span class="variable">no_static_inner</span> <span class="operator">=</span> oc1.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br></pre></td></tr></table></figure>

<p>实例化一个静态内部类的方法 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.不依赖于外部类的实例,直接实例化内部类对象</span><br><span class="line">OutClassTest.<span class="type">InnerStaticClass</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutClassTest</span>.InnerStaticClass();</span><br><span class="line"></span><br><span class="line">b.调用内部静态类的方法或静态变量,通过类名直接调用</span><br><span class="line">OutClassTest.InnerStaticClass.static_value</span><br><span class="line">OutClassTest.InnerStaticClass.getMessage()</span><br></pre></td></tr></table></figure>

<h1 id="21-父类、子类实例化顺序"><a href="#21-父类、子类实例化顺序" class="headerlink" title="21. 父类、子类实例化顺序"></a>21. 父类、子类实例化顺序</h1><p>当实例化子类对象时，首先要加载父类的class文件进内存，静态代码块是随着类的创建而执行，所以父类静态代码块最先被执行，子类class文件再被加载，同理静态代码块被先执行；实例化子类对象要先调用父类的构造方法，而调用父类构造方法前会先执行父类的非静态代码块。</p>
<p>例如：子类Sub继承父类Parent，Parent a = new Sub(); 则父类B构造函数、父类B静态代码块、父类B非静态代码块、子类A构造函数、子类A静态代码块、子类A非静态代码块 执行的先后顺序是？</p>
<p>父类静态代码块-&gt;子类静态代码块-&gt;父类非静态代码块-&gt;父类构造函数-&gt;子类非静态代码块-&gt;子类构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParentCodeBlock 静态代码块</span><br><span class="line">SubBlockParent 静态代码块</span><br><span class="line">ParentCodeBlock 非静态代码块</span><br><span class="line">ParentCodeBlock 构造函数</span><br><span class="line">SubBlockParent 非静态代码块</span><br><span class="line">SubBlockParent 构造函数</span><br></pre></td></tr></table></figure>

<h1 id="22-OOP和AOP的区别"><a href="#22-OOP和AOP的区别" class="headerlink" title="22. OOP和AOP的区别"></a>22. OOP和AOP的区别</h1><p>OOP(面向对象编程)针对业务处理过程的实体及其属性和行为进行封装，以获得更加清晰的逻辑单元划分。</p>
<p>AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。AOP可以通过 <strong>预编译方式和运行期动态代理</strong> 实现在不修改源代码的情况下给程序动态统一添加功能的一种技术，把散落在程序中的公共部分提取出来做成切面类，这样的好处在于代码的可重用，一旦涉及到该功能的需求发生变化，只要修改该代码就行，否则你要到处修改，如果只要修改1、2处那还可以接受，万一有1000处呢？</p>
<h1 id="23-依赖注入和控制反转的区别"><a href="#23-依赖注入和控制反转的区别" class="headerlink" title="23. 依赖注入和控制反转的区别"></a>23. 依赖注入和控制反转的区别</h1><p>依赖注入，就其广义而言即是通过 “注入” 的方式来获得依赖。我们知道，A对象依赖于B对象，等价于A对象内部存在对B对象的 “调用”，而前提是A对象内部拿到了B对象的引用。B对象的引用的来源无非有以下几种：A对象内部创建（无论是作为字段还是作为临时变量）、构造器注入、属性注入、方法注入。后面三种方式统称为“依赖注入”，而第一种方式我也生造了一个名词，称为 “依赖内生” 。二者根本的差异即在于：我所依赖的对象的创建工作是否由我自己来完成。</p>
<p>控制反转跟依赖倒置都是一种编程思想，依赖倒置着眼于调用的形式，而控制反转则着眼于程序流程的控制权。一般来说，程序的控制权属于Client，而一旦控制权交到server，就叫控制反转。比如你去下馆子，你是Client餐馆是server。你点菜，餐馆负责做菜，程序流程的控制权属于Client；而如果你去自助餐厅，程序流程的控制权就转到server了，也就是控制反转。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之多线程</title>
    <url>/iBlogWebsite/2016/01/06/2016/2016-01-06-Java%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-多线程基础"><a href="#1-多线程基础" class="headerlink" title="1. 多线程基础"></a>1. 多线程基础</h1><h2 id="1-1-线程与进程-彩蛋链接"><a href="#1-1-线程与进程-彩蛋链接" class="headerlink" title="1.1. 线程与进程(彩蛋链接)"></a>1.1. 线程与进程(<a href="https://mp.weixin.qq.com/s?__biz=MzI2NjA3NTc4Ng==&mid=2652078313&idx=1&sn=78cd4e29efdb55129b57364dc26c3e06&scene=1&srcid=0720DVv28A1Nb6UzhN03BjxW#rd">彩蛋链接</a>)</h2><ul>
<li>进程：是一个正在执行中的程序</li>
<li>线程：是进程的一个独立的控制单元，程序的执行路径</li>
<li>举例：Java VM main线程</li>
<li>扩展：Java VM 的垃圾回收线程</li>
</ul>
<h2 id="1-2-线程的几个状态"><a href="#1-2-线程的几个状态" class="headerlink" title="1.2. 线程的几个状态"></a>1.2. 线程的几个状态</h2><p><img src="../../../../images/githubpages/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="线程的几个状态"></p>
<h2 id="1-3-对线程对象和名称的操作"><a href="#1-3-对线程对象和名称的操作" class="headerlink" title="1.3. 对线程对象和名称的操作"></a>1.3. 对线程对象和名称的操作</h2><ul>
<li>Thread.currentThread() 获取对象</li>
<li>getName() 获取当前线程线程名称</li>
<li>设置线程名称 setName() 或者通过构造函数</li>
</ul>
<h2 id="1-4-售票问题"><a href="#1-4-售票问题" class="headerlink" title="1.4. 售票问题"></a>1.4. 售票问题</h2><p>情景：多个窗口同时出售火车票,总票数100张</p>
<p>解决办法</p>
<ul>
<li>利用static</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.ticket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 售票问题展示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketWithProblem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">50</span>;<span class="comment">//总票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket + <span class="string">&quot;    &quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: no ticket&quot;</span>);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现Runable接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.ticket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 售票问题展示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketWithProblem2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">50</span>;<span class="comment">//总票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;....&quot;</span> + ticket--);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: no ticket&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下所示，出现了0，-1，-2号票：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>:<span class="number">50</span>    </span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">49</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">49</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">47</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">46</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">46</span>    </span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">44</span>    </span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">44</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">42</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">41</span>    </span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">40</span>    </span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">39</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">38</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">37</span>    </span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">36</span>    </span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">36</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">34</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">33</span>    </span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">32</span>    </span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">32</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">30</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">29</span>    </span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">28</span>    </span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">27</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">26</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">26</span>    </span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">24</span>    </span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">23</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">22</span>    </span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">22</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">22</span>    </span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">19</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">18</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">17</span>    </span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">16</span>    </span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">15</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">14</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">13</span>    </span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">12</span>    </span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">11</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">10</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">9</span>    </span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">8</span>    </span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">7</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">6</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">6</span>    </span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">4</span>    </span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">3</span>    </span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">2</span>    </span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">2</span>    </span><br><span class="line">Thread-<span class="number">2</span>: no ticket</span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">0</span>    </span><br><span class="line">Thread-<span class="number">1</span>: no ticket</span><br><span class="line">Thread-<span class="number">0</span>:-<span class="number">1</span>    </span><br><span class="line">Thread-<span class="number">0</span>: no ticket</span><br><span class="line">Thread-<span class="number">3</span>:-<span class="number">2</span>    </span><br><span class="line">Thread-<span class="number">3</span>: no ticket</span><br></pre></td></tr></table></figure>

<h2 id="1-5-创建线程"><a href="#1-5-创建线程" class="headerlink" title="1.5. 创建线程"></a>1.5. 创建线程</h2><ul>
<li>继承Thread类</li>
<li>实现Runable接口</li>
</ul>
<p>区别(继承Thread类, 实现Runable接口)</p>
<ul>
<li>实现的方式避免了单继承的局限性</li>
<li>线程代码存放位置不一样<ul>
<li>Thread 存放在Thread子类的run方法中</li>
<li>Runable 存放在接口子类的run方法中</li>
</ul>
</li>
</ul>
<h2 id="1-6-多线程的安全问题"><a href="#1-6-多线程的安全问题" class="headerlink" title="1.6. 多线程的安全问题"></a>1.6. 多线程的安全问题</h2><p>出问题的原因</p>
<ul>
<li>当多条语句在操作同一个线程的共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程就参与进来执行，导致共享数据错误</li>
</ul>
<p>解决办法：利用”同步代码块”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line"> 需被同步的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的“对象”其实是一个同步锁，持有锁的线程可以在同步中执行，没有持有锁的线程即使获得CPU执行权，也进不去</li>
<li>如何找到“需同步的代码”？ –&gt; 看哪些语句在操作共享数据</li>
</ul>
<p>代码实现：解决售票问题的安全性,避免出现0，-1，-2号票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.ticket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketSafe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketSafe</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketSafe</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketSafe</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">50</span>;<span class="comment">//总票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">//同步代码块</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>); <span class="comment">//制造线程冻结</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;....&quot;</span> + ticket--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: no ticket&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0.</span>..<span class="number">.50</span></span><br><span class="line">Thread-<span class="number">0.</span>..<span class="number">.49</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.48</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.47</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.46</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.45</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.44</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.43</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.42</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.41</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.40</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.39</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.38</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.37</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.36</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.35</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.34</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.33</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.32</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.31</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.30</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.29</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.28</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.27</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.26</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.25</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.24</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.23</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.22</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.21</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.20</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.19</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.18</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.17</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.16</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.15</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.14</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.13</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.12</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.11</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.10</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.9</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.8</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.7</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.6</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.5</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.4</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.3</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.2</span></span><br><span class="line">Thread-<span class="number">3.</span>..<span class="number">.1</span></span><br><span class="line">Thread-<span class="number">3</span>: no ticket</span><br><span class="line">Thread-<span class="number">2</span>: no ticket</span><br><span class="line">Thread-<span class="number">1</span>: no ticket</span><br><span class="line">Thread-<span class="number">0</span>: no ticket</span><br></pre></td></tr></table></figure>

<p>同步的3个前提</p>
<ul>
<li>两个或两个以上的线程</li>
<li>必须多个线程使用同一个锁</li>
<li>必须保证同步中只能有一个线程在运行</li>
</ul>
<p>同步的优缺点</p>
<ul>
<li>优点：解决的多线的安全问题</li>
<li>缺点：多个线程需要判断锁，较为消耗资源</li>
</ul>
<h2 id="1-7-同步函数"><a href="#1-7-同步函数" class="headerlink" title="1.7. 同步函数"></a>1.7. 同步函数</h2><p>情景：两个储户分别向银行存钱300元，每次存100，存3次</p>
<p>分析：该线程是否有安全问题，如何找到问题并解决？</p>
<ul>
<li>明确哪些代码是多线程运行的代码</li>
<li>明确共享数据</li>
<li>明确多线程运行中哪些语句是操作共享数据的</li>
</ul>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day11.bank;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaveMoney</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Cus</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cus</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c);</span><br><span class="line">    </span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span>&#123; <span class="comment">//同步函数</span></span><br><span class="line">    count += n ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cus</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">  <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">     bank.add(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步的两种形式</p>
<ul>
<li>同步代码</li>
<li>同步函数</li>
</ul>
<p>静态同步函数</p>
<ul>
<li>同步锁是所属类的字节码文件对象</li>
</ul>
<h2 id="1-8-单例设计模式"><a href="#1-8-单例设计模式" class="headerlink" title="1.8. 单例设计模式"></a>1.8. 单例设计模式</h2><p><a href="https://leeeyou.github.io/2016/09/30/blog-2016-09-30-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">设计模式之单例模式</a></p>
<h2 id="1-9-死锁"><a href="#1-9-死锁" class="headerlink" title="1.9. 死锁"></a>1.9. 死锁</h2><p>出现原因：同步中嵌套同步</p>
<p>写一个死锁程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day11.deadLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeadLock2</span>(<span class="literal">false</span>));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeadLock2</span>(<span class="literal">true</span>));</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeadLock2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  DeadLock2(<span class="type">boolean</span> flag)&#123;</span><br><span class="line">    <span class="built_in">this</span>.flag = flag;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (LockObject.lo1) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;if lo1&quot;</span>);</span><br><span class="line">       <span class="keyword">synchronized</span> (LockObject.lo2) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;if lo2&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (LockObject.lo2) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;else lo2&quot;</span>);</span><br><span class="line">       <span class="keyword">synchronized</span> (LockObject.lo1) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;else lo1&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockObject</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">LockObject</span> <span class="variable">lo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockObject</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">LockObject</span> <span class="variable">lo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockObject</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-多线程进阶"><a href="#2-多线程进阶" class="headerlink" title="2. 多线程进阶"></a>2. 多线程进阶</h1><h2 id="2-1-线程间的通信"><a href="#2-1-线程间的通信" class="headerlink" title="2.1. 线程间的通信"></a>2.1. 线程间的通信</h2><p>情景：利用多线程，交替显示员工的姓名性别到控制台</p>
<p>可能出现的问题</p>
<ul>
<li>显示错误的问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12.threadCorrespond;</span><br><span class="line"><span class="comment">//未加入同步锁时的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputOutputDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Res</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Res</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Input</span>(r)).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Output</span>(r)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Res r ;</span><br><span class="line">	Input(Res r)&#123;</span><br><span class="line">		<span class="built_in">this</span>.r = r ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">				r.name = <span class="string">&quot;Maroon5&quot;</span>;</span><br><span class="line">				r.sex = <span class="string">&quot;male&quot;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				r.name = <span class="string">&quot;凯蒂佩里&quot;</span>;</span><br><span class="line">				r.sex = <span class="string">&quot;女女女&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			i = (i+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Output</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Res r ; </span><br><span class="line">	Output(Res r)&#123;</span><br><span class="line">		<span class="built_in">this</span>.r = r ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">		</span><br><span class="line">		System.out.println(r.name + <span class="string">&quot;...&quot;</span> + r.sex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Res</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>安全问题：加入同步锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12.threadCorrespond;</span><br><span class="line"><span class="comment">//加入同步锁，注意:要使用同一把锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputOutputDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Res</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Res</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Input</span>(r)).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Output</span>(r)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Res r ;</span><br><span class="line">	Input(Res r)&#123;</span><br><span class="line">		<span class="built_in">this</span>.r = r ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(r)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">					r.name = <span class="string">&quot;Maroon5&quot;</span>;</span><br><span class="line">					r.sex = <span class="string">&quot;male&quot;</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					r.name = <span class="string">&quot;凯蒂佩里&quot;</span>;</span><br><span class="line">					r.sex = <span class="string">&quot;女女女&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				i = (i+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Output</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Res r ; </span><br><span class="line">	Output(Res r)&#123;</span><br><span class="line">		<span class="built_in">this</span>.r = r ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (r) &#123;</span><br><span class="line">				System.out.println(r.name + <span class="string">&quot;...&quot;</span> + r.sex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Res</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	String sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>交替控制问题：加入等待唤醒机制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12.threadCorrespond;</span><br><span class="line"><span class="comment">//加入等待唤醒机制，让姓名、性别逐一赋值再输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputOutputDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Res</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Res</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Input</span>(r)).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Output</span>(r)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Res r ;</span><br><span class="line">	Input(Res r)&#123;</span><br><span class="line">		<span class="built_in">this</span>.r = r ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(r)&#123;</span><br><span class="line">				<span class="keyword">if</span>(r.flag)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						r.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">					r.name = <span class="string">&quot;Maroon5&quot;</span>;</span><br><span class="line">					r.sex = <span class="string">&quot;male&quot;</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					r.name = <span class="string">&quot;凯蒂佩里&quot;</span>;</span><br><span class="line">					r.sex = <span class="string">&quot;女女女&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				i = (i+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">				r.flag = <span class="literal">true</span>;</span><br><span class="line">				r.notify();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Output</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Res r ; </span><br><span class="line">	Output(Res r)&#123;</span><br><span class="line">		<span class="built_in">this</span>.r = r ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (r) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!r.flag)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						r.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(r.name + <span class="string">&quot;...&quot;</span> + r.sex);</span><br><span class="line">				r.flag = <span class="literal">false</span>;</span><br><span class="line">				r.notify();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Res</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	String sex;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12.threadCorrespond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputOutputDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Res</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Res</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Input</span>(r)).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Output</span>(r)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Res r;</span><br><span class="line"></span><br><span class="line">	Input(Res r) &#123;</span><br><span class="line">		<span class="built_in">this</span>.r = r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">				r.set(<span class="string">&quot;Maroon5&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				r.set(<span class="string">&quot;凯蒂佩里&quot;</span>, <span class="string">&quot;女女女&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			i = (i + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Output</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Res r;</span><br><span class="line"></span><br><span class="line">	Output(Res r) &#123;</span><br><span class="line">		<span class="built_in">this</span>.r = r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			r.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Res</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String sex;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String name, String sex)</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					wait();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">this</span>.name = name;</span><br><span class="line">			<span class="built_in">this</span>.sex = sex;</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			notify();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					wait();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(name + <span class="string">&quot;...&quot;</span> + sex);</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			notify();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>小结</p>
<ul>
<li>wait()</li>
<li>notify()</li>
<li>notifyAll()</li>
</ul>
<p>三个方法都使用在同步中</p>
<ul>
<li>原因：要对持有监视器（锁）的线程操作而监视器（锁）只在同步中出现</li>
<li>注意：等待和唤醒必须是对同一个锁</li>
<li>思考：为什么都定义在Object类中？因为监视器（锁）可以是任意对象</li>
</ul>
<h2 id="2-2-生产者消费者问题"><a href="#2-2-生产者消费者问题" class="headerlink" title="2.2. 生产者消费者问题"></a>2.2. 生产者消费者问题</h2><p>重复消费和未消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12.proCus;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这种方式解决&quot;生产者消费者&quot;只适用与两个线程的情况（一个生产一个消费）</span></span><br><span class="line"><span class="comment"> * 但是实际往往是多条线程同时工作，但将strat()注释去掉后，四条线程同时工作时就会出问题了：重复消费或者未消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kongbei</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerCustomerDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Res</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Res</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(r);</span><br><span class="line">		<span class="type">Customer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(r);</span><br><span class="line"></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="comment">//t3.start();</span></span><br><span class="line">		<span class="comment">//t4.start();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Res r;</span><br><span class="line"></span><br><span class="line">	Producer(Res r) &#123;</span><br><span class="line">		<span class="built_in">this</span>.r = r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		r.set(<span class="string">&quot;iPhone5s&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Res r;</span><br><span class="line"></span><br><span class="line">	Customer(Res r) &#123;</span><br><span class="line">		<span class="built_in">this</span>.r = r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		r.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Res</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">5588</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="built_in">this</span>.wait();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">this</span>.name = name + <span class="string">&quot;..编号&quot;</span> + count++;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;- 生产 -&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">this</span>.notify();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="built_in">this</span>.wait();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-消费-&quot;</span> + name);</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="built_in">this</span>.notify();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产和消费逐一交替运行（利用JDK1.5 新特性）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.produceCustomer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决了&quot;重复消费和未消费&quot;的问题(if改成while)，同时利用JDK5.0新特性Lock和Condition 处理了同步时上锁解锁和等待唤醒的的问题</span></span><br><span class="line"><span class="comment"> * Lock最大的一个特点是：&quot;可以支持多个相关的 Condition 对象&quot;，也就是说一把锁上可以绑定多个&quot;状态条件&quot;对象，详见API</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kongbei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerCustomerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Res2</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Res2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer2</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer2</span>(r);</span><br><span class="line">        <span class="type">Customer2</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer2</span>(r);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;T1 - &quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;T2 - &quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;T3 - &quot;</span>);</span><br><span class="line">        t4.setName(<span class="string">&quot;T4 - &quot;</span>);</span><br><span class="line">        t5.setName(<span class="string">&quot;T5 - &quot;</span>);</span><br><span class="line">        t6.setName(<span class="string">&quot;T6 - &quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.start();</span><br><span class="line">        t6.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Res2 r;</span><br><span class="line"></span><br><span class="line">    Producer2(Res2 r) &#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        r.set(<span class="string">&quot;iPhone5s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Res2 r;</span><br><span class="line"></span><br><span class="line">    Customer2(Res2 r) &#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        r.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Res2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; mList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">pCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">cCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock(); <span class="comment">//上锁</span></span><br><span class="line">            <span class="keyword">if</span> (mList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">remove</span> <span class="operator">=</span> mList.remove(<span class="number">0</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费了:&quot;</span> + remove);</span><br><span class="line">                pCondition.signal();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费光了:&quot;</span> + mList.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock(); <span class="comment">//上锁</span></span><br><span class="line">            <span class="keyword">if</span> (mList.size() &lt; <span class="number">50</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">product</span> <span class="operator">=</span> <span class="string">&quot;一个手机 &quot;</span>;</span><br><span class="line">                mList.add(product);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产了:&quot;</span> + product);</span><br><span class="line">                cCondition.signal();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产满了:&quot;</span> + mList.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pCondition.await();<span class="comment">//让消费线程等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-停止线程-彩蛋链接"><a href="#2-3-停止线程-彩蛋链接" class="headerlink" title="2.3. 停止线程(彩蛋链接)"></a>2.3. 停止线程(<a href="http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/">彩蛋链接</a>)</h2><p>情况分析</p>
<ul>
<li>只有一种情况，即run()方法结束</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12.stopThread;</span><br><span class="line"><span class="comment">//利用标记结束线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread01</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t1);</span><br><span class="line"></span><br><span class="line">		t.start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;..&quot;</span> + i);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">99</span>)&#123;</span><br><span class="line">				t1.changeFlag();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread01</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;..&quot;</span>+i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeFlag</span><span class="params">()</span> &#123;</span><br><span class="line">		flag = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特殊情况</p>
<ul>
<li>当线程处于冻结状态，即使设置了标记，线程也不会结束</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12.stopThread;</span><br><span class="line"><span class="comment">//这种情况下设置了标记，但是线程也不会终止，原因是线程处于冻结状态，无法读取到标记的最新情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread02</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread02</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread02</span>();</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t2);</span><br><span class="line"></span><br><span class="line">		t.start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">99</span>)&#123;</span><br><span class="line">				t2.changeFlag();<span class="comment">//修改了标记</span></span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;..&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread02</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait(); <span class="comment">//线程冻结导致无法读取标记的最新情况</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;..Exception&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;..run&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeFlag</span><span class="params">()</span> &#123;</span><br><span class="line">		flag = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这时需要对冻结状态进行清除，强制让其恢复到运行状态（其实就是获取CPU执行权），此时便可以操作标记来结束线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12.stopThread;</span><br><span class="line"><span class="comment">//利用interrupt方法清楚冻结状态，并终止线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread02</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread02</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread02</span>();</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t2);</span><br><span class="line"></span><br><span class="line">		t.start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">99</span>)&#123;</span><br><span class="line">				t.interrupt();<span class="comment">//清除冻结状态，强制让其恢复到运行状态（其实就是获取CPU执行权）</span></span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;..&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread02</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait(); <span class="comment">//线程冻结导致无法读取标记的最新情况</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;..Exception&quot;</span>);</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;..run&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeFlag</span><span class="params">()</span> &#123;</span><br><span class="line">		flag = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-守护线程"><a href="#2-4-守护线程" class="headerlink" title="2.4. 守护线程"></a>2.4. 守护线程</h2><p>使用情况：在启动线程前调用</p>
<p>特点</p>
<ul>
<li>开启后，和前台线程共同抢夺CPU执行权并运行</li>
<li>结束时，当所有前台线程都结束后，后台线程会自动结束（JAVA VM退出）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12.deamonThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeamonThreadDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">DeamonThread</span> <span class="variable">dt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeamonThread</span>();</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dt);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dt);</span><br><span class="line"></span><br><span class="line">		t1.setDaemon(<span class="literal">true</span>);<span class="comment">//设置为后台线程</span></span><br><span class="line">		t2.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;..&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeamonThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;..&quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-join"><a href="#2-5-join" class="headerlink" title="2.5. join()"></a>2.5. join()</h2><p>用途：临时加入线程</p>
<p>特点</p>
<ul>
<li>当A线程执行到了B线程的join()方法，A就会等待B线程都执行完，A才会执行</li>
<li>通俗一点说，这个方法就是用来抢夺CPU执行权</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12.deamonThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeamonThreadDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="type">DeamonThread</span> <span class="variable">dt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeamonThread</span>();</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dt);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dt);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		</span><br><span class="line">		t1.join();</span><br><span class="line">		</span><br><span class="line">		t2.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//t1.join();</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;..&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeamonThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;..&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-优先级以及yield"><a href="#2-6-优先级以及yield" class="headerlink" title="2.6. 优先级以及yield()"></a>2.6. 优先级以及yield()</h2><p>yield 暂停当前正在执行的线程对象，并执行其他线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LastProblem</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="type">LastThread</span> <span class="variable">dt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LastThread</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dt);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dt);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LastThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().toString() + <span class="string">&quot;..&quot;</span> + i);</span><br><span class="line">			Thread.<span class="keyword">yield</span>();<span class="comment">//交出CPU执行权</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之注解</title>
    <url>/iBlogWebsite/2016/01/08/2016/2016-01-08-Java%E4%B9%8B%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记，没加则等于没有某种标记，之后javac编译器、开发工具和其他程序可以用反射来了解你的类及各种元素上有无何种标记，看你有什么标记，就去干相应的事。要在源程序中应用某个注解，得先准备好了这个注解类，就像你要调用某个类，得先开发好这个类。</p>
<p>标记可以加在包、类、字段、方法、方法的参数以及局部变量上。查看java.lang包可看到JDK中提供的最基本的<a href="http://developer.android.com/reference/java/lang/annotation/Annotation.html">annotation</a><br><br><img src="../../../../images/githubpages/java_annotation.png" alt="java_annotation"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>JDK5.0中提供了注解的功能，允许开发者定义和使用自己的注解类型。该功能由一个定义注解类型的语法和描述一个注解声明的语法，读取注解的API，一个使用注解修饰的class文件和一个注解处理工具组成。</p>
<p>Annotation并不直接影响代码的语义，但是它可以被看做是程序的工具或者类库，会反过来对正在运行的程序语义有所影响。</p>
<p>Annotation可以通过 <strong>源文件、class文件或者在运行时</strong> 通过反射机制多种方式被读取。</p>
<h2 id="Java中的基本注解"><a href="#Java中的基本注解" class="headerlink" title="Java中的基本注解"></a>Java中的基本注解</h2><h3 id="Override注解"><a href="#Override注解" class="headerlink" title="@Override注解"></a>@Override注解</h3><p>Indicates that a method declaration is intended to override a method declaration in a superclass. If a method is annotated with this annotation type but does not override a superclass method, compilers are required to generate an error message.<br>表示一个方法声明打算重写超类中的另一个方法声明。如果方法利用此注释类型进行注解但没有重写超类方法，则编译器会生成一条错误消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(value=METHOD)</span></span><br><span class="line"><span class="meta">@Retention(value=SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override</span><br></pre></td></tr></table></figure>

<h3 id="Deprecated注解"><a href="#Deprecated注解" class="headerlink" title="@Deprecated注解"></a>@Deprecated注解</h3><p>A program element annotated @Deprecated is one that programmers are discouraged from using, typically because it is dangerous, or because a better alternative exists. Compilers warn when a deprecated program element is used or overridden in non-deprecated code.<br>用@Deprecated注释的程序元素，不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。在使用不被赞成的程序元素或在不被赞成的代码中执行重写时，编译器会发出警告。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(value=RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated</span><br></pre></td></tr></table></figure>
<h3 id="SuppressWarnings注解"><a href="#SuppressWarnings注解" class="headerlink" title="@SuppressWarnings注解"></a>@SuppressWarnings注解</h3><p>Indicates that the named compiler warnings should be suppressed in the annotated element (and in all program elements contained in the annotated element). Note that the set of warnings suppressed in a given element is a superset of the warnings suppressed in all containing elements. For example, if you annotate a class to suppress one warning and annotate a method to suppress another, both warnings will be suppressed in the method.<br>As a matter of style, programmers should always use this annotation on the most deeply nested element where it is effective. If you want to suppress a warning in a particular method, you should annotate that method rather than its class.<br>指示应该在注释元素（以及包含在该注释元素中的所有程序元素）中取消显示指定的编译器警告。注意，在给定元素中取消显示的警告集是所有包含元素中取消显示的警告的超集。例如，如果注释一个类来取消显示某个警告，同时注释一个方法来取消显示另一个警告，那么将在此方法中同时取消显示这两个警告。<br>根据风格不同，程序员应该始终在 <strong>最里层</strong> 的嵌套元素上使用此注释，在那里使用才有效。如果要在特定的方法中取消显示某个警告，则应该注释该方法而不是注释它的类。</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="变量、默认值、数组"><a href="#变量、默认值、数组" class="headerlink" title="变量、默认值、数组"></a>变量、默认值、数组</h3><p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。<br>在定义注解时，不能继承其他的注解或接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"><span class="comment">//如果注解中有一个名为value的属性，且只想设置value属性(即其他属性都采用默认值或者你只有一个value属性），那么可以省略value=部分</span></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">String[] favor() <span class="keyword">default</span> <span class="string">&quot;play&quot;</span>;</span><br><span class="line">MyEnum <span class="title function_">me</span><span class="params">()</span> <span class="keyword">default</span> MyEnum.shopping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置注解的作用范围"><a href="#设置注解的作用范围" class="headerlink" title="设置注解的作用范围"></a>设置注解的作用范围</h3><p>指示注释类型的注释要保留多久。如果注释类型声明中不存在Retention注释，则保留策略默认为 RetentionPolicy.CLASS。<strong>只有元注释类型直接用于注释时，Target 元注释才有效。如果元注释类型用作另一种注释类型的成员，则无效。</strong></p>
<p>注释保留策略。此枚举类型的常量描述保留注释的不同策略。它们与 Retention 元注释类型一起使用，以指定保留多长的注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">  <span class="comment">//如果注解中有一个名为value的属性，且只想设置value属性(即其他属性都采用默认值或者你只有一个value属性），那么可以省略value=部分</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">  String[] favor() <span class="keyword">default</span> <span class="string">&quot;play&quot;</span>;</span><br><span class="line">  MyEnum <span class="title function_">me</span><span class="params">()</span> <span class="keyword">default</span> MyEnum.shopping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Annotation的解析"><a href="#Annotation的解析" class="headerlink" title="Annotation的解析"></a>Annotation的解析</h2><h3 id="运行时Annotation解析"><a href="#运行时Annotation解析" class="headerlink" title="运行时Annotation解析"></a>运行时Annotation解析</h3><p>只有当@Retention(RetentionPolicy.RUNTIME)时，才能够利用反射获取到annotation的信息。<br>getAnnotation(AnnotationName.class) 表示得到该Target某个Annotation的信息，因为一个Target可以被多个Annotation修饰<br>getAnnotations() 则表示得到该Target所有Annotation<br>isAnnotationPresent(AnnotationName.class) 表示该Target是否被某个Annotation修饰  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leeeyou.annotation.cust.MyAnnotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by kongbei on 2014/12/21.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnnotationByReflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">TestMyAnnotation</span> <span class="variable">tma</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestMyAnnotation</span>();</span><br><span class="line">        Class&lt;TestMyAnnotation&gt; c = TestMyAnnotation.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;go&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">            <span class="comment">//获取该方法的MyAnnotation注解实例</span></span><br><span class="line">            <span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class);</span><br><span class="line">            method.invoke(tma, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;);</span><br><span class="line">            System.out.println(myAnnotation.name());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应go方法的注解如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;Beijing&quot;,name=&quot;Rose&quot;,favor = &#123;&quot;travel&quot;,&quot;thinking&quot;&#125;,me= MyEnum.read)</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;let&#x27;s go &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编译时Annotation解析"><a href="#编译时Annotation解析" class="headerlink" title="编译时Annotation解析"></a>编译时Annotation解析</h3><p>编译时Annotation指@Retention为CLASS的Annotation，由apt(Annotation Processing Tool)解析自动解析。需要做的​<br>a. 自定义类集成自AbstractProcessor<br>b. 重写其中的process函数<br>实际上apt(Annotation Processing Tool) 在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes(&#123; &quot;com.leeeyou.annotation.MyAnnotation&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnnotationByReflectCompile</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations,</span></span><br><span class="line"><span class="params">            RoundEnvironment roundEnv)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (TypeElement te : annotations) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(te)) &#123;</span><br><span class="line">                <span class="type">MyAnnotation</span> <span class="variable">ma</span> <span class="operator">=</span> element.getAnnotation(MyAnnotation.class);</span><br><span class="line">                map.put(element.getEnclosingElement().toString(), ma.value());</span><br><span class="line">                System.out.println(ma.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="限定注解的使用"><a href="#限定注解的使用" class="headerlink" title="限定注解的使用"></a>限定注解的使用</h3><p>限定注解使用@Target，指注释类型所适用的程序元素的种类。如果注释类型声明中不存在Target元注释，则声明的类型可以用在任一程序元素上。如果存在这样的元注释，则编译器强制实施指定的使用限制。例如，此元注释指示该声明类型是其自身，即元注释类型。它只能用在注释类型声明上。</p>
<h2 id="几个Android开源库Annotation原理简析"><a href="#几个Android开源库Annotation原理简析" class="headerlink" title="几个Android开源库Annotation原理简析"></a>几个Android开源库Annotation原理简析</h2><h3 id="Butter-Knife"><a href="#Butter-Knife" class="headerlink" title="Butter Knife"></a>Butter Knife</h3><p>调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InjectView(R.id.user)</span> EditText username;</span><br></pre></td></tr></table></figure>

<p>定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(CLASS)</span></span><br><span class="line"><span class="meta">@Target(FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InjectView &#123; <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>可看出Butter Knife的InjectView Annotation是编译时Annotation，并且只能用于修饰属性</p>
<p>原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> &#123;</span><br><span class="line">    Map&lt;TypeElement, ViewInjector&gt; targetClassMap = findAndParseTargets(env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TypeElement, ViewInjector&gt; entry : targetClassMap.entrySet()) &#123;</span><br><span class="line">        <span class="type">TypeElement</span> <span class="variable">typeElement</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">ViewInjector</span> <span class="variable">viewInjector</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">JavaFileObject</span> <span class="variable">jfo</span> <span class="operator">=</span> filer.createSourceFile(viewInjector.getFqcn(), typeElement);</span><br><span class="line">            <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> jfo.openWriter();</span><br><span class="line">            writer.write(viewInjector.brewJava());</span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            error(typeElement, <span class="string">&quot;Unable to write injector for type %s: %s&quot;</span>, typeElement, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ButterKnifeProcessor.java 的process方法如上，编译时，在此方法中过滤InjectView这个Annotation到targetClassMap后，会根据targetClassMap中元素生成不同的class文件到最终的APK中，然后在运行时调用ButterKnife.inject(x)函数时会到之前编译时生成的类中去找。</p>
<h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h3><p>调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GET(&quot;/users/&#123;username&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">getUser</span><span class="params">(<span class="meta">@Path(&quot;username&quot;)</span> String username)</span>;</span><br></pre></td></tr></table></figure>

<p>定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@RestMethod(&quot;GET&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GET &#123; String <span class="title function_">value</span><span class="params">()</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>从定义可看出 Retrofit 的 Get Annotation 是运行时 Annotation，并且只能用于修饰 Method  </p>
<p>原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseMethodAnnotations</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Annotation methodAnnotation : method.getAnnotations()) &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType = methodAnnotation.annotationType();</span><br><span class="line">    <span class="type">RestMethod</span> <span class="variable">methodInfo</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Annotation innerAnnotation : annotationType.getAnnotations()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (RestMethod.class == innerAnnotation.annotationType()) &#123;</span><br><span class="line">            methodInfo = (RestMethod) innerAnnotation;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RestMethodInfo.java 的parseMethodAnnotations方法如上，会检查每个方法的每个Annotation，看是否被RestMethod这个Annotation修饰的Annotation修饰，这个有点绕，就是是否被GET、DELETE、POST、PUT、HEAD、PATCH 这些Annotation修饰，然后得到Annotation信息，在对接口进行动态代理时会调用到这些Annotation信息从而完成调用。</p>
<h2 id="练习Annotation的基本使用"><a href="#练习Annotation的基本使用" class="headerlink" title="练习Annotation的基本使用"></a>练习Annotation的基本使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ItcastAnnotation(value = &quot;abc&quot;,annotationAttr=@MetaAnnotation(&quot;MetaAnnotation&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.runFinalizersOnExit(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(AnnotationTest.class.isAnnotationPresent(ItcastAnnotation.class))&#123;</span><br><span class="line">            <span class="comment">//用反射方式获得注解对应的实例对象后，再通过该对象调用属性对应的方法</span></span><br><span class="line">            <span class="type">ItcastAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> AnnotationTest.class.getAnnotation(ItcastAnnotation.class);</span><br><span class="line">            System.out.println(annotation.getClass().getName());</span><br><span class="line">            System.out.println(annotation.color());</span><br><span class="line">            System.out.println(annotation.value());</span><br><span class="line">            System.out.println(annotation.num().length);</span><br><span class="line">            System.out.println(annotation.lamp().nextLamp());</span><br><span class="line">            System.out.println(annotation.annotationAttr());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;HI&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习元注解"><a href="#练习元注解" class="headerlink" title="练习元注解"></a>练习元注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Retention元注解.RetetionPolicy.SOURCE、RetetionPolicy.CLASS、RetetionPolicy.RUNTIME;分别对应：java源文件--&gt;class文件--&gt;内存中的字节码。</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//@Target元注解默认值为任何元素，设置Target等于ElementType.METHOD，原来加在类上的注解就报错，改为用数组方式设置&#123;ElementType.METHOD,ElementType.TYPE&#125;</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ItcastAnnotation &#123;</span><br><span class="line">  String <span class="title function_">color</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;blue&quot;</span>; <span class="comment">//为属性指定缺省值</span></span><br><span class="line">  <span class="comment">//如果注解中有一个名为value的属性，且只想设置value属性(即其他属性都采用默认值或者你只有一个value属性），那么可以省略value=部分</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">int</span> [] num () <span class="keyword">default</span> &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;;<span class="comment">//数组类型的属性</span></span><br><span class="line">  EnumTest.TrrificLamp <span class="title function_">lamp</span><span class="params">()</span> <span class="keyword">default</span> EnumTest.TrrificLamp.RED;<span class="comment">//枚举类型的属性</span></span><br><span class="line">  MetaAnnotation <span class="title function_">annotationAttr</span><span class="params">()</span> <span class="keyword">default</span> <span class="meta">@MetaAnnotation(&quot;Meta&quot;)</span>;<span class="comment">//注解类型的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>参考文献：</p>
<ol>
<li><a href="http://www.trinea.cn/android/java-annotation-android-open-source-analysis/">http://www.trinea.cn/android/java-annotation-android-open-source-analysis/</a>  </li>
<li><a href="http://blog.csdn.net/kongbeily/article/details/8005422">http://blog.csdn.net/kongbeily/article/details/8005422</a>  </li>
<li><a href="http://www.cnblogs.com/mandroid/archive/2011/07/18/2109829.html">http://www.cnblogs.com/mandroid/archive/2011/07/18/2109829.html</a>  </li>
<li><a href="http://www.itzhai.com/java-based-notebook-annotation-annotation-introduction-and-use-custom-annotations.html">http://www.itzhai.com/java-based-notebook-annotation-annotation-introduction-and-use-custom-annotations.html</a>  </li>
<li><a href="http://docs.oracle.com/javase/6/docs/api/">http://docs.oracle.com/javase/6/docs/api/</a>  </li>
<li>关于反射的影响：<a href="http://stackoverflow.com/questions/435553/java-reflection-performance">http://stackoverflow.com/questions/435553/java-reflection-performance</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之集合框架</title>
    <url>/iBlogWebsite/2016/01/09/2016/2016-01-09-Java%E4%B9%8B%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>在Java中集合是非常重要的一大块，文章从Collection展开，再涉及到泛型和Map集合，大致结构如下：概述、Collection、泛型、Map集合、集合框架工具类。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>集合类：是存储对象最常用的一种方式</p>
<p>集合和数组的区别</p>
<ul>
<li>数组：可以存储基本数据类型和对象，但长度是固定的</li>
<li>集合：只能存储对象（可以是不同类型的对象），长度是可变的</li>
</ul>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>集合框架根接口</p>
<h2 id="共性方法"><a href="#共性方法" class="headerlink" title="共性方法"></a>共性方法</h2><p>新增：集合中存储的都是对象的引用(即在集合中新增一份地址)</p>
<ul>
<li>add(E e)</li>
<li>addAll(Collection&lt;? extends E&gt; c)</li>
</ul>
<p>删除</p>
<ul>
<li>remove(Object o)</li>
<li>removeAll(Collection&lt;?&gt; c)</li>
<li>clear() :清空集合</li>
</ul>
<p>判断</p>
<ul>
<li>contains(Object o)</li>
<li>containsAll(Collection&lt;?&gt; c)</li>
<li>isEmpty()</li>
</ul>
<p>取交集</p>
<ul>
<li>retainAll(Collection&lt;?&gt; c)</li>
</ul>
<h2 id="迭代器：Iterator"><a href="#迭代器：Iterator" class="headerlink" title="迭代器：Iterator"></a>迭代器：Iterator</h2><ul>
<li>hasNext()</li>
<li>next()</li>
<li>remove()</li>
</ul>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>凡是可以操作角标的方法都是该体系的特有方法</p>
<p>增加</p>
<ul>
<li>add(int index, E element)</li>
<li>addAll(int index, Collection&lt;? extends E&gt; c)</li>
</ul>
<p>删除</p>
<ul>
<li>remove(int index)</li>
</ul>
<p>修改</p>
<ul>
<li>set(int index, E element)</li>
</ul>
<p>查询</p>
<ul>
<li>get(int index)</li>
<li>listIterator() / listIterator(int index)  -&gt; List特有的迭代器，在迭代的过程中，可CRUD</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExerciseListIterator</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		method2();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		list.add(<span class="string">&quot;eclipse01&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;eclipse02&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;eclipse03&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">&quot;eclipse02&quot;</span>.equals(object))&#123;</span><br><span class="line">				list.remove(<span class="string">&quot;eclipse02&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(object);</span><br><span class="line">			<span class="comment">//list.add(&quot;eclipse04&quot;);//抛出运行时异常  java.util.ConcurrentModificationException</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(list); <span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		list.add(<span class="string">&quot;eclipse01&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;eclipse02&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;eclipse03&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">ListIterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.listIterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">&quot;eclipse02&quot;</span>.equals(object))&#123;</span><br><span class="line">				iterator.set(<span class="string">&quot;eclipse05&quot;</span>);<span class="comment">//修改元素的值</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">&quot;eclipse03&quot;</span>.equals(object))&#123;</span><br><span class="line">				iterator.add(<span class="string">&quot;eclipse04&quot;</span>);<span class="comment">//往集合中添加元素</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(list);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>subList(int fromIndex, int toIndex)</li>
</ul>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>底层使用数组数据结构。默认长度10，按1.5倍增长</p>
<p>特点：查询速度快，增删速度慢，线程不同步</p>
<p>练习</p>
<p>1、去除ArrayList中的重复元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="comment">//ArrayList去重复元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListTest01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		</span><br><span class="line">		al.add(<span class="string">&quot;server01&quot;</span>);</span><br><span class="line">		al.add(<span class="string">&quot;server02&quot;</span>);</span><br><span class="line">		al.add(<span class="string">&quot;server01&quot;</span>);</span><br><span class="line">		al.add(<span class="string">&quot;server02&quot;</span>);</span><br><span class="line">		al.add(<span class="string">&quot;server01&quot;</span>);</span><br><span class="line">		al.add(<span class="string">&quot;server03&quot;</span>);</span><br><span class="line">		al.add(<span class="string">&quot;server04&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;原集合：&quot;</span>+al);</span><br><span class="line">		System.out.println(<span class="string">&quot;去重复后的集合：&quot;</span>+singleElement(al));</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//最佳实践：在迭代时循环中next调用一次，就要hasNext()判断一次</span></span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> al.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			System.out.println(it.next()+<span class="string">&quot;...&quot;</span>+it.next()); <span class="comment">//可能抛出NoSuchElementException异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title function_">singleElement</span><span class="params">(ArrayList al)</span>&#123;</span><br><span class="line">		<span class="type">ArrayList</span> <span class="variable">newAl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;al.size();i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!newAl.contains(al.get(i)))&#123;</span><br><span class="line">				newAl.add(al.get(i));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> newAl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、将自定义对象作为元素存入到ArrayList集合中，并去除重复元素。重要结论：List集合判断元素是否相同，依据是元素的equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">//将自定义对象作为元素存入到ArrayList集合中，并去除重复元素</span></span><br><span class="line"><span class="comment">//将姓名和年龄相同看作是同一元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要结论：List集合判断元素是否相同，依据是元素的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListTest02</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		</span><br><span class="line">		al.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi01&quot;</span>,<span class="number">22</span>));</span><br><span class="line">		al.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi02&quot;</span>,<span class="number">20</span>));</span><br><span class="line">		al.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi03&quot;</span>,<span class="number">24</span>));</span><br><span class="line">		al.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi04&quot;</span>,<span class="number">25</span>));</span><br><span class="line">		al.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi04&quot;</span>,<span class="number">25</span>));</span><br><span class="line">		al.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi05&quot;</span>,<span class="number">28</span>));</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;原集合元素：&quot;</span>);</span><br><span class="line">		sop(al);</span><br><span class="line">		System.out.println(<span class="string">&quot;去重复后集合元素：&quot;</span>);</span><br><span class="line">		sop(singleElement(al));</span><br><span class="line">		</span><br><span class="line">		al.remove(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi05&quot;</span>,<span class="number">28</span>)); <span class="comment">//如注释掉Person中的equals方法，那么这样remove是不能成功的</span></span><br><span class="line">		sop(al);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title function_">singleElement</span><span class="params">(ArrayList al)</span> &#123;</span><br><span class="line">		<span class="type">ArrayList</span> <span class="variable">newAl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; al.size(); i++) &#123;</span><br><span class="line">			<span class="comment">//引自 API: (o==null ? e==null : o.equals(e)) </span></span><br><span class="line">			<span class="keyword">if</span> (!newAl.contains(al.get(i))) &#123; <span class="comment">//会调用对象的equals方法进行比较</span></span><br><span class="line">				newAl.add(al.get(i));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> newAl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sop</span><span class="params">(ArrayList al)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;al.size();i++)&#123;</span><br><span class="line">			<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)al.get(i);</span><br><span class="line">			System.out.print(person.getName()+<span class="string">&quot;...&quot;</span>+person.getAge()+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	Person(String name, <span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//覆写equals方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)obj;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name.equals(p.getName())&amp;&amp;<span class="built_in">this</span>.age==p.getAge();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>底层使用链表数据结构。</p>
<p>特点：增删速度快，查询速度慢</p>
<p>特有方法</p>
<ul>
<li>addFirst(E e)</li>
<li>addLast(E e)</li>
<li>getFirst()</li>
<li>getLast()</li>
<li>removeFirst()</li>
<li>removeLast()</li>
</ul>
<p>但是如果集合中没有元素，会抛出NoSuchElementException，从JDK1.6开始出现了替代方法。集合中没有元素，则返回null。</p>
<ul>
<li>offerFirst(E e)</li>
<li>offerLast(E e)</li>
<li>peekFirst()</li>
<li>peekLast()</li>
<li>pollFirst()</li>
<li>pollLast()</li>
</ul>
<p>练习：使用LinkedList模拟堆栈或队列数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="comment">//LinkedList模拟队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">DuiLie</span> <span class="variable">dl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DuiLie</span>();</span><br><span class="line">		dl.myAdd(<span class="string">&quot;duilie01&quot;</span>);</span><br><span class="line">		dl.myAdd(<span class="string">&quot;duilie02&quot;</span>);</span><br><span class="line">		dl.myAdd(<span class="string">&quot;duilie03&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(dl.myGet());</span><br><span class="line">		System.out.println(dl.myGet());</span><br><span class="line">		System.out.println(dl.myGet());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;队列是否为空：&quot;</span>+dl.isNull());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DuiLie</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> LinkedList linkedList ; </span><br><span class="line">	DuiLie()&#123;</span><br><span class="line">		<span class="built_in">this</span>.linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myAdd</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">		linkedList.add(obj);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">myGet</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> linkedList.removeFirst();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> linkedList.isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h3><p>底层使用数组数据结构。除了线程同步外，其他内容同ArrayList。</p>
<p>特点：查询速度快，增删速度慢，线程同步。</p>
<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>元素是无序的，元素不可能重复。”无序”指存入和取出的顺序不一定一致。</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层数据结构是哈希表,线程不同步</p>
<p>HashSet是如何保证元素唯一性的？</p>
<ul>
<li>是通过元素的两个方法：hashCode和equals</li>
<li>如果元素的HashCode值相同，才回判断equals是否为true</li>
<li>如果元素的HashCode值不同，不会调用equals</li>
</ul>
<p>练习：将自定义对象作为元素存入到HashSet集合中，并去除重复元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="comment">//将自定义对象作为元素存入到ArrayList集合中，并去除重复元素</span></span><br><span class="line"><span class="comment">//将姓名和年龄相同的人看作是同一人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">HashSet</span> <span class="variable">hs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi01&quot;</span>,<span class="number">20</span>));</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi02&quot;</span>,<span class="number">23</span>));</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi02&quot;</span>,<span class="number">23</span>));<span class="comment">//</span></span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi03&quot;</span>,<span class="number">22</span>));</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi04&quot;</span>,<span class="number">24</span>));</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi04&quot;</span>,<span class="number">24</span>));<span class="comment">//</span></span><br><span class="line">		</span><br><span class="line">		sop(hs); <span class="comment">//没有覆写hashCode和equals方法时，并没有去重的效果</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sop</span><span class="params">(HashSet hs)</span>&#123;</span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> hs.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)it.next();</span><br><span class="line">			System.out.println(p.getName()+<span class="string">&quot;...&quot;</span>+p.getAge());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//覆写hashCode和equals方法</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name.hashCode()+age*<span class="number">35</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)obj;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name.equals(p.getName())&amp;&amp;<span class="built_in">this</span>.age==p.getAge();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层数据结构是二叉树</p>
<p>特点：默认对集合中元素排序</p>
<p>TreeSet是如何保证元素唯一性的？</p>
<ul>
<li>compare方法 return 0 表示是重复元素</li>
<li>compareTo方法 return 0 表示是重复元素</li>
</ul>
<p>练习：往TreeSet集合中存储自定义对象学生，按照学生的年龄进行排序。在排序时，当主要条件相同时，一定要判断次要条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day15;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="comment">//往TreeSet集合中存储自定义对象学生，按照学生的年龄进行排序,年龄相同按姓名排</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">TreeSet</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">		</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi01&quot;</span>,<span class="number">20</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi02&quot;</span>,<span class="number">22</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi03&quot;</span>,<span class="number">18</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi003&quot;</span>,<span class="number">18</span>));<span class="comment">//</span></span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi04&quot;</span>,<span class="number">25</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi05&quot;</span>,<span class="number">30</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi05&quot;</span>,<span class="number">30</span>));<span class="comment">//</span></span><br><span class="line">		</span><br><span class="line">		sop(ts);<span class="comment">//在Student类未实现Comparable接口时，往TreeSet中存入对象抛出java.lang.ClassCastException</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sop</span><span class="params">(TreeSet hs)</span>&#123;</span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> hs.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			<span class="type">Student</span> <span class="variable">p</span> <span class="operator">=</span> (Student)it.next();</span><br><span class="line">			System.out.println(p.getName()+<span class="string">&quot;...&quot;</span>+p.getAge());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123; <span class="comment">//该接口强制让学生类具备比较性,此时再将对象插入到TreeSet集合中时，TreeSet集合就知道按照什么条件排序了</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Student))&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student)o;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.age &gt; s.getAge())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.age == s.getAge())&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(s.getName());<span class="comment">//年龄相同的情况下比较姓名</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序方式</p>
<ul>
<li><p>第一种：让元素自身具备比较性。要求元素实现Comparable接口，并覆盖compareTo方法，这种方式也成为自然顺序或默认顺序</p>
</li>
<li><p>第二种：让容器自身具备比较性。在容器初始化时(构造函数中)就让其具有比较方式，具体做法：定义一个类(作为比较器)，实现Comparator接口，并覆盖compare方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day15;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让TreeSet容器自身具备比较性，还是以学生为例，姓名年龄都相同的看作是同一人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest02</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">TreeSet</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">MyComparator</span>()); <span class="comment">//让容器自身具备比较性</span></span><br><span class="line">		</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi01&quot;</span>,<span class="number">20</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi02&quot;</span>,<span class="number">22</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi02&quot;</span>,<span class="number">25</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi03&quot;</span>,<span class="number">18</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi003&quot;</span>,<span class="number">18</span>));<span class="comment">//</span></span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi04&quot;</span>,<span class="number">25</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi05&quot;</span>,<span class="number">30</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi05&quot;</span>,<span class="number">30</span>));<span class="comment">//</span></span><br><span class="line">		</span><br><span class="line">		sop(ts);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sop</span><span class="params">(TreeSet hs)</span>&#123;</span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> hs.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			<span class="type">Student</span> <span class="variable">p</span> <span class="operator">=</span> (Student)it.next();</span><br><span class="line">			System.out.println(p.getName()+<span class="string">&quot;...&quot;</span>+p.getAge());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让元素自身具备比较性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123; <span class="comment">//默认按年龄排序，年龄相同再比较姓名</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Student))&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student)o;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.age &gt; s.getAge())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.age == s.getAge())&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(s.getName());<span class="comment">//年龄相同的情况下比较姓名</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student)o1;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student)o2;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span>  s1.getName().compareTo(s2.getName());</span><br><span class="line">		<span class="keyword">if</span>(num == <span class="number">0</span> )&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(s1.getAge()).compareTo(<span class="keyword">new</span> <span class="title class_">Integer</span>(s2.getAge()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当两种排序都存在时，以”比较器”为主，推荐采用”比较器”的方式开发编程。</p>
<h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><h2 id="共性方法-1"><a href="#共性方法-1" class="headerlink" title="共性方法"></a>共性方法</h2><p>添加</p>
<ul>
<li>put(K key, V value)，返回前一个与key关联的值或者null</li>
<li>putAll(Map&lt;? extends K,? extends V&gt; m) </li>
</ul>
<p>删除</p>
<ul>
<li>remove(Object key)</li>
<li>clear()</li>
</ul>
<p>判断</p>
<ul>
<li>containsKey(Object key)</li>
<li>containsValue(Object value)</li>
</ul>
<p>获取</p>
<ul>
<li>get(Object key)</li>
<li>size()</li>
<li>values()</li>
<li>entrySet() -&gt; 将Map集合中的映射关系取出存入到Map.Entry中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="comment">//将学生对象存入到Map集合中，要求：同姓名和年龄的看作同一人，先按姓名排再按年龄排</span></span><br><span class="line"><span class="comment">//entrySet 练习</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		TreeMap&lt;Student, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Student, String&gt;(<span class="keyword">new</span> <span class="title class_">myCompare</span>());</span><br><span class="line">		map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi044&quot;</span>, <span class="number">22</span>), <span class="string">&quot;wuhan&quot;</span>);</span><br><span class="line">		map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi02&quot;</span>, <span class="number">26</span>), <span class="string">&quot;shenzhen&quot;</span>);</span><br><span class="line">		map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi03&quot;</span>, <span class="number">20</span>), <span class="string">&quot;chengdu&quot;</span>);</span><br><span class="line">		map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi04&quot;</span>, <span class="number">29</span>), <span class="string">&quot;wuhan&quot;</span>);</span><br><span class="line">		map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi01&quot;</span>, <span class="number">23</span>), <span class="string">&quot;changsha&quot;</span>);</span><br><span class="line">		map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi01&quot;</span>, <span class="number">23</span>), <span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">		map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi04&quot;</span>, <span class="number">22</span>), <span class="string">&quot;wuhan&quot;</span>);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		Set&lt;Map.Entry&lt;Student, String&gt;&gt; set = map.entrySet();</span><br><span class="line"></span><br><span class="line">		Iterator&lt;Map.Entry&lt;Student, String&gt;&gt; it = set.iterator();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Map.Entry&lt;Student, String&gt; ss = it.next();</span><br><span class="line">			<span class="type">Student</span> <span class="variable">key</span> <span class="operator">=</span> ss.getKey();</span><br><span class="line">			<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> ss.getValue();</span><br><span class="line">			System.out.println(key.getName() + <span class="string">&quot;...&quot;</span> + key.getAge() + <span class="string">&quot;...&quot;</span> + value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	Student(String name, <span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// hashCode和equals保证元素的唯一性</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name.hashCode() + age * <span class="number">37</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Student)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>(<span class="string">&quot;类型不匹配&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name.equals(s.getName()) &amp;&amp; <span class="built_in">this</span>.age == s.getAge();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myCompare</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt;&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">		<span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(o1.getAge()).compareTo(<span class="keyword">new</span> <span class="title class_">Integer</span>(o2.getAge()));</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>keySet() -&gt; 将map中所有的键存入到Set集合中，再迭代取出所有键，然后利用get()方法获取每一个值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">//KeySet练习</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeySetTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">		map.put(<span class="string">&quot;A001&quot;</span>, <span class="string">&quot;zhangsan001&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;A002&quot;</span>, <span class="string">&quot;zhangsan002&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;A003&quot;</span>, <span class="string">&quot;zhangsan003&quot;</span>);</span><br><span class="line">		map.put(<span class="string">&quot;A004&quot;</span>, <span class="string">&quot;zhangsan004&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		Set&lt;String&gt; set = map.keySet();</span><br><span class="line">		</span><br><span class="line">		Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">			System.out.println(<span class="string">&quot;key:&quot;</span>+key+<span class="string">&quot;...&quot;</span>+<span class="string">&quot;value:&quot;</span>+map.get(key));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="Hashtable类"></a>Hashtable类</h2><p>底层数据结构哈希表，不可以存入null键null值，线程同步，jdk1.0，效率低</p>
<h2 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h2><p>底层数据结构哈希表，可以存入null键null值，线程不同步，jdk1.2，效率高</p>
<h2 id="TreeMap类"><a href="#TreeMap类" class="headerlink" title="TreeMap类"></a>TreeMap类</h2><p>底层数据结构是二叉树，线程不同步，可用于给Map集合中的键排序</p>
<p>练习：获取字符串中字母出现的次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="comment">//获取字符串中字母出现的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapTest2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		CountChars(<span class="string">&quot;aa.?abccDS43/.][&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">CountChars</span><span class="params">(String str)</span>&#123;</span><br><span class="line">		<span class="type">char</span> [] ch = str.toCharArray();</span><br><span class="line">		TreeMap&lt;String,Integer&gt; tm = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;String,Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ;i&lt;ch.length;i++)&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span> ; </span><br><span class="line">			<span class="type">char</span> <span class="variable">cha</span> <span class="operator">=</span> ch[i];</span><br><span class="line">			<span class="keyword">if</span>(cha&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; cha &lt;= <span class="string">&#x27;z&#x27;</span> || cha&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; cha&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> String.valueOf(cha);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(tm.get(c)!=<span class="literal">null</span>)</span><br><span class="line">					value = tm.get(c)+<span class="number">1</span>;</span><br><span class="line">				</span><br><span class="line">				tm.put(c, value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(tm);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合框架工具类"><a href="#集合框架工具类" class="headerlink" title="集合框架工具类"></a>集合框架工具类</h1><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>排序</p>
<ul>
<li><p>sort(List<T> list)</p>
</li>
<li><p>sort(List<T> list, Comparator&lt;? super T&gt; c)</p>
</li>
</ul>
<p>获取最大值</p>
<ul>
<li><p>max(Collection&lt;? extends T&gt; coll)</p>
</li>
<li><p>max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</p>
</li>
</ul>
<p>二分查找</p>
<ul>
<li><p>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</p>
</li>
<li><p>binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c)</p>
</li>
</ul>
<p>替换反转</p>
<ul>
<li><p>fill(List&lt;? super T&gt; list, T obj)</p>
</li>
<li><p>replaceAll(List<T> list, T oldVal, T newVal)</p>
</li>
<li><p>reverse(List&lt;?&gt; list)</p>
</li>
<li><p>reverseOrder()</p>
</li>
<li><p>reverseOrder(Comparator<T> cmp)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day17;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reverseOrderTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		TreeSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;(Collections.reverseOrder(<span class="keyword">new</span> <span class="title class_">myCompare</span>()));<span class="comment">//调用Collections.reverseOrder()使其按长度从长到短排序</span></span><br><span class="line">		</span><br><span class="line">		set.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;iejl&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;bbida&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;bda&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;pom&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		sop(set);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sop</span><span class="params">(TreeSet&lt;String&gt; set)</span> &#123;</span><br><span class="line">		Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">			System.out.println(iterator.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myCompare</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(o1.length()).compareTo(<span class="keyword">new</span> <span class="title class_">Integer</span>(o2.length())); <span class="comment">//默认按字符串长度排序</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>swap(List&lt;?&gt; list, int i, int j)</li>
</ul>
<p>线程同步</p>
<ul>
<li>synchronizedList(List<T> list)</li>
</ul>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>用于操作数组的工具类</p>
<ul>
<li>asList(T… a) 将数组变成集合后，不可以使用集合的增删方法</li>
<li>toString(byte[] a)</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之绘图基础Path类</title>
    <url>/iBlogWebsite/2016/01/11/2016/2016-01-11-Android%E4%B9%8B%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80Path%E7%B1%BB/</url>
    <content><![CDATA[<p>先上一段Andorid官网关于Path的解释：</p>
<p>The Path class encapsulates compound (multiple contour) geometric paths consisting of straight line segments, quadratic curves, and cubic curves. It can be drawn with canvas.drawPath(path, paint), either filled or stroked (based on the paint’s Style), or it can be used for clipping or to draw text on a path.</p>
<p>Path类封装了复合(多个轮廓)几何路径组成的直线段,二次曲线,立方曲线。它可以通过canvas.drawPath()带上填充或描边（基于涂料的风格）的效果被绘制，也可用于剪切或在路径上绘制文本。总而言之就是：Path类可以画线。至于怎么画，加什么效果，就是接下来的事情了。</p>
<h2 id="利用Path画基本形状"><a href="#利用Path画基本形状" class="headerlink" title="利用Path画基本形状"></a>利用Path画基本形状</h2><p>先上效果图：<br><img src="../../../../images/githubpages/path_%E5%9F%BA%E6%9C%AC%E5%BD%A2%E7%8A%B6.png" alt="path_基本形状.png"></p>
<p>代码实现如下  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.leeyou.demopath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.graphics.CornerPathEffect;</span><br><span class="line"><span class="keyword">import</span> android.graphics.LinearGradient;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Path;</span><br><span class="line"><span class="keyword">import</span> android.graphics.PathEffect;</span><br><span class="line"><span class="keyword">import</span> android.graphics.RectF;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Shader;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参考：http://www.cnblogs.com/tt_mc/archive/2012/12/07/2807518.html</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPaintView</span> <span class="keyword">extends</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPaintView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPaintView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPaintView</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyleAttr)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PathEffect[] effects = <span class="keyword">new</span> <span class="title class_">PathEffect</span>[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        canvas.drawColor(Color.WHITE);</span><br><span class="line"></span><br><span class="line">        <span class="type">Paint</span> <span class="variable">paint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">        paint.setAntiAlias(<span class="literal">true</span>);</span><br><span class="line">        paint.setColor(Color.RED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 画笔样式分三种：</span></span><br><span class="line"><span class="comment">        * 1.Paint.Style.STROKE：描边</span></span><br><span class="line"><span class="comment">        * 2.Paint.Style.FILL_AND_STROKE：描边并填充</span></span><br><span class="line"><span class="comment">        * 3.Paint.Style.FILL：填充</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 设置描边的粗细，单位：像素px</span></span><br><span class="line"><span class="comment">         * 注意：当setStrokeWidth(0)的时候描边宽度并不为0而是只占一个像素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        paint.setStrokeWidth(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        canvas.drawCircle(<span class="number">140</span>, <span class="number">140</span>, <span class="number">100</span>, paint);<span class="comment">//圆形</span></span><br><span class="line"></span><br><span class="line">        canvas.drawRect(<span class="number">50</span>, <span class="number">270</span>, <span class="number">150</span>, <span class="number">370</span>, paint);<span class="comment">//正方形</span></span><br><span class="line"></span><br><span class="line">        canvas.drawRect(<span class="number">50</span>, <span class="number">400</span>, <span class="number">250</span>, <span class="number">450</span>, paint);<span class="comment">//长方形</span></span><br><span class="line"></span><br><span class="line">        canvas.drawOval(<span class="keyword">new</span> <span class="title class_">RectF</span>(<span class="number">50</span>, <span class="number">470</span>, <span class="number">250</span>, <span class="number">570</span>), paint);<span class="comment">//画椭圆</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//画三角形</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>();</span><br><span class="line">        path.moveTo(<span class="number">50</span>, <span class="number">800</span>);</span><br><span class="line">        path.lineTo(<span class="number">250</span>, <span class="number">800</span>);</span><br><span class="line">        path.lineTo(<span class="number">150</span>, <span class="number">600</span>);</span><br><span class="line">        path.close();</span><br><span class="line">        canvas.drawPath(path, paint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//画梯形</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>();</span><br><span class="line">        path2.moveTo(<span class="number">50</span>, <span class="number">1100</span>);</span><br><span class="line">        path2.lineTo(<span class="number">250</span>, <span class="number">1100</span>);</span><br><span class="line">        path2.lineTo(<span class="number">200</span>, <span class="number">900</span>);</span><br><span class="line">        path2.lineTo(<span class="number">100</span>, <span class="number">900</span>);</span><br><span class="line">        path2.close();</span><br><span class="line">        canvas.drawPath(path2, paint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">////////////////////////////////////////第二列</span></span><br><span class="line">        paint.setColor(Color.BLUE);</span><br><span class="line">        paint.setStyle(Paint.Style.FILL);</span><br><span class="line"></span><br><span class="line">        canvas.drawCircle(<span class="number">390</span>, <span class="number">140</span>, <span class="number">100</span>, paint);<span class="comment">//圆形</span></span><br><span class="line"></span><br><span class="line">        canvas.drawRect(<span class="number">300</span>, <span class="number">270</span>, <span class="number">400</span>, <span class="number">370</span>, paint);<span class="comment">//正方形</span></span><br><span class="line"></span><br><span class="line">        canvas.drawRect(<span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>, <span class="number">450</span>, paint);<span class="comment">//长方形</span></span><br><span class="line"></span><br><span class="line">        canvas.drawOval(<span class="keyword">new</span> <span class="title class_">RectF</span>(<span class="number">300</span>, <span class="number">470</span>, <span class="number">500</span>, <span class="number">570</span>), paint);<span class="comment">//画椭圆</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//画三角形</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>();</span><br><span class="line">        path3.moveTo(<span class="number">300</span>, <span class="number">800</span>);</span><br><span class="line">        path3.lineTo(<span class="number">500</span>, <span class="number">800</span>);</span><br><span class="line">        path3.lineTo(<span class="number">400</span>, <span class="number">600</span>);</span><br><span class="line"><span class="comment">//        path3.close();  // paint.setStyle(Paint.Style.FILL); 可以不设置close</span></span><br><span class="line">        canvas.drawPath(path3, paint);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>();</span><br><span class="line">        path4.moveTo(<span class="number">300</span>, <span class="number">1100</span>);</span><br><span class="line">        path4.lineTo(<span class="number">500</span>, <span class="number">1100</span>);</span><br><span class="line">        path4.lineTo(<span class="number">450</span>, <span class="number">900</span>);</span><br><span class="line">        path4.lineTo(<span class="number">350</span>, <span class="number">900</span>);</span><br><span class="line"><span class="comment">//        path4.close();  // paint.setStyle(Paint.Style.FILL); 可以不设置close</span></span><br><span class="line">        canvas.drawPath(path4, paint);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        ////////////////////////////////////////第三列</span></span><br><span class="line"><span class="comment">//        //参数一为渐变起初点坐标x位置，参数二为y轴位置，参数三和四分辨对应渐变终点</span></span><br><span class="line"><span class="comment">//        //其中参数new int[]&#123;startColor, midleColor,endColor&#125;是参与渐变效果的颜色集合</span></span><br><span class="line"><span class="comment">//        //其中参数new float[]&#123;0 , 0.5f, 1.0f&#125;是定义每个颜色处于的渐变相对位置，这个参数可以为null，如果为null表示所有的颜色按顺序均匀的分布</span></span><br><span class="line">        <span class="type">Shader</span> <span class="variable">mShader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinearGradient</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;Color.RED, Color.GREEN, Color.BLUE&#125;, <span class="literal">null</span>, Shader.TileMode.REPEAT);</span><br><span class="line"><span class="comment">//        Shader mShader = new LinearGradient(0, 0, 100, 100, new int[]&#123;Color.RED, Color.GREEN, Color.BLUE&#125;, new float[]&#123;0, 0.5f, 1.0f&#125;, Shader.TileMode.REPEAT);</span></span><br><span class="line">        paint.setShader(mShader);</span><br><span class="line"></span><br><span class="line">        canvas.drawCircle(<span class="number">640</span>, <span class="number">140</span>, <span class="number">100</span>, paint);<span class="comment">//圆形</span></span><br><span class="line"></span><br><span class="line">        canvas.drawRect(<span class="number">550</span>, <span class="number">270</span>, <span class="number">650</span>, <span class="number">370</span>, paint);<span class="comment">//正方形</span></span><br><span class="line"></span><br><span class="line">        canvas.drawRect(<span class="number">550</span>, <span class="number">400</span>, <span class="number">750</span>, <span class="number">450</span>, paint);<span class="comment">//长方形</span></span><br><span class="line"></span><br><span class="line">        canvas.drawOval(<span class="keyword">new</span> <span class="title class_">RectF</span>(<span class="number">550</span>, <span class="number">470</span>, <span class="number">750</span>, <span class="number">570</span>), paint);<span class="comment">//画椭圆</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//画三角形</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>();</span><br><span class="line">        path5.moveTo(<span class="number">550</span>, <span class="number">800</span>);</span><br><span class="line">        path5.lineTo(<span class="number">750</span>, <span class="number">800</span>);</span><br><span class="line">        path5.lineTo(<span class="number">650</span>, <span class="number">600</span>);</span><br><span class="line">        canvas.drawPath(path5, paint);</span><br><span class="line"></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>();</span><br><span class="line">        path6.moveTo(<span class="number">550</span>, <span class="number">1100</span>);</span><br><span class="line">        path6.lineTo(<span class="number">750</span>, <span class="number">1100</span>);</span><br><span class="line">        path6.lineTo(<span class="number">700</span>, <span class="number">900</span>);</span><br><span class="line">        path6.lineTo(<span class="number">600</span>, <span class="number">900</span>);</span><br><span class="line">        canvas.drawPath(path6, paint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">////////////////////////////////////////第四列</span></span><br><span class="line">        paint.setTextSize(<span class="number">70</span>);</span><br><span class="line"></span><br><span class="line">        canvas.drawText(<span class="string">&quot;圆形&quot;</span>, <span class="number">800</span>, <span class="number">140</span>, paint);</span><br><span class="line">        canvas.drawText(<span class="string">&quot;正方形&quot;</span>, <span class="number">800</span>, <span class="number">340</span>, paint);</span><br><span class="line">        canvas.drawText(<span class="string">&quot;长方形&quot;</span>, <span class="number">800</span>, <span class="number">450</span>, paint);</span><br><span class="line">        canvas.drawText(<span class="string">&quot;椭圆&quot;</span>, <span class="number">800</span>, <span class="number">540</span>, paint);</span><br><span class="line">        canvas.drawText(<span class="string">&quot;三角形&quot;</span>, <span class="number">800</span>, <span class="number">700</span>, paint);</span><br><span class="line">        canvas.drawText(<span class="string">&quot;梯形&quot;</span>, <span class="number">800</span>, <span class="number">1000</span>, paint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">////////////////////////////////////////画折线</span></span><br><span class="line">        <span class="type">Paint</span> <span class="variable">paint8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">        paint8.setStyle(Paint.Style.STROKE);</span><br><span class="line">        paint8.setStrokeWidth(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] colors;</span><br><span class="line"></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>();</span><br><span class="line">        path7.moveTo(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">            path7.lineTo(i * <span class="number">900</span>, (<span class="type">float</span>) (Math.random() * <span class="number">60</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        colors = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW, Color.BLACK, Color.MAGENTA, Color.CYAN&#125;;</span><br><span class="line"></span><br><span class="line">        effects[<span class="number">0</span>] = <span class="literal">null</span>;<span class="comment">// 不实用路径</span></span><br><span class="line"></span><br><span class="line">        effects[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">CornerPathEffect</span>(<span class="number">10</span>);<span class="comment">//使用CornerPathEffect路径效果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; effects.length; i++) &#123;</span><br><span class="line">            paint8.setPathEffect(effects[i]);</span><br><span class="line">            paint8.setColor(colors[i]);</span><br><span class="line">            canvas.drawPath(path7, paint8);</span><br><span class="line">            canvas.translate(<span class="number">0</span>, <span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="利用Path画折线"><a href="#利用Path画折线" class="headerlink" title="利用Path画折线"></a>利用Path画折线</h2><p>Android为路径绘制提供了<a href="http://developer.android.com/reference/android/graphics/PathEffect.html">PathEffect</a>来定义绘制效果，画折线利用了PathEffect子类的各种效果：<br><a href="http://developer.android.com/reference/android/graphics/CornerPathEffect.html">CornerPathEffect</a><br><a href="http://developer.android.com/reference/android/graphics/DiscretePathEffect.html">DiscretePathEffect</a><br><a href="http://developer.android.com/reference/android/graphics/DashPathEffect.html">DashPathEffect</a><br><a href="http://developer.android.com/reference/android/graphics/PathDashPathEffect.html">PathDashPathEffect</a><br><a href="http://developer.android.com/reference/android/graphics/ComposePathEffect.html">ComposePathEffect</a>  </p>
<p>效果图如下，其中第一条线是默认效果，没有设置任何PathEffect：<br><img src="../../../../images/githubpages/path_%E6%8A%98%E7%BA%BF.png" alt="path_折线.png"></p>
<p>代码实现如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.leeyou.demopath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.graphics.ComposePathEffect;</span><br><span class="line"><span class="keyword">import</span> android.graphics.CornerPathEffect;</span><br><span class="line"><span class="keyword">import</span> android.graphics.DashPathEffect;</span><br><span class="line"><span class="keyword">import</span> android.graphics.DiscretePathEffect;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Path;</span><br><span class="line"><span class="keyword">import</span> android.graphics.PathDashPathEffect;</span><br><span class="line"><span class="keyword">import</span> android.graphics.PathEffect;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参考：http://blog.csdn.net/x605940745/article/details/17141987</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPathEffectView</span> <span class="keyword">extends</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPathEffectView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPathEffectView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPathEffectView</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyleAttr)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PathEffect[] effects = <span class="keyword">new</span> <span class="title class_">PathEffect</span>[<span class="number">7</span>];</span><br><span class="line">    <span class="type">float</span> <span class="variable">phase</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        canvas.drawColor(Color.WHITE);</span><br><span class="line"></span><br><span class="line">        <span class="type">Paint</span> <span class="variable">paint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">        paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        paint.setStrokeWidth(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] colors;</span><br><span class="line"></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>();</span><br><span class="line">        path.moveTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">            path.lineTo(i * <span class="number">30</span>, (<span class="type">float</span>) (Math.random() * <span class="number">150</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        colors = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;Color.RED, Color.BLUE, Color.GREEN, Color.parseColor(<span class="string">&quot;#FFF87D09&quot;</span>), Color.BLACK, Color.MAGENTA, Color.CYAN&#125;;</span><br><span class="line"></span><br><span class="line">        effects[<span class="number">0</span>] = <span class="literal">null</span>;<span class="comment">// 不实用路径</span></span><br><span class="line"></span><br><span class="line">        effects[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">CornerPathEffect</span>(<span class="number">20</span>);<span class="comment">//使用CornerPathEffect路径效果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Chop the path into lines of segmentLength, randomly deviating from the original path by deviation.</span></span><br><span class="line">        effects[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">DiscretePathEffect</span>(<span class="number">9.0f</span>, <span class="number">15.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//The intervals array must contain an even number of entries (&gt;=2), with the even indices specifying the &quot;on&quot; intervals, and the odd indices specifying the &quot;off&quot; intervals.</span></span><br><span class="line">        effects[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">DashPathEffect</span>(<span class="keyword">new</span> <span class="title class_">float</span>[]&#123;<span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">10</span>&#125;, phase);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Dash the drawn path by stamping it with the specified shape.</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>();</span><br><span class="line">        path1.addRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>, Path.Direction.CCW);</span><br><span class="line">        effects[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">PathDashPathEffect</span>(path1, <span class="number">12</span>, phase, PathDashPathEffect.Style.ROTATE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Construct a PathEffect whose effect is to apply first the inner effect and the the outer pathEffect</span></span><br><span class="line">        effects[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">ComposePathEffect</span>(effects[<span class="number">2</span>], effects[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">        effects[<span class="number">6</span>] = <span class="keyword">new</span> <span class="title class_">ComposePathEffect</span>(effects[<span class="number">4</span>], effects[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        canvas.translate(<span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; effects.length; i++) &#123;</span><br><span class="line">            paint.setPathEffect(effects[i]);</span><br><span class="line">            paint.setColor(colors[i]);</span><br><span class="line">            canvas.drawPath(path, paint);</span><br><span class="line">            canvas.translate(<span class="number">0</span>, <span class="number">150</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        phase += 1;</span></span><br><span class="line"><span class="comment">//        invalidate();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="http://pan.baidu.com/s/1o7bw3dK">源文件下载走你</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
        <tag>Path</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之自定义控件之画笔</title>
    <url>/iBlogWebsite/2016/01/20/2016/2016-01-20-Android%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%94%BB%E7%AC%94/</url>
    <content><![CDATA[<p>踉踉跄跄中，终于完成了对Paint各种效果的练习。收获非常多，对于Paint的各种过滤和混合效果，不再那么含糊和模棱两可，同时加深了对于矩阵的理解。</p>
<p>Demo中的各种示例均是在练习【aige】写的<a href="http://blog.csdn.net/aigestudio/article/details/41316141">文章</a>的基础上进行的整理。<a href="https://github.com/LeeeYou/DemoCustomView2">源码走你</a> 。 下面简单罗列下Demo中涉及到的知识点：</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>关于矩阵不清楚的童鞋可以转到<a href="https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%98%B5">wiki</a></p>
<h2 id="ColorMatrixColorFilter"><a href="#ColorMatrixColorFilter" class="headerlink" title="ColorMatrixColorFilter"></a>ColorMatrixColorFilter</h2><p>色彩矩阵过滤器，利用它可以实现很多美图秀秀中的效果，比如：变灰、变暗、颜色反转、老照片、高度对比等<br><img src="../../../../images/githubpages/colormatrix_%E5%8F%98%E6%9A%97.png" alt="变暗"><br><img src="../../../../images/githubpages/colormatrix_%E5%8F%98%E7%81%B0.png" alt="变灰"><br><img src="../../../../images/githubpages/colormatrix_%E5%8F%8D%E7%9B%B8.png" alt="反相效果"><br><img src="../../../../images/githubpages/colormatrix_%E7%BA%A2%E8%93%9D%E8%89%B2%E4%BA%92%E7%9B%B8%E5%8F%98%E6%8D%A2.png" alt="红蓝色相互变换"><br><img src="../../../../images/githubpages/colormatrix_%E8%80%81%E7%85%A7%E7%89%87.png" alt="老照片效果"><br><img src="../../../../images/githubpages/colormatrix_%E5%8E%BB%E8%89%B2%E5%90%8E%E9%AB%98%E5%BA%A6%E5%AF%B9%E6%AF%94.png" alt="去色后高度对比"><br><img src="../../../../images/githubpages/colormatrix_%E9%A5%B1%E5%92%8C%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%BA%A6%E5%8A%A0%E5%BC%BA.png" alt="饱和度对比度加强"></p>
<h2 id="LightingColorFilter"><a href="#LightingColorFilter" class="headerlink" title="LightingColorFilter"></a>LightingColorFilter</h2><p>光照颜色过滤器，利用它可以实现的效果就像有色光照在物体上染色一样。如过滤掉绿色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mPaint.setColorFilter(<span class="keyword">new</span> <span class="title class_">LightingColorFilter</span>(<span class="number">0xFFFF00FF</span>, <span class="number">0x00000000</span>));</span><br></pre></td></tr></table></figure>
<p><img src="../../../../images/githubpages/lightcolorfilter.png" alt="lightcolorfilter"></p>
<h2 id="PorterDuffColorFilter"><a href="#PorterDuffColorFilter" class="headerlink" title="PorterDuffColorFilter"></a>PorterDuffColorFilter</h2><p>混合颜色过滤器，可以通过指定一个颜色和一种模式，进行混合从而产生相应的效果。</p>
<p>红色+加深 混合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mPaint.setColorFilter(<span class="keyword">new</span> <span class="title class_">PorterDuffColorFilter</span>(Color.RED, PorterDuff.Mode.DARKEN));</span><br></pre></td></tr></table></figure>
<p><img src="../../../../images/githubpages/porterduffcolorfilter.png" alt="porterduffcolorfilter"></p>
<h2 id="PorterDuffXfermode"><a href="#PorterDuffXfermode" class="headerlink" title="PorterDuffXfermode"></a>PorterDuffXfermode</h2><p>这个是 <strong>最重量级 最重量级 最重量级</strong> 的东东了。ProterDuff是两个人名的组合: Tomas Proter和 Tom Duff. 他们是最早在SIGGRAPH上提出图形混合概念的大神级人物。有兴趣的童靴们可以自己查下并深入了解，在此不再做过多描述。<br>PorterDuffXfermode是一个非常强大的转换模式，通过它可以使用图像合成的16条Porter-Duff规则的任意一条来控制Paint如何与已有的Canvas图像进行交互。<br><img src="../../../../images/githubpages/porterduffxfermode2.jpg" alt="PorterDuffXfermode"></p>
<p>Demo中花了大量的篇幅练习和体会PorterDuffXfermode的强大，包括如下自定义view:  </p>
<blockquote>
<p>PorterDuffView :基本练习<br>DstInView：抠出美女轮廓<br>DstOutView：挖出美女轮廓<br>EraserView：橡皮擦练习</p>
</blockquote>
<p>基本练习<br><img src="../../../../images/githubpages/porterduffxfermode.png" alt="DST_IN效果"></p>
<p>使用DST_IN抠出美女图像，去掉了周围的黄色和顶部的文字<br><img src="../../../../images/githubpages/dst_in_%E7%BE%8E%E5%A5%B3%E7%BB%83%E4%B9%A0_%E5%89%8D.png" alt="DST_IN美女练习前"><br><img src="../../../../images/githubpages/dst_in_%E7%BE%8E%E5%A5%B3%E7%BB%83%E4%B9%A0_%E5%90%8E.png" alt="DST_IN美女练习后"></p>
<p>利用Path绘制路径，采用DST_IN混合模式，完成橡皮擦效果<br><img src="../../../../images/githubpages/eraserview.png" alt="eraserview"></p>
<hr>
<p>最后感谢<a href="http://blog.csdn.net/aigestudio/article/details/41316141">【aige】</a> 的高质量文章</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
        <tag>Paint</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之开发中必备的坐标体系知识</title>
    <url>/iBlogWebsite/2016/01/22/2016/2016-01-22-Android%E4%B9%8B%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BF%85%E5%A4%87%E7%9A%84%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="坐标体系基础知识"><a href="#坐标体系基础知识" class="headerlink" title="坐标体系基础知识"></a>坐标体系基础知识</h2><p>android中的坐标系统：屏幕的左上角是坐标系统原点（0,0），原点向右延伸是X轴正方向，原点向下延伸是Y轴正方向。</p>
<h2 id="Android屏幕区域划分"><a href="#Android屏幕区域划分" class="headerlink" title="Android屏幕区域划分"></a>Android屏幕区域划分</h2><p>屏幕区域的划分从上到下依次是：状态栏、标题栏、内容区域。值得注意的是app区域由标题栏和内容区域组成。</p>
<p>屏幕区域划分说明：<br><img src="../../../../images/githubpages/screen01.png" alt="屏幕区域划分说明"></p>
<p>获取屏幕宽高、app区域宽高以及状态栏宽高的代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_problem12_coordinate_system);</span><br><span class="line"></span><br><span class="line">        <span class="type">DisplayMetrics</span> <span class="variable">metrics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisplayMetrics</span>();</span><br><span class="line">        getWindowManager().getDefaultDisplay().getMetrics(metrics);</span><br><span class="line">        Log.d(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;屏幕高度&quot;</span> + metrics.heightPixels + <span class="string">&quot;；屏幕宽度&quot;</span> + metrics.widthPixels);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onWindowFocusChanged</span><span class="params">(<span class="type">boolean</span> hasFocus)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line"></span><br><span class="line">        <span class="type">Rect</span> <span class="variable">rect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rect</span>();</span><br><span class="line">        getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;app内容区域高度&quot;</span> + rect.height() + <span class="string">&quot;；app内容区域宽度&quot;</span> + rect.width());</span><br><span class="line">        Log.d(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;状态栏高度&quot;</span> + rect.top + <span class="string">&quot;；状态栏宽度&quot;</span> + rect.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">04</span>-<span class="number">05</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">10.169</span> <span class="number">5971</span>-<span class="number">5971</span>/com.example.leeeyou.fixmyproblem D/xxx: 屏幕高度<span class="number">2560</span>；屏幕宽度<span class="number">1440</span></span><br><span class="line"><span class="number">04</span>-<span class="number">05</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">10.226</span> <span class="number">5971</span>-<span class="number">5971</span>/com.example.leeeyou.fixmyproblem D/xxx: app内容区域高度<span class="number">2469</span>；app内容区域宽度<span class="number">1440</span></span><br><span class="line"><span class="number">04</span>-<span class="number">05</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">10.226</span> <span class="number">5971</span>-<span class="number">5971</span>/com.example.leeeyou.fixmyproblem D/xxx: 状态栏高度<span class="number">91</span>；状态栏宽度<span class="number">1440</span></span><br></pre></td></tr></table></figure>

<h2 id="View静态坐标系API介绍"><a href="#View静态坐标系API介绍" class="headerlink" title="View静态坐标系API介绍"></a>View静态坐标系API介绍</h2><h3 id="View绝对相对坐标"><a href="#View绝对相对坐标" class="headerlink" title="View绝对相对坐标"></a>View绝对相对坐标</h3><table>
<thead>
<tr>
<th align="left">View的静态坐标方法</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getLeft()</td>
<td align="left">返回View自身左边到父布局左边的距离</td>
</tr>
<tr>
<td align="left">getTop()</td>
<td align="left">返回View自身顶边到父布局顶边的距离</td>
</tr>
<tr>
<td align="left">getRight()</td>
<td align="left">返回View自身右边到父布局左边的距离</td>
</tr>
<tr>
<td align="left">getBottom()</td>
<td align="left">返回View自身底边到父布局顶边的距离</td>
</tr>
<tr>
<td align="left">getX()</td>
<td align="left"><strong>返回值为getLeft()+getTranslationX()，</strong> <br>当setTranslationX()时getLeft()不变，getX()变。</td>
</tr>
<tr>
<td align="left">getY()</td>
<td align="left"><strong>返回值为getTop()+getTranslationY()，</strong> <br>当setTranslationY()时getTop()不变，getY()变。</td>
</tr>
</tbody></table>
<h3 id="手指触摸屏幕时MotionEvent"><a href="#手指触摸屏幕时MotionEvent" class="headerlink" title="手指触摸屏幕时MotionEvent"></a>手指触摸屏幕时MotionEvent</h3><table>
<thead>
<tr>
<th align="left">MotionEvent坐标方法</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getX()</td>
<td align="left">当前触摸事件距离当前View左边的距离</td>
</tr>
<tr>
<td align="left">getY()</td>
<td align="left">当前触摸事件距离当前View顶边的距离</td>
</tr>
<tr>
<td align="left">getRawX()</td>
<td align="left">当前触摸事件距离整个屏幕左边的距离</td>
</tr>
<tr>
<td align="left">getRawY()</td>
<td align="left">当前触摸事件距离整个屏幕顶边的距离</td>
</tr>
</tbody></table>
<h3 id="在自定义View时经常要用的方法"><a href="#在自定义View时经常要用的方法" class="headerlink" title="在自定义View时经常要用的方法"></a>在自定义View时经常要用的方法</h3><table>
<thead>
<tr>
<th align="left">View宽高方法</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getWidth()</td>
<td align="left">layout后有效，返回值是mRight - mLeft，<br>一般会参考measure的宽度（measure可能没用），但不是必须的。</td>
</tr>
<tr>
<td align="left">getHeight()</td>
<td align="left">layout后有效，返回值是mBottom - mTop，<br>一般会参考measure的高度（measure可能没用），但不是必须的。</td>
</tr>
<tr>
<td align="left">getMeasuredWidth()</td>
<td align="left">返回measure过程得到的mMeasuredWidth值，<br>供layout参考，或许没用。</td>
</tr>
<tr>
<td align="left">getMeasuredHeight()</td>
<td align="left">返回measure过程得到的mMeasuredHeight值，<br>供layout参考，或许没用。</td>
</tr>
</tbody></table>
<h3 id="获取View在屏幕中的位置"><a href="#获取View在屏幕中的位置" class="headerlink" title="获取View在屏幕中的位置"></a>获取View在屏幕中的位置</h3><table>
<thead>
<tr>
<th align="left">View的方法</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getLocalVisibleRect()</td>
<td align="left">获取View自身可见的坐标区域，坐标以自己的左上角为原点(0,0)，另一点为可见区域右下角相对自己(0,0)点的坐标</td>
</tr>
<tr>
<td align="left">getGlobalVisibleRect()</td>
<td align="left">获取View在屏幕绝对坐标系中的可视区域，坐标以屏幕左上角为原点(0,0)，另一个点为可见区域右下角相对屏幕原点(0,0)点的坐标。</td>
</tr>
<tr>
<td align="left">getLocationOnScreen()</td>
<td align="left">坐标是相对整个屏幕而言，Y坐标为View左上角到屏幕顶部的距离。</td>
</tr>
<tr>
<td align="left">getLocationInWindow()</td>
<td align="left">如果为普通Activity则Y坐标为View左上角到屏幕顶部（此时Window与屏幕一样大）；如果为对话框式的Activity则Y坐标为当前Dialog模式Activity的标题栏顶部到View左上角的距离。</td>
</tr>
</tbody></table>
<h2 id="View滑动相关坐标系API介绍"><a href="#View滑动相关坐标系API介绍" class="headerlink" title="View滑动相关坐标系API介绍"></a>View滑动相关坐标系API介绍</h2><table>
<thead>
<tr>
<th align="left">View的滑动方法</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">offsetLeftAndRight(int offset)</td>
<td align="left">水平方向挪动View，offset为正则x轴正向移动，移动的是整个View，getLeft()会变的，自定义View很有用。</td>
</tr>
<tr>
<td align="left">offsetTopAndBottom(int offset)</td>
<td align="left">垂直方向挪动View，offset为正则y轴正向移动，移动的是整个View，getTop()会变的，自定义View很有用。</td>
</tr>
<tr>
<td align="left">scrollTo(int x, int y)</td>
<td align="left">将View中内容（不是整个View）滑动到相应的位置，参考坐标原点为ParentView左上角，x，y为正则向xy轴反方向移动，反之同理。</td>
</tr>
<tr>
<td align="left">scrollBy(int x, int y)</td>
<td align="left">在scrollTo()的基础上继续滑动xy。</td>
</tr>
<tr>
<td align="left">setScrollX(int value)</td>
<td align="left">实质为scrollTo()，只是只改变Y轴滑动。</td>
</tr>
<tr>
<td align="left">setScrollY(int value)</td>
<td align="left">实质为scrollTo()，只是只改变X轴滑动。</td>
</tr>
<tr>
<td align="left">getScrollX()/getScrollY()</td>
<td align="left">获取当前滑动位置偏移量。</td>
</tr>
<tr>
<td align="left">scrollTo()和scrollBy()方法特别注意：如果你给一个ViewGroup调用scrollTo()方法滚动的是ViewGroup里面的内容，如果想滚动一个ViewGroup则再给他嵌套一个外层，滚动外层即可。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Demo实战讲解"><a href="#Demo实战讲解" class="headerlink" title="Demo实战讲解"></a>Demo实战讲解</h2><p>看完上面这些get/set方法，是不是觉得很简单。我个人的体会是：在刚开始的时候，觉得这些奇葩的方法也就这么回事；但是每当自定义View时总是不能信手拈来，有种差一点点的感觉。这次配合DemoScrooler讲讲上面这些方法。Demo的效果非常简单，见下图：<br><img src="https://github.com/LeeeYou/Img/blob/master/leeeyou/ScrollXGif.gif?raw=true" alt="scroller"></p>
<p>Demo实现的效果是模仿ViewPager，当然比系统的ViewPager简单太多了。下面是自定义的完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.leeyou.demoscroller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.view.ViewConfigurationCompat;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewConfiguration;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.Scroller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollerLayout</span> <span class="keyword">extends</span> <span class="title class_">ViewGroup</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> ScrollerLayout.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Scroller mScroller;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mTouchSlop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mXDown;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mXMove;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mXLastMove;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftBorder;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightBorder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScrollerLayout</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步，创建Scroller的实例</span></span><br><span class="line">        mScroller = <span class="keyword">new</span> <span class="title class_">Scroller</span>(context);</span><br><span class="line"></span><br><span class="line">        <span class="type">ViewConfiguration</span> <span class="variable">viewConfiguration</span> <span class="operator">=</span> ViewConfiguration.get(context);</span><br><span class="line">        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(viewConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="type">View</span> <span class="variable">childAt</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="comment">// 为ScrollerLayout中的每一个子控件测量大小</span></span><br><span class="line">            measureChild(childAt, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> getChildCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">                <span class="type">View</span> <span class="variable">childAt</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">                childAt.layout(i * childAt.getMeasuredWidth(), <span class="number">0</span>, (i + <span class="number">1</span>) * childAt.getMeasuredWidth(), childAt.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                childAt.setOnTouchListener(<span class="keyword">new</span> <span class="title class_">OnTouchListener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouch</span><span class="params">(View v, MotionEvent event)</span> &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">                            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                                Log.e(TAG, <span class="string">&quot;consume ACTION_DOWN&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                                Log.e(TAG, <span class="string">&quot;consume ACTION_MOVE&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//onTouchEvent方法将不会被调用,OnTouchListener消耗掉了这个事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化左右边界值</span></span><br><span class="line">            leftBorder = getChildAt(<span class="number">0</span>).getLeft();<span class="comment">//相对于父视图的左边缘 0</span></span><br><span class="line">            rightBorder = getChildAt(childCount - <span class="number">1</span>).getRight();<span class="comment">//相对于父视图的右边缘 3240 = 1080*3</span></span><br><span class="line"></span><br><span class="line">            Log.e(TAG, <span class="string">&quot;leftBorder : &quot;</span> + leftBorder);</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;rightBorder : &quot;</span> + rightBorder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mXDown = ev.getRawX();</span><br><span class="line">                mXLastMove = mXDown;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                mXMove = ev.getRawX();</span><br><span class="line">                <span class="type">float</span> <span class="variable">diff</span> <span class="operator">=</span> Math.abs(mXMove - mXDown);</span><br><span class="line">                mXLastMove = mXMove;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当手指拖动值大于TouchSlop值时，认为应该进行滚动，拦截子控件的事件</span></span><br><span class="line">                <span class="keyword">if</span> (diff &gt; mTouchSlop) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                mXMove = event.getRawX();</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">scrolledX</span> <span class="operator">=</span> (<span class="type">int</span>) (mXLastMove - mXMove);</span><br><span class="line"></span><br><span class="line">                Log.e(TAG, <span class="string">&quot;getScrollX() : &quot;</span> + getScrollX());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//为了防止用户拖出边界这里还专门做了边界保护，当拖出边界时就调用scrollTo()方法来回到边界位置。</span></span><br><span class="line">                <span class="keyword">if</span> (getScrollX() + scrolledX &lt; leftBorder) &#123;</span><br><span class="line">                    scrollTo(leftBorder, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getScrollX() + getWidth() + scrolledX &gt; rightBorder) &#123;</span><br><span class="line">                    scrollTo(rightBorder - getWidth(), <span class="number">0</span>); <span class="comment">//getWidth()是获取视图的宽度</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                scrollBy(scrolledX, <span class="number">0</span>);</span><br><span class="line">                mXLastMove = mXMove;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="comment">// 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">targetIndex</span> <span class="operator">=</span> (getScrollX() + getWidth() / <span class="number">2</span>) / getWidth();</span><br><span class="line"></span><br><span class="line">                Log.e(TAG, <span class="string">&quot;ACTION_UP getScrollX() : &quot;</span> + getScrollX());</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;ACTION_UP getScrollX() : &quot;</span> + getScrollX());</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">dx</span> <span class="operator">=</span> targetIndex * getWidth() - getScrollX();</span><br><span class="line">                <span class="comment">// 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span></span><br><span class="line">                mScroller.startScroll(getScrollX(), <span class="number">0</span>, dx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果dx&gt;0,则整个视图往左移</span></span><br><span class="line">                <span class="comment">//如果dx&lt;0,则整个视图往右移</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//对getScrollX()的理解：将整个父视图的左上角定为(0,0)，那么子view.getScrollX会获取到屏幕左边缘减去父视图的左边缘为0的距离</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//targetIndex * getWidth() - getScrollX(); 得到的一个偏差值，这个偏差值是正数还是负数已经决定了view的左移右移方向</span></span><br><span class="line">                <span class="comment">//同时偏差值的计算中，始终是 n*1080 - getScrollX()，而getScrollX()就是父视图的左边缘隐藏的距离。</span></span><br><span class="line"></span><br><span class="line">                invalidate();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">computeScroll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义View依次出场的和坐标相关的方法有：<br>leftBorder = getChildAt(0).getLeft();  –&gt; 返回View自身左边到父布局左边的距离<br>rightBorder = getChildAt(childCount - 1).getRight();  –&gt; 返回View自身右边到父布局左边的距离<br>childAt.getMeasuredWidth()  –&gt; 返回measure过程得到的mMeasuredWidth值<br>childAt.getMeasuredHeight()  –&gt; 返回measure过程得到的mMeasuredHeight值<br>mXDown = ev.getRawX();  –&gt; 当前触摸事件距离整个屏幕左边的距离<br>getScrollX()  –&gt; 屏幕左边缘距整个父视图左上角定为(0,0)的距离<br>getWidth()  –&gt; layout后有效，返回值是mRight-mLeft<br>mScroller.getCurrX()  –&gt; 屏幕的左边缘离父视图的左边缘的距离。  </p>
<p>之前对getScrollX()的理解一直不到位，这次写Demo时终于终于弄明白了，这种感觉有种说不出的美好。<br><img src="https://github.com/LeeeYou/Img/blob/master/leeeyou/getScrollX.png?raw=true" alt="getScrollX说明"></p>
<p>值得一提的是 <strong>Scroller.startScroll(int startX, int startY, int dx, int dy)</strong> 四个参数分别表示起点的坐标和滑动的向量，即从(startX,startY)开始滑动，横向滑动dx的距离，纵向滑动dy的距离(正值向左滑，负值向右滑)，而这里的startX,startY又是参照的父视图左上角为原点坐标的坐标系，滑屏时经常使用getScrollX()和getScrollY()来代表屏幕左边缘和上边缘处于父视图坐标系的具体位置。<br><a href="https://github.com/LeeeYou/DemoScroller">DemoScroller源码走你</a></p>
<hr>
<p>本片文章参考：</p>
<ol>
<li><a href="http://blog.csdn.net/lvxiangan/article/details/19971509">http://blog.csdn.net/lvxiangan/article/details/19971509</a>  </li>
<li><a href="http://blog.csdn.net/yanbober/article/details/50419117">http://blog.csdn.net/yanbober/article/details/50419117</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
        <tag>坐标体系</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之基本排序算法</title>
    <url>/iBlogWebsite/2016/02/01/2016/2016-02-01-%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!-- 这篇博客基于自己写的一个项目[Algorithm2Practice](https://github.com/LeeeYou/Algorithm2Practice)， -->

<p>各个基本排序算法的源码参考：<a href="https://github.com/Leeeyou/iLeetcode/tree/main/src/personalwebsite/sort">https://github.com/Leeeyou/iLeetcode/tree/main/src/personalwebsite/sort</a></p>
<p>下图是各排序算法的时间空间复杂度：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/algorithm-time-complexity-of-each-sorting-method.png?raw=true" alt="time-complexity-of-each-sorting-method"></p>
<p>前提说明</p>
<blockquote>
<ul>
<li>排序算法无绝对优劣。通常不能随便说那种排序算法好，这个和具体的排序元素相关</li>
<li>为什么叫快速排序？并不代表它比堆排序和归并排序优良，只是快速排序的常量系数比较小而已  </li>
<li>工程上的排序是综合了很多种排序算法的综合排序。数组小时，可能会选择常量系数比较低的插入排序；数组大时，可能会选择快速排序或其他O(nlogn)的排序。</li>
</ul>
</blockquote>
<h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a>算法的运作如下：  </p>
<p>1、比较相邻的元素，如果第一个比第二个大，就交换他们两个。<br>2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>3、针对所有的元素重复以上的步骤，除了最后一个。<br>4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSortDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] array2 = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="type">BubbleSortDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BubbleSortDemo</span>();</span><br><span class="line">        demo.bubbleSort(array1);</span><br><span class="line">        demo.bubbleSort(array2);</span><br><span class="line">        demo.print(array1);</span><br><span class="line">        demo.print(array2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">                    startSwap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">                    flag = <span class="literal">true</span>;  <span class="comment">// 表示有数据交换</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换就提前退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSwap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] intArray)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : intArray) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a>算法的运作如下：</p>
<p>1、从第一个元素开始，该元素可以认为已经被排序<br>2、取出下一个元素，在已经排序的元素序列中从后向前扫描<br>3、如果该元素（已排序）大于新元素，将该元素移到下一位置<br>4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>5、将新元素插入到该位置后<br>6、重复步骤2~5</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSortDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] array2 = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="type">InsertionSortDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertionSortDemo</span>();</span><br><span class="line">        demo.insertionSort(array1);</span><br><span class="line">        demo.insertionSort(array2);</span><br><span class="line">        demo.print(array1);</span><br><span class="line">        demo.print(array2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 找到第一个小于等于v的下标</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; v) &#123;</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];  <span class="comment">// 向后移动数据，给v腾出空间</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j + <span class="number">1</span>] = v; <span class="comment">// 插入数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] intArray)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : intArray) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3. 希尔排序"></a>3. 希尔排序</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a>算法的运作如下：</p>
<p>1、外层循环控制step<br>2、内层循环做插入排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSortDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShellSortDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShellSortDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        demo.shellSort(array1);</span><br><span class="line">        demo.print(array1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array2 = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        demo.shellSort(array2);</span><br><span class="line">        demo.print(array2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升级版的插入排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> length / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> step; i &lt; length; i++) &#123;</span><br><span class="line">                v = nums[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - step;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; v) &#123;</span><br><span class="line">                    nums[j + step] = nums[j];</span><br><span class="line">                    j -= step;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j + step] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] intArray)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : intArray) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4. 选择排序"></a>4. 选择排序</h1><p><a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a>算法的运作如下：</p>
<p>1、首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，<br>2、再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>3、以此类推，直到所有元素均排序完毕。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSortDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SelectionSortDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SelectionSortDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        demo.selectionSort(array1);</span><br><span class="line">        demo.print(array1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array2 = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        demo.selectionSort(array2);</span><br><span class="line">        demo.print(array2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[min]) &#123;</span><br><span class="line">                    min = j; <span class="comment">// 找到最小的数，保存下标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            startSwap(array, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSwap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j];</span><br><span class="line">        array[j] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] intArray)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : intArray) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a>算法的运作如下：</p>
<p>1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>4、重复步骤3直到某一指针到达序列尾<br>5、将另一序列剩下的所有元素直接复制到合并序列尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSortDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MergeSortDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MergeSortDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        demo.mergeSort(array1, <span class="number">0</span>, array1.length - <span class="number">1</span>);</span><br><span class="line">        demo.print(array1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array2 = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        demo.mergeSort(array2, <span class="number">0</span>, array2.length - <span class="number">1</span>);</span><br><span class="line">        demo.print(array2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, l, mid);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        mergeArray(nums, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> low, r = mid + <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右子数组中的小数值放到临时数组中</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= high) temp[index++] = nums[l] &lt; nums[r] ? nums[l++] : nums[r++];</span><br><span class="line">        <span class="comment">// 剩余的直接放入</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid) temp[index++] = nums[l++];</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= high) temp[index++] = nums[r++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将临时数组放到原数组</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((low + index) &lt;= high) nums[low + index] = temp[index++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] intArray)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : intArray) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a>算法的运作如下：</p>
<p>1、最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点<br>2、创建最大堆（Build_Max_Heap）：将堆所有数据重新排序<br>3、堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSortDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HeapSortDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapSortDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        demo.heapSort(array1);</span><br><span class="line">        demo.print(array1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array2 = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        demo.heapSort(array2);</span><br><span class="line">        demo.print(array2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序的主要入口方法，共两步。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  第一步：将数组堆化</span></span><br><span class="line"><span class="comment">         *  beginIndex = 第一个非叶子节点。</span></span><br><span class="line"><span class="comment">         *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span></span><br><span class="line"><span class="comment">         *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">beginIndex</span> <span class="operator">=</span> (arr.length &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> beginIndex; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            maxHeapify(arr, i, len);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 第二步：对堆化数据排序</span></span><br><span class="line"><span class="comment">         * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span></span><br><span class="line"><span class="comment">         * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">         * 直至未排序的堆长度为 0。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            startSwap(arr, <span class="number">0</span>, i);</span><br><span class="line">            maxHeapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整索引为 index 处的数据，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要堆化处理的数据的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len   未排序的堆（数组）的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">li</span> <span class="operator">=</span> (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ri</span> <span class="operator">=</span> li + <span class="number">1</span>;           <span class="comment">// 右子节点索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cMax</span> <span class="operator">=</span> li;             <span class="comment">// 子节点值最大索引，默认左子节点。</span></span><br><span class="line">        <span class="keyword">if</span> (li &gt; len) <span class="keyword">return</span>;      <span class="comment">// 左子节点索引超出计算范围，直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (ri &lt;= len &amp;&amp; arr[ri] &gt; arr[li]) <span class="comment">// 先判断左右子节点，哪个较大。</span></span><br><span class="line">            cMax = ri;</span><br><span class="line">        <span class="keyword">if</span> (arr[cMax] &gt; arr[index]) &#123;</span><br><span class="line">            startSwap(arr, cMax, index);      <span class="comment">// 如果父节点被子节点调换，</span></span><br><span class="line">            maxHeapify(arr, cMax, len);  <span class="comment">// 则需要继续判断换下后的父节点是否符合堆的特性。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSwap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j];</span><br><span class="line">        array[j] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] intArray)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : intArray) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7. 快速排序"></a>7. 快速排序</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>算法的运作如下：</p>
<p>1、从数列中挑出一个元素，称为”基准”（pivot），<br>2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>3、递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">QuickSortDemo</span> <span class="variable">qs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QuickSortDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        qs.quickSort(array1, <span class="number">0</span>, array1.length - <span class="number">1</span>);</span><br><span class="line">        qs.print(array1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array2 = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        qs.quickSort(array2, <span class="number">0</span>, array2.length - <span class="number">1</span>);</span><br><span class="line">        qs.print(array2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> partition(nums, low, high); <span class="comment">// 分区函数，返回分区点的下标</span></span><br><span class="line">        quickSort(nums, low, mid - <span class="number">1</span>); <span class="comment">// 递归排序左分区</span></span><br><span class="line">        quickSort(nums, mid + <span class="number">1</span>, high); <span class="comment">// 递归排序右分区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> hight)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[low]; <span class="comment">// 以下标low的值为基准点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low, j = hight + <span class="number">1</span>; <span class="comment">// j之所以加1是因为下面开始找值的时候，开始就做了--操作</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= hight &amp;&amp; nums[i] &lt; pivot) ; <span class="comment">// 从左到右找第一个大于等于pivot的值</span></span><br><span class="line">            <span class="keyword">while</span> (--j &gt;= low &amp;&amp; nums[j] &gt; pivot) ; <span class="comment">// 从右到左找第一个小于等于pivot的值</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            startSwap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = nums[j]; <span class="comment">// 将mid的值(也就是下标j的值)与pivot交换</span></span><br><span class="line">        nums[j] = pivot;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSwap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] intArray)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : intArray) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h1><p><a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">计数排序</a>算法的运作如下：</p>
<p>1、找出待排序的数组中最大和最小的元素<br>2、统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br>3、对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>4、反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountSortDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CountSortDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountSortDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] array1Result = demo.countSort(array1);</span><br><span class="line">        demo.print(array1Result);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array2 = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">47</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] array2Result = demo.countSort(array2);</span><br><span class="line">        demo.print(array2Result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countSort(<span class="type">int</span>[] a) &#123;</span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>], min = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; max) max = i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; min) min = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里k的大小是要排序的数组中，元素大小的极值差+1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> max - min + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">            c[a[i] - min] += <span class="number">1</span>; <span class="comment">// 优化过的地方，减小了数组c的大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; c.length; ++i) &#123;</span><br><span class="line">            c[i] = c[i] + c[i - <span class="number">1</span>]; <span class="comment">// 对所有的计数累加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            b[--c[a[i] - min]] = a[i]; <span class="comment">// 按存取的方式取出c的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] intArray)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : intArray) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之排序进阶</title>
    <url>/iBlogWebsite/2016/02/22/2016/2016-02-22-%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="1-小范围排序"><a href="#1-小范围排序" class="headerlink" title="1. 小范围排序"></a>1. 小范围排序</h1><p>已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。<br>请选择一个合适的排序算法针对这个数据进行排序。<br>给定一个int数组A，同时给定A的大小n和题意中的k，请返回排序后的数组。</p>
<p>测试样例：<br>[2,1,4,3,6,5,8,7,10,9],10,2<br>返回：[1,2,3,4,5,6,7,8,9,10]</p>
<p><strong>关键点在于采用改进后的堆排序，建立小根堆，弹出堆顶</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort.advance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by liyou on 16/2/17. 小范围排序</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。</span></span><br><span class="line"><span class="comment"> * 给定一个int数组A，同时给定A的大小n和题意中的k，请返回排序后的数组。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * [2,1,4,3,6,5,8,7,10,9],10,2</span></span><br><span class="line"><span class="comment"> * 返回：[1,2,3,4,5,6,7,8,9,10]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScaleSortDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(sort(nums, nums.length, <span class="number">2</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] A, <span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] heap = getKHeap(A, k);<span class="comment">//获取长度为K的数组,并排序好</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(heap));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序下标为k到n的数组段,每次将heap[0]赋值到A数组中的合适位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; n; i++) &#123;</span><br><span class="line">            A[i - k] = heap[<span class="number">0</span>];</span><br><span class="line">            heap[<span class="number">0</span>] = A[i];</span><br><span class="line">            heapify(heap, <span class="number">0</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序下标为n - k到n的数组段,每次将heap[0]赋值到A数组中的合适位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - k; i &lt; n; i++) &#123;</span><br><span class="line">            A[i] = heap[<span class="number">0</span>];</span><br><span class="line">            swap(heap, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">            heapify(heap, <span class="number">0</span>, --k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] heap, <span class="type">int</span> index, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; heapSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap[left] &lt; heap[index]) &#123;</span><br><span class="line">                smallest = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; heap[right] &lt; heap[smallest]) &#123;</span><br><span class="line">                smallest = right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">                swap(heap, smallest, index);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            index = smallest;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            right = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] getKHeap(<span class="type">int</span>[] A, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] heap = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            heapInsert(heap, A[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] heap, <span class="type">int</span> value, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        heap[index] = value;</span><br><span class="line">        <span class="keyword">while</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[parent] &gt; heap[index]) &#123;</span><br><span class="line">                swap(heap, parent, index);</span><br><span class="line">                index = parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] heap, <span class="type">int</span> parent, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        heap[parent] = heap[parent] ^ heap[index];</span><br><span class="line">        heap[index] = heap[parent] ^ heap[index];</span><br><span class="line">        heap[parent] = heap[parent] ^ heap[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-有序数组合并"><a href="#2-有序数组合并" class="headerlink" title="2. 有序数组合并"></a>2. 有序数组合并</h1><p>有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲可容纳B。请编写一个方法，将B合并入A并排序。<br>给定两个有序int数组A和B，A中的缓冲可用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。  </p>
<p><strong>关键点在于从A数组的最后一个位置开始填充</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort.advance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by leeyou on 2016/2/18. 有序数组合并</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。</span></span><br><span class="line"><span class="comment"> * 给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeABDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] A1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">17413</span>, <span class="number">26696</span>, <span class="number">27419</span>, <span class="number">36377</span>, <span class="number">56415</span>, <span class="number">135953</span>, <span class="number">142208</span>, <span class="number">148191</span>, <span class="number">162935</span>, <span class="number">223175</span>, <span class="number">227457</span>, <span class="number">232547</span>, <span class="number">270061</span>, <span class="number">293536</span>, <span class="number">300646</span>, <span class="number">323370</span>, <span class="number">337601</span>, <span class="number">343498</span>, <span class="number">349062</span>, <span class="number">361535</span>, <span class="number">362542</span>, <span class="number">363281</span>, <span class="number">372346</span>, <span class="number">399285</span>, <span class="number">424290</span>, <span class="number">424891</span>, <span class="number">430823</span>, <span class="number">431146</span>, <span class="number">433225</span>, <span class="number">459024</span>, <span class="number">500673</span>, <span class="number">501109</span>, <span class="number">501915</span>, <span class="number">507799</span>, <span class="number">514223</span>, <span class="number">514646</span>, <span class="number">520564</span>, <span class="number">525483</span>, <span class="number">534100</span>, <span class="number">539424</span>, <span class="number">575651</span>, <span class="number">580326</span>, <span class="number">581038</span>, <span class="number">585391</span>, <span class="number">588557</span>, <span class="number">595756</span>, <span class="number">601421</span>, <span class="number">643763</span>, <span class="number">647735</span>, <span class="number">669766</span>, <span class="number">669941</span>, <span class="number">671404</span>, <span class="number">680057</span>, <span class="number">680320</span>, <span class="number">687351</span>, <span class="number">711669</span>, <span class="number">718681</span>, <span class="number">741883</span>, <span class="number">749333</span>, <span class="number">759829</span>, <span class="number">760008</span>, <span class="number">766856</span>, <span class="number">782114</span>, <span class="number">782759</span>, <span class="number">802341</span>, <span class="number">804566</span>, <span class="number">822965</span>, <span class="number">823452</span>, <span class="number">847246</span>, <span class="number">879368</span>, <span class="number">896815</span>, <span class="number">902133</span>, <span class="number">911041</span>, <span class="number">919142</span>, <span class="number">936836</span>, <span class="number">943065</span>, <span class="number">982593</span>, <span class="number">988176</span>, <span class="number">1015524</span>, <span class="number">1028627</span>, <span class="number">1044204</span>, <span class="number">1056030</span>, <span class="number">1056085</span>, <span class="number">1056621</span>, <span class="number">1071172</span>, <span class="number">1089708</span>, <span class="number">1097150</span>, <span class="number">1113894</span>, <span class="number">1115006</span>, <span class="number">1118614</span>, <span class="number">1134721</span>, <span class="number">1151263</span>, <span class="number">1178253</span>, <span class="number">1186313</span>, <span class="number">1233056</span>, <span class="number">1251125</span>, <span class="number">1256203</span>, <span class="number">1273615</span>, <span class="number">1275792</span>, <span class="number">1285086</span>, <span class="number">1302333</span>, <span class="number">1306432</span>, <span class="number">1315697</span>, <span class="number">1316031</span>, <span class="number">1337393</span>, <span class="number">1344430</span>, <span class="number">1361173</span>, <span class="number">1379606</span>, <span class="number">1389331</span>, <span class="number">1425968</span>, <span class="number">1427969</span>, <span class="number">1493366</span>, <span class="number">1505506</span>, <span class="number">1514123</span>, <span class="number">1522673</span>, <span class="number">1535749</span>, <span class="number">1544169</span>, <span class="number">1548120</span>, <span class="number">1594948</span>, <span class="number">1607054</span>, <span class="number">1636661</span>, <span class="number">1639341</span>, <span class="number">1671379</span>, <span class="number">1678150</span>, <span class="number">1686198</span>, <span class="number">1691751</span>, <span class="number">1716858</span>, <span class="number">1720848</span>, <span class="number">1752631</span>, <span class="number">1766501</span>, <span class="number">1768226</span>, <span class="number">1769213</span>, <span class="number">1778554</span>, <span class="number">1807015</span>, <span class="number">1820754</span>, <span class="number">1861536</span>, <span class="number">1867697</span>, <span class="number">1870014</span>, <span class="number">1884344</span>, <span class="number">1890660</span>, <span class="number">1896179</span>, <span class="number">1905934</span>, <span class="number">1908704</span>, <span class="number">1922214</span>, <span class="number">1941840</span>, <span class="number">1945809</span>, <span class="number">1962979</span>, <span class="number">1973065</span>, <span class="number">1974845</span>, <span class="number">1985003</span>, <span class="number">2021128</span>, <span class="number">2023622</span>, <span class="number">2025876</span>, <span class="number">2026541</span>, <span class="number">2035920</span>, <span class="number">2065297</span>, <span class="number">2076795</span>, <span class="number">2094946</span>, <span class="number">2107890</span>, <span class="number">2112889</span>, <span class="number">2126179</span>, <span class="number">2126583</span>, <span class="number">2137330</span>, <span class="number">2151196</span>, <span class="number">2154303</span>, <span class="number">2164515</span>, <span class="number">2183856</span>, <span class="number">2204159</span>, <span class="number">2212169</span>, <span class="number">2225243</span>, <span class="number">2234135</span>, <span class="number">2280538</span>, <span class="number">2287812</span>, <span class="number">2304762</span>, <span class="number">2313600</span>, <span class="number">2321748</span>, <span class="number">2347696</span>, <span class="number">2360344</span>, <span class="number">2400864</span>, <span class="number">2436301</span>, <span class="number">2450937</span>, <span class="number">2500668</span>, <span class="number">2516372</span>, <span class="number">2521740</span>, <span class="number">2530812</span>, <span class="number">2553004</span>, <span class="number">2553785</span>, <span class="number">2556379</span>, <span class="number">2571247</span>, <span class="number">2579918</span>, <span class="number">2587981</span>, <span class="number">2593730</span>, <span class="number">2599151</span>, <span class="number">2603585</span>, <span class="number">2611102</span>, <span class="number">2659102</span>, <span class="number">2664495</span>, <span class="number">2683060</span>, <span class="number">2685404</span>, <span class="number">2714644</span>, <span class="number">2720820</span>, <span class="number">2745828</span>, <span class="number">2756244</span>, <span class="number">2768818</span>, <span class="number">2775545</span>, <span class="number">2776592</span>, <span class="number">2794928</span>, <span class="number">2813026</span>, <span class="number">2813345</span>, <span class="number">2818735</span>, <span class="number">2821910</span>, <span class="number">2853850</span>, <span class="number">2857249</span>, <span class="number">2867847</span>, <span class="number">2875605</span>, <span class="number">2907800</span>, <span class="number">2908297</span>, <span class="number">2940285</span>, <span class="number">2942283</span>, <span class="number">2972829</span>, <span class="number">2976380</span>, <span class="number">2986013</span>, <span class="number">2989534</span>, <span class="number">3015162</span>, <span class="number">3025684</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] B1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">15181</span>, <span class="number">20937</span>, <span class="number">34523</span>, <span class="number">53329</span>, <span class="number">83373</span>, <span class="number">94526</span>, <span class="number">112629</span>, <span class="number">115543</span>, <span class="number">194613</span>, <span class="number">208478</span>, <span class="number">265297</span>, <span class="number">268974</span>, <span class="number">292027</span>, <span class="number">332294</span>, <span class="number">363837</span>, <span class="number">367196</span>, <span class="number">385237</span>, <span class="number">393630</span>, <span class="number">408551</span>, <span class="number">413216</span>, <span class="number">433405</span>, <span class="number">443321</span>, <span class="number">464497</span>, <span class="number">474039</span>, <span class="number">540533</span>, <span class="number">542456</span>, <span class="number">548033</span>, <span class="number">576284</span>, <span class="number">595360</span>, <span class="number">596912</span>, <span class="number">623229</span>, <span class="number">639268</span>, <span class="number">651070</span>, <span class="number">653427</span>, <span class="number">666818</span>, <span class="number">670894</span>, <span class="number">677075</span>, <span class="number">692155</span>, <span class="number">706595</span>, <span class="number">718743</span>, <span class="number">722856</span>, <span class="number">737892</span>, <span class="number">751281</span>, <span class="number">764934</span>, <span class="number">798768</span>, <span class="number">844048</span>, <span class="number">865715</span>, <span class="number">891280</span>, <span class="number">897575</span>, <span class="number">1033825</span>, <span class="number">1037001</span>, <span class="number">1099612</span>, <span class="number">1111165</span>, <span class="number">1116091</span>, <span class="number">1129796</span>, <span class="number">1133689</span>, <span class="number">1144898</span>, <span class="number">1182392</span>, <span class="number">1183875</span>, <span class="number">1190226</span>, <span class="number">1221605</span>, <span class="number">1227491</span>, <span class="number">1228354</span>, <span class="number">1244608</span>, <span class="number">1249157</span>, <span class="number">1267412</span>, <span class="number">1290421</span>, <span class="number">1298684</span>, <span class="number">1327266</span>, <span class="number">1337872</span>, <span class="number">1364796</span>, <span class="number">1394502</span>, <span class="number">1405391</span>, <span class="number">1471004</span>, <span class="number">1472387</span>, <span class="number">1478425</span>, <span class="number">1514465</span>, <span class="number">1527415</span>, <span class="number">1589733</span>, <span class="number">1635671</span>, <span class="number">1647384</span>, <span class="number">1657642</span>, <span class="number">1658417</span>, <span class="number">1686492</span>, <span class="number">1699286</span>, <span class="number">1739686</span>, <span class="number">1744389</span>, <span class="number">1785707</span>, <span class="number">1799269</span>, <span class="number">1799777</span>, <span class="number">1803987</span>, <span class="number">1848646</span>, <span class="number">1858803</span>, <span class="number">1863169</span>, <span class="number">1887748</span>, <span class="number">1931474</span>, <span class="number">1974413</span>, <span class="number">1994991</span>, <span class="number">2053465</span>, <span class="number">2054247</span>, <span class="number">2060481</span>, <span class="number">2064016</span>, <span class="number">2084626</span>, <span class="number">2094003</span>, <span class="number">2100807</span>, <span class="number">2102395</span>, <span class="number">2179141</span>, <span class="number">2195223</span>, <span class="number">2196483</span>, <span class="number">2217236</span>, <span class="number">2238453</span>, <span class="number">2274229</span>, <span class="number">2295144</span>, <span class="number">2317835</span>, <span class="number">2355472</span>, <span class="number">2362980</span>, <span class="number">2367366</span>, <span class="number">2417076</span>, <span class="number">2466653</span>, <span class="number">2487378</span>, <span class="number">2512416</span>, <span class="number">2530752</span>, <span class="number">2558439</span>, <span class="number">2578555</span>, <span class="number">2584074</span>, <span class="number">2632927</span>, <span class="number">2642426</span>, <span class="number">2671865</span>, <span class="number">2671913</span>, <span class="number">2676075</span>, <span class="number">2680872</span>, <span class="number">2691884</span>, <span class="number">2699411</span>, <span class="number">2702655</span>, <span class="number">2707867</span>, <span class="number">2728772</span>, <span class="number">2741442</span>, <span class="number">2755202</span>, <span class="number">2770399</span>, <span class="number">2810875</span>, <span class="number">2812537</span>, <span class="number">2888485</span>, <span class="number">2890613</span>, <span class="number">2898710</span>, <span class="number">2911540</span>, <span class="number">2920980</span>, <span class="number">2954424</span>, <span class="number">2955485</span>, <span class="number">2978795</span>, <span class="number">2984864</span>, <span class="number">2988301</span>, <span class="number">2989000</span>, <span class="number">2989421</span>, <span class="number">3017261</span>&#125;;</span><br><span class="line">        mergeAB(A1, B1, <span class="number">225</span>, <span class="number">154</span>);</span><br><span class="line">        System.out.println(Arrays.toString(A1));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] A2 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">244484</span>, <span class="number">382226</span>, <span class="number">521918</span>, <span class="number">538703</span>, <span class="number">617120</span>, <span class="number">652965</span>, <span class="number">669495</span>, <span class="number">729542</span>, <span class="number">797115</span>, <span class="number">818660</span>, <span class="number">893085</span>, <span class="number">893509</span>, <span class="number">995454</span>, <span class="number">1030570</span>, <span class="number">1067232</span>, <span class="number">1111004</span>, <span class="number">1182465</span>, <span class="number">1227629</span>, <span class="number">1285086</span>, <span class="number">1296017</span>, <span class="number">1391934</span>, <span class="number">1409484</span>, <span class="number">1432605</span>, <span class="number">1474413</span>, <span class="number">1482857</span>, <span class="number">1570061</span>, <span class="number">1617132</span>, <span class="number">1634333</span>, <span class="number">1751583</span>, <span class="number">1766981</span>, <span class="number">1782158</span>, <span class="number">1853608</span>, <span class="number">1902609</span>, <span class="number">1903687</span>, <span class="number">1961566</span>, <span class="number">1994655</span>, <span class="number">1996731</span>, <span class="number">2092815</span>, <span class="number">2283347</span>, <span class="number">2335154</span>, <span class="number">2340995</span>, <span class="number">2462149</span>, <span class="number">2501051</span>, <span class="number">2612826</span>, <span class="number">2636391</span>, <span class="number">2668527</span>, <span class="number">2717732</span>, <span class="number">2763132</span>, <span class="number">2805249</span>, <span class="number">2910951</span>, <span class="number">2943026</span>, <span class="number">2955464</span>, <span class="number">3027490</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] B2 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">25874</span>, <span class="number">82219</span>, <span class="number">240853</span>, <span class="number">241601</span>, <span class="number">379641</span>, <span class="number">499258</span>, <span class="number">546853</span>, <span class="number">573576</span>, <span class="number">671190</span>, <span class="number">812313</span>, <span class="number">1151154</span>, <span class="number">1161910</span>, <span class="number">1206096</span>, <span class="number">1275917</span>, <span class="number">1374652</span>, <span class="number">1507686</span>, <span class="number">1513725</span>, <span class="number">1740580</span>, <span class="number">1906642</span>, <span class="number">1954426</span>, <span class="number">2259302</span>, <span class="number">2478482</span>, <span class="number">2540276</span>, <span class="number">2579950</span>, <span class="number">2899843</span>, <span class="number">2914486</span>&#125;;</span><br><span class="line">        mergeAB(A2, B2, <span class="number">53</span>, <span class="number">26</span>);</span><br><span class="line">        System.out.println(Arrays.toString(A2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeAB(<span class="type">int</span>[] A, <span class="type">int</span>[] B, <span class="type">int</span> n, <span class="type">int</span> m) &#123;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                A[m - <span class="number">1</span>] = B[m - <span class="number">1</span>];</span><br><span class="line">                m--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                A[m + n - <span class="number">1</span>] = B[m - <span class="number">1</span>] &gt;= A[n - <span class="number">1</span>] ? B[--m] : A[--n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-重复值判断"><a href="#3-重复值判断" class="headerlink" title="3. 重复值判断"></a>3. 重复值判断</h1><p>请设计一个高效算法，判断数组中是否有重复值。必须保证额外空间复杂度为O(1)。<br>给定一个int数组A及它的大小n，请返回它是否有重复值。  </p>
<p>测试样例：<br>[1,2,3,4,5,5,6],7<br>返回：true</p>
<p><strong>1. 关键点在于先排序，后比较</strong><br><strong>2. 也可利用HashSet的特点快速查找重复值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort.advance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by liyou on 16/2/17.重复值判断</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 请设计一个高效算法，判断数组中是否有重复值。必须保证额外空间复杂度为O(1)。</span></span><br><span class="line"><span class="comment"> * 给定一个int数组A及它的大小n，请返回它是否有重复值。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * [1,2,3,4,5,5,6],7</span></span><br><span class="line"><span class="comment"> * 返回：true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckDuplicateDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">CheckDuplicateDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckDuplicateDemo</span>();</span><br><span class="line">        System.out.println(demo.checkDuplicate(nums, nums.length));</span><br><span class="line">        System.out.println(demo.checkDuplicate2(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkDuplicate</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || a.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        shellSort(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升级版的插入排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> length / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> step; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - step;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; v) &#123;</span><br><span class="line">                    nums[j + step] = nums[j];</span><br><span class="line">                    j -= step;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j + step] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkDuplicate2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-三色排序问题"><a href="#4-三色排序问题" class="headerlink" title="4. 三色排序问题"></a>4. 三色排序问题</h1><p>有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。<br>给定一个只含0，1，2的整数数组A及它的大小，请返回排序后的数组。保证数组大小小于等于500。</p>
<p>测试样例：<br>[0,1,1,0,2,2],6<br>返回：[0,0,1,1,2,2]  </p>
<p><strong>关键点在于建立两个区域，分别存储0和2，依次向原数组中间靠拢</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort.advance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by leeyou on 2016/2/19.三色排序问题</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。</span></span><br><span class="line"><span class="comment"> * 给定一个只含0，1，2的整数数组A及它的大小，请返回排序后的数组。保证数组大小小于等于500。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * [0,1,1,0,2,2],6</span></span><br><span class="line"><span class="comment"> * 返回：[0,0,1,1,2,2]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreeColorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.print(Arrays.toString(sortThreeColor(nums, nums.length)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sortThreeColor(<span class="type">int</span>[] nums, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, ++l, index++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] == <span class="number">2</span>) &#123;</span><br><span class="line">                swap(nums, index, --r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-有序矩阵查找"><a href="#5-有序矩阵查找" class="headerlink" title="5. 有序矩阵查找"></a>5. 有序矩阵查找</h1><p><a href="https://leetcode-cn.com/problems/sorted-matrix-search-lcci/">LeetCode 面试题 10.09. 排序矩阵查找</a></p>
<p>现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。<br>给定一个int矩阵mat，同时给定矩阵大小nxm及待查找的数x，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及x均为int范围内整数。保证n和m均小于等于1000。</p>
<p>测试样例：<br>[[1,2,3],[4,5,6],[7,8,9]],3,3,10<br>返回：false</p>
<p><strong>关键点在于从矩阵右上角开始遍历，二分查找的思想</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort.advance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by leeyou on 2016/2/19.有序矩阵查找</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * [LeetCode 面试题 10.09. 排序矩阵查找](https://leetcode-cn.com/problems/sorted-matrix-search-lcci/)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。</span></span><br><span class="line"><span class="comment"> * 给定一个int矩阵mat，同时给定矩阵大小nxm及待查找的数x，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及x均为int范围内整数。保证n和m均小于等于1000。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * [[1,2,3],[4,5,6],[7,8,9]],3,3,10</span></span><br><span class="line"><span class="comment"> * 返回：false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindMatrixDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] nums = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;</span><br><span class="line">        System.out.print(find(nums, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[][] mat, <span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">horizon</span> <span class="operator">=</span> <span class="number">0</span>, vertical = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (horizon &lt; n &amp;&amp; vertical &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mat[horizon][vertical] &gt; x) &#123;</span><br><span class="line">                vertical--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mat[horizon][vertical] &lt; x) &#123;</span><br><span class="line">                horizon++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-最短子数组"><a href="#6-最短子数组" class="headerlink" title="6. 最短子数组"></a>6. 最短子数组</h1><p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">LeetCode 581. 最短无序连续子数组</a></p>
<p>对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。<br>给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。  </p>
<p>测试样例：<br>[1,4,6,5,9,10],6<br>返回：2</p>
<p><strong>关键点在于从左到右，找到最右边小于当前最大数的下标；从右到左，找到最左边大于当前最小数的下标</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort.advance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by leeyou on 2016/2/19.最短子数组</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。</span></span><br><span class="line"><span class="comment"> * 给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * [1,4,6,5,9,10],6</span></span><br><span class="line"><span class="comment"> * 返回：2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortestSubsequenceDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] nums2 = &#123;<span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] nums3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] nums4 = &#123;&#125;;</span><br><span class="line">        System.out.println(subsequence(nums1, nums1.length));</span><br><span class="line">        System.out.println(subsequence(nums2, nums2.length));</span><br><span class="line">        System.out.println(subsequence(nums3, nums3.length));</span><br><span class="line">        System.out.println(subsequence(nums4, nums4.length));</span><br><span class="line">        System.out.println(subsequence(<span class="literal">null</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">subsequence</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从左到右找局部最大值，找到最右边小于最大数的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (max &gt; nums[i]) right = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从右到左找局部最小值，找到最左边大于最小数的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            min = Math.min(min, nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (min &lt; nums[i]) &#123;</span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-相邻两数最大差值"><a href="#7-相邻两数最大差值" class="headerlink" title="7. 相邻两数最大差值"></a>7. 相邻两数最大差值</h1><p>有一个整形数组A，请设计一个复杂度为O(n)的算法，算出排序后相邻两数的最大差值。<br>给定一个int数组A和A的大小n，请返回最大的差值。保证数组元素多于1个。</p>
<p>测试样例：<br>[1,2,7,5,4,6],6<br>返回：2</p>
<p><strong>关键点在于先找到最大值和最小值，再按数组长度划分区间，最后利用桶的思想将数值装桶，找到空桶区间并计算差值，此时还需要比较当前桶最大值与下一个桶的最小值的差值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.sort.advance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by leeyou on 2016/2/19.相邻两数最大差值</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 有一个整形数组A，请设计一个复杂度为O(n)的算法，算出排序后相邻两数的最大差值。</span></span><br><span class="line"><span class="comment"> * 给定一个int数组A和A的大小n，请返回最大的差值。保证数组元素多于1个。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * [1,2,7,5,4,6],6</span></span><br><span class="line"><span class="comment"> * 返回：2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxGapDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        System.out.print(gap(nums, nums.length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gap</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> A[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; min) &#123;</span><br><span class="line">                min = A[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; max) &#123;</span><br><span class="line">                max = A[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (max == min)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] hasNum = <span class="keyword">new</span> <span class="title class_">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] maxs = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] mins = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">bid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            bid = bucket(A[i], len, min, max); <span class="comment">// 算出桶号</span></span><br><span class="line">            mins[bid] = hasNum[bid] ? Math.min(mins[bid], A[i]) : A[i];</span><br><span class="line">            maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], A[i]) : A[i];</span><br><span class="line">            hasNum[bid] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasNum[i++]) &#123; <span class="comment">// 找到第一个不空的桶</span></span><br><span class="line">                lastMax = maxs[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasNum[i]) &#123;</span><br><span class="line">                res = Math.max(res, mins[i] - lastMax);</span><br><span class="line">                lastMax = maxs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用long类型是为了防止相乘时溢出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bucket</span><span class="params">(<span class="type">long</span> num, <span class="type">long</span> len, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ((num - min) * len / (max - min));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之Toolbar与软键盘的恩恩怨怨</title>
    <url>/iBlogWebsite/2016/01/23/2016/2016-01-23-Android%E4%B9%8BToolbar%E4%B8%8E%E8%BD%AF%E9%94%AE%E7%9B%98%E7%9A%84%E6%81%A9%E6%81%A9%E6%80%A8%E6%80%A8/</url>
    <content><![CDATA[<p>虐心的软键盘与Toolbar折腾了我整整近10个小时!!</p>
<p>由于项目中需要对一条动态进行评论，所以需要添加评论功能，原来的实现方式是让EditText获取焦点，然后弹出软键盘，同时EditText由原来底部位置跳到软键盘的上方，一段很简单的处理流程搞定了,如下图所示：</p>
<p><img src="../../../../images/githubpages/softkeyboard1.png" alt="softkeyboard1"></p>
<p>于是乎，我拷贝代码到新项目中，还是同样的配方发现EditText获取到了光标，竟然不弹到软键盘的上方了，此时我强烈的预感到自己入坑了!</p>
<p>于是乎，我苦逼的bug解决之旅开始了。</p>
<p>由于当时逼近傍晚，精神恍惚，脑袋也运转不起来，就各种baidu、google，我甚至不知道该输入什么关键字，悲哀…</p>
<p>几番搜索之后，找到了一个解决方法，在清单文件中设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android:windowSoftInputMode=<span class="string">&quot;adjustPan&quot;</span></span><br></pre></td></tr></table></figure>

<p>再不行就设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android:windowSoftInputMode=<span class="string">&quot;stateVisible|adjustResize&quot;</span></span><br></pre></td></tr></table></figure>

<p>然而，然并卵。</p>
<p>但是此时的现象有所不同了，使用 <strong>adjustPan</strong> 会把标题栏顶到屏幕外边，使用 <strong>stateVisible|adjustResize</strong> 时，EditText获取到了光标但还是不弹到软键盘的上方。</p>
<p>也尝试了ScrollView包裹的方式，都没有用……..</p>
<p>此时我意识到可能是使用Toolbar导致的问题，但当时已是快22点，实在码不动就先下班了。</p>
<p>回家的路上我始终在想这件事情，怎么会把Toolbar顶上去呢？</p>
<p>结果当然是没有想出来，到家之后，就google了很多把这个问题，还发了邮件记录可能有用的链接：</p>
<p><img src="../../../../images/githubpages/softkeyboard2.png" alt="softkeyboard2"></p>
<p>我甚至还想到了一个解决方法：动态获取软键盘的高度，然后让EditText marginBottom这个高度。</p>
<p>以为自己准备的够充分了，第二天早上到公司之后，就兴致勃勃的开码了。</p>
<p>然而都以失败告终，<strong>让EditText marginBottom这个高度</strong> 的方法倒是可以marginBottom，但并不是理想的效果，当软键盘弹出时，activity的底部已经被顶上去了，此时EditText再marginBottom软键盘高度时就会出现下图的效果：</p>
<p><img src="../../../../images/githubpages/softkeyboard3.png" alt="softkeyboard3"></p>
<p>问题还是要解决的。继续google</p>
<p><img src="../../../../images/githubpages/softkeyboard4.png" alt="softkeyboard4"></p>
<p>其实在stackoverflow上还是有很多人提这个问题的，所以搜索的关键字非常重要!</p>
<p>stackoverflow上的<a href="http://stackoverflow.com/questions/29384134/adjustpan-pushing-my-layout-and-hiding-status-bar">这个问题</a>带领我一步一步解开了bug的面纱。</p>
<p>先设置 **fitsSystemWindows=”true”**，调试发现Toolbar未被顶上去，这是一个好消息，但是输入框的样式却改变了，<br>然后就是在布局文件中的很多个地方设置 **fitsSystemWindows=”true”**，再调试调试调试…，就这样持续了很长时间之后，效果如下图：<br><img src="../../../../images/githubpages/softkeyboard5.png" alt="softkeyboard5"></p>
<p>EditText上方的灰线框其实不是我的布局内容，它的高度和statusBar的非常接近，而此时我使用的Toolbar代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    WindowManager.<span class="type">LayoutParams</span> <span class="variable">localLayoutParams</span> <span class="operator">=</span> getWindow().getAttributes();</span><br><span class="line">    localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里其实我大致知道问题的原因了：由于我使用了Toolbar，并设置了FLAG_TRANSLUCENT_STATUS，同时toolbar的布局如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;android.support.v7.widget.Toolbar xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/toolbar&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android:background=<span class="string">&quot;?attr/colorPrimary&quot;</span></span><br><span class="line">    android:minHeight=<span class="string">&quot;?attr/actionBarSize&quot;</span></span><br><span class="line">    android:paddingTop=<span class="string">&quot;@dimen/toolbar_padding_top&quot;</span></span><br><span class="line">    app:popupTheme=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span></span><br><span class="line">    app:theme=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span><br><span class="line">    app:titleTextAppearance=<span class="string">&quot;@style/Toolbar.TitleText&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/toolbar_title&quot;</span></span><br><span class="line">        style=<span class="string">&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Title&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;@string/app_name&quot;</span></span><br><span class="line">        android:textSize=<span class="string">&quot;20sp&quot;</span> /&gt;</span><br><span class="line">&lt;/android.support.v7.widget.Toolbar&gt;</span><br></pre></td></tr></table></figure>

<p>关键的一行代码 <strong>android:paddingTop=”@dimen/toolbar_padding_top”</strong> 导致了这段虐心的经历。</p>
<p>什么 **fitsSystemWindows=”true”**、什么设置了FLAG_TRANSLUCENT_STATUS都没关系，这些都不是导致问题的直接原因。</p>
<p>我这里的toolbar实际上不是非常规范的，利用paddingTop+FLAG_TRANSLUCENT_STATUS的方式实现了Toolbar的效果。</p>
<p>规范的做法应该是Toolbar+StatusBar，两方没有纠缠在一起。</p>
<p>回到我的项目上，由于项目中大量使用了Toolbar，同时由于项目环境的复杂，我采取了一种妥协的方式，<br>在这个界面不使用 <strong>android:paddingTop=”@dimen/toolbar_padding_top”</strong>,同时也不再改变statusBar的颜色，在清单中配上 <strong>android:windowSoftInputMode=”adjustResize”</strong> ,虽然解决方法不是很完美，但是总算是一种方式。<br>最终效果图如下：</p>
<p><img src="../../../../images/githubpages/softkeyboard6.png" alt="softkeyboard6"></p>
<p>最后的最后，还是整理下基本概念的东西：  </p>
<ul>
<li>关于android:windowSoftInputMode的属性，<a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/39761461">参看这边博客</a></li>
<li>FLAG_TRANSLUCENT_STATUS和FLAG_TRANSLUCENT_NAVIGATION是Android4.4的新特性，皆在应用内开启透明状态栏和透明虚拟按钮。<a href="http://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_TRANSLUCENT_NAVIGATION">官方API</a></li>
<li>同时中文的说明可以<a href="http://www.cnblogs.com/zhengxt/p/3536905.html">参看这边博客</a></li>
<li><a href="http://developer.android.com/reference/android/view/View.html#attr_android:fitsSystemWindows">android:fitsSystemWindows</a>:布局时是否考虑给系统窗口留出空间，true为留出空间（如 Status Bar and App bar）</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Toolbar</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之图的深度优先遍历和广度优先遍历</title>
    <url>/iBlogWebsite/2016/02/23/2016/2016-02-23-%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>图的遍历分为深度优先遍历(DFS Depth First Search)和广度优先遍历(BFS Breadth First Search)，其对有向图和无向图都适用。</p>
<p>深度优先就是只要存在后续节点就一直往下走，直到没有后续节点或者后续节点已经被访问输出了。</p>
<p>广度优先就是节点一层一层的输出。</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/algorithm-dfs-bfs.png?raw=true" alt="graph-dfs-bfs"></p>
<p>下面的两段代码会先生成node节点，然后将其加入到ArrayList集合中。然后用一个而为数组描述图的各个连接状态，比如有无邻居节点，有无后序节点。</p>
<p>如上图所示，对上图进行深度优先排序和广度优先排序的代码如下：</p>
<h1 id="1-深度优先遍历"><a href="#1-深度优先遍历" class="headerlink" title="1. 深度优先遍历"></a>1. 深度优先遍历</h1><p>有两种方式可以完成深度优先遍历  </p>
<p>1、利用栈的数据结构，stack的特点天然跟递归思想match，先进后出<br>2、利用递归  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图的深度遍历</span></span><br><span class="line"><span class="comment"> * http://www.java2blog.com/2015/12/depth-first-search-in-java.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DfsDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node40</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">40</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node20</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node30</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">30</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node60</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">60</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node50</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node70</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">70</span>);</span><br><span class="line"></span><br><span class="line">        nodes.add(node40);</span><br><span class="line">        nodes.add(node10);</span><br><span class="line">        nodes.add(node20);</span><br><span class="line">        nodes.add(node30);</span><br><span class="line">        nodes.add(node60);</span><br><span class="line">        nodes.add(node50);</span><br><span class="line">        nodes.add(node70);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,  <span class="comment">// Node 1: 40</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,  <span class="comment">// Node 2 :10</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,  <span class="comment">// Node 3: 20</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,  <span class="comment">// Node 4: 30</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,  <span class="comment">// Node 5: 60</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,  <span class="comment">// Node 6: 50</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,  <span class="comment">// Node 7: 70</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">DfsDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DfsDemo</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;The DFS traversal of the graph using stack &quot;</span>);</span><br><span class="line">        demo.dfsUsingStack(matrix, node40);</span><br><span class="line">        System.out.println();</span><br><span class="line">        demo.clearVisitedFlags();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;The DFS traversal of the graph using recursion &quot;</span>);</span><br><span class="line">        demo.dfs(matrix, node40);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find neighbors of node using adjacency matrix</span></span><br><span class="line">    <span class="comment">// if matrix[i][j]==1, then nodes at index i and index j are connected</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Node&gt; <span class="title function_">findNeighbours</span><span class="params">(<span class="type">int</span>[][] matrix, Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;Node&gt; neighbours = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodes.get(i).equals(node)) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) <span class="keyword">return</span> neighbours;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[index].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[index][j] == <span class="number">1</span>) neighbours.add(nodes.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neighbours;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursive DFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] matrix, Node node)</span> &#123;</span><br><span class="line">        System.out.print(node.data + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        ArrayList&lt;Node&gt; neighbours = findNeighbours(matrix, node);</span><br><span class="line">        <span class="keyword">for</span> (Node n : neighbours) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="literal">null</span> &amp;&amp; !n.visited) &#123;</span><br><span class="line">                dfs(matrix, n);</span><br><span class="line">                n.visited = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterative DFS using stack</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfsUsingStack</span><span class="params">(<span class="type">int</span>[][] matrix, Node node)</span> &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.add(node);</span><br><span class="line">        node.visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">element</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            System.out.print(element.data + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ArrayList&lt;Node&gt; neighbours = findNeighbours(matrix, element);</span><br><span class="line">            <span class="keyword">for</span> (Node n : neighbours) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n != <span class="literal">null</span> &amp;&amp; !n.visited) &#123;</span><br><span class="line">                    stack.add(n); <span class="comment">// stack的特点天然跟递归思想match，先进后出</span></span><br><span class="line">                    n.visited = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearVisitedFlags</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node node : nodes) node.visited = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        <span class="type">boolean</span> visited;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> data) &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">The DFS traversal of the graph using stack</span><br><span class="line"><span class="number">40</span>	<span class="number">20</span>	<span class="number">50</span>	<span class="number">70</span>	<span class="number">60</span>	<span class="number">30</span>	<span class="number">10</span></span><br><span class="line">The DFS traversal of the graph using recursion</span><br><span class="line"><span class="number">40</span>	<span class="number">10</span>	<span class="number">30</span>	<span class="number">60</span>	<span class="number">70</span>	<span class="number">20</span>	<span class="number">50</span></span><br></pre></td></tr></table></figure>

<h1 id="2-广度优先遍历"><a href="#2-广度优先遍历" class="headerlink" title="2. 广度优先遍历"></a>2. 广度优先遍历</h1><p>利用队列先进先出的特性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.algorithm.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> personalwebsite.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图的广度遍历</span></span><br><span class="line"><span class="comment"> * http://www.java2blog.com/2015/12/breadth-first-search-in-java.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BfsDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Node&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BfsDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node40</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">40</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node20</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node30</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">30</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node60</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">60</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node50</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node70</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">70</span>);</span><br><span class="line"></span><br><span class="line">        nodes.add(node40);</span><br><span class="line">        nodes.add(node10);</span><br><span class="line">        nodes.add(node20);</span><br><span class="line">        nodes.add(node30);</span><br><span class="line">        nodes.add(node60);</span><br><span class="line">        nodes.add(node50);</span><br><span class="line">        nodes.add(node70);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,  <span class="comment">// Node 1: 40</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,  <span class="comment">// Node 2 :10</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,  <span class="comment">// Node 3: 20</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,  <span class="comment">// Node 4: 30</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,  <span class="comment">// Node 5: 60</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,  <span class="comment">// Node 6: 50</span></span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,  <span class="comment">// Node 7: 70</span></span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;The BFS traversal of the graph is &quot;</span>);</span><br><span class="line">        <span class="type">BfsDemo</span> <span class="variable">bfsExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BfsDemo</span>();</span><br><span class="line">        bfsExample.bfs(matrix, node40);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find neighbors of node using adjacency matrix</span></span><br><span class="line">    <span class="comment">// if adjacency_matrix[i][j]==1, then nodes at index i and index j are connected</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Node&gt; <span class="title function_">findNeighbours</span><span class="params">(<span class="type">int</span>[][] matrix, Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;Node&gt; neighbours = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodes.get(i).equals(node)) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) <span class="keyword">return</span> neighbours;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[index].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[index][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                neighbours.add(nodes.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neighbours;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[][] matrix, Node node)</span> &#123;</span><br><span class="line">        queue.add(node);</span><br><span class="line">        node.visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">element</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">            System.out.print(element.data + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            ArrayList&lt;Node&gt; neighbours = findNeighbours(matrix, element);</span><br><span class="line">            <span class="keyword">for</span> (Node n : neighbours) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n != <span class="literal">null</span> &amp;&amp; !n.visited) &#123;</span><br><span class="line">                    queue.add(n);</span><br><span class="line">                    n.visited = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        <span class="type">boolean</span> visited;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> data) &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">The BFS traversal of the graph is</span><br><span class="line"><span class="number">40</span>	<span class="number">10</span>	<span class="number">20</span>	<span class="number">30</span>	<span class="number">60</span>	<span class="number">50</span>	<span class="number">70</span></span><br></pre></td></tr></table></figure>

<hr>
<p>参考：</p>
<ol>
<li><a href="http://www.java2blog.com/2015/12/breadth-first-search-in-java.html">http://www.java2blog.com/2015/12/breadth-first-search-in-java.html</a></li>
<li><a href="http://www.java2blog.com/2015/12/depth-first-search-in-java.html">http://www.java2blog.com/2015/12/depth-first-search-in-java.html</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第1章 Activity的生命周期和启动模式</title>
    <url>/iBlogWebsite/2016/02/27/2016/2016-02-27-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC1%E7%AB%A0%20Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>谢天谢地，终于完成了《Android艺术探索》整本书的拆书工作。</p>
<p>其实本书购买是在2015年10月，到11月底的时候，第一遍就已经阅读完毕，那时就想着要整理拆书笔记，也都列在了计划中。本来是16年1月份就要完成的内容，一直拖到了2月底。</p>
<p>所幸的是，总结的不是太晚太晚。</p>
<p>Activity的生命周期和启动模式这一章节主要的内容摘要：Activity生命周期全面分析，Activity的启动模式，IntentFilter的匹配规则，知识扩展。</p>
<h1 id="1-生命周期全面分析"><a href="#1-生命周期全面分析" class="headerlink" title="1. 生命周期全面分析"></a>1. 生命周期全面分析</h1><h2 id="1-1-典型情况"><a href="#1-1-典型情况" class="headerlink" title="1.1. 典型情况"></a>1.1. 典型情况</h2><ul>
<li><p>一般情况下，当<strong>当前Activity从不可见重新变为可见状态时</strong>，onRestart方法就会被调用。</p>
</li>
<li><p>当用户打开新的Activity或者切换到桌面的时候，回调如下：onPause -&gt; onStop，<strong>但是如果新Activity采用了透明主题，那么onStop方法不会被回调。</strong> 当用户再次回到原来的Activity时，回调如下：onRestart -&gt; onStart -&gt; onResume。</p>
</li>
<li><p>onStart和onStop对应，它们是从Activity是否可见这个角度来回调的；onPause和onResume方法对应，它们是从Activity是否位于前台这个角度来回调的。</p>
</li>
<li><p>从Activity A进入到Activity B，回调顺序如下：onPause(A)-&gt;onCreate(B)-&gt;onStart(B)-&gt;onResume(B)-&gt;onStop(A)，<strong>所以不能在onPause方法中做重量级的操作。</strong></p>
</li>
<li><p><strong>锁屏与解锁屏幕时只会调用onPause()，而不会调用onStop方法，开屏后则调用onResume()。</strong></p>
</li>
</ul>
<h2 id="1-2-异常情况"><a href="#1-2-异常情况" class="headerlink" title="1.2. 异常情况"></a>1.2. 异常情况</h2><h3 id="1-2-1-onSaveInstanceState和onRestoreInstanceState"><a href="#1-2-1-onSaveInstanceState和onRestoreInstanceState" class="headerlink" title="1.2.1. onSaveInstanceState和onRestoreInstanceState"></a>1.2.1. onSaveInstanceState和onRestoreInstanceState</h3><p>onSaveInstanceState只出现在Activity被异常终止的情况下，它的调用时机是在onStop之前。它和onPause方法没有既定的时序关系，可能在它之前，也可能在它之后。当Activity被重新创建的时候，onRestoreInstanceState会被回调，它的调用时机是onStart之后。</p>
<h3 id="1-2-2-Activity按优先级的分类"><a href="#1-2-2-Activity按优先级的分类" class="headerlink" title="1.2.2. Activity按优先级的分类"></a>1.2.2. Activity按优先级的分类</h3><ul>
<li>前台Activity</li>
<li>可见但非前台Activity</li>
<li>后台Activity</li>
</ul>
<h3 id="1-2-3-android-configChanges-”xxx”属性，常用的主要有下面三个选项："><a href="#1-2-3-android-configChanges-”xxx”属性，常用的主要有下面三个选项：" class="headerlink" title="1.2.3. android:configChanges=”xxx”属性，常用的主要有下面三个选项："></a>1.2.3. android:configChanges=”xxx”属性，常用的主要有下面三个选项：</h3><ul>
<li><p>local：设备的本地位置发生了变化，一般指切换了系统语言。</p>
</li>
<li><p>keyboardHidden：键盘的可访问性发生了变化，比如用户调出了键盘。</p>
</li>
<li><p>orientation：屏幕方向发生了变化，比如旋转了手机屏幕。</p>
</li>
</ul>
<p>配置了android:configChanges=”xxx”属性之后，<strong>Activity就不会在对应变化发生时重新创建，</strong> 而是调用Activity的onConfigurationChanged方法。</p>
<h1 id="2-启动模式"><a href="#2-启动模式" class="headerlink" title="2. 启动模式"></a>2. 启动模式</h1><h2 id="2-1-standard"><a href="#2-1-standard" class="headerlink" title="2.1. standard"></a>2.1. standard</h2><p>标准启动模式，也是activity的默认启动模式。在这种模式下启动的activity<strong>可以被多次实例化，</strong> 即在同一个任务中可以存在多个activity的实例，每个实例都会处理一个Intent对象。</p>
<h2 id="2-2-singleTop"><a href="#2-2-singleTop" class="headerlink" title="2.2. singleTop"></a>2.2. singleTop</h2><p>如果一个以singleTop模式启动的activity的实例已经存在于任务桟的桟顶，那么再启动这个Activity时，不会创建新的实例，而是重用位于栈顶的那个实例，并且会调用该实例的onNewIntent()方法将Intent对象传递到这个实例中。</p>
<p>如果以singleTop模式启动的activity的一个实例已经存在与任务桟中，但是不在桟顶，那么它的行为和standard模式相同，也会创建多个实例。</p>
<h2 id="2-3-singleTask"><a href="#2-3-singleTask" class="headerlink" title="2.3. singleTask"></a>2.3. singleTask</h2><p>1.设置了singleTask启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的任务存在；如果存在这样的任务，它就会在这个任务中启动，否则就会在新任务中启动。因此如果我们想要设置了singleTask启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。</p>
<p>2.如果设置了singleTask启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例，如果存在就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity实例会位于任务的堆栈顶端中。</p>
<h2 id="2-4-singleInstance"><a href="#2-4-singleInstance" class="headerlink" title="2.4. singleInstance"></a>2.4. singleInstance</h2><p>1.以singleInstance模式启动的Activity具有全局唯一性，即整个系统中只会存在一个这样的实例。</p>
<p>2.以singleInstance模式启动的Activity具有独占性，即它会独自占用一个任务，被他开启的任何activity都会运行在其他任务中。官方文档上的描述为：singleInstance模式的Activity不允许其他Activity和它共存在一个任务中</p>
<p>3.被singleInstance模式的Activity开启的其他activity，能够开启一个新任务，但不一定开启新的任务，也可能在已有的一个任务中开启。</p>
<h1 id="3-IntentFilter-匹配规则"><a href="#3-IntentFilter-匹配规则" class="headerlink" title="3. IntentFilter 匹配规则"></a>3. IntentFilter 匹配规则</h1><h2 id="3-1-IntentFilter中的过滤信息包括action、category、data"><a href="#3-1-IntentFilter中的过滤信息包括action、category、data" class="headerlink" title="3.1. IntentFilter中的过滤信息包括action、category、data"></a>3.1. IntentFilter中的过滤信息包括action、category、data</h2><p>一个过滤列表中的action、category、data可以有多个，所有的action、category、data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程。</p>
<p>只有一个Intent同时匹配action类别、category类别和data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。</p>
<p>此外，一个Activity中可以有多个intent-filter，一个Intent只要能匹配任何一组intenf-filter即可成功启动对应的Activity。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">&quot;com.ryg.charpter_1.c&quot;</span> /&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">&quot;com.ryg.charpter_1.d&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;category android:name=<span class="string">&quot;com.ryg.category.c&quot;</span> /&gt;</span><br><span class="line">    &lt;category android:name=<span class="string">&quot;com.ryg.category.d&quot;</span> /&gt;</span><br><span class="line">    &lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data android:mimeType=<span class="string">&quot;text/plain&quot;</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-action匹配规则"><a href="#3-2-action匹配规则" class="headerlink" title="3.2. action匹配规则"></a>3.2. action匹配规则</h2><p>只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功，<strong>action匹配区分大小写。</strong></p>
<h2 id="3-3-category匹配规则"><a href="#3-3-category匹配规则" class="headerlink" title="3.3. category匹配规则"></a>3.3. category匹配规则</h2><p>Intent中如果有category，那么所有的category都必须和过滤规则中的其中一个category相同，如果没有category的话那么就是默认的category，即android.intent.category.DEFAULT，所以为了Activity能够接收隐式调用，配置多个category的时候必须加上默认的category。</p>
<h2 id="3-4-data匹配规则"><a href="#3-4-data匹配规则" class="headerlink" title="3.4. data匹配规则"></a>3.4. data匹配规则</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;data android:scheme=<span class="string">&quot;string&quot;</span></span><br><span class="line">android:host=<span class="string">&quot;string&quot;</span></span><br><span class="line">android:port=<span class="string">&quot;string&quot;</span></span><br><span class="line">android:path=<span class="string">&quot;string&quot;</span></span><br><span class="line">android:pathPattern=<span class="string">&quot;string&quot;</span></span><br><span class="line">android:pathPrefix=<span class="string">&quot;string&quot;</span></span><br><span class="line">android:mimeType=<span class="string">&quot;string&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>主要由mimeType和URI组成，其中mimeType代表媒体类型，而URI的结构也复杂，大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;scheme&gt;:<span class="comment">//&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;]|[&lt;pathPrefix&gt;]|[pathPattern]</span></span><br></pre></td></tr></table></figure>

<p>例如content://com.example.project:200/folder/subfolder/etc</p>
<p>scheme、host、port分别表示URI的模式、主机名和端口号，其中如果scheme或者host未指定那么URI就无效。path、pathPattern、pathPrefix都是表示路径信息，其中path表示完整的路径信息，pathPrefix表示路径的前缀信息；pathPattern表示完整的路径，但是它里面包含了通配符(*)。</p>
<h3 id="3-4-1-匹配规则"><a href="#3-4-1-匹配规则" class="headerlink" title="3.4.1. 匹配规则"></a>3.4.1. 匹配规则</h3><p>Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某一个data。URI有默认的scheme！</p>
<p>如果过滤规则中的mimeType指定为image/* 或者 text/* 等这种类型的话，那么即使过滤规则中没有指定URI，URI有默认的scheme是content和file！如果过滤规则中指定了scheme的话那就不是默认的scheme了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//URI有默认值</span></span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;data android:mimeType=<span class="string">&quot;image/*&quot;</span>/&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"><span class="comment">//URI默认值被覆盖</span></span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;data android:mimeType=<span class="string">&quot;image/*&quot;</span> android:scheme=<span class="string">&quot;http&quot;</span> .../&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p>如果要为Intent指定完整的data，必须要调用setDataAndType方法！不能先调用setData然后调用setType，因为这两个方法会彼此清除对方的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intent.setDataAndType(Uri.parse(<span class="string">&quot;file://abc&quot;</span>), <span class="string">&quot;image/png&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="4-知识扩展"><a href="#4-知识扩展" class="headerlink" title="4. 知识扩展"></a>4. 知识扩展</h1><h2 id="4-1-如何判断是否有Activity能够匹配我们的隐式Intent？"><a href="#4-1-如何判断是否有Activity能够匹配我们的隐式Intent？" class="headerlink" title="4.1. 如何判断是否有Activity能够匹配我们的隐式Intent？"></a>4.1. 如何判断是否有Activity能够匹配我们的隐式Intent？</h2><ul>
<li>PackageManager的resolveActivity方法或者Intent的resolveActivity方法：如果找不到就会返回null。</li>
<li>PackageManager的queryIntentActivities方法：它返回所有成功匹配的Activity信息。</li>
<li>针对Service和BroadcastReceiver等组件，PackageManager同样提供了类似的方法去获取成功匹配的组件信息，例如queryIntentServices、queryBroadcastReceivers等方法。</li>
<li>有一类action和category比较重要，它们在一起用来标明这是一个入口Activity，并且会出现在系统的应用列表中。</li>
</ul>
<h2 id="4-2-Activity缓存方法"><a href="#4-2-Activity缓存方法" class="headerlink" title="4.2. Activity缓存方法"></a>4.2. Activity缓存方法</h2><p>Activity的 onSaveInstanceState()和onRestoreInstanceState()并不是生命周期方法，它们不同于 onCreate()、onPause()等生命周期方法，并不一定会被触发。</p>
<p>当应用遇到意外情况（如：内存不足（LOW情况下低优先级Activity被销毁）、用户直接按Home键）由系统销毁一个Activity时onSaveInstanceState()会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。通常onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。</p>
<p>onRestoreInstanceState(Bundle savedInstanceState)只有在activity确实是被系统回收，重新创建activity的情况下才会被调用。比如屏幕旋转、LOW情况下低优先级Activity被销毁。</p>
<p>在工作的项目中，有用到在MainActivity页面中保存Fragment示例，以便后续操作快速恢复和复用。onSaveInstanceState()被执行的场景有哪些：</p>
<ul>
<li>当用户按下HOME键时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">03.893</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPause</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">04.214</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onSaveInstanceState</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">04.222</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onStop</span><br></pre></td></tr></table></figure>

<ul>
<li>长按HOME键，选择运行其他的程序时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">31</span>:<span class="number">33.314</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPause</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">31</span>:<span class="number">33.505</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onSaveInstanceState</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">31</span>:<span class="number">33.507</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onStop</span><br></pre></td></tr></table></figure>

<ul>
<li>锁屏时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">39.137</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPause</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">39.198</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onSaveInstanceState</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">39.223</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onStop</span><br></pre></td></tr></table></figure>

<ul>
<li>从activity A中启动一个新的activity时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">18.106</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onCreate</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">18.157</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onContentChanged</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">18.164</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onStart</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">18.165</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPostCreate</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">18.168</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onResume</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">18.170</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPostResume</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">18.190</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onAttachedToWindow</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">18.273</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onCreateOptionsMenu</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">18.273</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPrepareOptionsMenu</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">19.954</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPause</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">19.986</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/SubActivity: onCreate</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">20.023</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/SubActivity: onContentChanged</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">20.025</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/SubActivity: onStart</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">20.025</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/SubActivity: onPostCreate</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">20.028</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/SubActivity: onResume</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">20.028</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/SubActivity: onPostResume</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">20.047</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/SubActivity: onAttachedToWindow</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">20.095</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/SubActivity: onCreateOptionsMenu</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">20.096</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/SubActivity: onPrepareOptionsMenu</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">20.479</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onSaveInstanceState</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">20.483</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onStop</span><br></pre></td></tr></table></figure>

<ul>
<li>屏幕方向切换时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">27.555</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onCreate</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">27.835</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onContentChanged</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">27.869</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onStart</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">27.869</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPostCreate</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">27.877</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onResume</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">27.878</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPostResume</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">27.916</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onAttachedToWindow</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">28.017</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onCreateOptionsMenu</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">28.017</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPrepareOptionsMenu</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.543</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPause</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.544</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onSaveInstanceState</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.554</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onStop</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.555</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onDestroy</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.592</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onCreate</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.639</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onContentChanged</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.647</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onStart</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.648</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onRestoreInstanceState</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.648</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPostCreate</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.652</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onResume</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.653</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPostResume</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.675</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onAttachedToWindow</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.740</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onCreateOptionsMenu</span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">48.740</span> <span class="number">12648</span>-<span class="number">12648</span>/com.leeeyou.sampleoflifecycle E/MainActivity: onPrepareOptionsMenu</span><br></pre></td></tr></table></figure>

<h2 id="4-3-任务栈"><a href="#4-3-任务栈" class="headerlink" title="4.3. 任务栈"></a>4.3. 任务栈</h2><h3 id="4-3-1-任务（Task）是个什么样的概念"><a href="#4-3-1-任务（Task）是个什么样的概念" class="headerlink" title="4.3.1. 任务（Task）是个什么样的概念"></a>4.3.1. 任务（Task）是个什么样的概念</h3><p>Activity是Android应用程序的基础组件之一，在应用程序运行时，每一个Activity代表一个用户操作。用户为了完成某个功能而执行的一系列操作就形成了一个Activity序列，这个序列在Android应用程序中就称之为任务，它是从用户体验的角度出发，把一组相关的Activity组织在一起而抽象出来的概念。</p>
<p>这个task存在于一个称为back stack的数据结构中，也就是说framework是以栈的形式管理用户开启的activity。这个栈的基本行为是:当用户在多个activity之间跳转时，执行压栈操作，当用户按返回键时，执行出栈操作。</p>
<p>在开发Android应用程序时，还可以配置Activity任务属性，即告诉系统它是要在新的任务中启动还是在已有的任务中启动，甚至是其它的Activity能不能与它共享同一个任务。</p>
<h3 id="4-3-2-task的特点"><a href="#4-3-2-task的特点" class="headerlink" title="4.3.2. task的特点"></a>4.3.2. task的特点</h3><p>task是可以跨应用的，这正是task存在的一个重要原因。有的Activity虽然不在同一个app中，但为了保持用户操作的连贯性，把他们放在同一个任务中。最后任务（Task）不仅可以跨应用（Application），还可以跨进程（Process）。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索-第2章-IPC机制</title>
    <url>/iBlogWebsite/2016/02/28/2016/2016-02-28-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0-IPC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2016/wallpaper/2016-02-28.jpg?raw=true" alt="2016-02-28"></p>
<h1 id="1-IPC简介"><a href="#1-IPC简介" class="headerlink" title="1. IPC简介"></a>1. IPC简介</h1><ul>
<li>IPC不是Android特有的，任何一个操作系统都需要有相应的IPC机制。</li>
<li>在Android中有特色的进程间通信方式就是Binder了，通过Binder可以轻松地实现进程间通信。</li>
<li>除了Binder，Android还支持Socket，通过Socket也可以实现任意两个终端或两个进程之间的通信。</li>
</ul>
<h1 id="2-多进程模式"><a href="#2-多进程模式" class="headerlink" title="2. 多进程模式"></a>2. 多进程模式</h1><h2 id="2-1-开启多进程模式"><a href="#2-1-开启多进程模式" class="headerlink" title="2.1. 开启多进程模式"></a>2.1. 开启多进程模式</h2><ul>
<li>在清单文件中配置android:process属性。</li>
<li>以: 开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中。</li>
<li>而进程名不以: 开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。</li>
</ul>
<h2 id="2-2-多进程模式运行机制"><a href="#2-2-多进程模式运行机制" class="headerlink" title="2.2. 多进程模式运行机制"></a>2.2. 多进程模式运行机制</h2><h3 id="2-2-1-多进程造成的问题"><a href="#2-2-1-多进程造成的问题" class="headerlink" title="2.2.1. 多进程造成的问题"></a>2.2.1. 多进程造成的问题</h3><ul>
<li>静态成员和单例模式完全失效。</li>
<li>线程同步机制完全失效。</li>
<li>SharedPreferences的可靠性下降。</li>
<li>Application会多次创建，分配独立虚拟机，启动一个应用。</li>
</ul>
<h3 id="2-2-2-理解同一个应用间的多进程"><a href="#2-2-2-理解同一个应用间的多进程" class="headerlink" title="2.2.2. 理解同一个应用间的多进程"></a>2.2.2. 理解同一个应用间的多进程</h3><p>它就相当于两个不同的应用采用了SharedUID的模式，这样能够更加直接地理解多进程模式的本质。</p>
<h3 id="2-2-3-实现跨进程通信的方式"><a href="#2-2-3-实现跨进程通信的方式" class="headerlink" title="2.2.3. 实现跨进程通信的方式"></a>2.2.3. 实现跨进程通信的方式</h3><ul>
<li>Intent</li>
<li>共享文件</li>
<li>SharedPreferences</li>
<li>基于Binder的Messager和AIDL</li>
<li>Socket</li>
</ul>
<h1 id="3-IPC基础概念介绍"><a href="#3-IPC基础概念介绍" class="headerlink" title="3. IPC基础概念介绍"></a>3. IPC基础概念介绍</h1><h2 id="3-1-Serializable接口"><a href="#3-1-Serializable接口" class="headerlink" title="3.1. Serializable接口"></a>3.1. Serializable接口</h2><ul>
<li>Java所提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化。</li>
<li>序列化的时候系统会把当前类的SerialVersionUID写入序列化的文件中。</li>
<li>当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致。</li>
<li>注意：首先静态成员变量属于类不属于对象，所以不会参与序列化过程；其次用transient关键字标记的成员变量不参与序列化过程。</li>
</ul>
<h2 id="3-2-Parcelable接口"><a href="#3-2-Parcelable接口" class="headerlink" title="3.2. Parcelable接口"></a>3.2. Parcelable接口</h2><ul>
<li>序列化功能由writeToParcel方法来完成，最终是通过Parcel中的一系列write方法来完成。</li>
<li>反序列化功能由CREATOR来完成，其内部标明了如何创建序列化对象和数组，并通过Parcel的一系列read方法来完成反序列化过程。</li>
</ul>
<p>选择序列化方法的原则</p>
<ul>
<li>在使用内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。</li>
<li>Serializable在序列化的时候使用了反射，序列化的过程较慢，会产生大量的临时变量，从而引起频繁的GC。</li>
<li>但是在要将数组存储到外部磁盘的情况下，还是首先Serializable。因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。</li>
</ul>
<h2 id="3-3-Binder"><a href="#3-3-Binder" class="headerlink" title="3.3. Binder"></a>3.3. Binder</h2><h3 id="3-3-1-简介"><a href="#3-3-1-简介" class="headerlink" title="3.3.1. 简介"></a>3.3.1. 简介</h3><ul>
<li>直观来说，Binder是Android中的一个类，它实现了IBinder接口。</li>
<li>从IPC角度来说，Binder是Android中的一种跨进程通信方式。</li>
<li>Binder可以理解为一个虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有。</li>
<li>从Android Framework角度来说，Binder是ServiceManager连接各种Manager和ManagerService的桥梁。</li>
<li>从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务和数据，这里的服务包括普通服务和机遇AIDL的服务。</li>
</ul>
<h3 id="3-3-2-手动实现一个Binder"><a href="#3-3-2-手动实现一个Binder" class="headerlink" title="3.3.2. 手动实现一个Binder"></a>3.3.2. 手动实现一个Binder</h3><ul>
<li><p>声明一个AIDL性质的接口，只需要继承IInterface接口即可</p>
</li>
<li><p>实现Stub类和Stub类中的Proxy代理类</p>
<ul>
<li>asInterface：<strong>用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。</strong></li>
<li>asBinder：此方法返回当前Binder对象。</li>
<li>onTransact：<strong>这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。</strong> 该方法的原型为 public Boolean onTransact(int code , android.os.Parcel data , android.os.Parcel reply , int falgs)。服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出所需所需的参数（如果目标方法有参数的话），然后执行目标方法。当目标方法执行完毕后，就想reply中写入返回值（如果目标方法有返回值的话），onTransact方法的执行过程就是这样的。<strong>需要注意的是，如果此方法返回false，那么客户端的请求会失败，因此我们可以利用这个特性来做权限校验</strong>，毕竟我们也不希望随便一个进程都能远程调用我们的服务。</li>
<li>Proxy类</li>
</ul>
</li>
</ul>
<p>下面代码是IBookManager.aidl文件生成java文件的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.leeeyou.sampleofservice.book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leeeyou.sampleofservice.book.Book;</span><br><span class="line"><span class="keyword">import</span> com.leeeyou.sampleofservice.book.IOnNewBookArrivedListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IBookManager</span> &#123;</span><br><span class="line">     List&lt;Book&gt; <span class="title function_">getBookList</span><span class="params">()</span>;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(in Book book)</span>;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">registerListener</span><span class="params">(IOnNewBookArrivedListener listener)</span>;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">unregisterListener</span><span class="params">(IOnNewBookArrivedListener listener)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IBookManager.aidl编译后的java文件</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file is auto-generated.  DO NOT MODIFY.</span></span><br><span class="line"><span class="comment"> * Original file: /Users/leeeyou/github/SampleOfService/app/src/main/aidl/com/leeeyou/sampleofservice/book/IBookManager.aidl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.leeeyou.sampleofservice.book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBookManager</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.IInterface &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.Binder <span class="keyword">implements</span> <span class="title class_">com</span>.leeeyou.sampleofservice.book.IBookManager &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.<span class="type">String</span> <span class="variable">DESCRIPTOR</span> <span class="operator">=</span> <span class="string">&quot;com.leeeyou.sampleofservice.book.IBookManager&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an com.leeeyou.sampleofservice.book.IBookManager interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.leeeyou.sampleofservice.book.IBookManager <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="literal">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.leeeyou.sampleofservice.book.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.leeeyou.sampleofservice.book.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.leeeyou.sampleofservice.book.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">            java.lang.<span class="type">String</span> <span class="variable">descriptor</span> <span class="operator">=</span> DESCRIPTOR;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    java.util.List&lt;com.leeeyou.sampleofservice.book.Book&gt; _result = <span class="built_in">this</span>.getBookList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    com.leeeyou.sampleofservice.book.Book _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.leeeyou.sampleofservice.book.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">this</span>.addBook(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_registerListener: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    com.leeeyou.sampleofservice.book.IOnNewBookArrivedListener _arg0;</span><br><span class="line">                    _arg0 = com.leeeyou.sampleofservice.book.IOnNewBookArrivedListener.Stub.asInterface(data.readStrongBinder());</span><br><span class="line">                    <span class="built_in">this</span>.registerListener(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_unregisterListener: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    com.leeeyou.sampleofservice.book.IOnNewBookArrivedListener _arg0;</span><br><span class="line">                    _arg0 = com.leeeyou.sampleofservice.book.IOnNewBookArrivedListener.Stub.asInterface(data.readStrongBinder());</span><br><span class="line">                    <span class="built_in">this</span>.unregisterListener(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">com</span>.leeeyou.sampleofservice.book.IBookManager &#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.String <span class="title function_">getInterfaceDescriptor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;com.leeeyou.sampleofservice.book.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.leeeyou.sampleofservice.book.Book&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.leeeyou.sampleofservice.book.Book.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(com.leeeyou.sampleofservice.book.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((book != <span class="literal">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerListener</span><span class="params">(com.leeeyou.sampleofservice.book.IOnNewBookArrivedListener listener)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeStrongBinder((((listener != <span class="literal">null</span>)) ? (listener.asBinder()) : (<span class="literal">null</span>)));</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_registerListener, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterListener</span><span class="params">(com.leeeyou.sampleofservice.book.IOnNewBookArrivedListener listener)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeStrongBinder((((listener != <span class="literal">null</span>)) ? (listener.asBinder()) : (<span class="literal">null</span>)));</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_unregisterListener, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSACTION_getBookList</span> <span class="operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSACTION_addBook</span> <span class="operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSACTION_registerListener</span> <span class="operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSACTION_unregisterListener</span> <span class="operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.leeeyou.sampleofservice.book.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(com.leeeyou.sampleofservice.book.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerListener</span><span class="params">(com.leeeyou.sampleofservice.book.IOnNewBookArrivedListener listener)</span> <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterListener</span><span class="params">(com.leeeyou.sampleofservice.book.IOnNewBookArrivedListener listener)</span> <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>AIDL并不是实现Binder的必需品，AIDL文件的本质是系统为我们提供一种快速实现Binder的工具而已。</strong></p>
</blockquote>
<h3 id="3-3-3-两个重要的方法"><a href="#3-3-3-两个重要的方法" class="headerlink" title="3.3.3. 两个重要的方法"></a>3.3.3. 两个重要的方法</h3><ul>
<li>linkToDeath：给Binder设置一个死亡代理，当Binder死亡时，我们就会收到通知。</li>
<li>unlinkToDeath：当Binder连接断裂时，使用此方法解绑对象。</li>
</ul>
<h1 id="4-Android中的IPC方式"><a href="#4-Android中的IPC方式" class="headerlink" title="4. Android中的IPC方式"></a>4. Android中的IPC方式</h1><h2 id="4-1-使用Bundle"><a href="#4-1-使用Bundle" class="headerlink" title="4.1. 使用Bundle"></a>4.1. 使用Bundle</h2><p>Activity、Service、Receiver都支持在Intent中传递Bundle数据，由于Bundle实现了Parcelable接口，所以它可以方便地在不同的进程间传输。</p>
<h2 id="4-2-使用文件共享"><a href="#4-2-使用文件共享" class="headerlink" title="4.2. 使用文件共享"></a>4.2. 使用文件共享</h2><p>通过文件共享这种方式来共享数据对文件格式是没有具体要求的，比如可以是文本文件，也可以是XML文件，只要读/写双方约定数据格式即可。</p>
<p>通过文件共享的方式也是有局限性的，比如并发读/写的问题。因此我们要尽量避免并发写这种情况的发生或者考虑使用线程同步来限制多个线程的写操作。</p>
<p>文件共享方式适合在对数据同步要求不高的进程之间进行通信，并要妥善处理并发读/写的问题。</p>
<p>SharedPreferences是Android中提供的轻量级存储方案，它通过键值对的方式来存储数据，在底层实现上它采用XML文件来存储键值对。</p>
<p>从本质上来说，SharedPreferences也属于文件的一种，但是由于系统对它的读/写有一定的缓存策略，<strong>即在内存中会有一份SharedPrefereces文件的缓存，因此在多进程模式下，系统对它的读/写就变得不可靠，当面对高并发的读/写访问，SharedPreferences有很大几率会丢失数据，</strong> 因此，不建议在进程间通信中使用SharedPreferences。</p>
<h2 id="4-3-使用Messenger"><a href="#4-3-使用Messenger" class="headerlink" title="4.3. 使用Messenger"></a>4.3. 使用Messenger</h2><p>可以在不同进程中传递Message对象，在Message中放入我们需要传递的数据，就可以实现数据的进程间传递。Messenger是一种轻量级的IPC方案，它的底层实现是AIDL。</p>
<p>实现一个Messenger由如下几个步骤：</p>
<p>服务端进程</p>
<blockquote>
<p>在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler并通过它来创建一个Messenger对象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。</p>
</blockquote>
<p>客户端进程</p>
<blockquote>
<p>首先要绑定服务端的Service，绑定成功后，用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以想服务端发送消息了。</p>
</blockquote>
<p>数据传递细节：</p>
<p>在Android2.2以前object字段不支持跨进程传输，即便是2.2以后，也仅仅是系统提供的实现了Parcelable接口的对象才能通过它来传输。这就意味着我们自定义的Parcelable对象是无法通过object字段来传输的。</p>
<p>Messenger是以串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍只能一个个处理，如果有大量的并发请求，那么用Messenger就不太合适了。</p>
<p><strong>Messenger的作用主要是为了传递消息，很多时候我们可能需要跨进程调用服务端的方法，这种情形用Messenger无法做到。</strong></p>
<p>具体代码实现可参考：<br><a href="https://blog.csdn.net/lmj623565791/article/details/47017485">Android 基于Message的进程间通信 Messenger完全解析</a></p>
<h2 id="4-4-使用AIDL"><a href="#4-4-使用AIDL" class="headerlink" title="4.4. 使用AIDL"></a>4.4. 使用AIDL</h2><p>可以参考代码：<br><a href="https://github.com/Leeeyou/SampleOfService">SampleOfService</a></p>
<h3 id="4-4-1-基本使用"><a href="#4-4-1-基本使用" class="headerlink" title="4.4.1. 基本使用"></a>4.4.1. 基本使用</h3><p>服务端</p>
<blockquote>
<p>创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明。最后在Service中实现这个AIDL接口即可。</p>
</blockquote>
<p>客户端</p>
<blockquote>
<p>绑定服务端的Service，将服务端返回的Binder对象转成AIDL接口所属的类型，调用AIDL中的方法。</p>
</blockquote>
<p>AIDL接口的创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.sampleofservice.book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leeeyou.sampleofservice.book.Book;</span><br><span class="line"><span class="keyword">import</span> com.leeeyou.sampleofservice.book.IOnNewBookArrivedListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IBookManager</span> &#123;</span><br><span class="line">     List&lt;Book&gt; <span class="title function_">getBookList</span><span class="params">()</span>;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(in Book book)</span>;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">registerListener</span><span class="params">(IOnNewBookArrivedListener listener)</span>;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">unregisterListener</span><span class="params">(IOnNewBookArrivedListener listener)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AIDL文件支持的数据类型</p>
<ul>
<li>基本数据类型。</li>
<li>String和CharSequence。</li>
<li>List:只支持ArrayList，里面每个元素都必须能够被AIDL支持。</li>
<li>Map:只支持HashMap，里面的每个元素都必须被AIDL支持，包括key和value。</li>
<li>Parcelable:所有实现了Parcelable接口的对象。</li>
<li>AIDL:<strong>所有的AIDL接口本身也可以在AIDL文件中使用。</strong></li>
</ul>
<p>除了基本数据类型，其他类型的参数必须表上方向：in、out或者inout。</p>
<p>如果AIDL文件中用到了自定义的Parcelable对象，那么必须新建一个和它同名的AIDL文件，并在其中声明它为Parcelable类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.sampleofservice.book;</span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure>

<p><strong>AIDL接口中只支持方法，不支持声明静态变量，这一点区别于传统的接口。</strong></p>
<p>AIDL包结构在服务端和客户端要保持一致，否则运行会出错，这是因为客户端需要反序列化服务端中和AIDL接口相关的所有类，如果类的完整路径不一样的话，就无法成功反序列，程序也就无法正常运行。</p>
<p>远程服务端Service的运行流程</p>
<p>1 客户端的实现：先绑定远程服务，将服务端返回的Binder对象转换成AIDL接口，然后就可以通过这个接口去调用服务端的远程方法了。</p>
<p>2 创建Service，Kotlin版本的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.sampleofservice.book</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager</span><br><span class="line"><span class="keyword">import</span> android.os.*</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookManagerService</span> : Service() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">mIsServiceDestroyed</span> <span class="operator">=</span> AtomicBoolean(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">mBookList</span> <span class="operator">=</span> CopyOnWriteArrayList&lt;Book&gt;()</span><br><span class="line">    <span class="comment">// private CopyOnWriteArrayList&lt;IOnNewBookArrivedListener&gt; mListenerList =</span></span><br><span class="line">    <span class="comment">// new CopyOnWriteArrayList&lt;IOnNewBookArrivedListener&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">mListenerList</span> <span class="operator">=</span> RemoteCallbackList&lt;IOnNewBookArrivedListener&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">mBinder</span> <span class="operator">=</span> object : IBookManager.Stub() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(RemoteException::class)</span></span><br><span class="line">        override fun <span class="title function_">getBookList</span><span class="params">()</span>: List&lt;Book&gt; &#123;</span><br><span class="line">            <span class="comment">//模拟耗时操作</span></span><br><span class="line">            SystemClock.sleep(<span class="number">5000</span>)</span><br><span class="line">            <span class="keyword">return</span> mBookList</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(RemoteException::class)</span></span><br><span class="line">        override fun <span class="title function_">addBook</span><span class="params">(book: Book)</span> &#123;</span><br><span class="line">            mBookList.add(book)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(RemoteException::class)</span></span><br><span class="line">        override fun <span class="title function_">onTransact</span><span class="params">(code: Int, data: Parcel, reply: Parcel?, flags: Int)</span>: Boolean &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">check</span> <span class="operator">=</span> checkCallingOrSelfPermission(<span class="string">&quot;com.leeeyou.sampleofservice.book.permission.ACCESS_BOOK_SERVICE&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onTransact ，Check permission failed&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> packageName: String? = <span class="literal">null</span></span><br><span class="line">            <span class="type">val</span> <span class="variable">packages</span> <span class="operator">=</span> packageManager.getPackagesForUid(Binder.getCallingUid())</span><br><span class="line">            <span class="keyword">if</span> (packages != <span class="literal">null</span> &amp;&amp; packages.isNotEmpty()) &#123;</span><br><span class="line">                packageName = packages[<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (packageName == <span class="literal">null</span> || !packageName.startsWith(<span class="string">&quot;com.leeeyou.sampleofservice&quot;</span>)) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onTransact ，Check that packageName failed : &quot;</span> + packageName!!)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onTransact ，Check that packageName passed : $packageName&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(RemoteException::class)</span></span><br><span class="line">        override fun <span class="title function_">registerListener</span><span class="params">(listener: IOnNewBookArrivedListener)</span> &#123;</span><br><span class="line">            mListenerList.register(listener)</span><br><span class="line">            <span class="type">val</span> <span class="variable">count</span> <span class="operator">=</span> mListenerList.beginBroadcast()</span><br><span class="line">            mListenerList.finishBroadcast()</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;registerListener, current size:$count&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(RemoteException::class)</span></span><br><span class="line">        override fun <span class="title function_">unregisterListener</span><span class="params">(listener: IOnNewBookArrivedListener)</span> &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">success</span> <span class="operator">=</span> mListenerList.unregister(listener)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;unregister success.&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;not found, can not unregister.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">val</span> <span class="variable">count</span> <span class="operator">=</span> mListenerList.beginBroadcast()</span><br><span class="line">            mListenerList.finishBroadcast()</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;unregisterListener, current size:$count&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        mBookList.add(Book(<span class="number">1</span>, <span class="string">&quot;Android&quot;</span>))</span><br><span class="line">        mBookList.add(Book(<span class="number">2</span>, <span class="string">&quot;Ios&quot;</span>))</span><br><span class="line">        Thread(ServiceWorker()).start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onBind</span><span class="params">(intent: Intent)</span>: IBinder? &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onBind&quot;</span>)</span><br><span class="line">        <span class="type">val</span> <span class="variable">check</span> <span class="operator">=</span> checkCallingOrSelfPermission(<span class="string">&quot;com.leeeyou.sampleofservice.book.permission.ACCESS_BOOK_SERVICE&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onBind ，Check permission failed&quot;</span>)</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onBind ，Check permission passed&quot;</span>)</span><br><span class="line">            mBinder</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        mIsServiceDestroyed.set(<span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Throws(RemoteException::class)</span></span><br><span class="line">    <span class="keyword">private</span> fun <span class="title function_">onNewBookArrived</span><span class="params">(book: Book)</span> &#123;</span><br><span class="line">        mBookList.add(book)</span><br><span class="line">        <span class="comment">//beginBroadcast 与 finishBroadcast 要配套使用</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">count</span> <span class="operator">=</span> mListenerList.beginBroadcast()</span><br><span class="line">        <span class="keyword">for</span> (i in <span class="number">0</span> until count) &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">listener</span> <span class="operator">=</span> mListenerList.getBroadcastItem(i)</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    listener.onNewBookArrived(book)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: RemoteException) &#123;</span><br><span class="line">                    e.printStackTrace()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mListenerList.finishBroadcast()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> inner <span class="keyword">class</span> <span class="title class_">ServiceWorker</span> : Runnable &#123;</span><br><span class="line">        override fun <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// do background processing here.....</span></span><br><span class="line">            <span class="keyword">while</span> (!mIsServiceDestroyed.get()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">                    e.printStackTrace()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">val</span> <span class="variable">bookId</span> <span class="operator">=</span> mBookList.size + <span class="number">1</span></span><br><span class="line">                <span class="type">val</span> <span class="variable">newBook</span> <span class="operator">=</span> Book(bookId, <span class="string">&quot;new book#$bookId&quot;</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    onNewBookArrived(newBook)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: RemoteException) &#123;</span><br><span class="line">                    e.printStackTrace()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">val</span> <span class="variable">TAG</span> <span class="operator">=</span> BookManagerService::class.java.simpleName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AIDL方法是在服务端的Binder线程池中运行的，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以我们要在AIDL方法中处理线程同步，而我们这里直接使用CopyOnWriteArrayList来进行自动的线程同步。</p>
<p>在Binder中会按照List的规则去访问数据，并最终形成一个新的ArrayList传递给客户端。</p>
<h3 id="4-4-2-AIDL中增加并删除Listener"><a href="#4-4-2-AIDL中增加并删除Listener" class="headerlink" title="4.4.2. AIDL中增加并删除Listener"></a>4.4.2. AIDL中增加并删除Listener</h3><p>模仿观察者模式，当服务端有新的内容更新时，去通知客户端。</p>
<ul>
<li>创建一个IOnNewBookArrivedListener.aidl文件。</li>
<li>在原AIDL接口中增加两个新方法：注册监听器和注销监听器。</li>
<li>修改服务端中的Service的实现，针对上面增加的两个新方法。</li>
<li>最后修改客户端的代码，客户端要注册监听器到远程服务端，在activity退出时解除这个注册。</li>
</ul>
<p>为了便于UI操作，需要有一个handler可以在onNewBookArrived执行的时候，切换到客户端主线程执行。</p>
<h3 id="4-4-3-避免ANR和无响应"><a href="#4-4-3-避免ANR和无响应" class="headerlink" title="4.4.3. 避免ANR和无响应"></a>4.4.3. 避免ANR和无响应</h3><p><strong>不管是客户端还是服务端，通过Binder通信时都应该考虑耗时操作阻塞主线程导致ANR的问题，都需要将耗时任务放到子线程中执行。</strong></p>
<h3 id="4-4-4-Binder意外死亡处理方式"><a href="#4-4-4-Binder意外死亡处理方式" class="headerlink" title="4.4.4. Binder意外死亡处理方式"></a>4.4.4. Binder意外死亡处理方式</h3><p>给Binder设置DeathRecipient监听，当Binder死亡时，我们会收到binderDied方法的回调，在binderDied方法中我们可以重连远程服务。</p>
<p>另一种方法是在onServiceDisconnected中重连远程服务。</p>
<p><strong>这两种方法的区别在于：onServiceDisconnected在客户端的UI线程中被回调，而binderDied在客户端的binder线程池中被回调。也就是说，在binderDied方法中我们不能访问UI。</strong></p>
<h3 id="4-4-5-权限验证"><a href="#4-4-5-权限验证" class="headerlink" title="4.4.5. 权限验证"></a>4.4.5. 权限验证</h3><p>在onBinder中验证，验证不通过就直接返回null，这样验证失败的客户端直接无法绑定服务，至于验证方式可以有多种，比如使用permission验证。</p>
<p>第二种方法在服务端的onTransact方法中进行权限验证，如果验证失败就直接返回false，这样服务端就不会终止执行AIDL中的方法从而达到保护服务端的效果。</p>
<ul>
<li>permission验证</li>
<li>采用Uid和Pid来做验证</li>
</ul>
<h2 id="4-5-使用ContentProvider"><a href="#4-5-使用ContentProvider" class="headerlink" title="4.5. 使用ContentProvider"></a>4.5. 使用ContentProvider</h2><p>ContentProvider是Android中提供的专门用于不同应用间进行数据共享的方式。</p>
<p>和Messenger一样，ContentProvider的底层实现同样也是Binder，但是它的使用过程要比AIDL简单许多，因为系统底层的封装，我们无需关心底层细节即可轻松实现IPC。</p>
<h2 id="4-6-使用Socket"><a href="#4-6-使用Socket" class="headerlink" title="4.6. 使用Socket"></a>4.6. 使用Socket</h2><p>还可以通过Socket实现不通机器以及不同网络之间的数据传递。</p>
<h1 id="5-Binder连接池"><a href="#5-Binder连接池" class="headerlink" title="5. Binder连接池"></a>5. Binder连接池</h1><p>问题：Service是系统四大组件之一，本身就是一种系统资源，大多的service会使得我们的应用看起来很重量级，因为正在运行的Service可以在应用详情页看到，当我们的应用详情显示有10个服务正在运行时，这看起来并不是什么好事。针对上述问题，我们需要减少Service的数量，将所有的AIDL放在同一个Service去管理。</p>
<h2 id="5-1-工作机制"><a href="#5-1-工作机制" class="headerlink" title="5.1. 工作机制"></a>5.1. 工作机制</h2><p>每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象。</p>
<p>对于服务端来说，只需要一个Service就可以了，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给他们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。</p>
<h2 id="5-2-实现步骤"><a href="#5-2-实现步骤" class="headerlink" title="5.2. 实现步骤"></a>5.2. 实现步骤</h2><ul>
<li>首先，为每个业务模块创建AIDL接口并实现此接口及其业务方法。</li>
<li>创建IBinderPool的AIDL接口，定义IBinder queryBinder(int BinderCode)方法。外部通过调用此方法传入对应的code值来获取对应的Binder对象。</li>
<li>创建BinderPoolService，通过new BinderPool.BinderPoolImpl实例化Binder对象，通过onBind方法返回出去。</li>
<li>创建BinderPool类，单例模式，在构造方法中绑定Service，在onServiceConnected方法获取到BinderPoolImpl对象，这个BinderPoolImpl类是BinderPool的内部类，并实现了IBinderPool的业务方法。BinderPool类中向外暴露了queryBinder方法，这个方法其实调用的是BinderPoolImpl对象的queryBinder方法。</li>
</ul>
<h2 id="5-3-Binder连接池图示"><a href="#5-3-Binder连接池图示" class="headerlink" title="5.3. Binder连接池图示"></a>5.3. Binder连接池图示</h2><p><img src="https://github.com/Leeeyou/blog/blob/master/images/2016/code/android-art-exploration-2-binder-connection-pool.webp?raw=true" alt="android-art-exploration-2-binder-connection-pool"></p>
<h1 id="6-选用合适的IPC方式"><a href="#6-选用合适的IPC方式" class="headerlink" title="6. 选用合适的IPC方式"></a>6. 选用合适的IPC方式</h1><p><img src="https://github.com/Leeeyou/blog/blob/master/images/2016/code/android-art-exploration-2-choose-the-right-ipc-method.png?raw=true" alt="android-art-exploration-2-choose-the-right-ipc-method"></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IPC机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第3章 View的事件体系</title>
    <url>/iBlogWebsite/2016/02/29/2016/2016-02-29-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC3%E7%AB%A0%20View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>View的事件体系这一章节主要的内容摘要：<br>1、View基础知识<br>2、View的滑动<br>3、弹性滑动<br>4、View的事件分发机制<br>5、View的滑动冲突  </p>
<p>本次总结采用的方式依然是最爱的脑图方式，利用Xmind整理出来的思维脑图《第三章：View的事件体系》如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/android-art-exploration-chapter-03.png?raw=true" alt="android-art-exploration-chapter-03"></p>
<p><a href="https://pan.baidu.com/s/1JwYd7xdt9zdIgzvfWyd2LA">xmind文件走你</a> 密码: 4y9k</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View的事件体系</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第4章 View的工作原理</title>
    <url>/iBlogWebsite/2016/03/01/2016/2016-03-01-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC4%E7%AB%A0%20View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>View的工作原理这一章节主要的内容摘要：<br>1、ViewRoot和DecorView<br>2、理解MeasureSpec<br>3、View的绘制流程<br>4、自定义View<br>5、View的注意事项</p>
<p>本次总结采用的方式依然是最爱的脑图方式，利用Xmind整理出来的思维脑图《第四章：View的工作原理》如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/android-art-exploration-chapter-04.png?raw=true" alt="android-art-exploration-chapter-04"></p>
<p><a href="https://pan.baidu.com/s/1NvR9JY-B5BiA7gJT1bL8pg">xmind文件走你</a> 密码: ydpm</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View的工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第7章 动画深入分析</title>
    <url>/iBlogWebsite/2016/03/03/2016/2016-03-03-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC7%E7%AB%A0%20%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Android动画深入分析这一章节主要的内容摘要：<br>1、View动画<br>2、View动画的特殊使用场景<br>3、属性动画<br>4、使用动画的注意事项</p>
<p>本次总结采用的方式依然是最爱的脑图方式，利用Xmind整理出来的思维脑图《第七章：Android动画深入分析》如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/android-art-exploration-chapter-07.png?raw=true" alt="android-art-exploration-chapter-07"></p>
<p><a href="https://pan.baidu.com/s/1ddAIOFQWINOcPFFl7GB0Dg">xmind文件走你</a>密码: rsgn</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第5章 理解RemoteViews</title>
    <url>/iBlogWebsite/2016/03/02/2016/2016-03-02-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC5%E7%AB%A0%20%E7%90%86%E8%A7%A3RemoteViews/</url>
    <content><![CDATA[<p>理解RemoteViews这一章节主要的内容摘要：<br>1、RemoteViews的应用<br>2、RemoteViews的内部机制<br>3、RemoteViews的意义</p>
<p>本次总结采用的方式依然是最爱的脑图方式，利用Xmind整理出来的思维脑图《第五章：理解RemoteViews》如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/android-art-exploration-chapter-05.png?raw=true" alt="android-art-exploration-chapter-05"></p>
<p><a href="https://pan.baidu.com/s/1iuOPYvoj_riPY4m1ay9UVg">xmind文件走你</a>密码: 9mli</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RemoteViews</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第8章 理解Window和WindowManager</title>
    <url>/iBlogWebsite/2016/03/04/2016/2016-03-04-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC8%E7%AB%A0%20%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager/</url>
    <content><![CDATA[<p>理解Window和WindowManager这一章节主要的内容摘要：<br>1、Window和WindowManager<br>2、Window的内部机制<br>3、Window的创建过程</p>
<p>本次总结采用的方式依然是最爱的脑图方式，利用Xmind整理出来的思维脑图《第八章：理解Window和WindowManager》如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/android-art-exploration-chapter-08.png?raw=true" alt="android-art-exploration-chapter-08"></p>
<p><a href="https://pan.baidu.com/s/1yuNStoT8W-55uqig5vNBng">xmind文件走你</a> 密码: 3a7a</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Window</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第9章 四大组件的工作过程</title>
    <url>/iBlogWebsite/2016/03/05/2016/2016-03-05-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC9%E7%AB%A0%20%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>四大组件的工作过程这一章节主要的内容摘要：<br>1、四大组件的运行状态<br>2、Activity的工作过程（包括启动流程分析，不过总的来说，都是通过Binder调用的）</p>
<p>本次总结采用的方式依然是最爱的脑图方式，利用Xmind整理出来的思维脑图《第九章：四大组件的工作过程》如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/android-art-exploration-chapter-09.png?raw=true" alt="android-art-exploration-chapter-09"></p>
<p><a href="https://pan.baidu.com/s/1yGWl43-1O_dHNV7lNNe1Xw">xmind文件走你</a> 密码: 3iqn</p>
<p><img src="../../../../images/githubpages/AMS/startActivity%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.jpg" alt="startActivity调用流程"></p>
<p><img src="../../../../images/githubpages/AMS/ActivityThread%E4%B8%8EAMS%E9%80%9A%E4%BF%A1.jpg" alt="ActivityThread与AMS通信"></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>四大组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第10章 消息机制</title>
    <url>/iBlogWebsite/2016/03/06/2016/2016-03-06-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC10%E7%AB%A0%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-Andorid的消息机制概述"><a href="#1-Andorid的消息机制概述" class="headerlink" title="1. Andorid的消息机制概述"></a>1. Andorid的消息机制概述</h1><p>主要是指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper的支撑。</p>
<p>Handler的主要作用是将一个任务切换到某个指定的线程中去执行，为了解决在子线程中无法切换到UI的矛盾，Andorid规定访问UI必须在主线程中执行，ViewRootImpl对UI线程操作做了验证。</p>
<p>系统为什么不允许在子线程中访问UI呢？</p>
<ul>
<li>Andorid的UI控件不是线程安全的，如果在多线程中并发访问会导致其处于不可预期的状态。</li>
<li>为什么不对UI控件加锁访问？因为加锁会使得访问UI的逻辑变复杂，同时锁机制会降低UI访问的效率。</li>
<li>所以最简单高效的方法就是采用单线程模型来处理UI操作。</li>
</ul>
<h1 id="2-Android的消息机制分析"><a href="#2-Android的消息机制分析" class="headerlink" title="2. Android的消息机制分析"></a>2. Android的消息机制分析</h1><h2 id="2-1-ThreadLocal的工作原理"><a href="#2-1-ThreadLocal的工作原理" class="headerlink" title="2.1. ThreadLocal的工作原理"></a>2.1. ThreadLocal的工作原理</h2><p>参考：<a href="https://leeeyou.github.io/iBlogWebsite/2017/04/14/2017/2017-04-14-Java%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/#15-ThreadLocal">Java之基础知识汇总#ThreadLocal</a></p>
<h2 id="2-2-消息队列的工作原理"><a href="#2-2-消息队列的工作原理" class="headerlink" title="2.2. 消息队列的工作原理"></a>2.2. 消息队列的工作原理</h2><ol>
<li>MessageQueue主要包括两个操作：插入和读取。</li>
<li>读取操作本身会伴随着删除操作。</li>
<li>插入和读取对应的方法分别为enqueueMessage和next。</li>
<li>它的内部实现并不是队列，而是一个<strong>单链表的数据结构</strong>来维护消息列表，单链表在插入和删除上比较有优势。</li>
</ol>
<h2 id="2-3-Looper的工作原理"><a href="#2-3-Looper的工作原理" class="headerlink" title="2.3. Looper的工作原理"></a>2.3. Looper的工作原理</h2><ol>
<li>Looper扮演着消息循环的角色。</li>
<li>Looper除了prepare方法外，还提供了prepareMainLooper方法，这个方法主要是给主线程(即ActivityThread)创建Looper使用的。</li>
<li>Looper提供了quit和quitSafely来退出一个Looper。</li>
<li>Looper的loop方法是一个死循环，唯一跳出循环的方式是MessageQueue的next方法返回null。</li>
<li>Looper处理消息的流程<ul>
<li> msg.target.dispatchMessage(msg)</li>
<li> 这里的dispatch是在Looper中执行的，这样就成功将代码逻辑切换到了指定线程</li>
</ul>
</li>
</ol>
<h2 id="2-4-Handler的工作原理"><a href="#2-4-Handler的工作原理" class="headerlink" title="2.4. Handler的工作原理"></a>2.4. Handler的工作原理</h2><ol>
<li>Handler创建时会采用当前线程的Looper构建内部消息循环系统，如果当前没有Looper则报错。</li>
<li>Handler通过post或send将msg投递到MessageQueue中。</li>
<li>Looper轮询消息队列并且运行在创建Handler的线程中，这样一来Handler中的业务逻辑就被切换到创建Handler所在的线程中执行了。</li>
</ol>
<blockquote>
<p>问题：有两个Handler同时被创建，Looper是怎样保证将Msg分发到正确的Handler中执行的？</p>
</blockquote>
<p>下图是Handler机制原理图，包括了线程的数量关系：</p>
<p><img src="https://github.com/Leeeyou/Img/blob/master/Handler%E6%9C%BA%E5%88%B6/2019%E5%B9%B4%E5%A4%8D%E4%B9%A0%E5%BD%92%E6%A1%A3-Handler%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%9B%BE.png?raw=true" alt="2019年复习归档-Handler机制原理图"></p>
<h1 id="3-主线程的消息循环"><a href="#3-主线程的消息循环" class="headerlink" title="3. 主线程的消息循环"></a>3. 主线程的消息循环</h1><p>Android的主线程就是ActivityThread，主线程的入口是main，在main方法中系统会通过Looper.prepareMainLooper()来创建主线程的Looper和一个MessageQueue，并通过Looper.loop()来开启主线程的消息循环。</p>
<p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方式完成ActivityThread的请求后回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息。</p>
<p>H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第11章 线程和线程池</title>
    <url>/iBlogWebsite/2016/03/07/2016/2016-03-07-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC11%E7%AB%A0%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>Andorid中的消息机制这一章节主要的内容摘要：<br>1、Andorid中的线程形态<br>    AsyncTask<br>    AsyncTask的工作原理<br>    HandlerThread<br>    IntentService</p>
<p>2、Andorid中的线程池<br>    线程池优点<br>    ThraedPoolExecutor<br>    线程池的分类</p>
<p>本次总结采用的方式依然是最爱的脑图方式，利用Xmind整理出来的思维脑图《第十一章：Andorid的线程和线程池》如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/android-art-exploration-chapter-11.png?raw=true" alt="android-art-exploration-chapter-11"></p>
<p><a href="https://pan.baidu.com/s/1awKIFsRPqrMUceAen21bfA">xmind文件走你</a> 密码:rq4d</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>线程和线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第12章 Bitmap的加载和Cache</title>
    <url>/iBlogWebsite/2016/03/09/2016/2016-03-09-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC12%E7%AB%A0%20Bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache/</url>
    <content><![CDATA[<p>Bitmap的加载和Cache这一章节主要的内容摘要：<br>1、Bitmap的高效加载<br>2、Andorid中的缓存策略<br>3、ImageLoader的使用</p>
<p>本次总结采用的方式依然是最爱的脑图方式，利用Xmind整理出来的思维脑图《第十二章：Bitmap的加载和Cache》如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/android-art-exploration-chapter-12.png?raw=true" alt="android-art-exploration-chapter-12"></p>
<p><a href="https://pan.baidu.com/s/18gBE0DnQXE6SiEHqrip9hA">xmind文件走你</a> 密码:pw7a</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第13章 综合技术</title>
    <url>/iBlogWebsite/2016/03/10/2016/2016-03-10-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC13%E7%AB%A0%20%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>综合技术这一章节主要的内容摘要：<br>1、使用CrashHandler来获取应用的crash信息<br>2、使用multidex来解决方法数越界<br>3、Android的动态加载技术<br>4、反编译初步</p>
<p>本次总结采用的方式依然是最爱的脑图方式，利用Xmind整理出来的思维脑图《第十三章：综合技术》如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/android-art-exploration-chapter-13.png?raw=true" alt="android-art-exploration-chapter-13"></p>
<p><a href="http://pan.baidu.com/s/1pJYumWr">xmind文件走你</a> 密码:difp</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第14章 JNI和NDK编程</title>
    <url>/iBlogWebsite/2016/03/11/2016/2016-03-11-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC14%E7%AB%A0%20JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>JNI和NDK编程这一章节主要的内容摘要：<br>1、JNI的开发流程<br>2、NDK的开发流程<br>3、JNI的数据类型和类型签名</p>
<p>本次总结采用的方式依然是最爱的脑图方式，利用Xmind整理出来的思维脑图《第十四章：JNI和NDK编程》如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/android-art-exploration-chapter-14.png?raw=true" alt="android-art-exploration-chapter-14"></p>
<p><a href="http://pan.baidu.com/s/1skewezr">xmind文件走你</a> 密码:6ixd</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>JNI</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Android艺术探索 第15章 性能优化</title>
    <url>/iBlogWebsite/2016/03/12/2016/2016-03-12-Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20%E7%AC%AC15%E7%AB%A0%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>Android性能优化这一章节主要的内容摘要：<br>1、Andorid性能优化方法<br>2、内存泄露分析之MAT工具<br>3、提高程序的可维护性</p>
<p>本次总结采用的方式依然是最爱的脑图方式，利用Xmind整理出来的思维脑图《第十五章：Android性能优化》如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2016/code/android-art-exploration-chapter-15.png?raw=true" alt="android-art-exploration-chapter-15"></p>
<p><a href="http://pan.baidu.com/s/1eRuYaR4">xmind文件走你</a> 密码: 43hd</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之栈和队列</title>
    <url>/iBlogWebsite/2016/03/17/2016/2016-03-17-%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="1-栈和队列的基本性质"><a href="#1-栈和队列的基本性质" class="headerlink" title="1. 栈和队列的基本性质"></a>1. 栈和队列的基本性质</h1><ul>
<li>栈是先进后出的  </li>
<li>队列是先进先出的  </li>
<li>栈和队列在实现结构上可以有数组和链表两种形式    <ul>
<li>数组结构实现比较容易，用链表结构较复杂，因为牵扯很多指针操作  </li>
</ul>
</li>
</ul>
<h1 id="2-栈结构的基本操作"><a href="#2-栈结构的基本操作" class="headerlink" title="2. 栈结构的基本操作"></a>2. 栈结构的基本操作</h1><ul>
<li>pop操作</li>
<li>top和peek操作</li>
<li>push操作</li>
<li>size操作</li>
</ul>
<h1 id="3-队列的基本操作"><a href="#3-队列的基本操作" class="headerlink" title="3. 队列的基本操作"></a>3. 队列的基本操作</h1><ul>
<li>与栈操作不同的是，push操作是在队头加入元素</li>
<li>而pop操作是从队列尾部弹出一个元素</li>
<li>栈和队列的基本操作都是时间复杂度为O(1)的操作</li>
<li>双端队列结构是首尾都可以压入和弹出元素</li>
<li>优先级队列是根据元素的优先级值，决定元素的弹出顺序</li>
<li>优先级队列的结构是堆结构，并不是线性结构</li>
</ul>
<h1 id="4-DFS和BFS"><a href="#4-DFS和BFS" class="headerlink" title="4. DFS和BFS"></a>4. DFS和BFS</h1><ul>
<li>深度优先遍历可以用栈实现<ul>
<li>元素入栈的顺序就是深度优先遍历的顺序</li>
</ul>
</li>
<li>宽度优先遍历可以用队列实现<ul>
<li>元素进队列的顺序就是宽度优先遍历的顺序</li>
</ul>
</li>
<li>平时使用的递归函数实际上用到了系统提供的函数系统栈<ul>
<li>递归的过程可以看做递归函数依次进入函数栈的处理过程</li>
<li>所有用递归函数处理的过程都一定可以用非递归的方式实现</li>
</ul>
</li>
</ul>
<h1 id="5-实战演练"><a href="#5-实战演练" class="headerlink" title="5. 实战演练"></a>5. 实战演练</h1><h2 id="5-1-可查询最值的栈"><a href="#5-1-可查询最值的栈" class="headerlink" title="5.1. 可查询最值的栈"></a>5.1. 可查询最值的栈</h2><p><a href="https://leetcode-cn.com/problems/min-stack-lcci/">LeetCode 面试题 03.02. 栈的最小值</a></p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<p><strong>关键点在于用一个stackMin保存每一步的最小值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stackData;</span><br><span class="line">    Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stackData = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackMin = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackMin.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackData.push(x);</span><br><span class="line">        stackMin.push(Math.min(x, stackMin.peek()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stackMin.pop();</span><br><span class="line">        stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackData.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-双栈队列"><a href="#5-2-双栈队列" class="headerlink" title="5.2. 双栈队列"></a>5.2. 双栈队列</h2><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">LeetCode 232. 用栈实现队列</a></p>
<p>编写一个类，只能用两个栈结构实现队列,支持队列的基本操作(push，pop)。</p>
<p>给定一个操作序列ope及它的长度n，其中元素为正数代表push操作，为0代表pop操作，保证操作序列合法且一定含pop操作，请返回pop的结果序列。</p>
<p>测试样例：<br>[1,2,3,0,4,0],6<br>返回：[1,2]</p>
<p><strong>关键点在于stackPop栈只有为空才能往里面压入数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Stack&lt;Integer&gt; stackPush = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> Stack&lt;Integer&gt; stackPop = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] twoStack(<span class="type">int</span>[] ope, <span class="type">int</span> n) &#123;</span><br><span class="line">    Vector&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        temp = ope[i];</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            stackPush.push(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stackPop.isEmpty()) &#123;<span class="comment">//stackPop栈只有为空才能往里面压入数据</span></span><br><span class="line">                <span class="keyword">while</span> (!stackPush.isEmpty()) &#123;</span><br><span class="line">                    stackPop.push(stackPush.pop());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(stackPop.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] mResult = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;result.size();i++)&#123;</span><br><span class="line">        mResult[i] = result.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-栈的反转"><a href="#5-3-栈的反转" class="headerlink" title="5.3. 栈的反转"></a>5.3. 栈的反转</h2><p>实现一个栈的逆序，但是只能用递归函数和这个栈本身的pop操作来实现，而不能自己申请另外的数据结构。<br>给定一个整数数组A即为给定的栈，同时给定它的大小n，请返回逆序后的栈。</p>
<p>测试样例：<br>[4,3,2,1],4<br>返回：[1,2,3,4]</p>
<p><strong>关键点在于编写get()函数获取栈底的值，利用reverse()函数递归将栈中元素逆序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] reverseStack(<span class="type">int</span>[] A, <span class="type">int</span> n) &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        stack.push(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse(stack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        A[i] = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把栈中元素逆序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> get(stack);</span><br><span class="line">    reverse(stack);</span><br><span class="line">    stack.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除栈底元素并返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> get(stack);</span><br><span class="line">        stack.push(last);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-双栈排序"><a href="#5-4-双栈排序" class="headerlink" title="5.4. 双栈排序"></a>5.4. 双栈排序</h2><p><a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci/">LeetCode 面试题 03.05. 栈排序</a></p>
<p>请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。<br>给定一个int[] numbers(C++中为vector<int>)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。</p>
<p>测试样例：<br>[1,2,3,4,5]<br>返回：[5,4,3,2,1]</p>
<p><strong>关键点在于将stackData栈顶的值与stackHelp栈顶值进行大小比较，若大于stackHelp栈顶值，则stackHelp栈顶出栈到stackData中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.stackqueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by LeeeYou on 2016/3/19. 双栈排序练习题</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。</span></span><br><span class="line"><span class="comment"> * 给定一个int[] numbers(C++中为vector&lt;int&gt;)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"> * 返回：[5,4,3,2,1]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoStackSortDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        twoStacksSort(nums);</span><br><span class="line">        System.out.println(twoStacksSort(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">twoStacksSort</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; help = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> number : numbers) &#123;</span><br><span class="line">            stack.push(number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (!help.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!help.isEmpty() &amp;&amp; top &gt; help.peek()) &#123;</span><br><span class="line">                    stack.push(help.pop());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            help.push(top); <span class="comment">// help栈逐渐保存最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(help);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5-滑动窗口"><a href="#5-5-滑动窗口" class="headerlink" title="5.5. 滑动窗口"></a>5.5. 滑动窗口</h2><p>有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。</p>
<p>给定整形数组arr及它的大小n，同时给定w，请返回res数组。保证w小于等于n，同时保证数组大小小于等于500。</p>
<p>测试样例：<br>[4,3,5,4,3,3,6,7],8,3<br>返回：[5,5,5,4,6,7]</p>
<p><strong>关键点在于利用双端队列实现窗口最大值的更新，可达到时间复杂度为O(n)，额外空间复杂度为O(n)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] slide(<span class="type">int</span>[] arr, <span class="type">int</span> n, <span class="type">int</span> w) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || w == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *假设当前数为arr[i],放入规则如下：</span></span><br><span class="line"><span class="comment">     * 1、如果qmax为空，则直接把下标i放入到qmax中</span></span><br><span class="line"><span class="comment">     * 2、如果qmax不为空，取出当前qmax队尾存放的下表j。如果arr[j]&gt;arr[i],直接把下标i放到qmax队尾</span></span><br><span class="line"><span class="comment">     * 3、如果arr[j]&lt;=arr[i],则一直从qmax弹出下标，知道某个下标在qmax中对应的值大于arr[i]为止，，把i放入qmax队尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//双端队列，存放的是数组中的下标值</span></span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n - w + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">resultIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[i] &gt;= arr[qmax.peekLast()]) &#123;</span><br><span class="line">            qmax.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qmax.addLast(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qmax.peekFirst() == i - w) &#123;<span class="comment">//检查队头的下标是否过期</span></span><br><span class="line">            qmax.pollFirst();<span class="comment">//如过期，则弹出队头下标</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= w - <span class="number">1</span>) &#123;</span><br><span class="line">            result[resultIndex++] = arr[qmax.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-构造一棵MaxTree"><a href="#5-6-构造一棵MaxTree" class="headerlink" title="5.6. 构造一棵MaxTree"></a>5.6. 构造一棵MaxTree</h2><p>对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个数和右边比它大的第一个数中更小的一个。若两边都不存在比它大的数，那么它就是树根。请设计O(n)的算法实现这个方法。</p>
<p>给定一个无重复元素的数组A和它的大小n，请返回一个数组，其中每个元素为原数组中对应位置元素在树中的父亲节点的编号，若为根则值为-1。</p>
<p>测试样例：<br>[3,1,4,2],4<br>返回：[2,0,-1,2]</p>
<p><strong>关键点在于寻找左边第一个大的数，将值存放到ALeft;寻找右边第一个大的数，将值存放到ARight。然后每一个数的父节点是它左边第一个比它大的数与右边第一个比它大的数中较小的那个数</strong></p>
<p>证明该方法的的正确性：<br>1、该方法可以生成一棵树，而不是森林。（因为数组中的数值都不同，一个数向上一定可以找到比它大的数，会有一个共同的头部）<br>2、生成的这一棵树是二叉树，而不是多叉树。（任何一个数在单独一侧，孩子的数量都不超过一个）</p>
<p>假设A这棵树在单独一侧，有两个孩子 k1,k2, 假如设在右侧<br>….A……k1…k2…<br>A&gt;k1且A&gt;k2</p>
<p>假设k1&lt;k2<br>根据A&gt;k2,有k1&lt;k2&lt;A<br>所以根据我们的方法，k1不可能以A为父节点</p>
<p>假设k1&gt;k2<br>根据A&gt;k1,有k2&lt;k1&lt;A<br>所以根据我们的方法，k2不可能以A为父节点</p>
<p>总之，A在单独一侧不可能有超过一个孩子节点的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] buildMaxTree(<span class="type">int</span>[] A, <span class="type">int</span> n) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] ALeft = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//左边第一个大的数</span></span><br><span class="line">    <span class="type">int</span>[] ARight = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//右边第一个大的数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找左边第一个大的数，将值存放到ALeft</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            stack.push(A[i]);</span><br><span class="line">            ALeft[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; A[i] &gt; stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                ALeft[i] = stack.peek();</span><br><span class="line">                stack.push(A[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(A[i]);</span><br><span class="line">                ALeft[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找右边第一个大的数，将值存放到ARight</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            stack.push(A[i]);</span><br><span class="line">            ARight[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; A[i] &gt; stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                ARight[i] = stack.peek();</span><br><span class="line">                stack.push(A[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(A[i]);</span><br><span class="line">                ARight[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(ALeft));</span><br><span class="line">    System.out.println(Arrays.toString(ARight));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一个数的父节点是它左边第一个比它大的数与右边第一个比它大的数中较小的那个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ALeft[i] == -<span class="number">1</span> &amp;&amp; ARight[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">            temp = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ALeft[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">            temp = ARight[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ARight[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">            temp = ALeft[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = ALeft[i] &lt; ARight[i] ? ALeft[i] : ARight[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result[i] = getIndex(A, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(result));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据元素值，获取它在数组A中的下标位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[j] == num)</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之字符串</title>
    <url>/iBlogWebsite/2016/03/14/2016/2016-03-14-%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="1-字符串问题具有广泛性特点"><a href="#1-字符串问题具有广泛性特点" class="headerlink" title="1. 字符串问题具有广泛性特点"></a>1. 字符串问题具有广泛性特点</h1><ul>
<li>字符串可以看成字符类型的数组，与数组排序、查找、调整有关</li>
<li>很多其他类型的面试题可以看做字符串类型的面试题</li>
</ul>
<h1 id="2-字符串的概念"><a href="#2-字符串的概念" class="headerlink" title="2. 字符串的概念"></a>2. 字符串的概念</h1><ul>
<li>回文</li>
<li>子串（连续）</li>
<li>子序列（不连续）</li>
<li>前缀树（Trie树）</li>
<li>后缀树和后缀数组</li>
<li>匹配</li>
<li>字典序</li>
</ul>
<h1 id="3-字符串的操作"><a href="#3-字符串的操作" class="headerlink" title="3. 字符串的操作"></a>3. 字符串的操作</h1><ul>
<li>与数组有关的操作：增删改查</li>
<li>字符的替换</li>
<li>字符串的旋转</li>
</ul>
<h1 id="4-字符串题目的常见类型"><a href="#4-字符串题目的常见类型" class="headerlink" title="4. 字符串题目的常见类型"></a>4. 字符串题目的常见类型</h1><h2 id="4-1-规则判断"><a href="#4-1-规则判断" class="headerlink" title="4.1. 规则判断"></a>4.1. 规则判断</h2><ul>
<li>判断字符串是否符合整数规则</li>
<li>判断字符串是否符合浮点数规则</li>
<li>判断字符串是否符合回文字符串规则</li>
</ul>
<h2 id="4-2-数字运算"><a href="#4-2-数字运算" class="headerlink" title="4.2. 数字运算"></a>4.2. 数字运算</h2><ul>
<li>int和long类型表达整数范围有限，所以经常用字符串实现大整数</li>
<li>与大整数有关的加减乘除操作，需要模拟笔算的过程</li>
</ul>
<h2 id="4-3-与数组操作有关的类型"><a href="#4-3-与数组操作有关的类型" class="headerlink" title="4.3. 与数组操作有关的类型"></a>4.3. 与数组操作有关的类型</h2><ul>
<li>数组有关的调整，排序等操作需要掌握</li>
<li>快速排序的划分过程需要掌握和该写</li>
</ul>
<h2 id="4-4-字符计数类型"><a href="#4-4-字符计数类型" class="headerlink" title="4.4. 字符计数类型"></a>4.4. 字符计数类型</h2><ul>
<li>哈希表</li>
<li>固定长度的数组，C/C++(256长度)，Java(65535长度)</li>
<li>滑动窗口问题</li>
<li>寻找无重复字符子串问题</li>
<li>计算变位词问题</li>
</ul>
<h2 id="4-5-动态规划类型"><a href="#4-5-动态规划类型" class="headerlink" title="4.5. 动态规划类型"></a>4.5. 动态规划类型</h2><ul>
<li>最长公共子串</li>
<li>最长公共子序列</li>
<li>最长回文子串</li>
<li>最长回文子序列</li>
</ul>
<h2 id="4-6-搜索类型"><a href="#4-6-搜索类型" class="headerlink" title="4.6. 搜索类型"></a>4.6. 搜索类型</h2><ul>
<li>宽度优先搜索</li>
<li>深度优先搜索</li>
</ul>
<h2 id="4-7-高级算法与数据结构解决的问题"><a href="#4-7-高级算法与数据结构解决的问题" class="headerlink" title="4.7. 高级算法与数据结构解决的问题"></a>4.7. 高级算法与数据结构解决的问题</h2><ul>
<li>Manacher算法解决最长回文子串问题</li>
<li>KMP算法解决字符串匹配问题</li>
<li>前缀树结构</li>
<li>后缀树和后缀数组</li>
<li>通常面试中很少出现</li>
</ul>
<h1 id="5-代码练习"><a href="#5-代码练习" class="headerlink" title="5. 代码练习"></a>5. 代码练习</h1><h2 id="5-1-拓扑结构相同子树"><a href="#5-1-拓扑结构相同子树" class="headerlink" title="5.1. 拓扑结构相同子树"></a>5.1. 拓扑结构相同子树</h2><p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">LeetCode 572. 另一个树的子树</a></p>
<p>对于两棵彼此独立的二叉树A和B，请编写一个高效算法，检查A中是否存在一棵子树与B树的拓扑结构完全相同。<br>给定两棵二叉树的头结点A和B，请返回一个bool值，代表A中是否存在一棵同构于B的子树。  </p>
<p><strong>最优解法为二叉树序列化 + KMP算法</strong></p>
<p>对比KMP算法太复杂了，也可以考虑将问题转化为比较两个树是否相等的思路，利用递归来解答就简单很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.string;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by liyou on 16/2/21. 拓扑结构相同子树问题</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * [LeetCode 572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对于两棵彼此独立的二叉树A和B，请编写一个高效算法，检查A中是否存在一棵子树与B树的拓扑结构完全相同。</span></span><br><span class="line"><span class="comment"> * 给定两棵二叉树的头结点A和B，请返回一个bool值，代表A中是否存在一棵同构于B的子树。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubTreeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">// t 为 null 一定都是 true</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 这里 t 一定不为 null, 只要 s 为 null，肯定是 false</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t) || isSameTree(s, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两棵树是否相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.val != t.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(s.left, t.left) &amp;&amp; isSameTree(s.right, t.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最优解法为二叉树序列化 + KMP算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">chkIdentical</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">t1Str</span> <span class="operator">=</span> serialByPre(t1);</span><br><span class="line">        <span class="type">String</span> <span class="variable">t2Str</span> <span class="operator">=</span> serialByPre(t2);</span><br><span class="line">        <span class="keyword">return</span> getIndexOf(t1Str, t2Str) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">serialByPre</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> head.val + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        res += serialByPre(head.left);</span><br><span class="line">        res += serialByPre(head.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KMP</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndexOf</span><span class="params">(String s, String m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || m == <span class="literal">null</span> || m.length() &lt; <span class="number">1</span> || s.length() &lt; m.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] ms = m.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] nextArr = getNextArray(ms);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; ss.length &amp;&amp; mi &lt; ms.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ss[index] == ms[mi]) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                mi++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextArr[mi] == -<span class="number">1</span>) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mi = nextArr[mi];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mi == ms.length ? index - mi : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] getNextArray(<span class="type">char</span>[] ms) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ms.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] nextArr = <span class="keyword">new</span> <span class="title class_">int</span>[ms.length];</span><br><span class="line">        nextArr[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        nextArr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cn</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; nextArr.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ms[pos - <span class="number">1</span>] == ms[cn]) &#123;</span><br><span class="line">                nextArr[pos++] = ++cn;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cn = nextArr[cn];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextArr[pos++] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-词语变形"><a href="#5-2-词语变形" class="headerlink" title="5.2. 词语变形"></a>5.2. 词语变形</h2><p><a href="https://leetcode-cn.com/problems/valid-anagram/">LeetCode 242. 有效的字母异位词</a></p>
<p>所谓变形词就是两个字符串中的字符出现的种类一样，次数也一样。</p>
<p>对于两个字符串A和B，如果A和B中出现的字符种类相同且每种字符出现的次数相同，则A和B互为变形词，请设计一个高效算法，检查两给定串是否互为变形词。<br>给定两个字符串A和B及他们的长度，请返回一个bool值，代表他们是否互为变形词。</p>
<p>测试样例：<br>“abc”,3,”bca”,3<br>返回：true</p>
<p><strong>关键点在于使用哈希表做字符计数（可以用固定长度的数组代替哈希表结构，时间复杂度为O(n),额外空间复杂度为O(n)）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.string;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by liuzhif on 16/2/21.词语变形</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * [LeetCode 242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对于两个字符串A和B，如果A和B中出现的字符种类相同且每种字符出现的次数相同，则A和B互为变形词，请设计一个高效算法，检查两给定串是否互为变形词。</span></span><br><span class="line"><span class="comment"> * 给定两个字符串A和B及他们的长度，请返回一个bool值，代表他们是否互为变形词。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * &quot;abc&quot;,3,&quot;bca&quot;,3</span></span><br><span class="line"><span class="comment"> * 返回：true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordTransformDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WordTransformDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WordTransformDemo</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;ac&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;bb&quot;</span>;</span><br><span class="line">        System.out.println(demo.isAnagram(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            array[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            array[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-两串旋转"><a href="#5-3-两串旋转" class="headerlink" title="5.3. 两串旋转"></a>5.3. 两串旋转</h2><p><a href="https://leetcode-cn.com/problems/rotate-string/">LeetCode 796. 旋转字符串</a></p>
<p>所谓旋转词就是一个字符串，左边任意长度的子串挪到右边去，都叫这个字符串的旋转词。</p>
<p>如果对于一个字符串A，将A的前面任意一部分挪到后边去形成的字符串称为A的旋转词。比如A=”12345”,A的旋转词有”12345”,”23451”,”34512”,”45123”和”51234”。对于两个字符串A和B，请判断A和B是否互为旋转词。<br>给定两个字符串A和B及他们的长度lena，lenb，请返回一个bool值，代表他们是否互为旋转词。</p>
<p>测试样例：<br>“cdab”,4,”abcd”,4<br>返回：true</p>
<p><strong>关键点在于生成str1+str1大字符串，再利用KMP算法判断是否包含str2（最优时间复杂度为O(n)）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.string;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by LeeeYou on 2016/3/13. 两串旋转练习题</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * [LeetCode 796. 旋转字符串](https://leetcode-cn.com/problems/rotate-string/)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 如果对于一个字符串A，将A的前面任意一部分挪到后边去形成的字符串称为A的旋转词。比如A=&quot;12345&quot;,A的旋转词有&quot;12345&quot;,&quot;23451&quot;,&quot;34512&quot;,&quot;45123&quot;和&quot;51234&quot;。对于两个字符串A和B，请判断A和B是否互为旋转词。</span></span><br><span class="line"><span class="comment"> * 给定两个字符串A和B及他们的长度lena，lenb，请返回一个bool值，代表他们是否互为旋转词。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * &quot;cdab&quot;,4,&quot;abcd&quot;,4</span></span><br><span class="line"><span class="comment"> * 返回：true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RotationStrDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RotationStrDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RotationStrDemo</span>();</span><br><span class="line">        System.out.println(chkRotation(<span class="string">&quot;love&quot;</span>, <span class="number">5</span>, <span class="string">&quot;elo&quot;</span>, <span class="number">5</span>));</span><br><span class="line">        System.out.println(demo.rotateString(<span class="string">&quot;love&quot;</span>, <span class="string">&quot;elo&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">chkRotation</span><span class="params">(String str1, <span class="type">int</span> n, String str2, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n != m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> str1 + str1;</span><br><span class="line">        <span class="keyword">return</span> getIndexOf(a, str2) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KMP Algorithm</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndexOf</span><span class="params">(String s, String m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; m.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] ms = m.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">si</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = getNextArray(ms);</span><br><span class="line">        <span class="keyword">while</span> (si &lt; ss.length &amp;&amp; mi &lt; ms.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ss[si] == ms[mi]) &#123;</span><br><span class="line">                si++;</span><br><span class="line">                mi++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[mi] == -<span class="number">1</span>) &#123;</span><br><span class="line">                si++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mi = next[mi];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mi == ms.length ? si - mi : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getNextArray(<span class="type">char</span>[] ms) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ms.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[ms.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cn</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; next.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ms[pos - <span class="number">1</span>] == ms[cn]) &#123;</span><br><span class="line">                next[pos++] = ++cn;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cn = next[cn];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[pos++] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rotateString</span><span class="params">(String s, String goal)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length() == goal.length() &amp;&amp; (s + s).contains(goal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-句子的逆序"><a href="#5-4-句子的逆序" class="headerlink" title="5.4. 句子的逆序"></a>5.4. 句子的逆序</h2><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">LeetCode 151. 翻转字符串里的单词</a></p>
<p>对于一个字符串，请设计一个算法，只在字符串的单词间做逆序调整，也就是说，字符串由一些由空格分隔的部分组成，你需要将这些部分逆序。<br>给定一个原字符串A和他的长度，请返回逆序后的字符串。</p>
<p>测试样例：<br>“dog loves pig”,13<br>返回：”pig loves dog”</p>
<p><strong>1. 两次翻转法：关键点在于实现将字符串局部所有字符逆序的函数f</strong><br><strong>2. 系统api也很好用🐶</strong><br><strong>3. 双端队列法，牛得一批</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by LeeeYou on 2016/3/13. 句子的逆序练习题</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * [LeetCode 151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对于一个字符串，请设计一个算法，只在字符串的单词间做逆序调整，也就是说，字符串由一些由空格分隔的部分组成，你需要将这些部分逆序。</span></span><br><span class="line"><span class="comment"> * 给定一个原字符串A和他的长度，请返回逆序后的字符串。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * &quot;dog loves pig&quot;,13</span></span><br><span class="line"><span class="comment"> * 返回：&quot;pig loves dog&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReverseDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReverseDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;dog loves pig&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;I&#x27;m a pig.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot; a good   example &quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(demo.reverseWords(str1));</span><br><span class="line">        System.out.println(demo.reverseWords(str2));</span><br><span class="line">        System.out.println(demo.reverseWords(str3));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(demo.reverseWords2(str1));</span><br><span class="line">        System.out.println(demo.reverseWords2(str2));</span><br><span class="line">        System.out.println(demo.reverseWords2(str3));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(demo.reverseWords3(str1));</span><br><span class="line">        System.out.println(demo.reverseWords3(str2));</span><br><span class="line">        System.out.println(demo.reverseWords3(str3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双端队列法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords3</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>) ++left; <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">&#x27; &#x27;</span>) --right;  <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line"></span><br><span class="line">        Deque&lt;String&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">word</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="keyword">if</span> ((word.length() != <span class="number">0</span>) &amp;&amp; (c == <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 将单词 push 到队列的头部</span></span><br><span class="line">                d.offerFirst(word.toString());</span><br><span class="line">                word.setLength(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                word.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        d.offerFirst(word.toString());</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统api</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(s.split(<span class="string">&quot;\\s+&quot;</span>));</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两次翻转法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        String[] strArray = reverse(s).split(<span class="string">&quot;\\s+&quot;</span>); <span class="comment">// 按空格切割字符串</span></span><br><span class="line">        String[] result = <span class="keyword">new</span> <span class="title class_">String</span>[strArray.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strArray.length; i++) &#123;</span><br><span class="line">            result[i] = reverse(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverse</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len / <span class="number">2</span>) &#123;</span><br><span class="line">            swap(chars, i, len - i - <span class="number">1</span>);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        chars[i] = (<span class="type">char</span>) (chars[i] ^ chars[j]);</span><br><span class="line">        chars[j] = (<span class="type">char</span>) (chars[i] ^ chars[j]);</span><br><span class="line">        chars[i] = (<span class="type">char</span>) (chars[i] ^ chars[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5-字符串移位（要求：时间复杂度为O-n-额外空间复杂度为O-1-）"><a href="#5-5-字符串移位（要求：时间复杂度为O-n-额外空间复杂度为O-1-）" class="headerlink" title="5.5. 字符串移位（要求：时间复杂度为O(n),额外空间复杂度为O(1)）"></a>5.5. 字符串移位（要求：时间复杂度为O(n),额外空间复杂度为O(1)）</h2><p>对于一个字符串，请设计一个算法，将字符串的长度为len的前缀平移到字符串的最后。<br>给定一个字符串A和它的长度，同时给定len，请返回平移后的字符串。</p>
<p>测试样例：<br>“ABCDE”,5,3<br>返回：”DEABC”</p>
<blockquote>
<p>关键点在于先将0<del>i部分的字符逆序，再将i+1</del>n部分的字符逆序，最后整体逆序调整</p>
</blockquote>
<p>大部分字符串交换相关的题目是活用局部逆序函数组合的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">stringTranslation</span><span class="params">(String A, <span class="type">int</span> n, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span> || len &gt; n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] chars = A.toCharArray();</span><br><span class="line"></span><br><span class="line">    reverse(chars, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    reverse(chars, len, n - <span class="number">1</span>);</span><br><span class="line">    reverse(chars, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chas, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        tmp = chas[start];</span><br><span class="line">        chas[start] = chas[end];</span><br><span class="line">        chas[end] = tmp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-拼接最小字典序"><a href="#5-6-拼接最小字典序" class="headerlink" title="5.6. 拼接最小字典序"></a>5.6. 拼接最小字典序</h2><p>对于一个给定的字符串数组，请找到一种拼接顺序，使所有小字符串拼接成的大字符串是所有可能的拼接中字典序最小的。<br>给定一个字符串数组strs，同时给定它的大小，请返回拼接成的串。</p>
<p>测试样例：<br>[“abc”,”de”],2<br>“abcde”</p>
<blockquote>
<p>最优解的时间复杂度O(N*logN)，其实质是一种排序的实现。如果str1+str2&lt;str2+str1,则str1放在前面，否则str2放在前面</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (s1 + s2).compareTo(s2 + s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">findSmallest</span><span class="params">(String[] strs, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(strs, <span class="keyword">new</span> <span class="title class_">MyComparator</span>());</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        sb.append(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-7-空格替换"><a href="#5-7-空格替换" class="headerlink" title="5.7. 空格替换"></a>5.7. 空格替换</h2><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">LeetCode 剑指 Offer 05. 替换空格</a></p>
<p>请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。<br>给定一个string iniString 为原始的串，以及串的长度 int len, 返回替换后的string。</p>
<p>测试样例：<br>“Mr John Smith”,13<br>返回：”Mr%20John%20Smith”<br>”Hello  World”,12<br>返回：”Hello%20%20World”</p>
<p><strong>关键点在于从后往前依次替换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.string;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by LeeeYou on 2016/3/14. 空格替换练习题</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * [LeetCode 剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。</span></span><br><span class="line"><span class="comment"> * 给定一个string iniString 为原始的串，以及串的长度 int len, 返回替换后的string。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * &quot;Mr John Smith”,13</span></span><br><span class="line"><span class="comment"> * 返回：&quot;Mr%20John%20Smith&quot;</span></span><br><span class="line"><span class="comment"> * ”Hello  World”,12</span></span><br><span class="line"><span class="comment"> * 返回：”Hello%20%20World”</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplaceDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReplaceDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReplaceDemo</span>();</span><br><span class="line">        System.out.println(demo.replaceSpace(<span class="string">&quot;We are happy.&quot;</span>));</span><br><span class="line">        System.out.println(demo.replaceSpace2(<span class="string">&quot;We are happy.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统api</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">build</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> chars.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                build.insert(<span class="number">0</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                build.insert(<span class="number">0</span>, chars[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[s.length() + count * <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> cs.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                cs[index--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                cs[index--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                cs[index--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cs[index--] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-8-合法括号序列判断"><a href="#5-8-合法括号序列判断" class="headerlink" title="5.8. 合法括号序列判断"></a>5.8. 合法括号序列判断</h2><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">LeetCode 20. 有效的括号</a></p>
<p>对于一个字符串，请设计一个算法，判断其是否为一个合法的括号串。<br>给定一个字符串A和它的长度n，请返回一个bool值代表它是否为一个合法的括号串。</p>
<p>测试样例：<br>“(()())”,6<br>返回：true<br>测试样例：<br>“()a()()”,7<br>返回：false<br>测试样例：<br>“()(()()”,7<br>返回：false</p>
<p><strong>解法1: 栈 + 辅助HashMap</strong><br><strong>解法2: 栈 + 不用辅助HashMap</strong><br><strong>解法3: 替换法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by LeeeYou on 2016/3/14. 合法括号序列判断练习题</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * [LeetCode 20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对于一个字符串，请设计一个算法，判断其是否为一个合法的括号串。</span></span><br><span class="line"><span class="comment"> * 给定一个字符串A和它的长度n，请返回一个bool值代表它是否为一个合法的括号串。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * &quot;(()())&quot;,6</span></span><br><span class="line"><span class="comment"> * 返回：true</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * &quot;()a()()&quot;,7</span></span><br><span class="line"><span class="comment"> * 返回：false</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * &quot;()(()()&quot;,7</span></span><br><span class="line"><span class="comment"> * 返回：false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BracketsDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BracketsDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BracketsDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;()[]&#123;&#125;((&#123;&#125;))&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;(]&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;()&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(demo.isValid(s1));</span><br><span class="line">        System.out.println(demo.isValid(s2));</span><br><span class="line">        System.out.println(demo.isValid(s3));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(demo.isValid2(s1));</span><br><span class="line">        System.out.println(demo.isValid2(s2));</span><br><span class="line">        System.out.println(demo.isValid2(s3));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(demo.isValid3(s1));</span><br><span class="line">        System.out.println(demo.isValid3(s2));</span><br><span class="line">        System.out.println(demo.isValid3(s3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈 + 辅助HashMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pairs.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != pairs.get(c)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈（不用辅助HashMap）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.empty() || c != stack.pop()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid3</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (s.contains(<span class="string">&quot;()&quot;</span>) || s.contains(<span class="string">&quot;[]&quot;</span>) || s.contains(<span class="string">&quot;&#123;&#125;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.contains(<span class="string">&quot;()&quot;</span>)) &#123;</span><br><span class="line">                s = s.replace(<span class="string">&quot;()&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.contains(<span class="string">&quot;&#123;&#125;&quot;</span>)) &#123;</span><br><span class="line">                s = s.replace(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.contains(<span class="string">&quot;[]&quot;</span>)) &#123;</span><br><span class="line">                s = s.replace(<span class="string">&quot;[]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.length() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-9-最长无重复字符子串"><a href="#5-9-最长无重复字符子串" class="headerlink" title="5.9. 最长无重复字符子串"></a>5.9. 最长无重复字符子串</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LeetCode 3. 无重复字符的最长子串</a></p>
<p>对于一个字符串,请设计一个高效算法，找到字符串的最长无重复字符的子串长度。<br>给定一个字符串A及它的长度n，请返回它的最长无重复字符子串长度。保证A中字符全部为小写英文字符，且长度小于等于500。</p>
<p>测试样例：<br>“aabcb”,5<br>返回：3</p>
<p><strong>关键点在于利用滑动窗口，不断向右查找最长不重复子串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> personalwebsite.string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by LeeeYou on 2016/3/14. 最长无重复字符子串练习题</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * [LeetCode 3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对于一个字符串,请设计一个高效算法，找到字符串的最长无重复字符的子串长度。</span></span><br><span class="line"><span class="comment"> * 给定一个字符串A及它的长度n，请返回它的最长无重复字符子串长度。保证A中字符全部为小写英文字符，且长度小于等于500。</span></span><br><span class="line"><span class="comment"> * 测试样例：</span></span><br><span class="line"><span class="comment"> * &quot;aabcb&quot;,5</span></span><br><span class="line"><span class="comment"> * 返回：3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestSubstringDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LongestSubstringDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongestSubstringDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abcabcbb&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;rfrxkfrb&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(demo.lengthOfLongestSubstring(s1));</span><br><span class="line">        System.out.println(demo.lengthOfLongestSubstring(s2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rk</span> <span class="operator">=</span> -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                set.remove(s.charAt(i - <span class="number">1</span>));  <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从i位置开始不断地移动右指针找不重复的最长字串</span></span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !set.contains(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">                set.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, rk - i + <span class="number">1</span>); <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-10-删除特定的字符"><a href="#5-10-删除特定的字符" class="headerlink" title="5.10. 删除特定的字符"></a>5.10. 删除特定的字符</h2><p>输入两个字符串，从第一字符串中删除第二个字符串中所有的字符。例如，输入”They are students.”和”aeiou”，则删除之后的第一个字符串变成”Thy r stdnts.”。</p>
<p>要编程完成这道题要求的功能可能并不难。毕竟，这道题的基本思路就是在第一个字符串中拿到一个字符，在第二个字符串中查找一下，看它是不是在第二个字符串中。如果在的话，就从第一个字符串中删除。但如何能够把效率优化到让人满意的程度，却也不是一件容易的事情。也就是说，如何在第一个字符串中删除一个字符，以及如何在第二字符串中查找一个字符，都是需要一些小技巧的。</p>
<p>首先我们考虑如何在字符串中删除一个字符。由于字符串的内存分配方式是连续分配的。我们从字符串当中删除一个字符，需要把后面所有的字符往前移动一个字节的位置。但如果每次删除都需要移动字符串后面的字符的话，对于一个长度为n的字符串而言，删除一个字符的时间复杂度为O(n)。而对于本题而言，有可能要删除的字符的个数是n，因此该方法就删除而言的时间复杂度为O(n2)。</p>
<p>事实上，我们并不需要在每次删除一个字符的时候都去移动后面所有的字符。我们可以设想，当一个字符需要被删除的时候，我们把它所占的位置让它后面的字符来填补，也就相当于这个字符被删除了。在具体实现中，我们可以定义两个指针(pFast和pSlow)，初始的时候都指向第一字符的起始位置。当pFast指向的字符是需要删除的字符，则pFast直接跳过，指向下一个字符。如果pFast指向的字符是不需要删除的字符，那么把pFast指向的字符赋值给pSlow指向的字符，并且pFast和pSlow同时向后移动指向下一个字符。这样，前面被pFast跳过的字符相当于被删除了。用这种方法，整个删除在O(n)时间内就可以完成。</p>
<p>接下来我们考虑如何在一个字符串中查找一个字符。当然，最简单的办法就是从头到尾扫描整个字符串。显然，这种方法需要一个循环，对于一个长度为n的字符串，时间复杂度是O(n)。</p>
<p>由于字符的总数是有限的。对于八位的char型字符而言，总共只有2^8=256个字符。我们可以新建一个大小为256的数组，把所有元素都初始化为0。然后对于字符串中每一个字符，把它的ASCII码映射成索引，把数组中该索引对应的元素设为１。这个时候，要查找一个字符就变得很快了：根据这个字符的ASCII码，在数组中对应的下标找到该元素，如果为0，表示字符串中没有该字符，否则字符串中包含该字符。此时，查找一个字符的时间复杂度是O(1)。其实，这个数组就是一个hash表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.leeeyou.test.string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by leeeyou on 2016/12/20.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteStr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceStr</span> <span class="operator">=</span> <span class="string">&quot;public class DeleteStr&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">deleteStr</span> <span class="operator">=</span> <span class="string">&quot;cs&quot;</span>;</span><br><span class="line">        deleteStr(sourceStr, deleteStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteStr</span><span class="params">(String sourceStr, String deleteStr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sourceStr == <span class="literal">null</span> || deleteStr == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] deleteCharAsciiArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="type">char</span>[] deleteCharArray = deleteStr.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; deleteCharArray.length; i++) &#123;</span><br><span class="line">            deleteCharAsciiArray[deleteCharArray[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Character&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sourceCharArray = sourceStr.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sourceCharArray.length; i++) &#123;</span><br><span class="line">            linkedList.add(sourceCharArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> linkedList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deleteCharAsciiArray[linkedList.get(i)] == <span class="number">1</span>) &#123;</span><br><span class="line">                linkedList.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">            sb.append(linkedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-11-字符串的左右移动"><a href="#5-11-字符串的左右移动" class="headerlink" title="5.11. 字符串的左右移动"></a>5.11. 字符串的左右移动</h2><p>例如，输入<code>****so*h*a*ppy**t*oday*</code>，则移动之后的字符串变成<code>***********sohappytoday</code>。</p>
<p>利用一个快指针fast和一个慢指针slow从后向前扫描字符串，初始状态下slow记录从后向前第一次出现<code>*</code>的位置，fast指向slow的前一个位置。之后fast开始从后向前扫描，碰到<code>*</code>则跳过，碰到非<code>*</code>则与slow指针所在的位置交换字符且slow索引-1，同时置fast位置为<code>*</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.leeeyou.test.string;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by leeeyou on 2016/12/16.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoveStr</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;*so*h*a*ppy**t*oday*&quot;</span>;</span><br><span class="line">        moveStr(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">moveStr</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> chars.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="string">&#x27;*&#x27;</span> != chars[slow]) &#123;</span><br><span class="line">            --slow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> slow - <span class="number">1</span>; fast &gt;= <span class="number">0</span>; fast--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;*&#x27;</span> != chars[fast]) &#123;</span><br><span class="line">                chars[slow] = chars[fast];</span><br><span class="line">                chars[fast] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-12-字符串的全排列"><a href="#5-12-字符串的全排列" class="headerlink" title="5.12. 字符串的全排列"></a>5.12. 字符串的全排列</h2><p>从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理；</p>
<p>比如：首先我要打印abc的全排列，就是第一步把a 和bc交换（得到bac,cab），这需要一个for循环，循环里面有一个swap，交换之后就相当于不管第一步了，进入下一步递归，所以跟一个递归函数，完成递归之后把交换的换回来，变成原来的字串 递归方法1（July 方法）：</p>
<p>abc 为例子：</p>
<ol>
<li>固定a, 求后面bc的全排列： abc, acb。 求完后，a 和 b交换； 得到bac,开始第二轮</li>
<li>固定b, 求后面ac的全排列： bac, bca。 求完后，b 和 c交换； 得到cab,开始第三轮</li>
<li>固定c, 求后面ba的全排列： cab, cba</li>
</ol>
<p>即递归树：</p>
<table>
<thead>
<tr>
<th align="center">str</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">c</th>
</tr>
</thead>
</table>
<pre><code>   | ab ac    | ba bc   | ca cb
</code></pre>
<p>result | abc acb  | bac bca | cab cba</p>
<p><img src="/images/githubpages/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97.jpg" alt="字符串全排列"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.test.string;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by leeeyou on 2016/12/15.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Permutation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        permutation(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s    字符数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from 起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to   结束位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">permutation</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> from, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (to &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (from == to) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> from; i &lt;= to; i++) &#123;</span><br><span class="line">                swap(s, i, from);</span><br><span class="line">                permutation(s, from + <span class="number">1</span>, to);</span><br><span class="line">                swap(s, from, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-13-字符串的回文问题：Manacher算法"><a href="#5-13-字符串的回文问题：Manacher算法" class="headerlink" title="5.13. 字符串的回文问题：Manacher算法"></a>5.13. 字符串的回文问题：Manacher算法</h2><p>最长回文子串问题：给定一个字符串，求它的最长回文子串长度。如果一个字符串正着读和反着读是一样的，那它就是回文串。下面是一个回文串的实例：a aba abba aaaa tattarrattat（牛津英语词典中最长的回文单词）</p>
<p>参考：<br><a href="https://segmentfault.com/a/1190000003914228">最长回文子串——Manacher 算法</a><br><a href="https://www.felix021.com/blog/read.php?2040">Manacher’s ALGORITHM: O(n)时间求字符串的最长回文子串  不指定</a>  </p>
<h2 id="5-14-字符串的包含"><a href="#5-14-字符串的包含" class="headerlink" title="5.14. 字符串的包含"></a>5.14. 字符串的包含</h2><p>题目描述：<br>假设这有一个各种字母组成的字符串A，和另外一个字符串B，字符串里B的字母数相对少一些。什么方法能最快的查出所有小字符串B里的字母在大字符串A里都有？</p>
<p>比如，如果是下面两个字符串：<br>String 1: ABCDEFGHLMNOPQRS<br>String 2: DCGSRQPO<br>答案是true，所有在string2里的字母string1也都有。  </p>
<p>如果是下面两个字符串:<br>String 1: ABCDEFGHLMNOPQRS<br>String 2: DCGSRQPZ<br>答案是false，因为第二个字符串里的Z字母不在第一个字符串里。</p>
<p>我们可以对短字串进行轮询，把其中的每个字母都放入一个Hashtable里(我们始终设m为短字符串的长度，那么此项操作成本是O(m)次操作)。<br>然后轮询长字符串，在Hashtable里查询短字符串的每个字符，看能否找到；如果找不到，说明没有匹配成功。</p>
<p>用散列表实现：<br>1、hash[26]，先全部清零，然后扫描短的字符串，若有相应的置1，<br>2、计算hash[26]中1的个数，记为m<br>3、扫描长字符串的每个字符a；若原来hash[a] == 1 ，则修改hash[a] = 0，并将m减1；若hash[a] == 0，则不做处理<br>4、若m == 0 or 扫描结束，退出循环。</p>
<p>参考：<a href="https://blog.csdn.net/v_july_v/article/details/6347454">程序员编程艺术：第二章、字符串是否包含问题</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之Paint的使用总结</title>
    <url>/iBlogWebsite/2016/04/29/2016/2016-04-29-Android%E4%B9%8BPaint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>我始终觉得自定义控件是前端开发中非常重要的一项技能，不管是Android、iOS还是web前端。每当看到那些美轮美奂的自定义控件时，就会意淫：要是自己也能写出来该多好。<br>我们不能老是停留在“想”的层面上，做技术的实践才是王道。同时自定义控件如果掌握的好，分分钟在他人面前装13好不好，但是注意好分寸，别装死了就行。<br>对自定义控件最简单的理解就是：一张纸和一支笔，有了这两样东西，自定义控件还不是你想怎么弄怎么弄咯。<br>先说说“笔”的事吧，Android的自定义控件中，笔就是Paint，趁着这些天对Paint的练习也不少了，在这先好好总结下。</p>
<p>Android官方文档中对Paint的解释：</p>
<blockquote>
<p>The Paint class holds the style and color information about how to draw geometries, text and bitmaps.</p>
</blockquote>
<p>多么精炼、多么精炼的描述。<br>但是google提供的API还真不少。下面简单的罗列下本文的大纲：<br>1、Paint的基本属性和常用方法<br>2、颜色、矩阵过滤器(ColorFilter)<br>3、图像混合模式(PortDuffXfermode)<br>4、对文字的处理(FontMetrics)<br>5、遮罩滤镜(MaskFilter)<br>6、路径效果(PathEffect)<br>7、着色器(BitmapShader)</p>
<h2 id="Paint的基本属性和常用方法"><a href="#Paint的基本属性和常用方法" class="headerlink" title="Paint的基本属性和常用方法"></a>Paint的基本属性和常用方法</h2><p>ANTI_ALIAS_FLAG：抗锯齿</p>
<p>画笔的样式：<br>1.Paint.Style.STROKE：描边<br>2.Paint.Style.FILL_AND_STROKE：描边并填充<br>3.Paint.Style.FILL：填充</p>
<p>setStrokeWidth:设置描边的粗细，单位：像素px; 注意：当setStrokeWidth(0)的时候描边宽度并不为0而是只占一个像素</p>
<h2 id="颜色、矩阵过滤器-ColorFilter"><a href="#颜色、矩阵过滤器-ColorFilter" class="headerlink" title="颜色、矩阵过滤器(ColorFilter)"></a>颜色、矩阵过滤器(ColorFilter)</h2><p>颜色过滤，就像拿个筛子把颜色“滤”一遍获取我们想要的色彩结果。<br>ColorFilter有3个子类<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/colorFilter.png" alt="colorFilter.png"></p>
<h3 id="ColorMatrixColorFilter"><a href="#ColorMatrixColorFilter" class="headerlink" title="ColorMatrixColorFilter"></a>ColorMatrixColorFilter</h3></h3><p>在Android中图片是以RGBA像素点的形式加载到内存中的，修改这些像素信息需要一个叫做ColorMatrix类的支持，其定义了一个4x5的float[]类型的矩阵:<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/newColorFilter.png" alt="newColorFilter.png"><br>其中，第一行表示的R（红色）的向量，第二行表示的G（绿色）的向量，第三行表示的B（蓝色）的向量，最后一行表示A（透明度）的向量，这一顺序必须要正确不能混淆！<br>这个矩阵不同的位置表示的RGBA值，其范围在0.0F至2.0F之间，1为保持原图的RGB值。每一行的第五列数字表示偏移值，何为偏移值？顾名思义当我们想让颜色更倾向于红色的时候就增大R向量中的偏移值，想让颜色更倾向于蓝色的时候就增大B向量中的偏移值，这是最最朴素的理解。</p>
<p>利用ColorMatrixColorFilter可以实现很多特效，比如：反相效果，老照片效果，饱和度强对比效果，大致的原理就是利用colorMatrix做矩阵相乘实现的。</p>
<h3 id="LightingColorFilter"><a href="#LightingColorFilter" class="headerlink" title="LightingColorFilter"></a>LightingColorFilter</h3><p>光照颜色过滤，可以简单的理解为有色光照在物体上染色一般。它的构造函数是：<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/LightingColorFilter.png" alt="LightingColorFilter.png"><br>mul全称是colorMultiply意为色彩倍增，而add全称是colorAdd意为色彩添加，这两个值都是16进制的色彩值0xAARRGGBB。</p>
<p>LightingColorFilter(0xFFFFFFFF, 0x00000000)的时候原图是不会有任何改变的，如果我们想增加红色的值，那么LightingColorFilter(0xFFFFFFFF, 0x00XX0000)就好，其中XX取值为00至FF。</p>
<h3 id="PorterDuffColorFilter"><a href="#PorterDuffColorFilter" class="headerlink" title="PorterDuffColorFilter"></a>PorterDuffColorFilter</h3><p>PorterDuffColorFilter跟LightingColorFilter一样，只有一个构造方法：<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/PorterDuffColorFilter.png" alt="PorterDuffColorFilter.png"><br>PorterDuffColorFilter的作用很好理解，将你指定的color和mode混合，简称混合颜色过滤。比如这里我们把Color的值设为红色，而模式设为PorterDuff.Mode.DARKEN变暗，得到的效果如图：<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/PorterDuffColorFilterEffect.png" alt="PorterDuffColorFilterEffect.png"></p>
<h2 id="图像混合模式-PortDuffXfermode"><a href="#图像混合模式-PortDuffXfermode" class="headerlink" title="图像混合模式(PortDuffXfermode)"></a>图像混合模式(PortDuffXfermode)</h2><p>这个是最重量级 最重量级 最重量级的东东了。ProterDuff是两个人名的组合: Tomas Proter和Tom Duff. 他们是最早在SIGGRAPH上提出图形混合概念的大神级人物。有兴趣的童靴们可以自己查下并深入了解，在此不再做过多描述。</p>
<p>PorterDuffXfermode是一个非常强大的转换模式，通过它，可以使用图像合成的16条Porter-Duff规则的任意一条来控制Paint如何与已有的Canvas图像进行交互。<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/PorterDuffXfermode.png" alt="PorterDuffXfermode.png"></p>
<p>下面简单的说明各效果：</p>
<ul>
<li>CLEAR 计算方式：[0, 0];  解释: 清除</li>
<li>SRC 计算方式：[Sa, Sc];  解释: 显示源图</li>
<li>DST 计算方式：[Da, Dc];  解释: 只绘制目标图像</li>
<li>SRC_OVER 计算方式：[Sa + (1 - Sa)Da, Rc = Sc + (1 - Sa)Dc];  解释: 在目标图像的上方绘制源图像</li>
<li>DST_OVER 计算方式：[Sa + (1 - Sa)Da, Rc = Dc + (1 - Da)Sc];  解释: 在源图像的上方绘制目标图像</li>
<li>SRC_IN 计算方式：[Sa * Da, Sc * Da];  解释: 在源图像和目标图像相交的地方只绘制源图像</li>
<li>DST_IN 计算方式：[Sa * Da, Sa * Dc];  解释: 在源图像和目标图像相交的地方只绘制目标图像</li>
<li>SRC_OUT 计算方式：[Sa * (1 - Da), Sc * (1 - Da)];  解释: 在源图像和目标图像不相交的地方只绘制源图像</li>
<li>DST_OUT 计算方式：[Da * (1 - Sa), Dc * (1 - Sa)];  解释: 在源图像和目标图像不相交的地方只绘制目标图像</li>
<li>SRC_ATOP 计算方式：[Da, Sc * Da + (1 - Sa) * Dc];  解释: 在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像</li>
<li>DST_ATOP 计算方式：[Sa, Sa * Dc + Sc * (1 - Da)];  解释: 在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像</li>
<li>XOR 计算方式：[Sa + Da - 2 * Sa * Da, Sc * (1 - Da) + (1 - Sa) * Dc];  解释: 在源图像和目标图像重叠之外的任何地方绘制他们，而在重叠的地方不绘制任何内容</li>
<li>DARKEN 计算方式：[Sa + Da - Sa<em>Da, Sc</em>(1 - Da) + Dc*(1 - Sa) + min(Sc, Dc)];  解释: 变暗,两个图像混合，较深的颜色总是会覆盖较浅的颜色，如果两者深浅相同则混合，如图，黄色覆盖了红色而蓝色和青色因为是跟透明混合所以不变</li>
<li>LIGHTEN 计算方式：[Sa + Da - Sa<em>Da, Sc</em>(1 - Da) + Dc*(1 - Sa) + max(Sc, Dc)];  解释: 变亮</li>
<li>MULTIPLY 计算方式：[Sa * Da, Sc * Dc];  解释: 正片叠底,源图像素颜色值乘以目标图像素颜色值除以255即得混合后图像像素的颜色值</li>
<li>SCREEN 计算方式：[Sa + Da - Sa * Da, Sc + Dc - Sc * Dc];  解释: 滤色</li>
<li>ADD 计算方式：Saturate(S + D);  解释: 饱和相加,ADD模式简单来说就是对图像饱和度进行相加，这个模式在应用中不常用</li>
<li>OVERLAY 计算方式：未给出;  解释: 叠加,这个模式没有在官方的API DEMO中给出，谷歌也没有给出其计算方式，在实际效果中其对亮色和暗色不起作用，也就是说黑白色无效，它会将源色与目标色混合产生一种中间色，这种中间色生成的规律也很简单，如果源色比目标色暗，那么让目标色的颜色倍增否则颜色递减。</li>
</ul>
<p>了解了PortDuffXfermode的混合模式后，在编写自定义控件时，有几个地方需要注意下：<br>  1 利用canvas绘图时，先绘制的是dst，后绘制的是src<br>  2 利用完xfermode后，调用setXfermode(null)还原混合模式  </p>
<h2 id="对文字的处理-FontMetrics"><a href="#对文字的处理-FontMetrics" class="headerlink" title="对文字的处理(FontMetrics)"></a>对文字的处理(FontMetrics)</h2><p>Android对文字的支持占用了Paint的将近一半API，可见Android对Paint写字功能的重视。<br>FontMetrics是和字体有关的非常重要的类，其实就是Paint的一个内部类。<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/FontMetrics.png" alt="FontMetrics.png"><br>其中有五个属性，top,ascent,descent,bottom,leading，看图说话：<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/FontMetricsFields.png" alt="FontMetricsFields.png"></p>
<p>首先我们要知道Baseline基线，在Android中，文字的绘制都是从Baseline处开始的，Baseline往上至字符最高处的距离我们称之为ascent（上坡度），Baseline往下至字符最底处的距离我们称之为descent（下坡度），而leading（行间距）则表示上一行字符的descent到该行字符的ascent之间的距离，而top的意思其实就是除了Baseline到字符顶端的距离外还应该包含这些符号的高度，bottom的意思也是一样，一般情况下我们极少使用到类似的符号所以往往会忽略掉这些符号的存在，但是Android依然会在绘制文本的时候在文本外层留出一定的边距，这就是为什么top和bottom总会比ascent和descent大一点的原因。</p>
<p>还有一点非常重要，在我们绘制文本之前我们便可以获取文本的FontMetrics属性值，也就是说我们FontMetrics的这些值跟我们要绘制什么文本是无关的，而仅与绘制文本Paint的size和typeface有关。size和typeface一变，FontMetrics的属性值也会随之改变。</p>
<p>知道这些的一个明显的用处就是文本居中，自定义控件时用baseY = canvas.getHeight() / 2; 控制文本的垂直居中是不准确的。因为文本的绘制是从Baseline开始，同时Baseline并非文本的分割线，当想让文本绘制居中屏幕时就需要计算Baseline的Y轴坐标。<br>baseY = (int) ((canvas.getHeight() / 2) + ((Math.abs(textPaint.ascent()-Math.abs(textPaint.descent()))) / 2));<br>用这个公式可以准确的让文本居中。</p>
<p>Paint有一个唯一的子类TextPaint就是专门为文本绘制量身定做的“笔”，而这支笔就如API所描述的那样能够在绘制时为文本添加一些额外的信息，这些信息包括：baselineShift,bgColor,density,drawableState,linkColor，这些属性都很简单，那么这支笔有何用呢？最常用的用法是在绘制文本时能够实现换行绘制！在正常情况下Android绘制文本是不能识别换行符之类的标识符的，这时候如果我们想实现换行绘制就得另辟途径使用StaticLayout结合TextPaint实现换行，StaticLayout是android.text.Layout的一个子类，很明显它也是为文本处理量身定做的，其内部实现了文本绘制换行的处理。</p>
<p>下面继续介绍一些常用的API:</p>
<ul>
<li>设置下划线：setUnderlineText(boolean underlineText)</li>
<li>设置字体类型：setTypeface(Typeface typeface) Android中字体有四种样式：<br>BOLD（加粗）,BOLD_ITALIC（加粗并倾斜）,ITALIC（倾斜）,NORMAL（正常）；<br>而其为我们提供的字体有五种：DEFAULT,DEFAULT_BOLD,MONOSPACE,SANS_SERIF和SERIF<br>Typeface typeface = Typeface.createFromAsset(context.getAssets(), “kt.ttf”);<br>textPaint.setTypeface(typeface);</li>
<li>在水平方向上倾斜：setTextSkewX(float skewX)</li>
<li>在X轴方向上缩放：setTextScaleX (float scaleX) 默认值为1，当值大于1会沿X轴水平放大文本，当值小于1会沿X轴水平缩放文本</li>
<li>设置文本的对其方式：可供选的方式有三种：CENTER,LEFT和RIGHT</li>
<li>文本删除线：setStrikeThruText (boolean strikeThruText)</li>
<li>抗抖动，也称为递色：setDither(boolean dither)</li>
</ul>
<h2 id="遮罩滤镜-MaskFilter"><a href="#遮罩滤镜-MaskFilter" class="headerlink" title="遮罩滤镜(MaskFilter)"></a>遮罩滤镜(MaskFilter)</h2><p>MaskFilter类中没有任何实现方法，而它有两个子类BlurMaskFilter和EmbossMaskFilter，前者为模糊遮罩滤镜（比起称之为过滤器哥更喜欢称之为滤镜）而后者为浮雕遮罩滤镜。<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/MaskFilter.png" alt="MaskFilter.png"></p>
<p>BlurMaskFilter<br>在某个控件 (比如Button) 周围想要绘制一层模糊，可以通过mPaint.setMaskFilter(new BlurMaskFilter(20, BlurMaskFilter.Blur.SOLID));实现，但是有些坑需要注意：</p>
<p>Paint的setMaskFilter()方法在API 16+上想获得正确的效果就必需关闭应用的硬件加速，我们可以在AndroidManifest.xml文件中设置android:hardwareAccelerated为false来关闭，具体有哪些绘制的方法不支持硬件加速可以参考下图<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/hardwareAcceleratedfalse.png" alt="hardwareAcceleratedfalse.png"><br>同时我们也可以只针对某个View关闭硬件加速，我们可以在View中通过setLayerType(LAYER_TYPE_SOFTWARE, null);来关闭单个View的硬件加速功能</p>
<p>至于EmbossMaskFilter，本身没有太多的使用地方，故不再记录总结。</p>
<h2 id="路径效果-PathEffect"><a href="#路径效果-PathEffect" class="headerlink" title="路径效果(PathEffect)"></a>路径效果(PathEffect)</h2><p>PathEffect一共有六个子类<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/PathEffect.png" alt="PathEffect.png"><br>可以实现下面不同的路径效果（其中第一条线是默认效果，没有设置任何PathEffect）<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/DemoPathEffect.png" alt="DemoPathEffect.png"></p>
<p>当我们不设置路径效果的时候路径的默认效果就如上图第一条线那样直的转折生硬；而CornerPathEffect则可以将路径的转角变得圆滑如图第二条线的效果，CornerPathEffect的构造方法只接受一个参数radius，意思就是转角处的圆滑程度。</p>
<p>DiscretePathEffect离散路径效果相对来说则稍微复杂点，其会在路径上绘制很多“杂点”的突出来模拟一种类似生锈铁丝的效果如上图第三条线，其构造方法有两个参数，第一个呢指定这些突出的“杂点”的密度，值越小杂点越密集，第二个参数呢则是“杂点”突出的大小，值越大突出的距离越大反之反之。<br>mEffects[2] = new DiscretePathEffect(3.0F, 5.0F);</p>
<p>DashPathEffect的效果相对与上面两种路径效果来说要略显复杂，其虽说也是包含了两个参数，但是第一个参数是一个浮点型的数组，我们在定义该参数的时候只要浮点型数组中元素个数大于等于2即可，也就是说上面我们的代码可以写成这样的：<br>mEffects[3] = new DashPathEffect(new float[] {20, 10}, mPhase);</p>
<p>float[] {20, 10}的偶数参数20（注意数组下标是从0开始哦）定义了我们第一条实线的长度，而奇数参数10则表示第一条虚线的长度，如果此时数组后面不再有数据则重复第一个数以此往复循环，比如我们20,10后没数了，那么整条线就成了[20,10,20,10,20,10…………………………]这么一个状态。而DashPathEffect的第二个参数我称之为偏移值，动态改变其值会让路径产生动画的效果。</p>
<p>PathDashPathEffect和DashPathEffect是类似的，不同的是PathDashPathEffect可以让我们自己定义路径虚线的样式，比如我们将其换成一个个小圆组成的虚线：<br>Path path = new Path();<br>path.addCircle(0, 0, 3, Direction.CCW);<br>mEffects[4] = new PathDashPathEffect(path, 12, mPhase, PathDashPathEffect.Style.ROTATE);</p>
<p>ComposePathEffect和SumPathEffect都可以用来组合两种路径效果，唯一不同的是组合的方式，ComposePathEffect(PathEffect outerpe, PathEffect innerpe)会先将路径变成innerpe的效果，再去复合outerpe的路径效果，即：outerpe(innerpe(Path))；而SumPathEffect(PathEffect first, PathEffect second)则会把两种路径效果加起来再作用于路径。</p>
<h2 id="着色器-Shader"><a href="#着色器-Shader" class="headerlink" title="着色器(Shader)"></a>着色器(Shader)</h2><p>Shader一共有5个子类<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/ShaderApi.png" alt="ShaderApi.png"><br>BitmapShader其构造函数有三个入参：<br><img src="../../../../images/githubpages/Paint%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/Shader.png" alt="Shader.png"></p>
<p>Shader.TileMode里有三种模式：CLAMP、MIRROR和REPETA；<br>MIRROR表示镜像，REPETA表示重复，这两个都很好理解，而CLAMP其实就是边缘拉伸，同时注意BitmapShader是先应用了Y轴的模式而X轴是后应用的！</p>
<p>LinearGradient、RadialGradient、SweepGradient三个都表示渐变<br>LinearGradient表示线性渐变；SweepGradient表示梯度渐变，也称为扫描式渐变；RadialGradient表示径向渐变，就是圆形中心向四周渐变的效果。<br>ComposeShader就是组合Shader……</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>Paint的内容真的有很多，先简略的总结到这为止，demo地址如下：<br><a href="https://github.com/LeeeYou/DemoCustomView1">https://github.com/LeeeYou/DemoCustomView1</a> Path的使用：PathEffect<br><a href="https://github.com/LeeeYou/DemoCustomView2">https://github.com/LeeeYou/DemoCustomView2</a> 画笔的使用：ColorMatrix、PorterDuffXfermode<br><a href="https://github.com/LeeeYou/DemoCustomView3">https://github.com/LeeeYou/DemoCustomView3</a> 画笔的使用：Font、Shadow、MaskFilter<br><a href="https://github.com/LeeeYou/DemoCustomView4">https://github.com/LeeeYou/DemoCustomView4</a> 画笔的使用：BitmapShader、LinearGradient、RadialGradient</p>
<p>这些总结的内容以及Demo的案例大部分参考aige的自定义控件日志的  <a href="http://blog.csdn.net/aigestudio/article/details/41799811">http://blog.csdn.net/aigestudio/article/details/41799811</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记之增长黑客</title>
    <url>/iBlogWebsite/2016/06/28/2016/2016-06-28-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/</url>
    <content><![CDATA[<p><img src="../../../../images/readingNotes/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2.jpg" alt="增长黑客"></p>
<h1 id="第1章：概念"><a href="#第1章：概念" class="headerlink" title="第1章：概念"></a>第1章：概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>以数据驱动营销，以市场指导产品，通过技术化手段贯彻增长目标的人。</p>
<h2 id="增长目标"><a href="#增长目标" class="headerlink" title="增长目标"></a>增长目标</h2><p>『AARRR』转化漏斗模型</p>
<ul>
<li>Acquisition 获取用户</li>
<li>Activation 激发活跃</li>
<li>Retention 提高留存</li>
<li>Revenue 增加收入</li>
<li>Referral 传播推荐</li>
</ul>
<h2 id="能力特质"><a href="#能力特质" class="headerlink" title="能力特质"></a>能力特质</h2><blockquote>
<p>（Andy Johns的增长黑客生涯）：facebook小挂件，向潜在用户发邮件广告推广，Twitter的着陆页改进（关注注册登录），新用户注册推荐用户，开发内部群发邮件系统，Quora捉摸用户行为模式，归纳为标准流程，引导其他用户执行流程</p>
</blockquote>
<ul>
<li>数据为王：具有数据思维，一切工作建立在数据分析之上</li>
<li>专注目标：时刻围绕增长目标展开，不断的测试、改进，学习、再测试</li>
<li>关注细节：对细小改动做出评估</li>
<li>富于创意：缜密分析+天马行空的增长方案</li>
<li>信息通透：深入理解产品用户的活跃渠道，关注新生渠道和业界趋势</li>
</ul>
<h2 id="一切以数据说话"><a href="#一切以数据说话" class="headerlink" title="一切以数据说话"></a>一切以数据说话</h2><ul>
<li><p>明确分析目的</p>
</li>
<li><p>了解数据来源的相关信息</p>
<ul>
<li>强调核心指标：建立在品类特性和自身提供服务的核心价值之上</li>
<li>确定上报机制：时机、内容、技术实践形式</li>
</ul>
</li>
<li><p>数据分析方法</p>
<ul>
<li>定性分析：对事物性质进行判断</li>
<li>定量分析： 对事物数量做统计</li>
</ul>
</li>
</ul>
<h2 id="团队定位"><a href="#团队定位" class="headerlink" title="团队定位"></a>团队定位</h2><p>游走在产品、运营、研发、设计、用户研究之间的多面手，比产品更关注能带来数据增长的功能特性，比运营更倾向于数据中探索新的增长机会，比设计师更少关注感观层面的艺术性，长于用户研究</p>
<h2 id="招聘经验以及发展要素"><a href="#招聘经验以及发展要素" class="headerlink" title="招聘经验以及发展要素"></a>招聘经验以及发展要素</h2><ul>
<li>要求：具备技术、产品、营销思维、传播和分享的精神（案例为Teambition , WIFI万能钥匙的招聘经验）</li>
<li>如何培养：熟悉产品和技术的市场影响，有产品干和市场思维，培养横向跨界知识，纵向某一领域专攻。软实力为：热情、聪明、好奇、收集资源、影响力、心态开放、内心强大、轻微强迫症</li>
<li>常用的工具箱：Google Analytics , Mixpanel , KissMeteics , UserCycle , Customer.io , Optimize.ly , Basscamp , 友盟</li>
</ul>
<h1 id="第2章：产品"><a href="#第2章：产品" class="headerlink" title="第2章：产品"></a>第2章：产品</h1><h2 id="PMF"><a href="#PMF" class="headerlink" title="PMF"></a>PMF</h2><blockquote>
<p>所以，应当先做好产品的验证，达到了PMF状态再全力推广。</p>
</blockquote>
<ul>
<li>也就是产品与市场的完美切合度，Product / market fit。从早期用户得到反馈，利用最小的成本持续改进产品。</li>
<li>成功案例： instagram的转型，砍掉冗余功能，把用户喜欢的照片分享功能拿出来做</li>
<li>失败案例： 叮咚小区，前期粗暴的线下广告投放，但是产品的基础功能不完善，用户体验极差。</li>
</ul>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul>
<li>需求是真实存在的还是伪需求（QQ邮箱将邮件附件单列出来，但几乎没人用）</li>
<li>需求是否属于刚需</li>
<li>需求是否足够大：估计目标用户的基数、消费能力、意愿预算；评估进入市场的原有规模和新的规模、借助排行榜和搜索热度了解需求（YY 向视频直播平台转变）</li>
<li>需求的变现能力如何</li>
</ul>
<p>MVP</p>
<blockquote>
<p>也就是最小化的可行产品来验证需求。同时应当注意，在产品早期应当尽快适配新环境，案例：多拉口袋的iOS8崩溃问题。</p>
</blockquote>
<ul>
<li>基本功能： 在最短时间内完成，如Dropbox通过仅完成宣传视频，Groupon 通过WordPress建站，排版软件制作礼券等，大众点评3天做出网页，数据来源于旅游手册，微信游戏近似于图片拼凑视觉稿。这几种常见的方式：伪造网站，不提供实际的功能；用户点击按钮后告知正在开发，留下电子邮箱；调研用户呼声最高的功能，然后成为种子用户；基于微信做MVP的开发（无需适配，分发方便，便于收集反馈，数据可以沉淀，开发成本低）</li>
<li>反馈渠道：内部反馈机制等</li>
<li>官方公告： 群体公告 + 单用户通知</li>
<li>自动升级： 启动时提示更新</li>
<li>使用行为统计</li>
</ul>
<h1 id="第3章：获取用户"><a href="#第3章：获取用户" class="headerlink" title="第3章：获取用户"></a>第3章：获取用户</h1><h2 id="种子用户"><a href="#种子用户" class="headerlink" title="种子用户"></a>种子用户</h2><p>通过冷启动来获取第一批用户和制作过程，早期的种子用户的质量将决定产品初期的氛围、运营走向、以及日后的发展策略，案例如：知乎的早期邀请制度，哔哩哔哩的答题机制，小米的种子用户反馈。</p>
<p>但是一定要警惕『产品蝗虫』，也就是目标客户之外的围观群众，他们将占用原有的目标用户名额，伤害到社区的生态，抠一些没用的『细节』，行为会对产品的决策产生误导。</p>
<h2 id="从最笨的事情做起"><a href="#从最笨的事情做起" class="headerlink" title="从最笨的事情做起"></a>从最笨的事情做起</h2><ul>
<li>聚美优品，写BB霜的软文，提供化妆品的高质量美图</li>
<li>Strikinfly，寻找超级粉丝，线上线下聊天</li>
<li>云笔记，邀请内测用户成立反馈协助群</li>
<li>Airbnb , 挨家挨户的上门拍照</li>
</ul>
<h2 id="社交红利与数据抓取"><a href="#社交红利与数据抓取" class="headerlink" title="社交红利与数据抓取"></a>社交红利与数据抓取</h2><p>与社交网络整合，获取用户量、关系链和行为数据（Spotify用facebook 登陆，Zynga用Facebook的开放平台制作社交游戏）</p>
<p>第三方社交网络的账号登陆，达成移动应用的分享和回流（啪啪，使用微博QQ登陆，挖掘关系链潜力）</p>
<p>数据抓取，可以保证产品初期启动的数据量，以及抢占先机，或者争取资源（微软关闭空间主页服务的时候，网易迅速提供『一键搬家』，追TA抓取唱吧的用户头像）</p>
<h2 id="内容营销"><a href="#内容营销" class="headerlink" title="内容营销"></a>内容营销</h2><p>其作用是吸引流量，培养潜在用户，劝诱转化，所以应当讲用户爱听的故事，如官方微博输出用户喜欢的图文（知乎）。</p>
<p>注意事项：明确目标受众，持续稳定输出高质量内容，标题的撰写技巧，保证文章长度（2400），数据分享与互动（有让人讨论的空间，如知乎刊发有争议的文章），选择合适的发布渠道。</p>
<h2 id="搜索的优化"><a href="#搜索的优化" class="headerlink" title="搜索的优化"></a>搜索的优化</h2><p>分为搜索引擎的优化和应用商店的优化。</p>
<p>搜索引擎的优化案例，Facebook 针对用户资料的页面优化，twitter自动提交热门标签给搜索引擎，TochCrunch通过wiki百科建立反向链接。</p>
<p>应用商店的优化案例，如大姨吗，通过副标题的修改推关键词，大众点评『更新跑得快』活动。</p>
<h2 id="文案的撰写"><a href="#文案的撰写" class="headerlink" title="文案的撰写"></a>文案的撰写</h2><ul>
<li>简要概述（100字内）</li>
<li>话题事件</li>
<li>核心特色</li>
<li>主要功能</li>
<li>团队访谈</li>
<li>未来计划</li>
<li>推广活动</li>
<li>转化引导</li>
</ul>
<h2 id="更多的技巧"><a href="#更多的技巧" class="headerlink" title="更多的技巧"></a>更多的技巧</h2><ul>
<li>捆绑下载：如豌豆荚捆绑下载其APP</li>
<li>排队机制，饥饿营销： Mailbox显示排队人数，Trak.io付费插队，邀请好友插队。</li>
<li>嵌入式代码和小挂件： Youtube分享</li>
<li>线上到线下</li>
<li>海外的扩张： 猎豹，Facebook等</li>
</ul>
<h1 id="第4章：激发活跃"><a href="#第4章：激发活跃" class="headerlink" title="第4章：激发活跃"></a>第4章：激发活跃</h1><h2 id="A-B测试"><a href="#A-B测试" class="headerlink" title="A/B测试"></a>A/B测试</h2><blockquote>
<p>但注意，不要过度依赖AB测试。</p>
</blockquote>
<ul>
<li>提供两个方案并行测试，</li>
<li>变量唯一排除其他干扰因素，</li>
<li>有判定结果优劣的标准，</li>
<li>移动应用也可以借助HTML5快速验证需求。</li>
<li>几个典型案例如37Signals 『注册高额回报账户』vs 『所有账户享受30天免费使用』，ZAGG 商品的静态图片 vs 360度图片 ， OkDork 先注册后进网站的测试，根据行为热点图去掉导航栏的测试。移动端如百姓网利用HTML5容器实现A/B测试。</li>
</ul>
<h2 id="独辟蹊径的技术"><a href="#独辟蹊径的技术" class="headerlink" title="独辟蹊径的技术"></a>独辟蹊径的技术</h2><blockquote>
<p>在技术瓶颈下通过巧妙的手段破除用户使用功能的障碍，降低用户活跃的门槛。</p>
</blockquote>
<ul>
<li>SKype『伪立体声』，提高清晰度，击败了其他同类服务</li>
<li>QQ音乐利用专辑图片实现了IOS的『锁屏歌词』</li>
<li>WIFI万能钥匙通过截图加上OCR技术识别WIFI热点，同时利用GPS+云服务获取附近的热点</li>
</ul>
<h2 id="补贴"><a href="#补贴" class="headerlink" title="补贴"></a>补贴</h2><p>有直接的现金补贴，快速获取用户，激发活跃度，也就是如返利和嘀嘀快的的补贴大战。</p>
<p>也有新玩法的红包补贴，通过社交关系链的传播，比如嘀嘀打车的补贴新玩法，打车红包。</p>
<h2 id="游戏化与脚本自动化运营"><a href="#游戏化与脚本自动化运营" class="headerlink" title="游戏化与脚本自动化运营"></a>游戏化与脚本自动化运营</h2><p>《游戏改变世界》提到的游戏四大特征： 目标、规则、反馈系统、自愿参与。</p>
<p>比如星巴克的线下会员成长体系，同时还开发了app把线下的游戏化搬到了线上。移动签到应用Foursquare 通过积分排名，徽章挑战和抢夺地主的游戏设计抓取用户忠诚度。滴滴打车提供的『滴米』系统等等。</p>
<p>而产品在早期社区通过团队自己来运营启动，后期就可以通过写脚本来实现自动化运营，一个有趣的运营案例是豌豆荚打造的贴吧神兽，其实就是一个自动聊天的机器人，获得了几十万的关注度。</p>
<h1 id="第5章：提高留存"><a href="#第5章：提高留存" class="headerlink" title="第5章：提高留存"></a>第5章：提高留存</h1><h2 id="用户留存率"><a href="#用户留存率" class="headerlink" title="用户留存率"></a>用户留存率</h2><h3 id="用户流逝的原因"><a href="#用户流逝的原因" class="headerlink" title="用户流逝的原因"></a>用户流逝的原因</h3><ul>
<li>程序漏洞，性能瓶颈：Color基本流程都跑不通</li>
<li>用户频繁被骚扰： 新浪微博的各种通知、广告、推送、话题等</li>
<li>产品热度消减： 『你画我猜』的日活锐减</li>
<li>更好的替代产品 ： eBay被淘宝击败</li>
<li>其他原因</li>
</ul>
<h3 id="留存率的衡量标准"><a href="#留存率的衡量标准" class="headerlink" title="留存率的衡量标准"></a>留存率的衡量标准</h3><ul>
<li>次日留存（40%）</li>
<li>7日留存（20%）</li>
<li>30日留存（10%）</li>
</ul>
<h2 id="产品性能优化"><a href="#产品性能优化" class="headerlink" title="产品性能优化"></a>产品性能优化</h2><p>优化内容包括：用户终端性能、网络性能、流量压缩、安装包空间、界面设计与布局、其他。</p>
<p>如Facebook为非洲用户的优化，减少了启动速度，提供了预加载，压缩图片，优先家在适合当前分辨率的照片，优化安装包大小，其实就是前边所说的优化内容。</p>
<p>再如 Instagram 的安卓版优化，扁平化设计，重新布局精简架构专注内容，延迟加载不必要的模块（方法追踪method tracing 和时点声明 Timing Statements 技术）。</p>
<h2 id="有损服务——放下不必要的坚持"><a href="#有损服务——放下不必要的坚持" class="headerlink" title="有损服务——放下不必要的坚持"></a>有损服务——放下不必要的坚持</h2><p>定义：刻意输出在品质上存在某些损失的服务，换取其他方面的优化。</p>
<p>原则</p>
<ul>
<li>优先保证核心功能的运转</li>
<li>牺牲的特性越少越好，在条件允许的情况下</li>
</ul>
<p>几个经典的案例如：QQ农场在高峰期提供的静态默认列表，微信的高峰期不强求信息发送顺序的一致，小米在抢购的时候不提供剩余手机的精确统计（也有可能是饥饿营销），刀塔传奇的大版本升级采用『低清晰度版本』保证用户尽早升级。</p>
<h2 id="引导用户上手-社交维系与社交解绑"><a href="#引导用户上手-社交维系与社交解绑" class="headerlink" title="引导用户上手 社交维系与社交解绑"></a>引导用户上手 社交维系与社交解绑</h2><p>Twitter注册完成后的推荐用户，知乎的推荐订阅，都是引导用户快速上手的例子。</p>
<p>社交维系与社交解绑是对立的概念，前者如全民飞机大战，『啪啪』提示新加入的微博好友，Facebook在注销账号页面显示亲密好友的照片，通过社交手段维系用户留存。而same则通过解绑社交的方式，提高留存。</p>
<h2 id="唤醒机制"><a href="#唤醒机制" class="headerlink" title="唤醒机制"></a>唤醒机制</h2><blockquote>
<p>互联网产品中专为召回流失用户而设计的产品机制。</p>
</blockquote>
<h3 id="电子邮件召回EDM"><a href="#电子邮件召回EDM" class="headerlink" title="电子邮件召回EDM"></a>电子邮件召回EDM</h3><ul>
<li>提供奖励，Pocket 用高级付费账户试用来吸引你</li>
<li>告知进展，IFTTT增加Nest支持，Evernote推出商业版等方式</li>
<li>个性化推荐，如知乎的每周精选，淘宝的同类商品。</li>
<li>社交互动提示，如Twitter定期发送未处理消息，Facebook中通知用户『有一张照片中圈了你』。</li>
<li>优秀的第三方服务商包括 TinyLetter,MailChimp等，EDM要注意内容，和取消订阅方式。</li>
</ul>
<h3 id="消息推送通知"><a href="#消息推送通知" class="headerlink" title="消息推送通知"></a>消息推送通知</h3><ul>
<li>推送授权，推荐试用简单的浮层或者弹窗提示用户获取权限后的使用目的。</li>
<li>徽章通知，也就是角标，利用用户的强迫症。</li>
<li>本地通知，在预设的时间点通知，如刀塔传奇每天的三个时间点推送通知。</li>
<li>地理围栏通知</li>
<li>图片推送通知</li>
<li>表情文字通知</li>
</ul>
<h3 id="网页内唤醒移动应用"><a href="#网页内唤醒移动应用" class="headerlink" title="网页内唤醒移动应用"></a>网页内唤醒移动应用</h3><p>iOS有直接的URL Scheme技术来实现，安卓上有四种方式，分别是：拦截http跳转、自定义scheme、Crome Internet ，内嵌http服务。如知乎，哔哩哔哩等。</p>
<h1 id="第6章：增加收入"><a href="#第6章：增加收入" class="headerlink" title="第6章：增加收入"></a>第6章：增加收入</h1><h2 id="免费的世界"><a href="#免费的世界" class="headerlink" title="免费的世界"></a>免费的世界</h2><h3 id="互联网与免费的午餐"><a href="#互联网与免费的午餐" class="headerlink" title="互联网与免费的午餐"></a>互联网与免费的午餐</h3><p>互联网可以降低信息传播的承办本，海量用户摊薄了边际成本，人的本性对免费产品更感兴趣以及更喜欢『免费』的国人。</p>
<h3 id="免费又赚钱的策略"><a href="#免费又赚钱的策略" class="headerlink" title="免费又赚钱的策略"></a>免费又赚钱的策略</h3><ul>
<li>基本功能免费，高级功能收费的Freemium策略，比如Evernote，QQ，Flickr等等。</li>
<li>交叉补贴，《征途》的游戏免费，道具收费。</li>
<li>三方市场的流量变现，例子就是搜狗的『三级火箭』策略，通过输入法来带动搜狗浏览器下载，利浏览器下载带动搜狗搜索的使用量（虽然我巨恶心搜狗的这个行为，但是这种变现的方式确实是最佳方式）</li>
<li>开源代码的盈利可能，如厂商定制开发收费，比如卖技术说明文档，或者接受用户捐赠（其实这个不算是运营了，纯粹是情怀）</li>
<li>公司上市或者是被收购</li>
</ul>
<h3 id="免费午餐的终结"><a href="#免费午餐的终结" class="headerlink" title="免费午餐的终结"></a>免费午餐的终结</h3><p>在产品足够好的情况下，可以试着完全掐断免费。</p>
<h2 id="重定向广告"><a href="#重定向广告" class="headerlink" title="重定向广告"></a>重定向广告</h2><p>也就是cookie和url分析，业界对此存在两种声音，一种认为增加了收入，另一种则担心用户隐私的泄露。</p>
<h2 id="几个营销案例"><a href="#几个营销案例" class="headerlink" title="几个营销案例"></a>几个营销案例</h2><h3 id="Wet-Seal"><a href="#Wet-Seal" class="headerlink" title="Wet Seal"></a>Wet Seal</h3><p>『和友人一起逛街』的社交购物，虚拟的DIY服务，Etsy根据社交资料精准推荐礼物。</p>
<h3 id="罗辑思维的微信月饼"><a href="#罗辑思维的微信月饼" class="headerlink" title="罗辑思维的微信月饼"></a>罗辑思维的微信月饼</h3><p>这也是一次粉丝经济的催生，分别尝试了找人代付，多人代付，随机送礼，加入游戏思维的方式完成了一次精彩的营销。</p>
<h3 id="面对盗版的营销方式"><a href="#面对盗版的营销方式" class="headerlink" title="面对盗版的营销方式"></a>面对盗版的营销方式</h3><p>腾讯给『非法』的QQ会员提供了八折开通会员的服务，而CleanmyMac 给盗版用户提供半价的优惠。面对盗版的变惩为奖的几个原则是：绝不责备用户，给予合理补偿，提供转化便利</p>
<h3 id="建立商业智能系统"><a href="#建立商业智能系统" class="headerlink" title="建立商业智能系统"></a>建立商业智能系统</h3><p>用数据可视化的方式辅助企业管理，如百姓网建立内部的数据化营销系统，提高了业务增长。</p>
<h1 id="第7章：病毒营销"><a href="#第7章：病毒营销" class="headerlink" title="第7章：病毒营销"></a>第7章：病毒营销</h1><h2 id="核心指标"><a href="#核心指标" class="headerlink" title="核心指标"></a>核心指标</h2><p>K因子：评判病毒传播的覆盖面，等于感染率*转化率。</p>
<p>病毒传播周期： 用户发出病毒邀请，到新用户完成转化所花费的时间。（引爆点提到的个别人物法则，附着力法则和环境威力法则）。</p>
<h2 id="几个案例"><a href="#几个案例" class="headerlink" title="几个案例"></a>几个案例</h2><p>坏事传千里，百度的Bug营销，利用一个假装的bug，百度云获得了大量的新注册用户和铁杆粉丝，以及完整的流程体验，大量的用户个人文件。</p>
<p>借势营销，利用时机，比如各种旅游产品借助阿里的去啊做热点营销，猎豹移动专门推出的春节抢票版。segmentFault的光棍节程序员闯关秀。（如今打开segmentfault.com/game会有一个新的闯关游戏，不过也是很难的）</p>
<p>构建产品体系外的病毒循环，追TA的整蛊朋友圈游戏。三大考验</p>
<ul>
<li>创意来源</li>
<li>生命周期</li>
<li>产品契合度：知乎的财务包子铺与知乎的《金钱有术》。</li>
</ul>
<p>产品内置的传播因子。</p>
<ul>
<li>外置的传播因子有几个缺陷，渠道特性与产品特性不匹配，获得的用户参差不齐；渠道传播与下载转化之间可能存在断链（朋友圈可能屏蔽一些下载）；渠道传播的策划固然成功，但是用户可能对产品本身缺乏兴趣。所以借用内置的传播因子可能更好，如AirDrop的推荐产品解锁高级功能，美图秀秀内建的可分享到朋友圈的小功能。</li>
</ul>
<p>邮件提醒增强传播效率</p>
<ul>
<li>SpringSled 好友邀请提高排队名次，通过有效的邮件跟踪提高用户数量。</li>
</ul>
<h2 id="病毒传播中的用户心理把握"><a href="#病毒传播中的用户心理把握" class="headerlink" title="病毒传播中的用户心理把握"></a>病毒传播中的用户心理把握</h2><ul>
<li>喜爱：游戏，文学等大ip的作品，转化率比较高。</li>
<li>逐利：如Groupon的邀请好友奖励10美元等。</li>
<li>互惠： 是追逐利益的一种变体，基于理性经济人假说的传统经济学认为，经济行为主体是单纯追求个人利益最大化的，人们的复杂性为和社会参与，都基于成本收益的计算。如dropbox的推广获得额外空间。</li>
<li>求助：手机游戏，免费游戏，续命或者是买体力要钱。</li>
<li>炫耀： 支付宝每年一度的晒单</li>
<li>稀缺： 稀缺资源会引起争抢，如Gmail，Dribbble初期仅允许被邀请者发表作品。</li>
<li>害怕失去或错过： EverMemo 的互相扫描二维码解锁高级功能。</li>
<li>懒惰： 严肃的商业内容，大多数用户倾向于复制部分文字和链接再发送，偏重知识性娱乐性的网站，人们优先使用分享按钮分享他们看到的东西。</li>
</ul>
<h1 id="第8章：案例集"><a href="#第8章：案例集" class="headerlink" title="第8章：案例集"></a>第8章：案例集</h1><p>最后，作者复盘了几个完整的案例集，Airbnb ，Tinder ，Github，美丽说，外卖库，每一个都值得看几遍，了解一个成功的增长是如何做到的。</p>
]]></content>
      <categories>
        <category>opinion</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之反射</title>
    <url>/iBlogWebsite/2016/09/23/2016/2016-09-23-Java%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="1-反射的基石"><a href="#1-反射的基石" class="headerlink" title="1. 反射的基石"></a>1. 反射的基石</h1><p>Person类代表人，它的实例对象就是张三、李四这样一个个具体的人；Java程序中的各个类属于同一类事物，而描述这类事物的Java类名就是Class。众多的人用Person类表示，而众多的Java类则用Class类表示。</p>
<p>一个类被类加载器加载到内存中会占用一片存储空间，这个空间存储了类的字节码，不同类的字节码是不同的，所以它们在内存中的内容是不同的。这一个个的空间可分别用一个个的对象来表示，这些对象显然具有相同的类型，就是Class类型。</p>
<p><strong>Class类就是反射的基石，后续所有的反射操作都基于Class类。</strong> 另外需要注意的是，静态代码块不是在类加载时被调用的，而是第一个实例对象被创建时才执行。</p>
<p>如何得到各个字节码所对应的实例对象（Class类型），有如下三种方式：</p>
<ul>
<li>类名.class -&gt; System.class  </li>
<li>对象.getClass() -&gt; new Date().getClass()  </li>
<li>Class.forName(“类名”) -&gt; Class.forName(“java.util.Date”);   </li>
</ul>
<p>在判断基类型时，可以通过Class.isPrimitive()。JVM预定义了9个Class实例对象，分别是boolean、char、byte、short、int、long、float、double以及void。</p>
<p><a href="https://github.com/Leeeyou/BlogDemoForReflect.git">Demo下载在这里</a></p>
<h1 id="2-反射的组成部分"><a href="#2-反射的组成部分" class="headerlink" title="2. 反射的组成部分"></a>2. 反射的组成部分</h1><p><strong>反射就是把Java类中的各种成分映射成相应的java类。</strong></p>
<h2 id="2-1-Constructor类"><a href="#2-1-Constructor类" class="headerlink" title="2.1. Constructor类"></a>2.1. Constructor类</h2><p>Constructor类代表某个类中的一个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.reflect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by leeeyou on 2019/3/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到所有的构造函数</span></span><br><span class="line">            java.lang.reflect.Constructor&lt;?&gt;[] constructors = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getConstructors();</span><br><span class="line">            <span class="keyword">for</span> (java.lang.reflect.Constructor&lt;?&gt; c : constructors) &#123;</span><br><span class="line">                System.out.println(c.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到特定的构造函数</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.lang.reflect.Constructor&lt;String&gt; constructor = String.class.getConstructor(StringBuffer.class);</span><br><span class="line">                System.out.println(constructor.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印的结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String(<span class="type">byte</span>[],<span class="type">int</span>,<span class="type">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="type">byte</span>[],java.nio.charset.Charset)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="type">byte</span>[],java.lang.String) <span class="keyword">throws</span> java.io.UnsupportedEncodingException</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="type">byte</span>[],<span class="type">int</span>,<span class="type">int</span>,java.nio.charset.Charset)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="type">byte</span>[],<span class="type">int</span>,<span class="type">int</span>,java.lang.String) <span class="keyword">throws</span> java.io.UnsupportedEncodingException</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.StringBuilder)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.StringBuffer)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="type">byte</span>[])</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="type">int</span>[],<span class="type">int</span>,<span class="type">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String()</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="type">char</span>[])</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="type">char</span>[],<span class="type">int</span>,<span class="type">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="type">byte</span>[],<span class="type">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String(<span class="type">byte</span>[],<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span><br><span class="line">------------</span><br><span class="line"><span class="keyword">public</span> java.lang.String(java.lang.StringBuffer)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过反射我们拿到了String类的构造函数对象，现在就用它来构造String实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by leeeyou on 2019/3/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorInstance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构造默认实例对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">strObj</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).newInstance();</span><br><span class="line">            <span class="keyword">if</span> (strObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;yes! an object of type String is created&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//构造带有StringBuffer类型入参的实例对象</span></span><br><span class="line">                Constructor&lt;?&gt; constructor = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getConstructor(StringBuffer.class);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">shenZhen</span> <span class="operator">=</span> constructor.newInstance(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;shenZhen&quot;</span>));</span><br><span class="line">                <span class="keyword">if</span> (shenZhen <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;yes! an object of type String is created&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">shenzhenString</span> <span class="operator">=</span> (String) shenZhen;<span class="comment">//强制转换成String类型</span></span><br><span class="line">                    System.out.println(shenzhenString);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反射构造对象时，要特别注意入参的类型一定要准确，注意区分好基本类型、包装类型、String类型等。</strong>上述代码等运行结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yes! an object of type String is created</span><br><span class="line">--------</span><br><span class="line">yes! an object of type String is created</span><br><span class="line">shenZhen</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Field类"><a href="#2-2-Field类" class="headerlink" title="2.2. Field类"></a>2.2. Field类</h2><p>Field类代表某个类中的一个成员变量，当我们得到Field对象时，该对象是对应到类上的成员变量还是对象上的成员变量呢？我们知道类只有一个而该类的实例对象有多个，假如Field对象与实例对象关联，那关联的是哪个对象呢？所以Filed对象是对应到该类成员变量，而不是对应某个实例对象的变量。</p>
<p>下面通过代码感受下Field类的使用，先定义一个JavaBean用来描述一个点的x、y、z的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.reflect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by leeeyou on 2019/3/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(String x, String y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">z</span> <span class="operator">=</span> <span class="string">&quot;z:135&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(String x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(String y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着访问Point类中的静态属性变量z和私有属性x的值，并在最后改变x的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by leeeyou on 2019/3/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldValue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="string">&quot;x:10.1&quot;</span>, <span class="string">&quot;y:0.99&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">filedX</span> <span class="operator">=</span> point.getClass().getDeclaredField(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">filedZ</span> <span class="operator">=</span> point.getClass().getDeclaredField(<span class="string">&quot;z&quot;</span>);<span class="comment">//获取声明的属性，不管什么修饰符</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                filedZ.setAccessible(<span class="literal">true</span>);<span class="comment">//设置可访问</span></span><br><span class="line">                System.out.println(<span class="string">&quot;获取静态属性变量的值：&quot;</span> + filedZ.get(<span class="literal">null</span>));<span class="comment">//获取静态属性的值，传入null正常</span></span><br><span class="line"></span><br><span class="line">                filedX.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">//System.out.println(filedX.get(null));//获取非静态属性的值，传入null不正常，NullPointerException</span></span><br><span class="line">                System.out.println(<span class="string">&quot;获取私有属性变量的值：&quot;</span> + filedX.get(point));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//接着修改x的值为x:200.1</span></span><br><span class="line">                filedX.set(point, <span class="string">&quot;x:200.1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;反射修改后的值，filedX.get(point) = &quot;</span> + filedX.get(point));</span><br><span class="line">                System.out.println(<span class="string">&quot;反射修改后的值，point.getX() = &quot;</span> + point.getX());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取静态属性变量的值：z:<span class="number">135</span></span><br><span class="line">获取私有属性变量的值：x:<span class="number">10.1</span></span><br><span class="line">反射修改后的值，filedX.get(point) = x:<span class="number">200.1</span></span><br><span class="line">反射修改后的值，point.getX() = x:<span class="number">200.1</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-Method类"><a href="#2-3-Method类" class="headerlink" title="2.3. Method类"></a>2.3. Method类</h2><p>Method类代表某个类中的一个成员方法，反射调用Method的invoke方法时，同样需要特别注意入参的类型一定要准确，务必区分好基本类型、包装类型、String类型等。下面通过代码感受下反射Method。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodReflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MethodReflect</span> <span class="variable">methodReflect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodReflect</span>();</span><br><span class="line"></span><br><span class="line">        Method[] methods = methodReflect.getClass().getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            <span class="comment">//打印MethodReflect类所有方法，包括接口、父类</span></span><br><span class="line">            System.out.println(m.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Method[] declaredMethods = methodReflect.getClass().getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : declaredMethods) &#123;</span><br><span class="line">            <span class="comment">//打印MethodReflect类所有方法，不包括继承关系中的方法</span></span><br><span class="line">            System.out.println(m.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">witchCityDoYouLive</span> <span class="operator">=</span> methodReflect.getClass().getDeclaredMethod(<span class="string">&quot;witchCityDoYouLive&quot;</span>, String.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">cityBusinessCard</span> <span class="operator">=</span> methodReflect.getClass().getDeclaredMethod(<span class="string">&quot;cityBusinessCard&quot;</span>, String.class);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                witchCityDoYouLive.invoke(<span class="literal">null</span>, <span class="string">&quot;shenzhen&quot;</span>);<span class="comment">//第一个参数null表示该方法是static的</span></span><br><span class="line">                cityBusinessCard.invoke(methodReflect, <span class="string">&quot;shenzhen&quot;</span>);<span class="comment">//第一个参数不为null，表示该方法不是static的，代表目标对象</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">witchCityDoYouLive</span><span class="params">(String cityCode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cityCode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (cityCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;beijing&quot;</span>:</span><br><span class="line">                System.out.print(<span class="string">&quot;我来自北京，&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;shenzhen&quot;</span>:</span><br><span class="line">                System.out.print(<span class="string">&quot;我来自深圳，&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;shanghai&quot;</span>:</span><br><span class="line">                System.out.print(<span class="string">&quot;我来自上海，&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cityBusinessCard</span><span class="params">(String cityCode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cityCode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (cityCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;beijing&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;北京是中国的首都!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;shenzhen&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;深圳是一座创新之城!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;shanghai&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;上海是一座魔幻之城!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> com.leeeyou.reflect.MethodReflect.main(java.lang.String[])</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> com.leeeyou.reflect.MethodReflect.witchCityDoYouLive(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> com.leeeyou.reflect.MethodReflect.cityBusinessCard(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>,<span class="type">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.Object.toString()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> java.lang.Object.hashCode()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line">----</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> com.leeeyou.reflect.MethodReflect.main(java.lang.String[])</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> com.leeeyou.reflect.MethodReflect.witchCityDoYouLive(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> com.leeeyou.reflect.MethodReflect.cityBusinessCard(java.lang.String)</span><br><span class="line">----</span><br><span class="line">我来自深圳，深圳是一座创新之城!</span><br></pre></td></tr></table></figure>

<h2 id="2-4-反射数组"><a href="#2-4-反射数组" class="headerlink" title="2.4. 反射数组"></a>2.4. 反射数组</h2><p>具有相同维数和元素类型的数组属于同一个类型，即具有相同的Class实例对象；代表数组的Class实例对象的getSuperClass()方法返回的父类是Object类对应的Class。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayReflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[][] a3 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        String[] s4 = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;a1.getClass() == a2.getClass() = &quot;</span> + (a1.getClass() == a2.getClass()));<span class="comment">//字节码比较用==</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a1.getClass().getName() = &quot;</span> + a1.getClass().getName());<span class="comment">//[I</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a2.getClass().getName() = &quot;</span> + a2.getClass().getName());<span class="comment">//[I</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a3.getClass().getName() = &quot;</span> + a3.getClass().getName());<span class="comment">//[[I</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s4.getClass().getName() = &quot;</span> + s4.getClass().getName());<span class="comment">//[Ljava.lang.String;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a1.getClass().getSuperclass().getName() = &quot;</span> + a1.getClass().getSuperclass().getName());<span class="comment">//java.lang.Object</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s4.getClass().getSuperclass().getName() = &quot;</span> + s4.getClass().getSuperclass().getName());<span class="comment">//java.lang.Object</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Arrays.asList(a1) = &quot;</span> + Arrays.asList(a1));<span class="comment">//[[I@4554617c]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Arrays.asList(s4) = &quot;</span> + Arrays.asList(s4));<span class="comment">//[a, b, c]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayReflect</span> <span class="variable">ar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayReflect</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">whichProject</span> <span class="operator">=</span> ar.getClass().getDeclaredMethod(<span class="string">&quot;whichProject&quot;</span>, <span class="type">int</span>[].class);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                whichProject.invoke(<span class="literal">null</span>, a2);<span class="comment">//反射调用静态方法，传入数组类型的入参</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">whichProject</span><span class="params">(<span class="type">int</span>[] projectArray)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (projectArray == <span class="literal">null</span> || projectArray.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> project : projectArray) &#123;</span><br><span class="line">            System.out.println(project);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a1.getClass() == a2.getClass() = <span class="literal">true</span></span><br><span class="line">a1.getClass().getName() = [I</span><br><span class="line">a2.getClass().getName() = [I</span><br><span class="line">a3.getClass().getName() = [[I</span><br><span class="line">s4.getClass().getName() = [Ljava.lang.String;</span><br><span class="line">a1.getClass().getSuperclass().getName() = java.lang.Object</span><br><span class="line">s4.getClass().getSuperclass().getName() = java.lang.Object</span><br><span class="line">Arrays.asList(a1) = [[I@4554617c]</span><br><span class="line">Arrays.asList(s4) = [a, b, c]</span><br><span class="line">-----</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之观察者模式</title>
    <url>/iBlogWebsite/2016/09/26/2016/2016-09-26-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：&nbsp;定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖都会收到通知并自动更新。</p>
</blockquote>
<p>在这章节中作者引出了非常基本的设计原则：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 为交互对象之间的松耦合设计而努力。  </span><br><span class="line">   找出程序中会变化的方面，然后将其和固定不变的方面想分离    </span><br></pre></td></tr></table></figure>

<p>后续补充更多的内容：android中涉及的，java中涉及的观察者模式   </p>
<p>下面的内容转载自：<a href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a><br>文中以多人联机对战游戏案例展开，稳重包含了观察者模式结构图，解决方案结构图。同时介绍了JDK对观察者模式的支持<br><a href="http://blog.csdn.net/lovelion/article/details/7720232">对象间的联动——观察者模式（一）：多人联机对战游戏的设计</a><br><a href="http://blog.csdn.net/lovelion/article/details/7720382">对象间的联动——观察者模式（二）：观察者模式概述</a><br><a href="http://blog.csdn.net/lovelion/article/details/7720490">对象间的联动——观察者模式（三）：多人联机对战游戏的观察者模式解决方案</a><br><a href="http://blog.csdn.net/lovelion/article/details/7720507">对象间的联动——观察者模式（四）：JDK对观察者模式的支持</a><br><a href="http://blog.csdn.net/lovelion/article/details/7720522">对象间的联动——观察者模式（五）：观察者模式与Java事件处理</a><br><a href="http://blog.csdn.net/lovelion/article/details/7720537">对象间的联动——观察者模式（六）：观察者模式与MVC，观察者模式总结</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之策略模式</title>
    <url>/iBlogWebsite/2016/09/25/2016/2016-09-25-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：&nbsp;策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
</blockquote>
<p>head first书中在第一章引出策略模式，个人猜测<br>第一由于策略模式定义简单，容易理解；<br>第二策略模式是非常基本的模式，使用频率很高的缘故。</p>
<p>在这章节中作者引出了非常基本的设计原则：</p>
<blockquote>
<p>1.封装变化<br>2.针对接口编程，而不是针对实现编程<br>3.多用组合，少用继承  </p>
</blockquote>
<p>这三个设计原则基本却非常重要，在我们的工作编程中需时刻提醒自己，检查并重构自己的代码。  </p>
<p>下面的内容转载自：<a href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a><br>文中以电影票案例展开，介绍的非常详细。包含了策略模式结构图，解决方案结构图…<br><a href="http://blog.csdn.net/lovelion/article/details/7818983">算法的封装与切换——策略模式（一）：电影票打折方案</a><br><a href="http://blog.csdn.net/lovelion/article/details/7819136">算法的封装与切换——策略模式（二）：策略模式概述</a><br><a href="http://blog.csdn.net/lovelion/article/details/7819216">算法的封装与切换——策略模式（三）：电影票打折方案的策略模式解决方案</a><br><a href="http://blog.csdn.net/lovelion/article/details/7819266">算法的封装与切换——策略模式（四）：策略模式的两个典型应用，策略模式总结</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之装饰者模式</title>
    <url>/iBlogWebsite/2016/09/27/2016/2016-09-27-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：动态地将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。</p>
</blockquote>
<p>装饰模式和代理模式有点类似，有时甚至容易混淆，倒不是说会把代理当成装饰，而常常会将装饰看作代理。装饰模式是以客户端透明的方式扩展对象的功能，<strong>是继承关系的一个替代方案，给爱用继承的人一个全新的设计眼界；</strong> 而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。</p>
<p>装饰模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。</p>
<p><img src="https://img.mukewang.com/57a213c20001a3ee08100592.png" alt="装饰者模式类图"></p>
<p>装饰者和被装饰者必须是一样的类型，也就是有共同的超类，这是相当关键的地方。在这里，利用继承达到“类型匹配”，而不是利用继承获得“行为”。行为来自装饰者和基础组件，或与其他装饰者之间的组合关系。</p>
<h2 id="1-Java中的装饰者：Java-I-O"><a href="#1-Java中的装饰者：Java-I-O" class="headerlink" title="1. Java中的装饰者：Java I/O"></a>1. Java中的装饰者：Java I/O</h2><p><img src="https://img.mukewang.com/57a2241d0001a52607870577.png" alt="真实世界的装饰者：Java I/O"></p>
<p><img src="https://img.mukewang.com/57a22473000133c508330393.png" alt="装饰java.io类"></p>
<p>Java I/O也引出装饰者模式的一个“缺点”：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多了，可能会造成使用此API程序员的困扰。</p>
<h2 id="2-Android中的装饰者：Context"><a href="#2-Android中的装饰者：Context" class="headerlink" title="2. Android中的装饰者：Context"></a>2. Android中的装饰者：Context</h2><p><img src="http://upload-images.jianshu.io/upload_images/1417629-f30b4d949d425699.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android中Context类图"></p>
<p>从图中我们可以看出，ContextImpl和ContextWrapper继承自Context，ContextWrapper内部包含有Context类型的mBase对象，mBase具体指向的是ContextImpl。ContextImpl提供了很多功能，但是外界需要使用并拓展ContextImpl的功能，因此设计上使用了装饰模式，ContextWrapper是装饰类，它对ContextImpl进行包装，ContextWrapper主要是起了方法传递作用，ContextWrapper中几乎所有的方法实现都是调用ContextImpl的相应方法来实现的。</p>
<p>ContextThemeWrapper、Service和Application都继承自ContextWrapper，这样他们都可以通过mBase来使用Context的方法，同时它们也是装饰类，在ContextWrapper的基础上又添加了不同的功能。</p>
<p>ContextThemeWrapper中包含和主题相关的方法（比如： getTheme方法），因此，需要主题的Activity继承ContextThemeWrapper，而不需要主题的Service则继承ContextWrapper。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之抽象工厂模式</title>
    <url>/iBlogWebsite/2016/09/29/2016/2016-09-29-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：&nbsp;提供一个接口，用于创建相关或依赖对象的家族，而不需要明确制定具体类。</p>
</blockquote>
<p>下面的内容转载自：<a href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<blockquote>
<p>在抽象工厂模式中包含如下几个角色：<br>       ● AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。<br>       ● ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。<br>       ● AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。<br>       ● ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</p>
</blockquote>
<p><strong>在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。这也是抽象工厂模式最大的缺点。</strong><br>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：<br>(1) 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。<br>(2) 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。<br>正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</p>
<p>抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。</p>
<p><a href="http://blog.csdn.net/lovelion/article/details/9319181">工厂三兄弟之抽象工厂模式（一）：界面皮肤库的初始设计</a><br><a href="http://blog.csdn.net/lovelion/article/details/9319323">工厂三兄弟之抽象工厂模式（二）：产品等级结构与产品族</a><br><a href="http://blog.csdn.net/lovelion/article/details/9319423">工厂三兄弟之抽象工厂模式（三）：抽象工厂模式概述</a><br><a href="http://blog.csdn.net/lovelion/article/details/9319481">工厂三兄弟之抽象工厂模式（四）：界面皮肤库的抽象工厂模式解决方案</a><br><a href="http://blog.csdn.net/lovelion/article/details/9319571">工厂三兄弟之抽象工厂模式（五）：“开闭原则”的倾斜性，抽象工厂模式总结</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之工厂方法模式</title>
    <url>/iBlogWebsite/2016/09/28/2016/2016-09-28-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：&nbsp;定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。<br><br></p>
</blockquote>
<p>在这章节中作者引出了非常基本的设计原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 依赖抽象，不要依赖具体类。  </span><br></pre></td></tr></table></figure>

<p>下面的内容转载自：<a href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。<br>工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。</p>
<p><a href="http://blog.csdn.net/lovelion/article/details/9306457">工厂三兄弟之工厂方法模式（一）：日志记录器的设计</a><br><a href="http://blog.csdn.net/lovelion/article/details/9306745">工厂三兄弟之工厂方法模式（二）：工厂方法模式概述</a><br><a href="http://blog.csdn.net/lovelion/article/details/9307137">工厂三兄弟之工厂方法模式（三）：日志记录器的工厂方法模式解决方案，反射与配置文件</a><br><a href="http://blog.csdn.net/lovelion/article/details/9307561">工厂三兄弟之工厂方法模式（四）：重载的工厂方法，工厂方法的隐藏，工厂方法模式总结</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/iBlogWebsite/2016/09/30/2016/2016-09-30-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1、为什么要使用单例？"><a href="#1、为什么要使用单例？" class="headerlink" title="1、为什么要使用单例？"></a>1、为什么要使用单例？</h2><p>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<h2 id="2、单例的实现"><a href="#2、单例的实现" class="headerlink" title="2、单例的实现"></a>2、单例的实现</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式带来的问题是一上来就会创建对象，一定程度上造成资源的浪费。不过优点在于编写方式简单，容易理解。</p>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双重检测"><a href="#双重检测" class="headerlink" title="双重检测"></a>双重检测</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一重判断</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//锁定代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="comment">//第二重判断</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>(); <span class="comment">//创建单例实例</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>双重校验的懒汉式解决了饿汉式一上来就创建对象的问题，一定程度上做到了按需创建。同时双重校验机制只会在第一次创建实例时，有锁的介入，一旦实例创建成功，下次再获取实例就不会进入锁块了。</p>
<p>不过有个问题要注意，CPU 指令重排序可能导致在 LazySingleton 类的对象被关键字 new 创建并赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。这样，另一个线程就使用了一个没有完整初始化的 LazySingleton 类的对象。要解决这个问题，我们只需要给 instance 成员变量添加 volatile 关键字来禁止指令重排序即可。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Initialization on Demand Holder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HolderClass</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> HolderClass.instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">	    Singleton s1, s2;</span><br><span class="line">            s1 = Singleton.getInstance();</span><br><span class="line">	    s2 = Singleton.getInstance();</span><br><span class="line">	    System.out.println(s1==s2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类方式创建单例是最建议采用的一种方式，代码量较懒汉式少，同时做到了多线程安全，同时没有锁的消耗；对比饿汉式，静态内部类只有在第一次使用的时候才会创建实例，保证了对象按需获取。</p>
<p>instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p>
<h2 id="3、单例存在哪些问题？"><a href="#3、单例存在哪些问题？" class="headerlink" title="3、单例存在哪些问题？"></a>3、单例存在哪些问题？</h2><p>▪ 单例对 OOP 特性的支持不友好<br>▪ 单例会隐藏类之间的依赖关系<br>▪ 单例对代码的扩展性不友好<br>▪ 单例对代码的可测试性不友好<br>▪ 单例不支持有参数的构造函数</p>
<h2 id="4、单例与静态类的区别？"><a href="#4、单例与静态类的区别？" class="headerlink" title="4、单例与静态类的区别？"></a>4、单例与静态类的区别？</h2><p>静态方法无法支持延迟加载</p>
<h2 id="5、有何替代的解决方案？"><a href="#5、有何替代的解决方案？" class="headerlink" title="5、有何替代的解决方案？"></a>5、有何替代的解决方案？</h2><p>▪ 静态方法来实现<br>▪ 通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证</p>
<h2 id="6、如何理解单例模式中的唯一性？"><a href="#6、如何理解单例模式中的唯一性？" class="headerlink" title="6、如何理解单例模式中的唯一性？"></a>6、如何理解单例模式中的唯一性？</h2><p>通常指进程级别保证唯一性</p>
<h2 id="7、如何实现线程唯一的单例？"><a href="#7、如何实现线程唯一的单例？" class="headerlink" title="7、如何实现线程唯一的单例？"></a>7、如何实现线程唯一的单例？</h2><p>通过 HashMap 的方式或者 ThreadLocal</p>
<h2 id="8、如何实现集群环境下的单例？"><a href="#8、如何实现集群环境下的单例？" class="headerlink" title="8、如何实现集群环境下的单例？"></a>8、如何实现集群环境下的单例？</h2><p>▪ 把这个单例对象序列化并存储到外部共享存储区（比如文件）<br>▪ 为了保证安全，操作时要考虑加锁，用完后主动释放</p>
<h2 id="9、如何实现一个多例模式？"><a href="#9、如何实现一个多例模式？" class="headerlink" title="9、如何实现一个多例模式？"></a>9、如何实现一个多例模式？</h2><p>可以通过 HashMap 限定某个类仅能创建3个对象</p>
<h2 id="10、对于-Java-语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class-Loader），为什么？"><a href="#10、对于-Java-语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class-Loader），为什么？" class="headerlink" title="10、对于 Java 语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader），为什么？"></a>10、对于 Java 语言来说，单例类对象的唯一性的作用范围并非进程，而是类加载器（Class Loader），为什么？</h2><p>Java 中加载一个类是通过 <strong>ClassLoaderX + pacakge.class</strong> 的方式（双亲委派+类全限定名）唯一确定一个类。而单例指的是一个类对应一个对象。所以可以说 Java 中的单例是类加载器级别的。</p>
<hr>
<p>参考</p>
<ul>
<li><a href="https://time.geekbang.org/column/article/194035">41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？</a></li>
<li><a href="https://time.geekbang.org/column/article/194068">42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？</a></li>
<li><a href="https://time.geekbang.org/column/article/196790">43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？</a></li>
<li><a href="http://blog.csdn.net/lovelion/article/details/7420883">确保对象的唯一性——单例模式 （一）：单例模式的动机，单例模式概述</a></li>
<li><a href="http://blog.csdn.net/lovelion/article/details/7420885">确保对象的唯一性——单例模式 （二）：负载均衡器的设计与实现</a></li>
<li><a href="http://blog.csdn.net/lovelion/article/details/7420886">确保对象的唯一性——单例模式 （三）：饿汉式单例与懒汉式单例的讨论</a></li>
<li><a href="http://blog.csdn.net/lovelion/article/details/7420888">确保对象的唯一性——单例模式 （四）：一种更好的单例实现方法（静态内部类）</a></li>
<li><a href="http://blog.csdn.net/lovelion/article/details/7420889">确保对象的唯一性——单例模式 （五）：单例模式总结</a></li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之适配器模式</title>
    <url>/iBlogWebsite/2016/10/02/2016/2016-10-02-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：&nbsp;将一个类的接口，转换成客户期望另一个接口。适配器让原本不兼容的类可以合作无间。</p>
</blockquote>
<p>在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。<br><strong>根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。在实际开发中，对象适配器的使用频率更高。</strong></p>
<p>下面的内容转载自：<a href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在Spring等开源框架、驱动程序设计（如JDBC中的数据库驱动程序）中也使用了适配器模式。</p>
<p><a href="http://blog.csdn.net/lovelion/article/details/8624325">不兼容结构的协调——适配器模式（一）：没有源码的算法库，适配器模式概述</a><br><a href="http://blog.csdn.net/lovelion/article/details/8624412">不兼容结构的协调——适配器模式（二）：没有源码的算法库的适配器模式解决方案</a><br><a href="http://blog.csdn.net/lovelion/article/details/8624428">不兼容结构的协调——适配器模式（三）：类适配器，双向适配器</a><br><a href="http://blog.csdn.net/lovelion/article/details/8624633">不兼容结构的协调——适配器模式（四）：缺省适配</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之组合模式</title>
    <url>/iBlogWebsite/2016/10/06/2016/2016-10-06-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：&nbsp;允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致对方法处理个别对象以及对象组合。</p>
</blockquote>
<p>在这章节中作者引出了非常基本的设计原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 类应该只有一个改变的理由  </span><br></pre></td></tr></table></figure>

<p>组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。<br>同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。<br>如果不使用组合模式，客户端代码将过多地依赖于容器对象复杂的内部实现结构，容器对象内部实现结构的变化将引起客户代码的频繁变化，带来了代码维护复杂、可扩展性差等弊端。组合模式的引入将在一定程度上解决这些问题。</p>
<p>下面的内容转载自：<a href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p> 组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。<br> 由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式，Java SE中的AWT和Swing包的设计就基于组合模式，在这些界面包中为用户提供了大量的容器构件（如Container）和成员构件（如Checkbox、Button和TextComponent等）</p>
<p> <a href="http://blog.csdn.net/lovelion/article/details/7956898">树形结构的处理——组合模式（一）：设计杀毒软件的框架结构</a><br> <a href="http://blog.csdn.net/lovelion/article/details/7956908">树形结构的处理——组合模式（二）：组合模式概述</a><br> <a href="http://blog.csdn.net/lovelion/article/details/7956931">树形结构的处理——组合模式（三）：杀毒软件的框架结构的组合模式解决方案</a><br> <a href="http://blog.csdn.net/lovelion/article/details/7956937">树形结构的处理——组合模式（四）：透明组合模式与安全组合模式</a><br> <a href="http://blog.csdn.net/lovelion/article/details/7956962">树形结构的处理——组合模式（五）：公司组织结构，组合模式总结</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之外观模式</title>
    <url>/iBlogWebsite/2016/10/03/2016/2016-10-03-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：&nbsp;提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>
</blockquote>
<p><strong>外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化，而外观模式的引入在很大程度上降低了类与类之间的耦合关系。</strong><br>引入外观模式之后，增加新的子系统或者移除子系统都非常方便，客户类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。<br>从这一点来说，外观模式在一定程度上并不符合开闭原则，增加新的子系统需要对原有系统进行一定的修改，虽然这个修改工作量不大。<br>外观模式中所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统。</p>
<p>下面的内容转载自：<a href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>外观模式是一种使用频率非常高的设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。</p>
<ul>
<li>外观模式并不给系统增加任何新功能，它仅仅是简化调用接口。</li>
<li>在几乎所有的软件中都能够找到外观模式的应用，如绝大多数B/S系统都有一个首页或者导航页面，大部分C/S系统都提供了菜单或者工具栏，在这里，首页和导航页面就是B/S系统的外观角色，而菜单和工具栏就是C/S系统的外观角色，通过它们用户可以快速访问子系统，降低了系统的复杂程度。</li>
<li>所有涉及到与多个业务对象交互的场景都可以考虑使用外观模式进行重构。</li>
</ul>
<p><a href="http://blog.csdn.net/lovelion/article/details/8258121">深入浅出外观模式（一）：外观模式概述，外观模式结构与实现</a><br><a href="http://blog.csdn.net/lovelion/article/details/8259705">深入浅出外观模式（二）：外观模式应用实例（文件加密模块）</a><br><a href="http://blog.csdn.net/lovelion/article/details/8259789">深入浅出外观模式（三）：抽象外观类，外观模式效果与适用场景</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之命令模式</title>
    <url>/iBlogWebsite/2016/10/01/2016/2016-10-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：&nbsp;将请求封装成对象，这可以让你使用不同的请求，队列，或者日志请求来参数化其他对象。命令模式也可以支持撤销操作。</p>
</blockquote>
<p><strong>命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。</strong></p>
<p>下面的内容转载自：<a href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>命令模式是一种使用频率非常高的设计模式，它可以将请求发送者与接收者解耦，请求发送者通过命令对象来间接引用请求接收者，使得系统具有更好的灵活性和可扩展性。在基于GUI的软件开发，无论是在电脑桌面应用还是在移动应用中，命令模式都得到了广泛的应用。</p>
<p><a href="http://blog.csdn.net/lovelion/article/details/8796736">请求发送者与接收者解耦——命令模式（一）：自定义功能键，命令模式概述</a><br><a href="http://blog.csdn.net/lovelion/article/details/8806049">请求发送者与接收者解耦——命令模式（二）：自定义功能键的命令模式解决方案</a><br><a href="http://blog.csdn.net/lovelion/article/details/8806239">请求发送者与接收者解耦——命令模式（三）：命令队列的实现</a><br><a href="http://blog.csdn.net/lovelion/article/details/8806509">请求发送者与接收者解耦——命令模式（四）：撤销操作的简单实现</a><br><a href="http://blog.csdn.net/lovelion/article/details/8806643">请求发送者与接收者解耦——命令模式（五）：请求日志</a><br><a href="http://blog.csdn.net/lovelion/article/details/8806677">请求发送者与接收者解耦——命令模式（六）：宏命令，命令模式总结</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之迭代器模式</title>
    <url>/iBlogWebsite/2016/10/05/2016/2016-10-05-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：&nbsp;提供一种方法顺序访问一个聚合对象中的某个元素，而又不是暴露其内部的表示。</p>
</blockquote>
<p>在这章节中作者引出了非常基本的设计原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 类应该只有一个改变的理由</span><br></pre></td></tr></table></figure>

<p>下面的内容转载自：<a href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p> 迭代器模式是一种使用频率非常高的设计模式，通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。<br> 由于很多编程语言的类库都已经实现了迭代器模式，因此在实际开发中，我们只需要直接使用Java、C#等语言已定义好的迭代器即可，迭代器已经成为我们操作聚合对象的基本工具之一。</p>
<p><a href="http://blog.csdn.net/lovelion/article/details/9992005">遍历聚合对象中的元素——迭代器模式（一）：销售管理系统中数据的遍历</a><br><a href="http://blog.csdn.net/lovelion/article/details/9992243">遍历聚合对象中的元素——迭代器模式（二）：迭代器模式概述</a><br><a href="http://blog.csdn.net/lovelion/article/details/9992679">遍历聚合对象中的元素——迭代器模式（三）：销售管理系统中数据的遍历的迭代器模式解决方案</a><br><a href="http://blog.csdn.net/lovelion/article/details/9992731">遍历聚合对象中的元素——迭代器模式（四）：使用内部类实现迭代器</a><br><a href="http://blog.csdn.net/lovelion/article/details/9992799">遍历聚合对象中的元素——迭代器模式（五）：JDK内置迭代器的使用</a><br><a href="http://blog.csdn.net/lovelion/article/details/9992931">遍历聚合对象中的元素——迭代器模式（六）：迭代器模式总结</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之模板方法模式</title>
    <url>/iBlogWebsite/2016/10/04/2016/2016-10-04-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：&nbsp;在一个方法中定义一个算法的骨架，而将一些步骤延迟到子来中。模板方法使得子类可以在不改变算法接口的情况下，重新定义算法中的某些步骤。</p>
</blockquote>
<p>在这章节中作者引出了非常基本的设计原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 别找我，我会找你</span><br></pre></td></tr></table></figure>

<p>下面的内容转载自：<a href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>模板方法模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式。模板方法模式广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序（如框架的初始化，测试流程的设置等）。</p>
<p><a href="http://blog.csdn.net/lovelion/article/details/8299794">模板方法模式深度解析（一）：模板方法模式概述，模板方法模式结构与实现</a><br><a href="http://blog.csdn.net/lovelion/article/details/8299863">模板方法模式深度解析（二）：模板方法模式应用实例（银行利息计算模块）</a><br><a href="http://blog.csdn.net/lovelion/article/details/8299927">模板方法模式深度解析（三）：钩子方法的使用，模板方法模式效果与适用场景</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Monkey命令示例</title>
    <url>/iBlogWebsite/2016/12/09/2016/2016-12-09-Monkey%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>1、整机测试，而不测试拨号键盘应用，忽略所有错误，次数100万次</p>
<p>adb shell monkey –ignore-crashes –ignore-timeouts –pkg-blaklist-file -v -v 1000000</p>
<p>2、测试计算器30万次，随机种子为100，随机延迟0-1秒，忽略所有错误</p>
<p>adb shell monkey -p com.android.calculator2 -s 100 –throttle 1000 –randomize-throttle –ignore-crashes –ignore-timeouts -v -v 30000</p>
<p>3、测试计算器，触摸事件30%，其他按键50%，错误停止，延时200</p>
<p>adb shell monkey -p com.android.calculator2 –throttle 200 –pct-touch 30 –pct-anyevent 50 -v -v 100000</p>
<p>4、对计算器进行旋转压力测试，事件延时2秒，10万次</p>
<p>adb shell monkey -p com.android.calculator2 –pct-rotation 100 –throttle 2000 100000</p>
<p>5、仅对整机的应用开启测试，事件延时5秒，10万次</p>
<p>adb shell monkey –pct-appswitch 100 –throttle 5000 100000</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Monkey</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之状态模式</title>
    <url>/iBlogWebsite/2016/10/07/2016/2016-10-07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：&nbsp;允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
</blockquote>
<p>下面的内容转载自：<a href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p> 状态模式将一个对象在不同状态下的不同行为封装在一个个状态类中，通过设置不同的状态对象可以让环境对象拥有不同的行为，而状态转换的细节对于客户端而言是透明的，方便了客户端的使用。<br> 在实际开发中，状态模式具有较高的使用频率，在工作流和游戏开发中状态模式都得到了广泛的应用，例如公文状态的转换、游戏中角色的升级等。</p>
<p><a href="http://blog.csdn.net/lovelion/article/details/8522982">处理对象的多种状态及其相互转换——状态模式（一）：银行系统中的账户类设计</a><br><a href="http://blog.csdn.net/lovelion/article/details/8523062">处理对象的多种状态及其相互转换——状态模式（二）：状态模式概述</a><br><a href="http://blog.csdn.net/lovelion/article/details/8523083">处理对象的多种状态及其相互转换——状态模式（三）：账户类的状态模式解决方案</a><br><a href="http://blog.csdn.net/lovelion/article/details/8523105">处理对象的多种状态及其相互转换——状态模式（四）：共享状态的实现</a><br><a href="http://blog.csdn.net/lovelion/article/details/8523130">处理对象的多种状态及其相互转换——状态模式（五）：使用环境类实现状态转换</a><br><a href="http://blog.csdn.net/lovelion/article/details/8523162">处理对象的多种状态及其相互转换——状态模式（六）：状态模式总结</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之网络通信整理</title>
    <url>/iBlogWebsite/2016/12/28/2016/2016-12-28-Android%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>花了将近7、8个小时粗略整理了自己遇到的一些关于网络通信的问题，也算是对这一大块内容的一个交代。这节的内容非常多，主要包括如下几个主题：网络各层的结构、TCP和UDP、Http协议的理解和用法、Socket编程、以及一些扩展，包括访问一个网页的流程、ping的整个过程等。当然一些常见的问题：三次握手四次挥手以及Socket与Http、Socket与TCP/IP的纠缠在文档中都有说明。</p>
<h1 id="1-网络各层的结构"><a href="#1-网络各层的结构" class="headerlink" title="1. 网络各层的结构"></a>1. 网络各层的结构</h1><h2 id="1-1-OSI模型"><a href="#1-1-OSI模型" class="headerlink" title="1.1. OSI模型"></a>1.1. OSI模型</h2><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<h2 id="1-2-层模型"><a href="#1-2-层模型" class="headerlink" title="1.2. 层模型"></a>1.2. 层模型</h2><p>1.2.1 物理层、数据链路层、网络层、运输层、 应用层</p>
<h2 id="1-3-各层协议与作用"><a href="#1-3-各层协议与作用" class="headerlink" title="1.3. 各层协议与作用"></a>1.3. 各层协议与作用</h2><p>物理层</p>
<ul>
<li>RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）</li>
<li>通过媒介传输比特,确定机械及电气规范（比特Bit）</li>
</ul>
<p>数据链路</p>
<ul>
<li>PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）</li>
<li>将比特组装成帧和点到点的传递（帧Frame）</li>
</ul>
<p>网络层</p>
<ul>
<li>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li>
<li>负责数据包从源到宿的传递和网际互连（包PackeT）</li>
</ul>
<p>传输层</p>
<ul>
<li>TCP、UDP、SPX</li>
<li>提供端到端的可靠报文传递和错误恢复（段Segment）</li>
</ul>
<p>会话层</p>
<ul>
<li>NFS、SQL、NETBIOS、RPC</li>
<li>建立、管理和终止会话（会话协议数据单元SPDU）</li>
</ul>
<p>表示层</p>
<ul>
<li>JPEG、MPEG、ASII</li>
<li>对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
</ul>
<p>应用层</p>
<ul>
<li>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li>
<li>允许访问OSI环境的手段（应用协议数据单元APDU）</li>
</ul>
<h1 id="2-UDP协议"><a href="#2-UDP协议" class="headerlink" title="2. UDP协议"></a>2. UDP协议</h1><h1 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3. TCP协议"></a>3. TCP协议</h1><h2 id="3-1-TCP-UDP的区别"><a href="#3-1-TCP-UDP的区别" class="headerlink" title="3.1. TCP/UDP的区别"></a>3.1. TCP/UDP的区别</h2><ul>
<li><p>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。TCP需要建立连接，而UDP不需要建立连接（无连接传输）</p>
</li>
<li><p>TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。</p>
</li>
<li><p>是否建立真实连接的特性，造成了双方可靠性的差距。</p>
<ul>
<li><p>TCP属于可靠的传输协议：因为传输前双方建立好了连接，相当于买卖双方建立好了交易合同，传输中一般不会出现意外，直到连接终止；</p>
</li>
<li><p>UDP属于不可靠的传输协议：UDP的所谓连接相当于一种映射，UDP单方面的认为目标地址（端口）是可用的，从而进行收发数据，而实际上目标地址（端口）未必可用，所以传输数据不可靠</p>
</li>
</ul>
</li>
<li><p>由于TCP需要建立真实的连接，所以需要消耗服务器的负载要大于UDP</p>
</li>
</ul>
<h2 id="3-2-TCP报文结构"><a href="#3-2-TCP报文结构" class="headerlink" title="3.2. TCP报文结构"></a>3.2. TCP报文结构</h2><p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/tcp%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.jpg" alt="tcp报文结构"></p>
<p>源端口、目标端口</p>
<ul>
<li>计算机上的进程要和其他进程通信是要通过计算机端口的，而一个计算机端口某个时刻只能被一个进程占用，所以通过指定源端口和目标端口，就可以知道是哪两个进程需要通信。源端口、目标端口是用16位表示的，可推算计算机的端口个数为2^16个。</li>
</ul>
<p>序列号</p>
<ul>
<li><p>表示本报文段所发送数据的第一个字节的编号。在TCP连接中所传送的字节流的每一个字节都会按顺序编号。由于序列号由32位表示，所以每2^32个字节，就会出现序列号回绕，再次从 0 开始。</p>
</li>
<li><p>那如何区分两个相同序列号的不同TCP报文段就是一个问题了，后面会有答案，暂时可以不管。</p>
</li>
</ul>
<p>确认号</p>
<ul>
<li>表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。也就是告诉发送发：我希望你（指发送方）下次发送的数据的第一个字节数据的编号是这个确认号。也就是告诉发送方：我希望你（指发送方）下次发送给我的TCP报文段的序列号字段的值是这个确认号。</li>
</ul>
<p>TCP首部长度</p>
<ul>
<li>由于TCP首部包含一个长度可变的选项部分，所以需要这么一个值来指定这个TCP报文段到底有多长。或者可以这么理解：就是表示TCP报文段中数据部分在整个TCP报文段中的位置。该字段的单位是32位字，即：4个字节。</li>
</ul>
<p>URG</p>
<ul>
<li>表示本报文段中发送的数据是否包含紧急数据。URG=1，表示有紧急数据。后面的紧急指针字段只有当URG=1时才有效。</li>
</ul>
<p>ACK</p>
<ul>
<li>表示是否前面的确认号字段是否有效。ACK=1，表示有效。只有当ACK=1时，前面的确认号字段才有效。TCP规定，连接建立后，ACK必须为1。</li>
</ul>
<p>PSH</p>
<ul>
<li>告诉对方收到该报文段后是否应该立即把数据推送给上层。如果为1，则表示对方应当立即把数据提交给上层，而不是缓存起来。</li>
</ul>
<p>RST</p>
<ul>
<li>只有当RST=1时才有用。如果你收到一个RST=1的报文，说明你与主机的连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。或者说明你上次发送给主机的数据有问题，主机拒绝响应。</li>
</ul>
<p>SYN</p>
<ul>
<li>在建立连接时使用，用来同步序号。当SYN=1，ACK=0时，表示这是一个请求建立连接的报文段；当SYN=1，ACK=1时，表示对方同意建立连接。SYN=1，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中SYN才置为1。</li>
</ul>
<p>FIN</p>
<ul>
<li>标记数据是否发送完毕。如果FIN=1，就相当于告诉对方：“我的数据已经发送完毕，你可以释放连接了”</li>
</ul>
<p>窗口大小</p>
<ul>
<li>表示现在运行对方发送的数据量。也就是告诉对方，从本报文段的确认号开始允许对方发送的数据量。</li>
</ul>
<p>校验和</p>
<ul>
<li>提供额外的可靠性。具体如何校验，参考其他资料。</li>
</ul>
<p>紧急指针</p>
<ul>
<li>标记紧急数据在数据字段中的位置。</li>
</ul>
<p>选项部分</p>
<ul>
<li>其最大长度可根据TCP首部长度进行推算。TCP首部长度用4位表示，那么选项部分最长为：(2^4-1)*4-20=40字节。</li>
</ul>
<h2 id="3-3-三次握手"><a href="#3-3-三次握手" class="headerlink" title="3.3. 三次握手"></a>3.3. 三次握手</h2><ul>
<li><p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F.jpg" alt="三次握手示意"></p>
<ul>
<li><p>SYN攻击</p>
<ul>
<li><p>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。</p>
</li>
<li><p>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。</p>
</li>
<li><p>SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：#netstat -nap | grep SYN_RECV</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-4-四次挥手"><a href="#3-4-四次挥手" class="headerlink" title="3.4. 四次挥手"></a>3.4. 四次挥手</h2><ul>
<li><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p>
</li>
<li><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p>
</li>
<li><p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>
</li>
<li><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
</li>
<li><p>由于TCP连接是全双工的，因此每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%A4%BA%E6%84%8F.jpg" alt="四次挥手示意"></p>
<p>为什么建立连接是三次而关闭连接却要四次呢？</p>
<ul>
<li>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</li>
</ul>
<h2 id="3-5-流量控制"><a href="#3-5-流量控制" class="headerlink" title="3.5. 流量控制"></a>3.5. 流量控制</h2><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不<br>是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" alt="流量控制"></p>
<p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p>
<p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p>
<h2 id="3-6-拥塞控制"><a href="#3-6-拥塞控制" class="headerlink" title="3.6. 拥塞控制"></a>3.6. 拥塞控制</h2><p>拥塞</p>
<ul>
<li>即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。</li>
</ul>
<p>拥塞控制</p>
<ul>
<li>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</li>
</ul>
<p>流量控制</p>
<ul>
<li>指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
<p>拥塞控制代价</p>
<ul>
<li>需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。</li>
</ul>
<p>几种拥塞控制方法</p>
<ul>
<li><p>慢开始算法</p>
<ul>
<li>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</li>
</ul>
</li>
<li><p>拥塞控制算法</p>
<ul>
<li><p>当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。</p>
</li>
<li><p>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd 增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长。</p>
</li>
<li><p>假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小。</p>
</li>
<li><p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F.jpg" alt="拥塞控制算法示意"></p>
<ul>
<li><p>快重传算法</p>
<ul>
<li>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</li>
</ul>
</li>
<li><p>快恢复算法</p>
<ul>
<li><p>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p>
</li>
<li><p>由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E5%BF%AB%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F.jpg" alt="快恢复算法示意"></p>
<ul>
<li><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。</p>
</li>
<li><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
</li>
</ul>
<h1 id="4-Http协议"><a href="#4-Http协议" class="headerlink" title="4. Http协议"></a>4. Http协议</h1><h2 id="4-1-报文结构"><a href="#4-1-报文结构" class="headerlink" title="4.1. 报文结构"></a>4.1. 报文结构</h2><p>请求报文</p>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt="请求报文"></p>
<p>响应报文</p>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" alt="响应报文"></p>
<h2 id="4-2-状态说明"><a href="#4-2-状态说明" class="headerlink" title="4.2. 状态说明"></a>4.2. 状态说明</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值</p>
<ul>
<li>100~199：指示信息，表示请求已接收，继续处理</li>
<li>200~299：请求成功，表示请求已被成功接收、理解、接受</li>
<li>300~399：重定向，要完成请求必须进行更进一步的操作</li>
<li>400~499：客户端错误，请求有语法错误或请求无法实现</li>
<li>500~599：服务器端错误，服务器未能实现合法的请求</li>
</ul>
<p>常见的状态码如下</p>
<ul>
<li>200 OK 客户端请求成功</li>
<li>400 Bad Request 客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li>
<li>403 Forbidden 服务器收到请求，但是拒绝提供服务</li>
<li>500 Internal Server Error 服务器发生不可预期的错误</li>
<li>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<h2 id="4-3-Request的几种类型"><a href="#4-3-Request的几种类型" class="headerlink" title="4.3. Request的几种类型"></a>4.3. Request的几种类型</h2><p>OPTIONS</p>
<ul>
<li>返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</li>
</ul>
<p>HEAD</p>
<ul>
<li>向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</li>
</ul>
<p>GET</p>
<ul>
<li>向特定的资源发出请求。</li>
</ul>
<p>POST</p>
<ul>
<li>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和 / 或已有资源的修改。</li>
</ul>
<p>PUT</p>
<ul>
<li>向指定资源位置上传其最新内容。</li>
</ul>
<p>DELETE</p>
<ul>
<li>请求服务器删除Request-URI所标识的资源。</li>
</ul>
<p>TRACE</p>
<ul>
<li>回显服务器收到的请求，主要用于测试或诊断。</li>
</ul>
<h2 id="4-4-Http1-1和Http1-0的区别"><a href="#4-4-Http1-1和Http1-0的区别" class="headerlink" title="4.4. Http1.1和Http1.0的区别"></a>4.4. Http1.1和Http1.0的区别</h2><p>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p>
<ul>
<li><p>HTTP 1.0规定浏览器与服务器只保持短暂的连接，而HTTP 1.1 支持长连接。</p>
<ul>
<li><p>在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</p>
</li>
<li><p>在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p>
</li>
</ul>
</li>
<li><p>HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。HTTP1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p>
</li>
<li><p>HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。</p>
</li>
<li><p>HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。</p>
</li>
</ul>
<h2 id="4-5-Http怎么处理长连接"><a href="#4-5-Http怎么处理长连接" class="headerlink" title="4.5. Http怎么处理长连接"></a>4.5. Http怎么处理长连接</h2><p>http长连接即持久连接是http1.1版本的一个特性，即一个http连接建立完成一个请求-回应后，可以不需要立刻关闭，可以重复使用。http的长连接是可以发送多个请求而不用等待每个响应的。</p>
<h2 id="4-6-HTTP缓存机制"><a href="#4-6-HTTP缓存机制" class="headerlink" title="4.6. HTTP缓存机制"></a>4.6. HTTP缓存机制</h2><p>缓存对于移动端是非常重要的存在。</p>
<p>优点</p>
<ul>
<li>减少请求次数，减小服务器压力.</li>
<li>本地数据读取速度更快，让页面不会空白几百毫秒。</li>
<li>在无网络的情况下提供数据。</li>
</ul>
<p>具体实施</p>
<ul>
<li>缓存一般由服务器控制(通过某些方式可以本地控制缓存，比如向过滤器添加缓存控制信息)。</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/http%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E8%AF%B7%E6%B1%82%E5%A4%B4.png" alt="http缓存相关请求头"></p>
<ul>
<li>客户端发起请求的时候要检查缓存。遵循下面步骤，注意服务器返回304意思是数据没有变动滚去读缓存信息。</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.png" alt="浏览器缓存机制"></p>
<h1 id="5-Socket"><a href="#5-Socket" class="headerlink" title="5. Socket"></a>5. Socket</h1><h2 id="5-1-套接字的概念"><a href="#5-1-套接字的概念" class="headerlink" title="5.1. 套接字的概念"></a>5.1. 套接字的概念</h2><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>
<p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<h2 id="5-2-建立socket连接"><a href="#5-2-建立socket连接" class="headerlink" title="5.2. 建立socket连接"></a>5.2. 建立socket连接</h2><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<p>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p>
<p>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p>
<p>连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与服务端建立Socket连接</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(GlobalParams.HOST, GlobalParams.PORT);</span><br><span class="line">Log.e(TAG, <span class="string">&quot;开始发送Socket请求&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往服务端写数据</span></span><br><span class="line">writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(client.getOutputStream());</span><br><span class="line">writer.write(packageJSON());<span class="comment">// 将封装好的 JSON传递到服务端</span></span><br><span class="line">writer.flush();<span class="comment">// 字节流需要flush</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取服务端传回的数据</span></span><br><span class="line"><span class="keyword">if</span> (client.isConnected()) &#123;</span><br><span class="line">  Log.e(TAG, <span class="string">&quot;socket已连接成功&quot;</span>)</span><br><span class="line">  reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(client.getInputStream()));</span><br><span class="line">  <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;接收到了服务端传来的数据：&quot;</span> + line + <span class="string">&quot;----长度：&quot;</span> + line.length());</span><br><span class="line">    result.append(line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">IOUtils.close(reader, writer);</span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure>

<h2 id="5-3-短线重连怎么实现"><a href="#5-3-短线重连怎么实现" class="headerlink" title="5.3. 短线重连怎么实现"></a>5.3. 短线重连怎么实现</h2><p>利用心跳检测客户端是否与服务端连接正常，如断开了就发起重连</p>
<h2 id="5-4-心跳机制又是怎样实现"><a href="#5-4-心跳机制又是怎样实现" class="headerlink" title="5.4. 心跳机制又是怎样实现"></a>5.4. 心跳机制又是怎样实现</h2><p>介绍</p>
<ul>
<li><p>心跳信息是单方向的，只有终端发到应用服务器；</p>
</li>
<li><p>心跳信息的周期比较长，比如旧版QQ的心跳周期为30s，新版QQ为180s，微信为300s，Google原生应用为1680s左右。</p>
</li>
<li><p>另外，互联网应用的心跳包除了宣告终端在线外，还有一项重要的任务，就是提供终端的即时地址，方便应用服务器的寻址。</p>
</li>
<li><p>有了互联网应用的心跳机制，应用服务器可以及时下发(Push)用户相关的信息，比如微信中的短消息、图片或者语音等。</p>
</li>
<li><p>心跳包也会带来很多副作用，比如终端更为费电，还可能给移动通信网络带来信令风暴。</p>
</li>
</ul>
<p>实现</p>
<ul>
<li><p>轮询：定时去server查询数据</p>
</li>
<li><p>推送：使用XMPP长连接</p>
</li>
</ul>
<p>移动无线网络的特点</p>
<ul>
<li><p>因IPv4的数量有限，运营商分配给手机终端的 IP 是运营商内网的 IP，手机要连接 Internet，就需要通过运营商的网关做一个网络地址转换（Network Address Translation，NAT）。简单的说运营商的网关需要维护一个外网 IP、端口到内网 IP、端口的对应关系，以确保内网的手机可以跟 Internet 的服务器通讯</p>
</li>
<li><p>我们知道移动端要和Internet进行通信，必须通过运营商的网关，所以，为了不让NAT映射表失效，我们需要定时向Internet发送数据，因为只是为了不然NAT映射表失效，所以只需发送长度为0的数据即可。</p>
</li>
</ul>
<h1 id="6-扩展"><a href="#6-扩展" class="headerlink" title="6. 扩展"></a>6. 扩展</h1><h2 id="6-1-Socket、TCP-IP与HTTP"><a href="#6-1-Socket、TCP-IP与HTTP" class="headerlink" title="6.1. Socket、TCP/IP与HTTP"></a>6.1. Socket、TCP/IP与HTTP</h2><h3 id="6-1-1-Socket连接与TCP-IP连接"><a href="#6-1-1-Socket连接与TCP-IP连接" class="headerlink" title="6.1.1. Socket连接与TCP/IP连接"></a>6.1.1. Socket连接与TCP/IP连接</h3><p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p>
<p>Socket是对TCP/IP协议的封装和应用（程序员层面上）。也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</p>
<p>我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。</p>
<p>实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket我们才能使用TCP/IP协议。Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。</p>
<p>实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。Socket是对端口通信开发的工具,它要更底层一些。</p>
<h3 id="6-1-2-Socket连接与HTTP连接"><a href="#6-1-2-Socket连接与HTTP连接" class="headerlink" title="6.1.2. Socket连接与HTTP连接"></a>6.1.2. Socket连接与HTTP连接</h3><p>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p>
<p>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</p>
<p>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。</p>
<p>有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</p>
<p>两个计算机之间的交流无非是两个端口之间的数据通信，具体的数据会以什么样的形式展现，是以不同的应用层协议来定义的：如HTTP，FTP…</p>
<h2 id="6-2-Cookie与Session的作用与原理"><a href="#6-2-Cookie与Session的作用与原理" class="headerlink" title="6.2. Cookie与Session的作用与原理"></a>6.2. Cookie与Session的作用与原理</h2><h3 id="6-2-1-Cookie"><a href="#6-2-1-Cookie" class="headerlink" title="6.2.1. Cookie"></a>6.2.1. Cookie</h3><p>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于在服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上还有其他选择。  </p>
<p>会话cookie和持久cookie的区别</p>
<ul>
<li><p>如果不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。  </p>
</li>
<li><p>如果设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。  </p>
</li>
<li><p>存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。</p>
</li>
</ul>
<h3 id="6-2-2-Sessioin"><a href="#6-2-2-Sessioin" class="headerlink" title="6.2.2. Sessioin"></a>6.2.2. Sessioin</h3><p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。</p>
<p>保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID，而。比如weblogic对于web应用程序生成的cookie，JSESSIONID=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764，它的名字就是JSESSIONID。 由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，表现形式为http://…../xxx;jsessionid=ByOK … 99zWpBng!-145788764。另一种是作为查询字符串附加在URL后面，表现形式为http://…../xxx?jsessionid=ByOK …99zWpBng!-145788764</p>
<p>另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。这种技术现在已较少应用，笔者接触过的很古老的iPlanet6(SunONE应用服务器的前身)就使用了这种技术。 实际上这种技术可以简单的用对action应用URL重写来代替。这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把session id的信息和正常程序参数区分开来。 为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。</p>
<p>在谈论session机制的时候，常常听到这样一种误解“只要关闭浏览器，session就消失了”。其实可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对session来说也是一样的，除非程序通知服务器删除一个session，否则服务器会一直保留，程序一般都是在用户做log off的时候发个指令去删除session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接服务器时也就无法找到原来的session。如果服务器设置的cookie被保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的session id发送给服务器，则再次打开浏览器仍然能够找到原来的session。</p>
<p>恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。</p>
<h2 id="6-3-访问一个网页其整个过程是怎样的？"><a href="#6-3-访问一个网页其整个过程是怎样的？" class="headerlink" title="6.3. 访问一个网页其整个过程是怎样的？"></a>6.3. 访问一个网页其整个过程是怎样的？</h2><p>浏览器先尝试从Host文件中获取 <a href="http://www.baidu.com/">http://www.baidu.com/</a> 对应的IP地址，如果能取到当然万事大吉大家都能嗨，如果不能，就使用DNS协议来获取IP咯。</p>
<p>得到百度的IP，下一步是使用TCP协议，建立TCP连接。（在TCP协议中，建立TCP需要与百度服务器握手三次，你先告诉服务器你要给服务器发东西（SYN），服务器应答你并告诉你它也要给你发东西（SYN、ACK），然后你应答服务器（ACK），总共来回了3次，称为3次握手。）</p>
<p>不过，建立TCP连接有个前提，为了将消息从你的PC上传到服务器上，需要用到IP协议、ARP协议和OSPF协议。你的PC和百度服务器之间一般会有许多路由器之类的东西，IP协议指定了出发地（你的PC）和目的地（服务器）；你的数据会经过一个又一个路由器，OSPF决定了会经过那些路由器（用一种叫路由算法的玩意，找出最佳路径）；从一个路由器怎么传给下一个路由器？这是ARP协议的JOB，ARP负责求下一个节点的地址（我们不止是要目的地，还要中间节点的地址）。IP协议使用的是IP地址，整个发送过程中只涉及出发地和目的地2个IP地址，而ARP协议使用的是MAC地址，整个发送过程中涉及到每一个节点的MAP地址</p>
<p>发送HTTP请求报文给服务器，如果服务器禁止你访问它就给你回个”Forbidden”，如果它暂时挂掉了就给你回个“内部服务错误”，如果它正常才给你回个“OK“并将你要的数据传给你；如果你还需要其它的东西再去跟它要（它一般还会给你的-_-）。</p>
<p>你收到了服务器的回复，是一坨HTML形式的文本。浏览器必须要能够理解文本的内容，并快速地渲染到屏幕上（浏览器一般用有限自动机来理解文本内容，渲染的话就各看本事了，之所以微软IE卡成狗而谷歌浏览器很6，就是它们的渲染速度不同…）</p>
<h2 id="6-4-Ping的整个过程，ICMP报文是什么"><a href="#6-4-Ping的整个过程，ICMP报文是什么" class="headerlink" title="6.4. Ping的整个过程，ICMP报文是什么"></a>6.4. Ping的整个过程，ICMP报文是什么</h2><h3 id="6-4-1-ICMP报文"><a href="#6-4-1-ICMP报文" class="headerlink" title="6.4.1. ICMP报文"></a>6.4.1. ICMP报文</h3><ul>
<li>在IP通信中，经常有数据包到达不了对方的情况。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。这时，在错误发生的现场，为了联络而飞过来的信鸽就是ICMP 报文。在IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助IP 协议，交换各种各样的控制信息而被制造出来的。</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/icmp%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg" alt="icmp报文格式"></p>
<ul>
<li>差错通知和信息查询</li>
</ul>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E5%B7%AE%E9%94%99%E9%80%9A%E7%9F%A5%E5%92%8C%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2.jpg" alt="差错通知和信息查询"></p>
<h3 id="6-4-2-ping-命令"><a href="#6-4-2-ping-命令" class="headerlink" title="6.4.2. ping 命令"></a>6.4.2. ping 命令</h3><p>ping 命令用来在IP 层次上调查与指定机器是否连通，调查数据包往复需要多少时间。为了实现这个功能，ping 命令使用了两个ICMP 报文。</p>
<p><img src="/images/githubpages/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/ping%E5%91%BD%E4%BB%A4.jpg" alt="ping命令"></p>
<p>同一网段内（实际过程的发生不到1毫秒）</p>
<ul>
<li><p>首先，如果主机A，要去ping主机B，那么主机A，就要封装二层报文，他会先查自己的MAC地址表，如果没有B的MAC地址，就会向外发送一个ARP广播包</p>
</li>
<li><p>交换机会收到这个报文后，交换机有学习MAC地址的功能，所以他会检索自己有没有保存主机B的MAC地址，如果有，就返回给主机A，如果没有，就会向所有端口发送ARP广播，其它主机收到后，发现不是在找自己，就纷纷丢弃了该报文，不去理会。直到主机B收到了报文后，就立即响应，我的MAC地址是多少，同时学到主机A的MAC地址，并按同样的ARP报文格式返回给主机A。</p>
</li>
</ul>
<p>跨网段的ping</p>
<ul>
<li><p>如果主机A要ping主机C，那么主机A发现主机C的IP和自己不是同一网段，他就去找网关转发，但是他也不知道网关的MAC地址情况下呢？他就会像之前那个步骤一样先发送一个ARP广播，学到网关的MAC地址，再发封装ICMP报文给网关路由器.。</p>
</li>
<li><p>当路由器收到主机A发过来的ICMP报文，发现自己的目的地址是其本身MAC地址，根据目的的IP2.1.1.1，查路由表，发现2.1.1.1/24的路由表项，得到一个出口指针，去掉原来的MAC头部，加上自己的MAC地址向主机C转发。(如果网关也没有主机C的MAC地址，还是要向前面一个步骤一样，ARP广播一下即可相互学到。路由器2端口能学到主机D的MAC地址，主机D也能学到路由器2端口的MAC地址。)</p>
</li>
<li><p>最后，在主机C已学到路由器2端口MAC地址，路由器2端口转发给路由器1端口，路由1端口学到主机A的MAC地址的情况下，他们就不需要再做ARP解析，就将ICMP的回显请求回复过来。</p>
</li>
</ul>
<h2 id="6-5-SSID、ESSID、BSSID区别"><a href="#6-5-SSID、ESSID、BSSID区别" class="headerlink" title="6.5. SSID、ESSID、BSSID区别"></a>6.5. SSID、ESSID、BSSID区别</h2><h3 id="6-5-1-SSID"><a href="#6-5-1-SSID" class="headerlink" title="6.5.1. SSID"></a>6.5.1. SSID</h3><p>SSID是Service Set Identifier的缩写，意思是：服务集标识。SSID技术可以将一个无线局域网分为几个需要不同身份验证的子网络，每一个子网络都需要独立的身份验证，只有通过身份验证的用户才可以进入相应的子网络，防止未被授权的用户进入本网络。</p>
<p>什么是SSID？SSID（Service Set Identifier）也可以写为ESSID，用来区分不同的网络，最多可以有32个字符，无线网卡设置了不同的SSID就可以进入不同网络，SSID通常由AP广播出来，通过XP自带的扫描功能可以相看当前区域内的SSID。出于安全考虑可以不广播SSID，此时用户就要手工设置SSID才能进入相应的网络。简单说，SSID就是一个局域网的名称，只有设置为名称相同SSID的值的电脑才能互相通信。</p>
<p>禁用SSID广播通俗地说，SSID便是你给自己的无线网络所取的名字。需要注意的是，同一生产商推出的无线路由器或AP都使用了相同的SSID，一旦那些企图非法连接的攻击者利用通用的初始化字符串来连接无线网络，就极易建立起一条非法的连接，从而给我们的无线网络带来威胁。因此，建议最好能够将 SSID命名为一些较有个性的名字。</p>
<p>无线路由器一般都会提供“允许SSID广播”功能。如果不想让自己的无线网络被别人通过SSID名称搜索到，那么最好“禁止SSID广播”。你的无线网络仍然可以使用，只是不会出现在其他人所搜索到的可用网络列表中。</p>
<p>小提示:通过禁止SSID广播设置后，无线网络的效率会受到一定的影响，但以此换取安全性的提高，笔者认为还是值得的。</p>
<p>测试结果:由于没有进行SSID广播，该无线网络被无线网卡忽略了，尤其是在使用Windows XP管理无线网络时，达到了“掩人耳目”的目的。</p>
<h3 id="6-5-2-BSSID"><a href="#6-5-2-BSSID" class="headerlink" title="6.5.2. BSSID"></a>6.5.2. BSSID</h3><p>BSS:一种特殊的Ad-hoc LAN的应用，称为Basic Service Set (BSS)，一群计算机设定相同的BSS名称，即可自成一个group，而此BSS名称，即所谓BSSID。</p>
<h3 id="6-5-3-ESSID"><a href="#6-5-3-ESSID" class="headerlink" title="6.5.3. ESSID"></a>6.5.3. ESSID</h3><p>ESSID（也称为服务区别号）将被放置在到每个无线访问接入点中，它是无线客户端与无线访问接入点联系所必不可少的。利用特定存取点的ESSID来做存取的控制，是AP的一种安全保护机制，它强制每一个客户端都必须要有跟存取点相同的ESSID值。但是，如果你在无线网卡上设定其ESSID为“ANY”时，它就可以自动的搜寻在讯号范围内所有的存取点，并试图连上它。</p>
<p>对于任何一个可能存取UWA-11接入点的适配器来说，无线设备首先决定这个适配器是否属于该网络，或扩展服务集。无线设备判断适配器的32位字符的标识ESSID是否和它自己的相符。即使有另外一套UWA-11产品，也没有人能够加入到网络或学习到跳频序列和定时。ESSID编程写入无线设备,并且在一个安装者密码的控制下，而且只能通过和设备的直接连接才能修改。如果需要在一个网络上有分别的网段，比如财务部门和公司其他部门拥有不同的网段，那么你可以编写不同的SSID。如果你需要支持移动用户和扩大带宽而连接多个无线设备，那么它们的SSID必须设置成一致而跳频序列应该不一样。所有这些设置都受UWA-11安装者密码的控制。<br>由于有了32位字符的SSID和3位字符的跳频序列，你会发现对于那些试图经由局域网的无线网段进入局域网的人来讲，想推断出确切的SSID和跳频序列有多么困难。</p>
<hr>
<p>参考：</p>
<ol>
<li><a href="https://www.jianshu.com/p/3141d4e46240">Android网络请求心路历程</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>知识汇总</tag>
        <tag>网络通信</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理模式</title>
    <url>/iBlogWebsite/2016/10/08/2016/2016-10-08-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>定义：&nbsp;为另一个对象提供一个替身或占位符以访问这个对象。</p>
</blockquote>
<p>后续补充更多的内容：  </p>
<p>  在实际开发过程中，代理类的实现比上述代码要复杂很多，代理模式根据其目的和实现方式不同可分为很多种类，其中常用的几种代理模式简要说明如下：<br>       (1) 远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。<br>       (2) 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>       (3) 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。<br>       (4) 缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>       (5) 智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。<br>       在这些常用的代理模式中，有些代理类的设计非常复杂，例如远程代理类，它封装了底层网络通信和对远程对象的调用，其实现较为复杂。</p>
<p>下面的内容转载自：<a href="http://blog.csdn.net/lovelion/article/details/17517213">http://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>代理模式是常用的结构型设计模式之一，它为对象的间接访问提供了一个解决方案，可以对对象的访问进行控制。<br>代理模式类型较多，其中远程代理、虚拟代理、保护代理等在软件开发中应用非常广泛。</p>
<p><a href="http://blog.csdn.net/lovelion/article/details/8227953">代理模式（一）：代理模式概述，代理模式结构与实现</a><br><a href="http://blog.csdn.net/lovelion/article/details/8228042">代理模式（二）：代理模式应用实例（收费商务信息查询系统）</a><br><a href="http://blog.csdn.net/lovelion/article/details/8228132">代理模式（三）：远程代理，虚拟代理，缓冲代理</a><br><a href="http://blog.csdn.net/lovelion/article/details/8228156">代理模式（四）：代理模式效果与适用场景</a></p>
<p>关于java的代理机制及分析,下面有两篇文章详细的介绍：<br><a href="http://www.ibm.com/developerworks/cn/java/j-lo-proxy1/index.html">Java 动态代理机制分析及扩展，第 1 部分</a><br><a href="http://www.ibm.com/developerworks/cn/java/j-lo-proxy2/index.html">Java 动态代理机制分析及扩展，第 2 部分</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记之图解HTTP</title>
    <url>/iBlogWebsite/2018/02/26/2018/2018-02-06-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP/</url>
    <content><![CDATA[<p><img src="../../../../images/readingNotes/%E5%9B%BE%E8%A7%A3HTTP/%E5%9B%BE%E8%A7%A3HTTP.jpg" alt="图解HTTP"></p>
<p>大概去年5月份的时候，从同事桌上看到这本书，随手一翻觉得里面的插图很有意思，留下了深刻的印象。这几天花了几个小时的时间看完之后，收获颇多。总得来说，这是一本偏基础的书，阅读起来没什么困难，对我而言，主要是理顺了一些之前模棱两可的概念。<br>TCP/IP协议族按层次分别是：应用层、传输层、网络层和数据链路层。层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题。简单来说就是职责单一化了，可以只关心自己应该关心的内容。</p>
<p>应用层：应用层决定了向用户提供应用服务时通信的活动。<br>TCP/IP协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类。HTTP协议也处于该层。</p>
<p>传输层：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。</p>
<p>网络层：网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p>
<p>链路层：用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p>
<p>经过作者的讲述后，对四层的职责，分别干了些什么是不是有了很明确的了解。反正经过这段文字之后，我是有种顿悟的感觉。</p>
<p>当输入一个网址后接着发生了什么？这段描述或许会给你一个清晰的认知流程：“利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。我们用HTTP举例来说明，首先作为发送端的客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求。接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。 ”下面图示更能清晰明了说明问题：</p>
<p><img src="../../../../images/readingNotes/%E5%9B%BE%E8%A7%A3HTTP/%E5%9B%BE%E8%A7%A3HTTP1.jpg" alt="getScrollX"></p>
<p>在HTTP协议中，状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。数字中的第一位指定了响应类别，详细如下图所示：</p>
<p><img src="../../../../images/readingNotes/%E5%9B%BE%E8%A7%A3HTTP/%E5%9B%BE%E8%A7%A3HTTP2.jpg" alt="getScrollX"></p>
<p>HTTP首部字段大致分为四类：通用首部字段，请求首部字段，响应首部字段，实体首部字段。<br><img src="../../../../images/readingNotes/%E5%9B%BE%E8%A7%A3HTTP/%E5%9B%BE%E8%A7%A3HTTP3.jpg" alt="getScrollX"><br><img src="../../../../images/readingNotes/%E5%9B%BE%E8%A7%A3HTTP/%E5%9B%BE%E8%A7%A3HTTP4.jpg" alt="getScrollX"><br><img src="../../../../images/readingNotes/%E5%9B%BE%E8%A7%A3HTTP/%E5%9B%BE%E8%A7%A3HTTP5.jpg" alt="getScrollX"><br><img src="../../../../images/readingNotes/%E5%9B%BE%E8%A7%A3HTTP/%E5%9B%BE%E8%A7%A3HTTP6.jpg" alt="getScrollX">  </p>
<p>在这些首部字段中，有很多值得关注。</p>
<p>例如no-cache字段，使用no-cache指令的目的是为了防止从缓存中返回过期的资源。客户端发送的请求中如果包含no-cache指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</p>
<p>例如首部字段If-Modified-Since，属附带条件之一，它会告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望能处理该请求。而在指定If-Modified-Since字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码304 Not Modified的响应。If-Modified-Since用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段Last-Modified来确定。</p>
<p>例如首部字段Expire，s会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段Expires的响应后，会以缓存来应答请求，在Expires字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。源服务器不希望缓存服务器对资源缓存时，最好在Expires字段内写入与首部字段Date相同的时间值。但是，当首部字段Cache-Control有指定max-age指令时，比起首部字段Expires，会优先处理max-age指令。</p>
<p>书籍的结尾章节主要讨论的是HTTP的缺点、性能、安全问题，这里不再总结。关于网络的知识总结，可以参考我写的一篇日志：<a href="https://leeeyou.github.io/2016/12/28/blog-2016-12-28-Android%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%95%B4%E7%90%86/">Android之网络通信整理</a></p>
<p>总得来说，这本书的内容简单、阅读起来无障碍，主要用于疏通知识点，值得一阅。</p>
]]></content>
      <categories>
        <category>opinion</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>⎡稳扎稳打系列⎦：Handler机制全面解析3(3/3)</title>
    <url>/iBlogWebsite/2022/02/18/2022/2022-02-18-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%903/</url>
    <content><![CDATA[<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2022/wallpaper/2022-02-18-ekaterina-sazonova-CMhxw3lgZ7M-unsplash-modified.webp?raw=true" alt="2022-02-18-ekaterina-sazonova-CMhxw3lgZ7M-unsplash-modified.webp"></p>
<h1 id="1-延时消息的原理"><a href="#1-延时消息的原理" class="headerlink" title="1. 延时消息的原理"></a>1. 延时消息的原理</h1><p>无论通过Handler的哪个post函数发消息，最终都会来到sendMessageAtTime，基于android.os.SystemClock#uptimeMillis时间，最终以<strong>SystemClock.uptimeMillis()+delayMillis</strong>的结果作为入队列和消息执行的基准。</p>
<h2 id="1-1-延时消息是怎样入队列的？"><a href="#1-1-延时消息是怎样入队列的？" class="headerlink" title="1.1 延时消息是怎样入队列的？"></a>1.1 延时消息是怎样入队列的？</h2><p>消息入队列是通过MessageQueue#enqueueMessage函数，when表示消息执行的时间，通过下方源码可知如果当前消息队列为空，或者when等于0，或者新消息的when小于头消息的when，则直接将新消息替换为头消息。否则按照when的值将消息插入到队列的合适位置中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="comment">// 当前消息队列为空 or when等于0 or 新消息的when小于头消息的when</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123; </span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="comment">// 否则按照when的值将消息插入到队列的合适位置中</span></span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="1-2-延时消息是怎样被唤醒并执行的？"><a href="#1-2-延时消息是怎样被唤醒并执行的？" class="headerlink" title="1.2 延时消息是怎样被唤醒并执行的？"></a>1.2 延时消息是怎样被唤醒并执行的？</h2><p>其实这个问题在上一节中已经分析过了，在MessageQueue#next中会调用nativePollOnce在native层轮询一次，这里可能会导致阻塞，最终会进入native层Looper.cpp中的pollInner函数，调用epoll_wait等待感兴趣的事件或超时发生，而这里会有个timeoutMillis描述需要等待的时间。</p>
<p>有关epoll_wait更详细的分析，参考<a href="https://leeeyou.github.io/iBlogWebsite/2021/12/16/2021/2021-12-16-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%902/#3-%E5%90%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%96%E6%B6%88%E6%81%AF">2021-12-16-⎡稳扎稳打系列⎦：Handler机制全面解析2/#3-向消息队列取消息</a></p>
<h1 id="2-IdleHandler的作用和原理"><a href="#2-IdleHandler的作用和原理" class="headerlink" title="2. IdleHandler的作用和原理"></a>2. IdleHandler的作用和原理</h1><p>IdleHandler是定义在MessageQueue中的静态内部接口，源码如下：</p>
<p><strong>frameworks/base/core/java/android/os/MessageQueue.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">IdleHandler</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">queueIdle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IdleHandler终归也是一种Handler，也是需要执行的，只是它的执行时机有点特殊而已。</p>
<blockquote>
<p>a. 消息队列为空<br>b. 消息队列中的消息还没到执行时间</p>
</blockquote>
<p>通过其执行时机，可以知道IdleHandler的作用就是在消息队列空闲的时候处理一些非紧急任务或者优先级不那么高的任务。</p>
<p><strong>frameworks/base/core/java/android/os/MessageQueue.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;IdleHandler&gt;();</span><br><span class="line"><span class="keyword">private</span> IdleHandler[] mPendingIdleHandlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.remove(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部通过MessageQueue#addIdleHandler添加IdleHandler，在next函数中会将IdleHandler拷贝到临时数组mPendingIdleHandlers中。然后在next函数空闲时遍历mPendingIdleHandlers并逐一回调queueIdle执行。</p>
<p><strong>frameworks/base/core/java/android/os/MessageQueue.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果空闲会走到下面代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">        pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">        mBlocked = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">        mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); <span class="comment">// 拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i]; <span class="comment">// 取出IdleHandler实例</span></span><br><span class="line">        mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// 每次都清空临时数组中的实例</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 逐一回调queueIdle</span></span><br><span class="line">            keep = idler.queueIdle(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果不需要保留IdleHandler实例，则移除mIdleHandlers中的实例</span></span><br><span class="line">                mIdleHandlers.remove(idler); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">    nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下IdleHandler流程</p>
<blockquote>
<p>a. 本次轮询中如果msg为空，或者msg还没到触发时间，则判定为空闲状态<br>b. 接着遍历mPendingIdleHandlers数组取出IdleHandler实例并调用queueIdle方法<br>c. 如果queueIdle返回false表示执行完后不需要保留，则在mIdleHandlers中直接彻底移除</p>
</blockquote>
<p>处理完IdleHandler后会将nextPollTimeoutMillis置为0，也就是不阻塞消息队列，这里要注意queueIdle不能太耗时，因为它是同步执行的，如果太耗时肯定会影响后面的message执行。</p>
<h1 id="3-Android消息通信机制中IPC方式的变迁"><a href="#3-Android消息通信机制中IPC方式的变迁" class="headerlink" title="3. Android消息通信机制中IPC方式的变迁"></a>3. Android消息通信机制中IPC方式的变迁</h1><p>Android所拥有的IPC总共有这些：</p>
<blockquote>
<p>a. 基于Unix系统的IPC的管道，FIFO，信号<br>b. 基于SystemV和Posix系统的IPC的消息队列，信号量，共享内存<br>c. 基于Socket的IPC<br>d. Linux的内存映射函数mmap()<br>e. Linux 2.6.22版本后才有的eventfd<br>f. Android系统独有的Binder和匿名共享内存Ashmen</p>
</blockquote>
<p>这里要讨论的是消息通信机制中的IPC变迁，其实也就是Looper唤醒方式的变迁，大体上是从【a. 基于Unix系统的IPC的管道，FIFO，信号】到【e. Linux 2.6.22版本后才有的eventfd】的升级。</p>
<h2 id="3-1-管道"><a href="#3-1-管道" class="headerlink" title="3.1 管道"></a>3.1 管道</h2><p>PIPE和FIFO都是指管道，只是PIPE独指匿名管道，FIFO独指有名管道。有关管道的具体分析参考<a href="https://juejin.cn/post/6876046258406948878#heading-0">深入理解Android进程间通信机制-管道</a></p>
<p>pipe和fifo的异同点</p>
<table>
<thead>
<tr>
<th>相同</th>
<th>不同</th>
</tr>
</thead>
<tbody><tr>
<td>IPC的本质都是通过在内核创建虚拟文件，并且调用文件读写函数来进行数据通信</td>
<td>pipe是单向通信，fifo可以双向通信</td>
</tr>
<tr>
<td>都只能接收字节流数据</td>
<td>pipe只能在父子，兄弟进程间通信，fifo没有这个限制</td>
</tr>
<tr>
<td>都是半双工通信</td>
<td>pipe是单向通信，不存在并发问题；fifo可以双向通信，这样不可避免的带来了并发的问题</td>
</tr>
</tbody></table>
<p>在Android6.0以下版本中，主线程Looper的唤醒就使用到了管道。</p>
<p><strong>android-5.0.1_r1分支，system/core/libutils/Looper.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Looper::<span class="built_in">Looper</span>(<span class="type">bool</span> allowNonCallbacks) :</span><br><span class="line">        <span class="built_in">mAllowNonCallbacks</span>(allowNonCallbacks), <span class="built_in">mSendingMessage</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mResponseIndex</span>(<span class="number">0</span>), <span class="built_in">mNextMessageUptime</span>(LLONG_MAX) &#123;</span><br><span class="line">    <span class="type">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">pipe</span>(wakeFds); <span class="comment">// 创建pipe</span></span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(result != <span class="number">0</span>, <span class="string">&quot;Could not create wake pipe.  errno=%d&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>]; <span class="comment">// 写文件描述符</span></span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>]; <span class="comment">// 读文件描述符</span></span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">fcntl</span>(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(result != <span class="number">0</span>, <span class="string">&quot;Could not make wake read pipe non-blocking.  errno=%d&quot;</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">fcntl</span>(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(result != <span class="number">0</span>, <span class="string">&quot;Could not make wake write pipe non-blocking.  errno=%d&quot;</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    mIdling = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate the epoll instance and register the wake pipe.</span></span><br><span class="line">    mEpollFd = <span class="built_in">epoll_create</span>(EPOLL_SIZE_HINT);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mEpollFd &lt; <span class="number">0</span>, <span class="string">&quot;Could not create epoll instance.  errno=%d&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItem;</span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="built_in">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.fd = mWakeReadPipeFd;</span><br><span class="line">    result = <span class="built_in">epoll_ctl</span>(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(result != <span class="number">0</span>, <span class="string">&quot;Could not add wake read pipe to epoll instance.  errno=%d&quot;</span>,</span><br><span class="line">            errno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">&quot;%p ~ wake&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 往管道mWakeWritePipeFd里写入一个字母“W”</span></span><br><span class="line">        nWrite = <span class="built_in">write</span>(mWakeWritePipeFd, <span class="string">&quot;W&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Could not write wake signal, errno=%d&quot;</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，唤醒函数其实就是往管道mWakeWritePipeFd里写入一个字母“W”，mWakeReadPipeFd接收到数据后，就会唤醒Looper。</p>
<h2 id="3-2-eventfd"><a href="#3-2-eventfd" class="headerlink" title="3.2 eventfd"></a>3.2 eventfd</h2><p>eventfd是Linux 2.6.22后才开始支持的一种IPC通信方式，它的作用主要是用来做事件通知，并且完全可以替代pipe，对于内核来说，eventfd的开销更低，eventfd只需要创建一个虚拟文件，而pipe需要创建两个，并且可用于select或epoll等多路复用模型中，来实现异步的信号通知功能。所以eventfd是很好用的一种IPC方式，而且它的使用也简单。</p>
<p>eventfd在内核里的核心是一个计数器counter，它是一个uint64_t的整形变量counter，初始值为initval。</p>
<p>当调用read() 函数读取eventfd时，会根据counter值执行下列操作：</p>
<blockquote>
<p>a. 如果当前counter &gt; 0，那么read返回counter值，并重置counter为0<br>b. 如果当前counter等于0，那么read 函数阻塞直到counter大于0，如果设置了NONBLOCK，那么返回-1</p>
</blockquote>
<p>当调用write() 往eventfd写数据时，我们只能写入一个64bit的整数value。</p>
<p>正是因为eventfd比管道更简单高效，所以在Android6.0之后，Looper的唤醒就换成了eventfd。</p>
<p><strong>android-6.0.0_r1分支，system/core/libutils/Looper.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Looper::<span class="built_in">Looper</span>(<span class="type">bool</span> allowNonCallbacks) :</span><br><span class="line">        <span class="built_in">mAllowNonCallbacks</span>(allowNonCallbacks), <span class="built_in">mSendingMessage</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mPolling</span>(<span class="literal">false</span>), <span class="built_in">mEpollFd</span>(<span class="number">-1</span>), <span class="built_in">mEpollRebuildRequired</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mNextRequestSeq</span>(<span class="number">0</span>), <span class="built_in">mResponseIndex</span>(<span class="number">0</span>), <span class="built_in">mNextMessageUptime</span>(LLONG_MAX) &#123;</span><br><span class="line">    mWakeEventFd = <span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK); <span class="comment">// 创建eventfd</span></span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mWakeEventFd &lt; <span class="number">0</span>, <span class="string">&quot;Could not make wake event fd.  errno=%d&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="built_in">rebuildEpollLocked</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">&quot;%p ~ wake&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nWrite = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">write</span>(mWakeEventFd, &amp;inc, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>))); <span class="comment">// 写入数字1</span></span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Could not write wake signal, errno=%d&quot;</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Looper的构造函数中mWakeEventFd已经由之前提到的pipe换成了evnentfd，wake()函数也不是之前的写入一个“w”字符，而是写入了一个64位整数1。</p>
<p>从pipe到eventfd可以看出，即使在Android源码级别，也是在不断更迭代码，往更简单更高效的方向在努力和优化。</p>
<h1 id="4-屏幕刷新机制与消息机制的结合运作"><a href="#4-屏幕刷新机制与消息机制的结合运作" class="headerlink" title="4. 屏幕刷新机制与消息机制的结合运作"></a>4. 屏幕刷新机制与消息机制的结合运作</h1><p>关于Android屏幕刷新机制原理，强烈推荐这篇：<a href="https://cloud.tencent.com/developer/article/1685247">“终于懂了” 系列：Android屏幕刷新机制—VSync、Choreographer 全面理解！</a></p>
<p>在这一系列文章中，屏幕刷新机制感兴趣的看上面的文章，这里我们重点关注<strong>屏幕刷新绘制与消息机制是怎么结合运作的</strong>？</p>
<h2 id="4-1-绘制入口"><a href="#4-1-绘制入口" class="headerlink" title="4.1 绘制入口"></a>4.1 绘制入口</h2><p><strong>所有UI的变化最终都是走到ViewRootImpl的scheduleTraversals()方法</strong>，那么scheduleTraversals()到performTraversals()中间经历了什么呢？是立刻执行吗？答案很显然是否定的，只有在VSync信号到来时才会执行绘制，即performTraversals()方法。</p>
<p>下面就从源码角度分析这是如何实现的：</p>
<p><strong>frameworks/base/core/java/android/view/ViewRootImpl.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 发送消息屏障，屏蔽同步消息，从而保证VSync到来立即执行绘制</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">// TraversalRunnable是内部类，会走run()方法，最终执行doTraversal()方法</span></span><br><span class="line">        <span class="comment">// 注意这里的callback类型是CALLBACK_TRAVERSAL</span></span><br><span class="line">        mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 移除同步屏障</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(<span class="string">&quot;ViewAncestor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始三大绘制流程</span></span><br><span class="line">        performTraversals();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下scheduleTraversals()方法到performTraversals()方法的流程：</p>
<blockquote>
<p>a. 发送消息屏障，屏蔽同步消息，从而保证VSYNC信号到来时可被立即执行<br>b. mChoreographer.postCallback()方法投递mTraversalRunnable，其消息类型是CALLBACK_TRAVERSAL<br>c. 执行mTraversalRunnable的run()方法，移除屏障，并执行performTraversals()方法</p>
</blockquote>
<p>上面只是大致流程，这里还有一些疑问点：</p>
<blockquote>
<p>a. VSYNC信号是怎么到来的，是怎样跟消息机制结合的？<br>b. mChoreographer.postCallback()发送的CALLBACK_TRAVERSAL代表什么含义？<br>c. mTraversalRunnable的run()方法是怎么被调起执行的？</p>
</blockquote>
<p>带着这些问题继续看下面的分析。</p>
<h2 id="4-2-Choreographer与FrameHandler结合"><a href="#4-2-Choreographer与FrameHandler结合" class="headerlink" title="4.2 Choreographer与FrameHandler结合"></a>4.2 Choreographer与FrameHandler结合</h2><p>在ViewRootImpl的构造函数中会获取Choreographer实例，在Choreographer的构造函数中会创建FrameHandler实例，所以Choreographer与FrameHandler结合在于其构造函数，同时利用FrameHandler将VSYNC信号到来时的消息同步到主线程中。</p>
<p><strong>frameworks/base/core/java/android/view/Choreographer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Choreographer</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper); <span class="comment">// 创建FrameHandler实例</span></span><br><span class="line">    <span class="comment">//USE_VSYNC 4.1以上默认是true，表示具备接受VSync的能力，这个接受能力就是FrameDisplayEventReceiver</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource) <span class="comment">// vsync信号接收器</span></span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算一帧的时间，Android手机屏幕是60Hz的刷新频率，就是16ms</span></span><br><span class="line">    mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个链表类型CallbackQueue的数组，大小为5，</span></span><br><span class="line">    <span class="comment">//也就是数组中有五个链表，每个链表存相同类型的任务：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL）</span></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b/68769804: For low FPS experiments.</span></span><br><span class="line">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Choreographer中的CALLBACK类型总共是5类，分别是：输入、动画、插入更新动画、布局和绘制、提交</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Callback type: Input callback.  Runs first.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_INPUT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Callback type: Animation callback.  Runs before &#123;<span class="doctag">@link</span> #CALLBACK_INSETS_ANIMATION&#125;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_ANIMATION</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Callback type: Animation callback to handle inset updates. This is separate from</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #CALLBACK_ANIMATION&#125; as we need to &quot;gather&quot; all inset animation updates via</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> WindowInsetsAnimationController#setInsetsAndAlpha(Insets, float, float)&#125; for multiple</span></span><br><span class="line"><span class="comment">* ongoing animations but then update the whole view system with a single callback to</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> View#dispatchWindowInsetsAnimationProgress&#125; that contains all the combined updated</span></span><br><span class="line"><span class="comment">* insets.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* Both input and animation may change insets, so we need to run this after these callbacks, but</span></span><br><span class="line"><span class="comment">* before traversals.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* Runs before traversals.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_INSETS_ANIMATION</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Callback type: Traversal callback.  Handles layout and draw.  Runs</span></span><br><span class="line"><span class="comment">* after all other asynchronous messages have been handled.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_TRAVERSAL</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Callback type: Commit callback.  Handles post-draw operations for the frame.</span></span><br><span class="line"><span class="comment">* Runs after traversal completes.  The &#123;<span class="doctag">@link</span> #getFrameTime() frame time&#125; reported</span></span><br><span class="line"><span class="comment">* during this callback may be updated to reflect delays that occurred while</span></span><br><span class="line"><span class="comment">* traversals were in progress in case heavy layout operations caused some frames</span></span><br><span class="line"><span class="comment">* to be skipped.  The frame time reported during this callback provides a better</span></span><br><span class="line"><span class="comment">* estimate of the start time of the frame in which animations (and other updates</span></span><br><span class="line"><span class="comment">* to the view hierarchy state) actually took effect.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_COMMIT</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_LAST</span> <span class="operator">=</span> CALLBACK_COMMIT;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>五种类型任务存入对应的CallbackQueue中，每当收到VSYNC信号时，Choreographer将首先处理INPUT类型的任务，然后是ANIMATION类型，最后才是TRAVERSAL类型。</p>
<p>现在回头看mChoreographer.postCallback()，最终会进入到scheduleVsyncLocked()方法中，通过mDisplayEventReceiver.scheduleVsync()申请vsync信号。</p>
<p><strong>frameworks/base/core/java/android/view/Choreographer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayedInternal</span><span class="params">(<span class="type">int</span> callbackType, Object action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">// 延迟时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dueTime</span> <span class="operator">=</span> now + delayMillis;</span><br><span class="line">        <span class="comment">// 取对应类型的CallbackQueue添加任务</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            <span class="comment">// 立即执行</span></span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 延迟运行，最终也会走到scheduleFrameLocked()</span></span><br><span class="line">            <span class="comment">// mHandler就是FrameHandler实例</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>); <span class="comment">// 设置成异步</span></span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FrameHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_FRAME:</span><br><span class="line">                <span class="comment">// 布局和绘制过程</span></span><br><span class="line">                doFrame(System.nanoTime(), <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">DisplayEventReceiver</span>.VsyncEventData());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                <span class="comment">// 申请VSYNC信号，例如当前需要绘制任务时</span></span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                <span class="comment">// 需要延迟的任务，最终还是执行上述两个事件</span></span><br><span class="line">                doScheduleCallback(msg.arg1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doScheduleCallback</span><span class="params">(<span class="type">int</span> callbackType)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class="line">                scheduleFrameLocked(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleFrameLocked</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 开启了VSYNC</span></span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前执行的线程，是否是mLooper所在线程</span></span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                <span class="comment">// 申请VSYNC信号</span></span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="literal">true</span>); <span class="comment">// 异步消息</span></span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">nextFrameTime</span> <span class="operator">=</span> Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果未开启VSYNC则直接doFrame方法（4.1后默认开启）</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleVsyncLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Choreographer#scheduleVsyncLocked&quot;</span>);</span><br><span class="line">        <span class="comment">// vsync信号接收器</span></span><br><span class="line">        mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FrameHandler的作用很明显里了</p>
<blockquote>
<p>a. 发送异步消息(因为前面设置了同步屏障)<br>b. 有延迟的任务发延迟消息<br>c. 不在原线程的切换到原线程<br>d. 没开启VSYNC的直接走doFrame方法取执行绘制</p>
</blockquote>
<p>总结下Choreographer与FrameHandler结合这一小节</p>
<blockquote>
<p>a. 如果系统未开启VSYNC机制，此时直接发送MSG_DO_FRAME消息到FrameHandler执行doFrame()方法<br>b. Android4.1之后系统默认开启VSYNC，最终通过scheduleVsyncLocked()方法申请VSYNC信号<br>c. 如果当前不在原线程，通过FrameHandler切换到主线程，最终还是调用scheduleVsyncLocked()方法申请VSYNC信号</p>
</blockquote>
<h2 id="4-3-申请vsync信号后的执行流程"><a href="#4-3-申请vsync信号后的执行流程" class="headerlink" title="4.3 申请vsync信号后的执行流程"></a>4.3 申请vsync信号后的执行流程</h2><p>通过scheduleVsyncLocked()方法申请VSYNC信号最终会来到DisplayEventReceiver中的scheduleVsync()方法，内部会调用 nativeScheduleVsync()方法，在DisplayEventReceiver的构造函数中会注册VSYNC信号监听者mReceiverPtr，当VSYNC信号到来时，会回调onVsync()方法。下面整理出源码的调用路径：</p>
<p><strong>frameworks/base/core/java/android/view/DisplayEventReceiver.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeScheduleVsync</span><span class="params">(<span class="type">long</span> receiverPtr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource, <span class="type">int</span> eventRegistration)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;looper must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    <span class="comment">// 注册VSYNC信号监听者</span></span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class="built_in">this</span>), mMessageQueue,</span><br><span class="line">            vsyncSource, eventRegistration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleVsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class="line">                + <span class="string">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 申请VSYNC中断信号，会回调onVsync方法</span></span><br><span class="line">        nativeScheduleVsync(mReceiverPtr); <span class="comment">// mReceiverPtr是VSYNC信号监听者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame,</span></span><br><span class="line"><span class="params">        VsyncEventData vsyncEventData)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onVsync的实现在FrameDisplayEventReceiver类中，最终会执行doFrame()方法</p>
<p><strong>frameworks/base/core/java/android/view/Choreographer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame,</span></span><br><span class="line"><span class="params">        VsyncEventData vsyncEventData)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW,</span><br><span class="line">                    <span class="string">&quot;Choreographer#onVsync &quot;</span> + vsyncEventData.id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">        <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">        <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">        <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">        <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">                    + <span class="string">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class="line">                    + <span class="string">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class="line">            timestampNanos = now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class="line">                    + <span class="string">&quot;one at a time.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mHavePendingVsync = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mTimestampNanos = timestampNanos;</span><br><span class="line">        mFrame = frame;</span><br><span class="line">        mLastVsyncEventData = vsyncEventData;</span><br><span class="line">        <span class="comment">// 将本身作为runnable传入msg， 发消息后等待执行</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>); <span class="comment">// 异步消息</span></span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当MessageQueue轮询到该消息后，会走run()方法，最终会调用doFrame()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">    doFrame(mTimestampNanos, mFrame, mLastVsyncEventData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame, DisplayEventReceiver.VsyncEventData vsyncEventData)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> startNanos;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">frameIntervalNanos</span> <span class="operator">=</span> vsyncEventData.frameInterval;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            ... </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">                traceMessage(<span class="string">&quot;Frame not scheduled&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ... </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 预计执行时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">intendedFrameTimeNanos</span> <span class="operator">=</span> frameTimeNanos;</span><br><span class="line">            startNanos = System.nanoTime();</span><br><span class="line">            <span class="comment">// 超时时间是否超过一帧</span></span><br><span class="line">            <span class="comment">// 这是因为MessageQueue虽然添加了同步屏障，但还是有正在执行的同步任务，导致doFrame()延迟执行了</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> startNanos - frameTimeNanos;</span><br><span class="line">            <span class="keyword">if</span> (jitterNanos &gt;= frameIntervalNanos) &#123;</span><br><span class="line">                <span class="comment">// 计算掉帧数</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">skippedFrames</span> <span class="operator">=</span> jitterNanos / frameIntervalNanos;</span><br><span class="line">                <span class="comment">// 掉帧数超过30，打印日志</span></span><br><span class="line">                <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Skipped &quot;</span> + skippedFrames + <span class="string">&quot; frames!  &quot;</span></span><br><span class="line">                            + <span class="string">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lastFrameOffset</span> <span class="operator">=</span> jitterNanos % frameIntervalNanos;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Missed vsync by &quot;</span> + (jitterNanos * <span class="number">0.000001f</span>) + <span class="string">&quot; ms &quot;</span></span><br><span class="line">                            + <span class="string">&quot;which is more than the frame interval of &quot;</span></span><br><span class="line">                            + (frameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">&quot; ms!  &quot;</span></span><br><span class="line">                            + <span class="string">&quot;Skipping &quot;</span> + skippedFrames + <span class="string">&quot; frames and setting frame &quot;</span></span><br><span class="line">                            + <span class="string">&quot;time to &quot;</span> + (lastFrameOffset * <span class="number">0.000001f</span>) + <span class="string">&quot; ms in the past.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Frame time appears to be going backwards.  May be due to a &quot;</span></span><br><span class="line">                            + <span class="string">&quot;previously skipped frame.  Waiting for next vsync.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                traceMessage(<span class="string">&quot;Frame time goes backward&quot;</span>);</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mFPSDivisor &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">timeSinceVsync</span> <span class="operator">=</span> frameTimeNanos - mLastFrameTimeNanos;</span><br><span class="line">                <span class="keyword">if</span> (timeSinceVsync &lt; (frameIntervalNanos * mFPSDivisor) &amp;&amp; timeSinceVsync &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    traceMessage(<span class="string">&quot;Frame skipped due to FPSDivisor&quot;</span>);</span><br><span class="line">                    scheduleVsyncLocked();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos, vsyncEventData.id,</span><br><span class="line">                    vsyncEventData.frameDeadline, startNanos, vsyncEventData.frameInterval);</span><br><span class="line">            <span class="comment">// Frame标志位恢复</span></span><br><span class="line">            mFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 记录最后一帧时间</span></span><br><span class="line">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">            mLastFrameIntervalNanos = frameIntervalNanos;</span><br><span class="line">            mLastVsyncEventData = vsyncEventData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按类型顺序执行任务</span></span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        <span class="comment">// 输入类型</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos, frameIntervalNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        <span class="comment">// 动画类型</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos, frameIntervalNanos);</span><br><span class="line">        <span class="comment">// 动画更新类型</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos,</span><br><span class="line">                frameIntervalNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        <span class="comment">// 布局和绘制</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos, frameIntervalNanos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos, frameIntervalNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doCallbacks</span><span class="params">(<span class="type">int</span> callbackType, <span class="type">long</span> frameTimeNanos, <span class="type">long</span> frameIntervalNanos)</span> &#123;</span><br><span class="line">    CallbackRecord callbacks;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">// 根据指定类型查找到达执行时间的CallbackRecord</span></span><br><span class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS;</span><br><span class="line">        <span class="keyword">if</span> (callbacks == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCallbacksRunning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务类型</span></span><br><span class="line">        <span class="keyword">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> now - frameTimeNanos;</span><br><span class="line">            <span class="keyword">if</span> (jitterNanos &gt;= <span class="number">2</span> * frameIntervalNanos) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lastFrameOffset</span> <span class="operator">=</span> jitterNanos % frameIntervalNanos + frameIntervalNanos;</span><br><span class="line">                frameTimeNanos = now - lastFrameOffset;</span><br><span class="line">                mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历执行所有任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">CallbackRecord</span> <span class="variable">c</span> <span class="operator">=</span> callbacks; c != <span class="literal">null</span>; c = c.next) &#123;</span><br><span class="line">            <span class="comment">// 回调run()方法，内部回调Callback类型的run()</span></span><br><span class="line">            c.run(frameTimeNanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mCallbacksRunning = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">CallbackRecord</span> <span class="variable">next</span> <span class="operator">=</span> callbacks.next;</span><br><span class="line">                <span class="comment">// 回收CallbackRecord</span></span><br><span class="line">                recycleCallbackLocked(callbacks); </span><br><span class="line">                callbacks = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (callbacks != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CallbackRecord</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> CallbackRecord next;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> dueTime;</span><br><span class="line">    <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">    <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">             <span class="comment">// 通过postFrameCallback或postFrameCallbackDelayed会执行这里</span></span><br><span class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行Runnable的run()</span></span><br><span class="line">            ((Runnable)action).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前面看到mChoreographer.postCallback传的token是null，所以取出action就是Runnable，执行run()，这里的action就是 ViewRootImpl发起的绘制任务mTraversalRunnable了，那么这样整个逻辑就闭环了。</p>
<p>下面整理了完整的流程图：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2022/code/2022-02-18-combination-of-screen-refresh-mechanism-and-message-mechanism.png?raw=true" alt="2022-02-18-屏幕刷新机制与消息机制的结合运作.png"></p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>Handler机制全面解析系列共3篇终于完成了。</p>
<p><a href="https://leeeyou.github.io/iBlogWebsite/2021/12/01/2021/2021-12-01-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%901/">2021-12-01-⎡稳扎稳打系列⎦：Handler机制全面解析1.md</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2021/12/16/2021/2021-12-16-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%902/">2021-12-16-⎡稳扎稳打系列⎦：Handler机制全面解析2.md</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2022/02/18/2022/2022-02-18-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%903/">2022-02-18-⎡稳扎稳打系列⎦：Handler机制全面解析3.md</a></p>
<p>系列开篇分析了Handler的运行机制，ActivityThread、Handler、Looper、MessageQueue之间关系，Message的类型，消息分发回调的优先级是怎样的以及Handler的内存泄漏。这些都是Handler机制的核心基础知识，比如Message的类型这一点，之前自己是不清楚的，导致对于全面理解机制原理是很困难的，系统怎么保证某类消息优先执行，为什么业务层传的Message其target不能为空等问题其实都跟Message的类型有关。</p>
<p>打通知识连贯性是很重要的，知识点不应该是一个一个单独的，而是相互关连相互牵扯的。再比如消息分发回调的优先级，在某些插件化方案中，这里Callback作为Hook点被使用，所以消息机制跟插件化有了关连关系。试想如果对消息机制不清楚的话，插件话开发找hook点怎么可能想到这里？</p>
<p>在第二篇中主要是分析了“存消息”和“取消息”的源码和原理，这里涉及到Java和Native两个世界的协同工作，而MessageQueue就是它们协作的桥梁。在看源码过程中，看到Looper取消息是一个死循环，进而分析了死循环的意义。“存消息”和“取消息”的过程涉及唤醒和等待，这里就牵扯出了epoll机制以及IPC机制。在Android6.0以下版本中，主线程Looper的唤醒就使用到了管道。到了Android6.0之后，Looper的唤醒就换成了eventfd。这便是IPC机制的变迁和升级。</p>
<p>在最后一篇中，先是分析了两个小问题：延时消息的原理以及IdleHandler的作用和原理，这两块算是自己的知识盲区，这里疏通了。最后其实我一直有个疑问就是：屏幕刷新绘制到底是怎么被通知和执行的呢？都知道绘制是从performTraversals()开始进行三大绘制流程，那么它本身是如何被调起执行的？VSYNC信号是怎么产生并给到主线程的？主线程收到信号后是怎么组织代码进行一系列处理的？这些问题在最后一篇的最后一节进行了全过程分析。这一部分也有全流程图供查阅源码时参考。</p>
<p>写完三篇文章后，自己对Handler机制的知识点有了大致的把握，后续如有需要再更新和完善吧。</p>
<hr>
<p>参考</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1685247">“终于懂了” 系列：Android屏幕刷新机制—VSync、Choreographer 全面理解！</a></li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>稳扎稳打系列</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之复杂度分析</title>
    <url>/iBlogWebsite/2018/04/11/2018/2018-04-11-%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>对于算法的复杂度，一直是懵懂状态。索性这次将这段时间听到看到的一些内容整理出来，以求准确清晰的理解它。</p>
<p>听吴军老师的音频，才了解在计算机发展初期，对于算法好坏的评判标准科学家也是不清楚的，1965年哈特马尼斯（Juris Hartmanis）和斯坦恩斯（Richard Stearns）提出了算法复杂度的概念（二人后来因此获得了图灵奖），计算机科学家们开始考虑一个公平的、一致的评判算法好坏的方法。不过，最早将复杂度严格量化衡量的是著名计算机科学家、算法分析之父 <strong>高德纳（Don Knuth）</strong> 。今天全世界计算机领域都以高德纳的思想为准。</p>
<p>高德纳的思想主要包括这三个部分：</p>
<ol>
<li><p>在比较算法的快慢时，需要考虑数据量特别特别大，大到近乎无穷大时的情况。为什么要比大数的情况，而不比小数的情况呢？因为计算机的发明就是为了处理大量数据的，而且数据越处理越多。</p>
</li>
<li><p>决定算法快慢的因素虽然可能很多，但是所有的因素都可以被分为两类。第一类是不随数据量变化的因素，第二类是随着数量变化的。</p>
<ul>
<li><p>比如说，有一种大小排序的算法，它的运算次数是10倍的N平方，其中N是要排序的数字的数量。前面的那个10倍是个常数，和N的大小显然没有关系，10个数排序是如此，一亿个数排序时也是如此。而后面的N平方自然和N有关系了。高德纳讲，我们在研究算法时，不必考虑前面那个不变的常数，它是10倍，还是1倍，或者是100倍，只需要看后面那个变化的因素即可。</p>
</li>
<li><p>因为N这个数趋近于无穷大时，前面那个不变的常数的影响是微乎其微的，算法的速度主要由后面一个因素决定。比如，当N＝10的时候，N平方就是100；N＝100，N平方就是1万；N＝1万，N平方就是一亿……总之，N平方这个因子的变化非常快。更广泛地讲，任何随着N变化的因素，通常会造成量级的差异。量级就如同芝麻和西瓜的差异，西瓜和地球的差异。100个芝麻是无法和一个西瓜去对比的。</p>
</li>
</ul>
</li>
<li><p>如果两种算法 <strong>在量级上相当</strong> ，在计算机科学里，就认为它们是一样好的，也就是计算机科学家并不关心三五倍的差别，这就好比1粒芝麻和5粒芝麻都是芝麻量级的东西，大家就不要比了。只有当科学家们不关心几倍的差异后，才可能集中精力考虑量级的差异。也就是说，计算机科学家要尽可能地去捡西瓜。事实上在计算机科学领域，如果谁说自己把目前最好的算法速度提升了一倍，这种论文是无法发表的。</p>
</li>
</ol>
<p>在了解了高德纳提出的思想后，对于算法复杂度关心的点以及评判标准才有了“最正宗”的理解。关心的是大量数据的问题，排除掉不变的因素，且只关注量级的差别，这其实是一个理想的环境，这种假设是非常有意义的。吴军老师说“回顾下科学发展的历史，那些能总结出理论的人要做的第一件事，就是多虑掉所有次要的因素，构建一个理想的环境（或者虚拟的环境），其目的是找到真正的主要矛盾，先把主要问题解决了再说。这些人的思维方式，比普通人是高出一大截的。我们都同意艺术上要有想象力，其实在科学上也是如此，抽象的想象力很重要。”</p>
<p>在有了上面这段内容作为基础后，下面对时间复杂度和空间复杂度的讲述会简单很多。</p>
<h1 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h1><p>一句话描述就是：<strong>一个算法在问题规模不断增大时对应的时间增长曲线。</strong><br>看完下面这两张图，你大概能理解问题规模的增大以及时间增长曲线之间的关系。</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/algorithm-time-complexity-summary.jpg?raw=true" alt="algorithm-time-complexity-summary"></p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/algorithm-time-complexity-problem-size.jpg?raw=true" alt="algorithm-time-complexity-problem-size"></p>
<p>从第二张图可以直观的反应出指数、立方和平方级别同线性对数级别的时间增长曲线不在一个量级上。所以你在写代码时，到底选择怎样的时间曲线增长量级是不是有底了？这里其实也印证了高德纳思想的第1和第3点，那第2点排除掉不变的因素怎么理解，这需要用到数学公式了。</p>
<p>在数学上定义： 存在常数 c，使得当 N &gt;= c 时 T(N) &lt;= f(N)，表示为 T(n) = O(f(n)) 。<br>算法需要执行的运算次数 用输入大小n的函数表示，即 T(n)。如下图示：  </p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/algorithm-time-complexity-math.jpg?raw=true" alt="algorithm-time-complexity-math"></p>
<p>当 N &gt;= 2 的时候，f(n) = n^2 总是大于 T(n) = n + 2 的，于是我们说 f(n) 的增长速度是大于或者等于 T(n) 的，也说 f(n) 是 T(n) 的上界，可以表示为 T(n) = O(f(n))。</p>
<p>因为f(n) 的增长速度是大于或者等于 T(n) 的，即T(n) = O(f(n))，所以我们可以用 f(n) 的增长速度来度量 T(n) 的增长速度，所以我们说这个算法的时间复杂度是 O(f(n))。其实就是我们通常所说的大O推倒法，几条重要的准则如下：<br>1.用常数1来取代运行时间中所有加法常数。<br>2.修改后的运行次数函数中，只保留最高阶项。<br>3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。  </p>
<p>至此，时间复杂度讲述完毕，没有复杂的描述，利用几张图和一个数学公式推倒就能理解好。另外还需要掌握时间复杂度分析的基本策略：<strong>从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。</strong></p>
<h1 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h1><p>空间复杂度讨论的是<strong>算法所需要的辅助存储空间</strong>，其中输入数据所占用的具体空间取决于问题本身, 与算法无关。记作：<br>S(n) = O(f(n))</p>
<p>若算法执行时间时所需要的辅助空间相对于输入数据量而言是一个常数，则称这个算法为原地工作， 辅助空间为O(1)。</p>
<p>将一维数组a中的n个数据逆序存放到原数组中, 下面是两种算法:</p>
<p>[算法1]<br>S(n) = O(n)  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)    b[i] = a[n - i - <span class="number">1</span>];   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)    a[i] = b[i]  </span><br></pre></td></tr></table></figure>

<p>[算法2]<br>S(n) = O(1)  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++)&#123;    t = a[i];    a[i] = a[n - i - <span class="number">1</span>];    a[n - i - <span class="number">1</span>] = t;   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>算法1的空间复杂度为O(n), 需要一个大小为n的辅助数组b</li>
<li>算法2的空间复杂度为O(1), 仅需要一个变量t, 与问题规模n无关</li>
</ul>
<p>算法的空间复杂度与时间复杂度合称为算法的复杂度。面对不同的算法如何选择主要就从这两个方面去考虑，理想情况是一个算法的时间与空间复杂度都小，但这是很难做到的，面对不同的情况要具体问题具体分析: 是以时间换空间, 还是以空间换时间。</p>
<p>参考：</p>
<ol>
<li><a href="https://www.jianshu.com/p/f4cca5ce055a">(数据结构）十分钟从零搞定时间复杂度（计算算法的时间复杂度)</a>  </li>
<li><a href="https://www.zhihu.com/question/21387264">如何理解算法时间复杂度的表示法O(n²)、O(n)、O(1)、O(nlogn)等？</a></li>
<li><a href="https://blog.csdn.net/itachi85/article/details/54882603"> 算法（一）时间复杂度</a>  </li>
<li><a href="https://ghui.me/post/2016/08/algorithm_performance/">算法的性能分析</a>  </li>
<li><a href="https://leeeyou.github.io/2016/02/01/blog-2016-02-01-%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">算法之基本排序算法</a>  </li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记之Android群英传</title>
    <url>/iBlogWebsite/2018/02/27/2018/2018-02-27-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8BAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0/</url>
    <content><![CDATA[<p><img src="../../../../images/readingNotes/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0/Android%E7%BE%A4%E8%8B%B1%E4%BC%A0.jpg" alt="Android群英传"></p>
<p>1、怎样区别Dalvik与ART的异同？<br>2、怎样理解Android UI界面架构图？<br>3、怎样理解requestWindowFeature的设置时机？<br>4、怎样理解当创建一个Canvas对象时，要传入一个bitmap对象？<br>5、怎样做好UI模板？<br>6、怎样理解getScrollX()和getScrollY()?<br>7、怎样自定义一个简单的scrollView和viewPager，理清思路？<br>8、怎样理解事件拦截中的时间传递和事件处理？<br>9、怎样设置ListView为空时的样式？<br>10、怎样判断ListView是否滚到最后一行？<br>11、怎样判断ListView的滚动方向？<br>12、怎样获取ActionBar的高度？<br>13、怎样理解Android坐标系中的各种方法？<br>14、怎样使用MarginLayoutParams?<br>15、怎样理解scrollTo和scrollBy参数正负值的含义？<br>16、怎样理解canvas的4个方法？<br>17、怎样理解颜色矩阵？<br>18、怎样理解图形变换矩阵？<br>19、怎样实现自定义刮刮乐效果？<br>20、怎样理解SurfaceView和View的异同和使用场景？<br>21、怎样绘制正弦曲线？<br>22、怎么理解Android任务栈？<br>23、怎样实现在真机上检测布局层级？  </p>
]]></content>
      <categories>
        <category>opinion</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记之在耶鲁精进</title>
    <url>/iBlogWebsite/2018/04/18/2018/2018-04-18-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/</url>
    <content><![CDATA[<p><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B.jpg" alt="在耶鲁精进.jpg"></p>
<p>对于我来说，这是一本信息量巨大的书。</p>
<p>我先试着整理出每个章节的摘录，然后找出关键词，再选择其中的某几个来展开，发现还有10多个，一时不知如何下笔。罢了，既然无从下笔，就写写最想说的吧。</p>
<p>首先是精进这个词，记得在罗振宇时间的朋友跨年晚会上也提过，大意是只有不停的迭代自己，成功的概率才能不断提高。这个惟一靠谱的人生策略，希望自己能铭记，不断的学习、总结、迭代、精进。</p>
<p>其次是通识教育，说实话之前一直没有通识教育的概念，以前在校读书是为了读而读，也没读出个什么花样来。知识结构过于片面，更不用谈触类旁通的智慧了。两年前自己有整理过专业方面的知识架构，目前也一直在完善它；但是通识这块可以说毫无准备，毫无积累，这可不是件好事。通识体系大致包括：文学、数学、科学、经济学、哲学、心理学等，多去了解，扩展自己的涉猎广度何乐而不为。</p>
<p>最后我想说说关于孩子的问题，吴军老师在如何给孩子最好的教育分享会中，讲到“如果有起跑线的话，父母的见识、格局，是孩子的第一起跑线”，父母是孩子的第一任老师，那么上面我们讲到的精进、迭代又或者是扩展自己的通识储备是不是等于在提高将来孩子的第一起跑线呢？此外，还有两点令我影响深刻，①小时候严格要求，长大尊重个人选择。顺序千万别反了。“你是愿意孩子小时候没有多少空间长大后有很多空间呢，还是小时候很多空间长大后没有空间？”什么使人幸福？有选择才有幸福。②让孩子知道生活不易，人生的错误要尽量犯在前面，犯在后面的错误你无法承受，少年则是最好的犯错时期，这时犯错的收益/风险比高到惊人，不犯错简直是虚度人生。将这种思想输送到孩子，不比什么十八线教育培训机构层次高太多？所以我特别特别认同“父母的见识、格局，是孩子的第一起跑线”。</p>
<p>为了利于重复翻阅，还是将摘录做成图片插入在下面:<br><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E5%BA%8F%E8%A8%80.png" alt="序言"></p>
<p><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E8%80%B6%E9%B2%81%E6%95%85%E4%BA%8B.png" alt="耶鲁故事"></p>
<p><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E6%9E%81%E7%AE%80%E9%87%91%E8%9E%8D%E8%AF%BE.png" alt="极简金融课"></p>
<p><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E6%9E%81%E7%AE%80%E8%B0%88%E5%88%A4%E8%AF%BE.png" alt="极简谈判课"></p>
<p><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E5%9C%A8%E7%BE%8E%E5%9B%BD%E7%9C%8B%E7%BE%8E%E5%9B%BD.png" alt="在美国看美国"></p>
<p><img src="../../../../images/readingNotes/%E5%9C%A8%E8%80%B6%E9%B2%81%E7%B2%BE%E8%BF%9B/%E5%A4%A7%E5%AD%A6.%E9%97%AE.%E7%AD%94%E7%BD%91%E5%8F%8B.png" alt="大学.问.答网友"></p>
]]></content>
      <categories>
        <category>opinion</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客hexo环境搭建</title>
    <url>/iBlogWebsite/2022/12/02/2022/2022-12-02-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2hexo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2022/wallpaper/2022-12-02-wallpaper.png?raw=true" alt="2022-12-02-wallpaper"></p>
<h1 id="1-hexo环境安装"><a href="#1-hexo环境安装" class="headerlink" title="1. hexo环境安装"></a>1. hexo环境安装</h1><ul>
<li><p>在macOS上安装homebrew</p>
<ul>
<li>命令<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>官网：<a href="https://brew.sh/">https://brew.sh/</a></li>
</ul>
</li>
<li><p>通过homobrew安装node.js</p>
<ul>
<li>命令   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure></li>
<li>参考：<a href="https://formulae.brew.sh/formula/node">https://formulae.brew.sh/formula/node</a></li>
<li><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2022/code/2022-12-02-09-38-32.png?raw=true" alt="检查是否安装成功"></li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>安装hexo</p>
<ul>
<li>命令<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li>
<li><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2022/code/2022-12-02-09-40-58.png?raw=true"></li>
</ul>
</li>
<li><p>上面这些都处理完后，就进入到iBlogRawResource项目根目录下，然后初始化、生成文档、然后启动服务、最后发布到仓库</p>
<ul>
<li>参考：<a href="https://hexo.io/zh-cn/docs/commands">https://hexo.io/zh-cn/docs/commands</a></li>
</ul>
</li>
</ul>
<h1 id="2-准备发布环境"><a href="#2-准备发布环境" class="headerlink" title="2. 准备发布环境"></a>2. 准备发布环境</h1><ol>
<li>首先要准备好SSH key并配置到系统中</li>
<li>接着将SSH key配置到github上</li>
<li>最后才能通过 <strong>hexo d</strong> 命令正确的发布到仓库</li>
</ol>
<h2 id="2-1-首先要准备好SSH-key并配置到系统中"><a href="#2-1-首先要准备好SSH-key并配置到系统中" class="headerlink" title="2.1 首先要准备好SSH key并配置到系统中"></a>2.1 首先要准备好SSH key并配置到系统中</h2><p>macOS下查看ssh，首先进入到用户根目录，然后快捷键 <strong>Shift+Command+.</strong> 以显示隐藏文件，进入 <strong>.ssh</strong> 目录看是否存在key，若无，则新创建一个。<br><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2022/code/2022-12-02-09-50-04.png?raw=true"></p>
<p>新建SSH key以及将其添加到系统环境变量的细节，参考：<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a><br><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2022/code/2022-12-02-09-51-54.png?raw=true"></p>
<h2 id="2-2-接着将SSH-key配置到github上"><a href="#2-2-接着将SSH-key配置到github上" class="headerlink" title="2.2 接着将SSH key配置到github上"></a>2.2 接着将SSH key配置到github上</h2><p>登录github，进入到设置页，然后将SSH key配置到该账号下，详细步骤参考：<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account</a><br><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2022/code/2022-12-02-09-54-54.png?raw=true"></p>
<h2 id="2-3-最后才能通过-hexo-g-d-命令正确的发布到仓库"><a href="#2-3-最后才能通过-hexo-g-d-命令正确的发布到仓库" class="headerlink" title="2.3 最后才能通过 hexo g -d 命令正确的发布到仓库"></a>2.3 最后才能通过 <strong>hexo g -d</strong> 命令正确的发布到仓库</h2><p>将上面两步做好后，再使用 <strong>hexo g -d</strong> 命令发布，如有问题再根据具体报错情况解决。</p>
<p>当然这条命令对应的发布仓库是在_config.yml中配置好的，如下图所示：<br><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2022/code/2022-12-02-09-59-03.png?raw=true"></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记之财务自由之路</title>
    <url>/iBlogWebsite/2018/08/09/2018/2018-08-09-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<p><img src="../../../../images/readingNotes/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF.jpg" alt="财务自由之路.jpg"></p>
<p>“先完成财务保障，再实现财务安全，最后最后才 <strong>有点可能</strong> 实现财务自由。如若不遵循这一投资哲学，你将会处于危险之地，更别谈实现你的梦想了” , 这点对我而言可能是读这本书的最大收获了。</p>
<p><img src="../../../../images/readingNotes/%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/20180815135720.png" alt="20180815135720.png"></p>
<p>是的，正如上图展示的那样，只有当第一个水壶被住满水以后，你才能加注第二个水壶。你只能使用第二水壶盈余的部分（你不需要用来实现财务安全的金钱）来对第三个水壶进行加注。这样，你的财务安全就永远不会承担风险。而现在的我，解决财务保障可能是最最紧迫的事情了。</p>
<p>老实说，这本书的副标题 “7年内赚到你的第一个1000万” 有点夺眼球的噱头之意，鉴于作者的声望和MacTalk的推荐，读完以后，副标题带来的负面作用可以完全忽略不计。作者的一些思想或者说是一些行为准则，对我而言，有较大的启发；当然你也可以理解为鸡汤，但在我看来，确实值得干了它。比如作者系统的分析你的收入时，从能力、精力、影响力、自我评价和创意五个方面着手，并非空口说白话，而是给出具体某方面的指导和建议；再比如作者提到的责任、持续学习和成长、思维的转变这些无一不是当今竞争激烈的社会上，你我的立足之本。</p>
<p>我们真的可以想象下7年之后自己的财务状况，至少可以定下一个目标吧。达到财务安全线对我而言可能有点难度，但是你的思维方式铸就了你今天的样子，做出改变，持续不断地学习和成长，还是有很大机会搏一搏的，谁说不是呢？</p>
<h4 id="金句摘录"><a href="#金句摘录" class="headerlink" title="金句摘录"></a>金句摘录</h4><blockquote>
<p>1、如果你想获得不一样的结果，那你就必须有所行动：你必须改变自己的方式，首先需要改变的便是你的思维方式，你的思维方式铸了你今天的样子，这样的思维方式却并不能让你变成你想成为的样子。  </p>
</blockquote>
<blockquote>
<p>2、你的思维方式铸就了你今天的样子，这样的思维方式却并不能让你变成你想成为的样子，如果你想获得不一样的结果，那你就必须有所行动：你必须改变自己的方式，首先需要改变的便是你的思维方式。</p>
</blockquote>
<blockquote>
<p>3、不管你相不相信，金钱确实改变了我生活中的许多东西，金钱不会解决你的所有问题，它也绝不是万能的，但是，缺钱却能使你的幸福蒙上一层阴影，有了金钱，你在处理问题的时候便能尝试许多方式，而且，你也将会有机会结识更多的人，参观风景优美的地方，得到更加有趣的工作，获得更多的自信，赢得更多的赞赏，获得更多的机会。 </p>
</blockquote>
<blockquote>
<p>4、我们想要自己掌控将来事态的发展，还是让我们的错误及其后果掌握将来的事态？如果我们在事件发生时勇于承担责任，那么所有的负面情绪在这一刻都会失去掌控力。  </p>
</blockquote>
<blockquote>
<p>5、只有你（绝非任何人）能对你7年内收获多少金钱负责，首先离开你的舒适环境；其次将困难当做成长的机会，并且问自己：我如何创造一种情况，是这个问题不再出现？接着提出正确的问题；最后扩展你的个人范畴，同时你的可控领域也得到了拓展，这世上有一些事你无能为力，但你可以决定，你打算如何判断以及如何对此作出反应，在这方面，你一直都是拥有权利的。  </p>
</blockquote>
<blockquote>
<p>6、责任意味着：没有任何东西能改变你的态度或品格，因为你是按照自己的本性对事情做出反应，你可以决定自己以哪种方式去生活，这种态度是你能够生活幸福，并且成为最好的自己，如果你勇于承担责任，那么你就能在7年内变得富有。  </p>
</blockquote>
<blockquote>
<p>7、随着年龄的增长，你只会对自己没有做过的事情感到后悔。  </p>
</blockquote>
<blockquote>
<p>8、引发奇迹的4个法则，被我统称为持续不断地学习和成长，对我来说，持续不断地学习和成长已经成为我的人生信条，当我们不再成长，我们就与死亡无异了，成长就是生命，持续不断地学习和成长意味着，感受到自身源源不断的活力，也意味着你能成为最好的自己。  </p>
</blockquote>
<blockquote>
<p>9、我们的自信心决定了我们是否敢于冒险，不去冒险便不可能获得成长。  </p>
</blockquote>
<blockquote>
<p>10、大多数人高估了自己1年内能做到的事情，也低估了自己10年内能做到的事情。  </p>
</blockquote>
<blockquote>
<p>11、我们不应该以他人来衡量自己，而应该与自己做纵向对比。  </p>
</blockquote>
<blockquote>
<p>12、我们常常忘记，顺着我们目前为止走过的道路继续前行，同样有风险，这条路给我们一种熟悉感，但也不会更安全，生活就是一场比赛，不去冒险的人不可能获得成功，立即采取行动！因为你永远不能为成功做好完美的准备。</p>
</blockquote>
<blockquote>
<p>13、世上唯一从来不犯错的人，是从来不做任何事的人。  </p>
</blockquote>
<blockquote>
<p>14、我们倾向于将自己无法理解的事物视为奇迹或好运，然而你也看到了，奇迹是可以创造的，就连好运也是多年准备的结果，最终还是在于我们的态度，态度决定我们是否将无法解释的奇迹定义为一种超自然的现象，决定我们是否将坏运气当作理由，答案如果是肯定的话，那么你就不再负有责任，你的坏运气也会成为一个很好的借口，然而，如果你主动承担责任，那么你的好运气就是可以期待的，每个人都会得到属于自己的机会，根本问题是：我们是否愿意对所有事情（包括奇迹和好运）承担责任？如果愿意承担责任，你将为自己创造的奇迹感到惊讶，如果拒绝承担责任，你就会声称“坏运气已经发生了”（但谁又能与之对抗呢），如果勇敢地承担责任，那么好运气就在你的安排计划之中。  </p>
</blockquote>
<blockquote>
<p>15、知足常乐的人也是主动放弃的人，我们拥有什么样的期望，也就决定了我们能获得什么，渴望从生活中获取许多东西的人，生活会给予更多的回报，乔纳森.斯威夫特曾经说过一句讽刺的话：“不期望任何事的人是有福之人，因为他也不会失望”。  </p>
</blockquote>
<blockquote>
<p>16、永远不让目标低于期望，永远不要劝自己说：你不“值得”拥有，你自己是可以决定你值得拥有什么的，你的期望决定你会获得什么，灯光下有你的一席之地。  </p>
</blockquote>
<blockquote>
<p>17、永远不要用短期解决方案来应对长期问题。  </p>
</blockquote>
<blockquote>
<p>18、每个人获得的东西都恰好是他值得获得的东西，虽然我总听到有人抱怨：“我远比我现在获得的东西有价值的多” 但这是错误的，正确的说法应该是：如果你“值得”更多，那么你早该获得了。  </p>
</blockquote>
<blockquote>
<p>19、你必须了解市场法则，你收入的高低取决于此，你今天的收入就是你昨天所做之决定的结果，如果不理解这一点，你就不能说：“现在我要另做选择” 作为自己人生的设计师，你的收入或加薪是由你自己创造的，不是你被加薪，而是你主动获得加薪，如果别人能够决定你的收入高低，那么他们也就拥有了操纵你人生的权利，你（也只有你）能增加自己的收入，你个人对此负责，你个人就可以做出决定。  </p>
</blockquote>
<blockquote>
<p>20、金钱和机遇并不会应需求而产生，而是应能力而产生，你不会因为自己需要更多金钱而获得加薪，你只会因为你所拥有的能力而获得加薪。  </p>
</blockquote>
<blockquote>
<p>21、永远不要将你对自己的怀疑告知任何人，要展示自己的强项，人们不会追随一个自我怀疑的人，只会追随那些坚强不屈的、对目标坚定不移的人，你的强项往往会为你挣得更多的报酬。  </p>
</blockquote>
<blockquote>
<p>22、如果说世上存在成功之终极秘密，那就是刻不容缓地去处理日常事务的能力，为自己确定一条指导原则：尽可能快地着手去做，不要害怕犯错误，IBM创始人说过：“在我的公司里，想要出成绩，就必须犯下双倍的错误” 犯错使人积累经验，经验帮助你快速做出正确决策。  </p>
</blockquote>
<blockquote>
<p>23、如果想让事物想着利于你的方向发展，那么首先你自己必须变得更好。  </p>
</blockquote>
<blockquote>
<p>24、如何分析你的收入之能力：你在自己的专业领域是一个什么水平？你有没有将自己定位为专家？你了解自己的专业领域吗？你是否已为自己建立起能提升你知识和能力的导师及专家团队？你在个人专业领域之外是否还继续深造？你的个人能力是否和你的专业技能共同成长？你了解成功的法则吗，是否运用了成功的法则？你具备领导资质吗？同你所在领域的优秀人士相比，你的能力如何？  </p>
</blockquote>
<blockquote>
<p>25、如何分析你的收入之精力：你准备将多少精力投入专业技能的提升中去？你实际投入了多少精力？你还有多少能量？你能否将精力集中起来，全身心做某件事情？对于你现在所做的事情，你的热情和激情有多大？你热爱你的工作吗？从长远来看，你在将来需要更多的精力，你是否任然为自己的健康、运动、家庭和持续学习以及成长而投入时间？  </p>
</blockquote>
<blockquote>
<p>26、如何分析你的收入之影响力/知名度：你是否知道这是你的收入板块中最重要的版块？影响力是最强大的乘数，你的产品/你的服务受众面有多广？知识、技术、产品在当今社会比比皆是，你能否利用你的产品挣到钱，取决于有多少人知道。  </p>
</blockquote>
<blockquote>
<p>27、如何分析你的收入之自我评价：你是否知道感知即现实？你推销自己的技巧如何？你对自己的举止有多自信？你的自信有多强？你是否认为自己出类拔萃、鹤立鸡群？你是否能很好地表现自己？别人是否认为你是一名专家？是否有人因为你优秀而愿意无偿地为你服务？别人是否认为认识你是莫大的荣幸？你能准确定位自己吗？  </p>
</blockquote>
<blockquote>
<p>28、如何分析你的收入之创意：你具有创造力吗？你是否易于接受新事物？你是否坚持自己的目标，同时准备不断尝试实现目标的新方法？你是否灵活变通？你会把自己的灵感马上写下来吗？你相信自己的灵感并付诸实施吗？你个人的创意工厂发展壮大了吗？你是否不断问自己，“这个创意如何才能切和我的情况”，“我如何才能快速采取行动”，你相信每一个你需要的信息和解决方法，都可以被找出来？你相信要得到这些信息，你就必须不断发展新的创意吗？  </p>
</blockquote>
<blockquote>
<p>29、你的收入水平很大程度上取决于你能做那些别人不能做的事情，“尽快”这条法则同样适用于此，不要等到自己能力足够了才去做，尽快放权，放权那些别人都能做的事情，把空出来的时间集中用于收入丰厚的活动上，放权其他无用的事情，将时间用来定位自己，在同等时间内，只要你挣到的钱别付给助你做事的人要多，账单就永远不会来烦你。  </p>
</blockquote>
<blockquote>
<p>30、借口是我们讲给自己听的谎言，我们应该自己对自己越来越诚实，承担越来越多的责任，许多人声称:“我没有时间去学习正确的投资方法” 是这样吗?这是真的吗?或者说这些人还可以对自己更诚实吗？“我还没有准备好为此投入更多的时间”，这样说会不会显得更诚实? 一位真正的人物不会将生活中的机会滥用在道歉和寻找借口上，借口使我们贫穷。  </p>
</blockquote>
<blockquote>
<p>31、我们能否实现财务自由，对此起决定性作用的是，我们听从的是两个声音中的哪一个：受害者的声音还是勇于承担责任者的声音，永远不要让你内心中那个弱小的人战胜强大的那个人。  </p>
</blockquote>
<blockquote>
<p>32、即使一直以来都没有什么意外发生，你还是应该坚持，因为有了这笔储备金，你才拥有安全感，安全感是每个人都需要的，当你面临困境时，有支持你的后盾，你才可以更好地解决困难，财务保障便是我们所说的后盾，没人能保证自己在意外和不幸来临时不受伤害，但是我们可以未雨绸缪，让我们在意外发生时，能够从容面对，如果意外来临时，我们还要面临财务危机，或者是因为财务问题而妥协，那才是真正的不幸。  </p>
</blockquote>
<blockquote>
<p>33、财务保障是短期目标：这应当是你下一个目标，一个必须尽快完成的目标。  </p>
</blockquote>
<blockquote>
<p>34、为你的强项找一位教练，为你的弱项找一个解决方案。  </p>
</blockquote>
<blockquote>
<p>35、开始阶段简单的事情以后会变得困难，开始阶段困难的事情以后也会变得简单、储蓄并不难，但由于这对你而言是一项全新的开始，所以在开始阶段你应该会感到十分陌生，用储蓄明智地投资不是一件易事，但你会觉得相对简单，因为有很多容易上手的投资形式，因为你有投资顾问、内行的朋友和其他可供参考的例子。  </p>
</blockquote>
<blockquote>
<p>36、第一项计划财务保障能给你带来很多的益处你可以安全地渡过一次危机，你会感到有安全感，可以时刻准备好面对一些未知的意外，但是财务保障有一个很大的缺点一旦意外情况发生，你会花光所有的积蓄，虽然你在财务上安然无恙地渡过了一次危机，但是你的积蓄都没了，真正保险的办法是，你需要积累足够的资金，使你可以靠利息生活。  </p>
</blockquote>
<blockquote>
<p>37、7年后，你要么就根本没有改变你的财务状况，要么就至少部分实现了你的财务安全，7年之后开始的未来，正是你今天所准备的未来，有的人不去从事自己感兴趣的职业，主要原因就是缺钱，这令人感到惋惜，也是一种才能的浪费，这之所以尤其可悲，是因为我们只有在做自己喜爱的事情时才会真正感到幸福，一个从来没有长期做过使自己快乐的有意义的事情的人，从来不会知道，自身究竟蕴藏着多少潜力，如果有人无法走出关键性的一步，不能做自己感兴趣的工作，那么原因往往都在于金钱。  </p>
</blockquote>
<blockquote>
<p>38、在你做出明确的决定之前，请不要继续读下去，这个决定应该包含你实际做的你所了解的必要之事，你知道，你首先必须着手改变信仰，你必须将巨大的痛苦与目标无法实现联系在一起，将巨大的快乐与目标得以实现联系在一起，你应该意识到为什么你一定要这样生活，记住你必须每天提升自己，全力以赴，你必须不断地学习和成长，你必须付出110%的努力，你必须全力以赴，成为最好的自己。你真的想要这样吗?你真的愿意为了财富和幸福去付出每个人都必须付出的代价吗?如果你决定好了这样做(我也想鼓励你这样做)，你就负有责任了你应该向自己承诺，不到最好，永不满足。多年前，第一次听到这一理念时，我几乎不敢相信，但它确确实实是正确的，当你为自己定好一个目标，制订出书面的计划，你就已经成功50%了，以下也有4个足以证明这一点的重要原因：目标拓宽你的机会意识，目标为你指出解决问题的方向，目标是你为了“赢”而去比赛，你有了一个目标，一切都变得很重要。  </p>
</blockquote>
<blockquote>
<p>39、他人可以短暂地阻止你，但只有你自己才可以永远地使自己停下来。  </p>
</blockquote>
<blockquote>
<p>40、你自己决定受谁影响、向谁学习、学习什么：只模仿那些比你成功的人。  </p>
</blockquote>
<blockquote>
<p>41、成功意味着获得你所爱的东西，而幸福意味着享受你获得的东西。  </p>
</blockquote>
]]></content>
      <categories>
        <category>opinion</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之多线程</title>
    <url>/iBlogWebsite/2018/08/17/2018/2018-08-17-Android%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>Android 程序的大多数代码操作都必须执行在主线程，例如：系统事件(例如设备屏幕发生旋转)，输入事件(例如用户点击滑动等)，程序回调服务，UI 绘制以及闹钟事件等等。那么我们在上述事件或者方法中插入的代码也将执行在主线程</p>
<p>一旦我们在主线程里面添加了操作复杂的代码，这些代码就很可能阻碍主线程去响应点击/滑动事件，阻碍主线程的 UI 绘制等等。</p>
<p>我们知道，为了让屏幕的刷新帧率达到 60fps，我们需要确保 16ms 内完成单次刷新的操作。一旦我们在主线程里面执行的任务过于繁重就可能导致接收到刷新信号的时候因为资源被占用而无法完成这次刷新操作，这样就会产生掉帧的现象，刷新帧率自然也就跟着下降了(一旦刷新帧率降到 20fps 左右，用户就可以明显感知到卡顿不流畅了)。</p>
<h1 id="1-Android-系统为我们提供的若干组工具类"><a href="#1-Android-系统为我们提供的若干组工具类" class="headerlink" title="1. Android 系统为我们提供的若干组工具类"></a>1. Android 系统为我们提供的若干组工具类</h1><h2 id="1-1-AsyncTask"><a href="#1-1-AsyncTask" class="headerlink" title="1.1. AsyncTask"></a>1.1. AsyncTask</h2><p>为 UI 线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。</p>
<p>默认情况下，所有的 AsyncTask 任务都是被线性调度执行的，他们处在同一个任务队列当中，按顺序逐个执行。假设你按照顺序启动20个 AsyncTask，一旦其中的某个 AsyncTask 执行时间过长，队列中的其他剩余 AsyncTask 都处于阻塞状态，必须等到该任务执行完毕之后才能够有机会执行下一个任务。</p>
<p>如何才能够真正的取消一个 AsyncTask 的执行呢？我们知道 AsyncTaks 有提供 cancel()的方法，但是这个方法实际上做了什么事情呢？线程本身并不具备中止正在执行的代码的能力，为了能够让一个线程更早的被销毁，我们需要在 doInBackground()的代码中不断的添加程序是否被中止的判断逻辑，一旦任务被成功中止，AsyncTask 就不会继续调用 onPostExecute()，而是通过调用 onCancelled()的回调方法反馈任务执行取消的结果。我们可以根据任务回调到哪个方法（是 onPostExecute 还是 onCancelled）来决定是对 UI 进行正常的更新还是把对应的任务所占用的内存进行销毁等。</p>
<p>使用 AsyncTask 很容易导致内存泄漏，一旦把 AsyncTask 写成 Activity 的内部类的形式就很容易因为 AsyncTask 生命周期的不确定而导致 Activity 发生泄漏。</p>
<h2 id="1-2-HandlerThread"><a href="#1-2-HandlerThread" class="headerlink" title="1.2. HandlerThread"></a>1.2. HandlerThread</h2><p>为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。</p>
<p>HandlerThread 比较合适处理那些在工作线程执行，需要花费时间偏长的任务。我们只需要把任务发送给 HandlerThread，然后就只需要等待任务执行结束的时候通知返回到主线程就好了。</p>
<p>另外很重要的一点是，一旦我们使用了 HandlerThread，需要特别注意给 HandlerThread 设置不同的线程优先级，CPU 会根据设置的不同线程优先级对所有的线程进行调度优化。</p>
<h2 id="1-3-IntentService"><a href="#1-3-IntentService" class="headerlink" title="1.3. IntentService"></a>1.3. IntentService</h2><p>适合于执行由 UI 触发的后台 Service 任务，并可以把后台任务执行的情况通过一定的机制反馈给 UI。</p>
<p>首先，因为 IntentService 内置的是 HandlerThread 作为异步线程，所以每一个交给 IntentService 的任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。</p>
<p>其次，通常使用到 IntentService 的时候，我们会结合使用 BroadcastReceiver 把工作线程的任务执行结果返回给主 UI 线程。使用广播容易引起性能问题，我们可以使用 LocalBroadcastManager 来发送在程序内部传递的广播，从而提升广播的性能。我们也可以使用 runOnUiThread() 快速回调到主 UI 线程。</p>
<p>最后，包含正在运行的 IntentService 的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的</p>
<p>IntentService 继承自普通 Service 同时又在内部创建了一个 HandlerThread，在 onHandlerIntent()的回调里面处理扔到 IntentService 的任务。所以 IntentService 就不仅仅具备了异步线程的特性，还同时保留了 Service 不受主页面生命周期影响的特点。</p>
<h2 id="1-4-ThreadPool"><a href="#1-4-ThreadPool" class="headerlink" title="1.4. ThreadPool"></a>1.4. ThreadPool</h2><p>把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</p>
<h3 id="1-4-1-线程池的基本概念"><a href="#1-4-1-线程池的基本概念" class="headerlink" title="1.4.1. 线程池的基本概念"></a>1.4.1. 线程池的基本概念</h3><p><img src="../../../../images/githubpages/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadPoolExecutor%E6%9C%89%E5%9B%9B%E4%B8%AA%E9%87%8D%E8%BD%BD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt="ThreadPoolExecutor有四个重载的构造方法"></p>
<p>corePoolSize：线程池中核心线程的数量</p>
<p>maximumPoolSize：线程池中最大线程数量</p>
<p>keepAliveTime：非核心线程的超时时长，当系统中非核心线程闲置时间超过keepAliveTime之后，则会被回收。如果ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，则该参数也表示核心线程的超时时长</p>
<p>unit：第三个参数的单位，有纳秒、微秒、毫秒、秒、分、时、天等</p>
<p>workQueue：线程池中的任务队列，该队列主要用来存储已经被提交但是尚未执行的任务。存储在这里的任务是由ThreadPoolExecutor的execute方法提交来的。</p>
<ul>
<li><p>workQueue是一个BlockingQueue类型，它是一个特殊的队列，当我们从BlockingQueue中取数据时，如果BlockingQueue是空的，则取数据的操作会进入到阻塞状态，当BlockingQueue中有了新数据时，这个取数据的操作又会被重新唤醒。同理，如果BlockingQueue中的数据已经满了，往BlockingQueue中存数据的操作又会进入阻塞状态，直到BlockingQueue中又有新的空间，存数据的操作又会被冲洗唤醒。</p>
</li>
<li><p>1.ArrayBlockingQueue 这个表示一个规定了大小的BlockingQueue，ArrayBlockingQueue的构造函数接受一个int类型的数据，该数据表示BlockingQueue的大小，存储在ArrayBlockingQueue中的元素按照FIFO（先进先出）的方式来进行存取。</p>
</li>
<li><p>2.LinkedBlockingQueue 这个表示一个大小不确定的BlockingQueue，在LinkedBlockingQueue的构造方法中可以传一个int类型的数据，这样创建出来的LinkedBlockingQueue是有大小的，也可以不传，不传的话，LinkedBlockingQueue的大小就为Integer.MAX_VALUE</p>
</li>
<li><p>3.PriorityBlockingQueue 这个队列和LinkedBlockingQueue类似，不同的是PriorityBlockingQueue中的元素不是按照FIFO来排序的，而是按照元素的Comparator来决定存取顺序的（这个功能也反映了存入PriorityBlockingQueue中的数据必须实现了Comparator接口）。</p>
</li>
<li><p>4.SynchronousQueue 这个是同步Queue，属于线程安全的BlockingQueue的一种，在SynchronousQueue中，生产者线程的插入操作必须要等待消费者线程的移除操作，Synchronous内部没有数据缓存空间，因此我们无法对SynchronousQueue进行读取或者遍历其中的数据，元素只有在你试图取走的时候才有可能存在。我们可以理解为生产者和消费者互相等待，等到对方之后然后再一起离开。</p>
</li>
</ul>
<p>threadFactory ：为线程池提供创建新线程的功能，这个我们一般使用默认即可</p>
<p>handler：拒绝策略，当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的）默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。</p>
<h3 id="1-4-2-线程池的运行规则"><a href="#1-4-2-线程池的运行规则" class="headerlink" title="1.4.2. 线程池的运行规则"></a>1.4.2. 线程池的运行规则</h3><ul>
<li>1.execute一个线程之后，如果线程池中的线程数未达到核心线程数，则会立马启用一个核心线程去执行</li>
<li>2.execute一个线程之后，如果线程池中的线程数已经达到核心线程数，且workQueue未满，则将新线程放workQueue中等待执行</li>
<li>3.execute一个线程之后，如果线程池中的线程数已经达到核心线程数但未超过非核心线程数，且wrkQueue已满，则开启一个非核心线程来执行任务</li>
<li>4.execute一个线程之后，如果线程池中的线程数已经超过非核心线程数，则拒绝执行该任</li>
</ul>
<h3 id="1-4-3-ThreadPool的使用"><a href="#1-4-3-ThreadPool的使用" class="headerlink" title="1.4.3. ThreadPool的使用"></a>1.4.3. ThreadPool的使用</h3><p>参考<a href="https://leeeyou.github.io/2017/04/14/blog-2017-04-14-Java%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/#ThreadPool%E7%94%A8%E6%B3%95%E4%B8%8E%E4%BC%98%E5%8A%BF">leeyou.xyz</a></p>
<h3 id="1-4-4-线程池其他常用功能"><a href="#1-4-4-线程池其他常用功能" class="headerlink" title="1.4.4. 线程池其他常用功能"></a>1.4.4. 线程池其他常用功能</h3><ul>
<li>shutDown()  关闭线程池，不影响已经提交的任务</li>
<li>shutDownNow() 关闭线程池，并尝试去终止正在执行的线程</li>
<li>allowCoreThreadTimeOut(boolean value) 允许核心线程闲置超时时被回收</li>
<li>submit 一般情况下我们使用execute来提交任务，但是有时候可能也会用到submit，使用submit的好处是submit有返回值</li>
</ul>
<h3 id="1-4-5-使用时要注意的几点"><a href="#1-4-5-使用时要注意的几点" class="headerlink" title="1.4.5. 使用时要注意的几点"></a>1.4.5. 使用时要注意的几点</h3><p>使用线程池需要特别注意同时并发线程数量的控制，理论上来说，我们可以设置任意你想要的并发数量，但是这样做非常的不好。因为 CPU 只能同时执行固定数量的线程数，一旦同时并发的线程数量超过 CPU 能够同时执行的阈值，CPU 就需要花费精力来判断到底哪些线程的优先级比较高，需要在不同的线程之间进行调度切换。</p>
<p>一旦同时并发的线程数量达到一定的量级，这个时候 CPU 在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降。另外需要关注的一点是，每开一个新的线程，都会耗费至少 64K+ 的内存。为了能够方便的对线程数量进行控制，ThreadPoolExecutor 为我们提供了初始化的并发线程数量，以及最大的并发数量进行设置。</p>
<p>另外需要关注的一个问题是：Runtime.getRuntime().availableProcesser()方法并不可靠，他返回的值并不是真实的 CPU 核心数，因为 CPU 会在某些情况下选择对部分核心进行睡眠处理，在这种情况下，返回的数量就只能是激活的 CPU 核心数。</p>
<h1 id="2-Android中的任务线程模型"><a href="#2-Android中的任务线程模型" class="headerlink" title="2. Android中的任务线程模型"></a>2. Android中的任务线程模型</h1><p>Looper：能够确保线程持续存活并且可以不断的从任务队列中获取任务并进行执行。</p>
<p>Handler：能够帮助实现队列任务的管理，不仅仅能够把任务插入到队列的头部，尾部，还可以按照一定的时间延迟来确保任务从队列中能够来得及被取消掉。</p>
<p>MessageQueue：使用 Intent，Message，Runnable 作为任务的载体在不同的线程之间进行传递。</p>
<p>三个组件打包到一起进行协作，这就是 HandlerThread</p>
<p><img src="../../../../images/githubpages/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/HandlerThread.png" alt="HandlerThread"></p>
<h1 id="3-平衡并发的线程数和内存消耗的问题"><a href="#3-平衡并发的线程数和内存消耗的问题" class="headerlink" title="3. 平衡并发的线程数和内存消耗的问题"></a>3. 平衡并发的线程数和内存消耗的问题</h1><p>多线程并发访问同一块内存区域有可能带来很多问题，例如读写的权限争夺问题，ABA 问题等等。为了解决这些问题，我们会需要引入锁的概念。</p>
<h2 id="3-1-Android中多线程引起的问题"><a href="#3-1-Android中多线程引起的问题" class="headerlink" title="3.1. Android中多线程引起的问题"></a>3.1. Android中多线程引起的问题</h2><p>Android UI 对象的创建，更新，销毁等等操作都默认是执行在主线程，但是如果我们在非主线程对UI对象进行操作，程序将可能出现异常甚至是崩溃。</p>
<p>在非 UI 线程中直接持有 UI 对象的引用也很可能出现问题。例如Work线程中持有某个 UI 对象的引用，在 Work 线程执行完毕之前，UI 对象在主线程中被从 ViewHierarchy 中移除了，这个时候 UI 对象的任何属性都已经不再可用了，另外对这个 UI 对象的更新操作也都没有任何意义了，因为它已经从 ViewHierarchy 中被移除，不再绘制到画面上了。</p>
<p>View 对象本身对所属的 Activity 是有引用关系的，如果工作线程持续保有 View 的引用，这就可能导致 Activity 无法完全释放。除了直接显式的引用关系可能导致内存泄露之外，我们还需要特别留意隐式的引用关系也可能导致泄露。例如通常我们会看到在 Activity 里面定义的一个 AsyncTask，这种类型的 AsyncTask 与外部的 Activity 是存在隐式引用关系的，只要 Task 没有结束，引用关系就会一直存在，这很容易导致 Activity 的泄漏。更糟糕的情况是，它不仅仅发生了内存泄漏，还可能导致程序异常或者崩溃。</p>
<p><strong>我们需要谨记的原则就是：不要在任何非 UI 线程里面去持有 UI 对象的引用。</strong></p>
<p><strong>系统为了确保所有的 UI 对象都只会被 UI 线程所进行创建，更新，销毁的操作，特地设计了对应的工作机制(当 Activity 被销毁的时候，由该 Activity 所触发的非 UI 线程都将无法对UI对象进行操作，否者就会抛出程序执行异常的错误)来防止 UI 对象被错误的使用。</strong></p>
<h1 id="4-Loaders"><a href="#4-Loaders" class="headerlink" title="4. Loaders"></a>4. Loaders</h1><p>当启动工作线程的 Activity 被销毁的时候，我们应该做点什么呢？</p>
<p>为了方便的控制工作线程的启动与结束，Android 为我们引入了 Loader 来解决这个问题。<br>我们知道 Activity 有可能因为用户的主动切换而频繁的被创建与销毁，也有可能是因为类似屏幕发生旋转等被动原因而销毁再重建。在 Activity 不停的创建与销毁的过程当中，很有可能因为工作线程持有 Activity 的 View 而导致内存泄漏(因为工作线程很可能持有 View 的强引用，另外工作线程的生命周期还无法保证和 Activity 的生命周期一致，这样就容易发生内存泄漏了)。除了可能引起内存泄漏之外，在 Activity 被销毁之后，工作线程还继续更新视图是没有意义的，因为此时视图已经不在界面上显示了。</p>
<p><img src="../../../../images/githubpages/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/loaders.jpg" alt="Loaders"></p>
<p>Loader 的出现就是为了确保工作线程能够和 Activity 的生命周期保持一致</p>
<ul>
<li><p>LoaderManager 会对查询的操作进行缓存，只要对应 Cursor 上的数据源没有发生变化，在配置信息发生改变的时候(例如屏幕的旋转)，Loader  可以直接把缓存的数据回调到 onLoadFinished()，从而避免重新查询数据。另外系统会在 Loader 不再需要使用到的时候(例如使用 Back 按钮退出当前页面)回调 onLoaderReset()方法，我们可以在这里做数据的清除等等操作。</p>
</li>
<li><p>在 Activity 或者 Fragment 中使用 Loader 可以方便的实现异步加载的框架，Loader 有诸多优点。但是实现 Loader 的这套代码还是稍微有点点复杂，Android 官方为我们提供了使用 Loader 的示例代码进行参考学习。</p>
</li>
</ul>
<h1 id="5-线程优先级的重要性"><a href="#5-线程优先级的重要性" class="headerlink" title="5. 线程优先级的重要性"></a>5. 线程优先级的重要性</h1><p>Android 系统会根据当前运行的可见的程序和不可见的后台程序对线程进行归类，划分为 forground 的那部分线程会大致占用掉 CPU 的90%左右的时间片，background 的那部分线程就总共只能分享到5%-10%左右的时间片。之所以设计成这样是因为 forground 的程序本身的优先级就更高，理应得到更多的执行时间。</p>
<p>默认情况下，新创建的线程的优先级默认和创建它的母线程保持一致。如果主 UI 线程创建出了几十个工作线程，这些工作线程的优先级就默认和主线程保持一致了，为了不让新创建的工作线程和主线程抢占 CPU 资源，需要把这些线程的优先级进行降低处理，这样才能给帮助 CPU 识别主次，提高主线程所能得到的系统资源。</p>
<p>在 Android 系统里面，我们可以通过 android.os.Process.setThreadPriority(int) 设置线程的优先级，参数范围从-20到19，数值越小优先级越高。Android 系统还为我们提供了以下的一些预设值，我们可以通过给不同的工作线程设置不同数值的优先级来达到更细粒度的控制。</p>
<p><img src="../../../../images/githubpages/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.jpg" alt="线程优先级"></p>
<p>Android 系统里面的 AsyncTask 与 IntentService已经默认帮助我们设置线程的优先级，但是对于那些非官方提供的多线程工具类，我们需要特别留意根据需要自己手动来设置线程的优先级。</p>
<p><img src="../../../../images/githubpages/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A72.jpg" alt="线程优先级"></p>
<p><img src="../../../../images/githubpages/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A73.jpg" alt="线程优先级"></p>
<h1 id="6-工具篇"><a href="#6-工具篇" class="headerlink" title="6. 工具篇"></a>6. 工具篇</h1><p>从 Android M 系统开始，系统更新了 GPU Profiling 的工具来帮助我们定位 UI 的渲染性能问题。早期的 CPU Profiling 工具只能粗略的显示出 Process，Execute，Update 三大步骤的时间耗费情况。但是仅仅显示三大步骤的时间耗费情况，还是不太能够清晰帮助我们定位具体的程序代码问题，所以在 Android M 版本开始，GPU Profiling 工具把渲染操作拆解成8个详细的步骤进行显示。</p>
<p>Sync &amp; Upload：通常表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片本身的大小。</p>
<p>Measure &amp; Layou：这里表示的是布局的 onMeasure 与 onLayout 所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题。</p>
<p>Animation：表示的是计算执行动画所需要花费的时间，包含的动画有 ObjectAnimator，ViewPropertyAnimator，Transition 等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等。</p>
<p>Input Handling：表示的是系统处理输入事件所耗费的时间，粗略等于对于的事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作。</p>
<p>Misc/Vsync Delay：如果稍加注意，我们可以在开发应用的 Log 日志里面看到这样一行提示：I/Choreographer(691): Skipped XXX frames! The application may be doing too much work on its main thread。这意味着我们在主线程执行了太多的任务，导致 UI 渲染跟不上 vSync 的信号而出现掉帧的情况。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之多态</title>
    <url>/iBlogWebsite/2018/08/28/2018/2018-08-28-Java%E4%B9%8B%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="1-实现机制"><a href="#1-实现机制" class="headerlink" title="1. 实现机制"></a>1. 实现机制</h1><p>多态靠的是父类的引用变量可以指向子类的具体实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。</p>
<h1 id="2-多态的前提"><a href="#2-多态的前提" class="headerlink" title="2. 多态的前提"></a>2. 多态的前提</h1><p>必须是类与类之间的关系。要么继承，要么实现。</p>
<p>通常还有一个前提就是：覆盖。</p>
<h1 id="3-多态的利弊"><a href="#3-多态的利弊" class="headerlink" title="3. 多态的利弊"></a>3. 多态的利弊</h1><ul>
<li>多态的出现大大的提高了程序的扩展性。</li>
<li>提高了扩展性的同时，只能使用父类的引用访问父类中的成员。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Activities</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">doActivity</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">			a.eat();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">			((Cat) a).catchMouse();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">			((Dog) a).kanJia();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Pig) &#123;</span><br><span class="line">			((Pig) a).sleep();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃鱼&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃骨头&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">kanJia</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;看家&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃饲料&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;老是睡觉&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DuoTaiDemo1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// new Activities().doActivity(null);</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//类型提升，向上转型</span></span><br><span class="line">		a.eat();</span><br><span class="line">		<span class="comment">//如果想要调用猫的特有方法，如何操作？？</span></span><br><span class="line">		<span class="comment">//强制将父类的应用转成子类类型，向下转型</span></span><br><span class="line">		<span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;</span><br><span class="line">		c.catchMouse();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 注意：前往不能将父类对象转成子类类型</span></span><br><span class="line"><span class="comment">		 * Animal a = new Animal();</span></span><br><span class="line"><span class="comment">		 * Cat c = (Cat)a;</span></span><br><span class="line"><span class="comment">		 * 我们能转换的是父类引用执行了自己子类对象是，该应用可以被提升</span></span><br><span class="line"><span class="comment">		 * 多态自始至终都是子类对象在做着变化</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//下面代码是利用Activities类创建对象完成对Cat，Dog，Pig进行的活动</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Activities</span>().doActivity(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Activities</span>().doActivity(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Activities</span>().doActivity(<span class="keyword">new</span> <span class="title class_">Pig</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：电脑运行实例，电脑运行基于主板，提供扩展功能</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LeeYou</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PCI</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主板，使用PCI接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainBoard</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;mainBoard run...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userPCI</span><span class="params">(PCI p)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">			p.open();</span><br><span class="line">			p.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 网卡扩展类，实现PCI接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetCard</span> <span class="keyword">implements</span> <span class="title class_">PCI</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;netcard open...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;netcard close...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声卡扩展类，实现PCI接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SoundCard</span> <span class="keyword">implements</span> <span class="title class_">PCI</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;soundcard open...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;soundcard close...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DuoTaiDemo3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MainBoard</span> <span class="variable">mb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MainBoard</span>();</span><br><span class="line">		mb.run();</span><br><span class="line">		mb.userPCI(<span class="keyword">new</span> <span class="title class_">SoundCard</span>());</span><br><span class="line">		mb.userPCI(<span class="keyword">new</span> <span class="title class_">NetCard</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-多态的注意事项"><a href="#4-多态的注意事项" class="headerlink" title="4. 多态的注意事项"></a>4. 多态的注意事项</h1><h2 id="4-1-在多态中成员函数的特点"><a href="#4-1-在多态中成员函数的特点" class="headerlink" title="4.1. 在多态中成员函数的特点"></a>4.1. 在多态中成员函数的特点</h2><ul>
<li>在编译时期：参阅引用型变量所属的类是否有调用的方法。如果有，编译通过；如果没有，编译失败。</li>
<li>在运行时期：参阅对象所属的类中是否有调用的方法。</li>
</ul>
<h2 id="4-2-在多态中，成员变量的特点（常用于面试）"><a href="#4-2-在多态中，成员变量的特点（常用于面试）" class="headerlink" title="4.2. 在多态中，成员变量的特点（常用于面试）"></a>4.2. 在多态中，成员变量的特点（常用于面试）</h2><p>无论编译和运行，都参考左边（引用型变量所属的类）</p>
<h2 id="4-3-在多态中，静态成员函数的特点（常用于面试）"><a href="#4-3-在多态中，静态成员函数的特点（常用于面试）" class="headerlink" title="4.3. 在多态中，静态成员函数的特点（常用于面试）"></a>4.3. 在多态中，静态成员函数的特点（常用于面试）</h2><p>无论在编译和运行，都参考左边（引用型变量所属的类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Father Class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father method 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father method 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father method 4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Son Class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son method 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son method 3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son method 4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DuoTaiDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//演示6.1</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        f.method1();</span><br><span class="line">        f.method2();<span class="comment">//对应6.1.2</span></span><br><span class="line">        <span class="comment">//f.method3(); //对应6.1.1,这一行会报错</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示6.2</span></span><br><span class="line">        System.out.println(f.num);</span><br><span class="line">        System.out.println(f.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示6.3</span></span><br><span class="line">        f.method4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../../../images/githubpages/%E5%A4%9A%E6%80%81/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="运行结果"></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle for Android</title>
    <url>/iBlogWebsite/2018/08/29/2018/2018-08-29-Gradle%20for%20Android/</url>
    <content><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h1><h2 id="1-1-理解基本的Gradle"><a href="#1-1-理解基本的Gradle" class="headerlink" title="1.1. 理解基本的Gradle"></a>1.1. 理解基本的Gradle</h2><p>Gradle是一种构建工具，Gradle脚本不是像传统的xml文件那样，而是一种基于Groovy的动态DSL。</p>
<ul>
<li>DSL: 指的是用于一个特定领域的语言（功能领域、业务领域），可以简单理解成就是一个配置文件，或者说是面向领域的某种配置文件，如Ant的build.xml某种意义上就是Ant的DSL文件。</li>
<li>Groovy语言: 是一种基于jvm的动态语言.</li>
</ul>
<p>当我们把Gradle作为构建工具使用时，我们只需要掌握它的配置脚本的基本写法就OK了；而当我们需要对构建流程进行高度定制时，就务必要掌握Groovy等相关知识了。如果想开始创建自己的tasks和插件，那么你最好对Groovy有一个较深的理解。</p>
<h2 id="1-2-两个重要的概念"><a href="#1-2-两个重要的概念" class="headerlink" title="1.2. 两个重要的概念"></a>1.2. 两个重要的概念</h2><h3 id="1-2-1-Project"><a href="#1-2-1-Project" class="headerlink" title="1.2.1. Project"></a>1.2.1. Project</h3><p>每一个build.grade文件代表着一个project。每个project有至少一个tasks，一个apk文件的构建包含以下Task：Java源码编译、资源文件编译、Lint检查、打包以生成最终的apk文件等等。</p>
<p>每一次构建都是有至少一个project来完成，所以Android studio中的project和Gradle中的project不是一个概念但可以简单理解为：Android Studio中的一个Module即为Gradle中的一个Project。</p>
<h3 id="1-2-2-Tasks"><a href="#1-2-2-Tasks" class="headerlink" title="1.2.2. Tasks"></a>1.2.2. Tasks</h3><p>tasks在build.gradle中定义，当初始化构建进程时，gradle会基于build文件集合所有的project和tasks。一个tasks包含了一系列动作，然后它们将会按照顺序执行，一个动作就是一段被执行的代码，很像Java中的方法。</p>
<h2 id="1-3-构建的生命周期"><a href="#1-3-构建的生命周期" class="headerlink" title="1.3. 构建的生命周期"></a>1.3. <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html">构建的生命周期</a></h2><p>初始化阶段：project实例在这儿创建，如果有多个模块，即有多个build.gradle文件，多个project将会被创建。</p>
<p>配置阶段：在该阶段，build.gradle脚本将会执行，为每个project创建和配置所有的tasks。</p>
<p>执行阶段：这一阶段，gradle会决定哪一个tasks会被执行，哪一个tasks会被执行完全依赖开始构建时传入的参数和当前所在的文件夹位置有关。</p>
<h2 id="1-4-Gradle工作流程"><a href="#1-4-Gradle工作流程" class="headerlink" title="1.4. Gradle工作流程"></a>1.4. Gradle工作流程</h2><p><img src="../../../../images/githubpages/gradle/Gradle%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="gradle工作流程"></p>
<p>首先是初始化阶段，就是执行settings.gradle。</p>
<p>Configration阶段的目标是解析每个project中的build.gradle，解析每个子目录中的build.gradle。在这两个阶段之间，我们可以加一些定制化的Hook。这当然是通过API来添加的。</p>
<p>Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。前面说过一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。所以我们可以添加一个HOOK，即当Task关系图建立好后，执行一些操作，另外不包含依赖的Tasks总是优先执行。</p>
<p>最后一个阶段就是执行任务了，当然任务执行完后，我们还可以加Hook。</p>
<h2 id="1-5-插件"><a href="#1-5-插件" class="headerlink" title="1.5. 插件"></a>1.5. 插件</h2><p>思考下为什么能在build.gradle中使用android标签？</p>
<p>因为应用”com.android.application”这个插件来构建app模块，如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">apply plugin:<span class="string">&#x27;com.android.application&#x27;</span></span><br></pre></td></tr></table></figure>

<p>整个插件中定义了如下4个顶级任务</p>
<ol>
<li>assemble: 构建项目的输出（apk）</li>
<li>check: 进行校验工作</li>
<li>build: 执行assemble任务与check任务</li>
<li>clean: 清除项目的输出</li>
</ol>
<p>还有一个插件是library，但不能同时使用他们2个，否则导致构建失败，一个模块要么使用Android application或者Android library插件，而不是二者。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">apply plugin:<span class="string">&#x27;com.android.library&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-6-使用Gradle-Wrapper"><a href="#1-6-使用Gradle-Wrapper" class="headerlink" title="1.6. 使用Gradle Wrapper"></a>1.6. 使用Gradle Wrapper</h2><p>grade只是一个构建工具，而新版本总是在更迭，所以使用Gradle Wrapper将会是一个好的选择去避免由于gradle版本更新导致的问题。</p>
<p>利用命令行./gradlew -v来查看当前gradle版本。</p>
<ul>
<li>gradlew是gradle wrapper的缩写，也就是说它对gradle的命令进行了包装</li>
<li>解压gradle-wrapper.jar看看</li>
</ul>
<p>在gradle-wrapper.properties中可以改变该url来改变你的gradle版本，如导入github项目跑不起来，可以尝试修改url。<a href="https://services.gradle.org/distributions">参考</a></p>
<h1 id="2-基本配置"><a href="#2-基本配置" class="headerlink" title="2. 基本配置"></a>2. 基本配置</h1><h2 id="2-1-根目录的build-gradle"><a href="#2-1-根目录的build-gradle" class="headerlink" title="2.1. 根目录的build.gradle"></a>2.1. 根目录的build.gradle</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">     repositories &#123;</span><br><span class="line">         jcenter()</span><br><span class="line">     &#125;</span><br><span class="line">      dependencies &#123;</span><br><span class="line">          classpath <span class="string">&#x27;com.android.tools.build:gradle:1.2.3&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">     repositories &#123;</span><br><span class="line">          jcenter()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buildscript方法是定义了全局的相关属性，repositories定义了jcenter作为仓库，一个仓库代表着你的依赖包的来源。</p>
<p>allprojects方法可以用来定义各个模块的默认属性，你可以不仅仅局限于默认的配置，未来你可以自己创造tasks在allprojects方法体内，这些tasks将会在所有模块中可见。</p>
<h2 id="2-2-模块内的build-gradle"><a href="#2-2-模块内的build-gradle" class="headerlink" title="2.2. 模块内的build.gradle"></a>2.2. <a href="http://apdr.qiniudn.com/index.html">模块内的build.gradle</a></h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载用于构建Android项目的插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line"></span><br><span class="line">android &#123; <span class="comment">//构建Android项目使用的配置</span></span><br><span class="line">    compileSdkVersion <span class="number">23</span> <span class="comment">//指定编译项目时使用的SDK版本</span></span><br><span class="line">    buildToolsVersion <span class="string">&quot;23.0.1&quot;</span> <span class="comment">//指定构建工具的版本</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.absfree.debugframwork&quot;</span> <span class="comment">//包名</span></span><br><span class="line">        minSdkVersion <span class="number">15</span>  <span class="comment">//指定支持的最小SDK版本</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span> <span class="comment">//针对的目标SDK版本</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123; <span class="comment">//针对不同的构建版本进行一些设置</span></span><br><span class="line">        release &#123; <span class="comment">//对release版本进行的设置</span></span><br><span class="line">            minifyEnabled <span class="literal">false</span> <span class="comment">//是否开启混淆</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span>  <span class="comment">//指定混淆文件的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123; <span class="comment">//指定当前模块的依赖</span></span><br><span class="line">    compile fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    testCompile <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;com.android.support:appcompat-v7:23.1.1&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;com.android.support:design:23.1.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性applicationId复写了AndroidManifest文件中的包名packagename，但是关于applicationId和package name有一些不同。package name在AndroidManifest.xml有两个作用：其作为一个app的唯一标示，并且其被用在了R资源文件的包名。</p>
<p>buildTypes方法定义了如何构建不同版本的app。<a href="https://developer.android.com/studio/build/index.html">参考</a></p>
<h2 id="2-3-依赖管理"><a href="#2-3-依赖管理" class="headerlink" title="2.3. 依赖管理"></a>2.3. 依赖管理</h2><p>依赖模块作为gradle默认的属性之一（这也是为什么其放在了Android的外面），为你的app定义了所有的依赖包。</p>
<h3 id="2-3-1-依赖第三方库"><a href="#2-3-1-依赖第三方库" class="headerlink" title="2.3.1. 依赖第三方库"></a>2.3.1. 依赖第三方库</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">       compile <span class="string">&#x27;com.google.code.gson:gson:2.3&#x27;</span></span><br><span class="line">       compile <span class="string">&#x27;com.squareup.retrofit:retrofit:1.9.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个依赖需要定义三个元素：group，name和version。</p>
<ul>
<li>group意味着创建该library的组织名，通常这会是包名</li>
<li>name是该library的唯一标示</li>
<li>version是该library的版本号</li>
</ul>
<h3 id="2-3-2-依赖本地jar包"><a href="#2-3-2-依赖本地jar包" class="headerlink" title="2.3.2. 依赖本地jar包"></a>2.3.2. 依赖本地jar包</h3><p>默认情况下，我们依赖了所有在libs文件下的jar文件，同时包含了AppCompat这个aar文件。</p>
<h3 id="2-3-3-依赖其它模块"><a href="#2-3-3-依赖其它模块" class="headerlink" title="2.3.3. 依赖其它模块"></a>2.3.3. 依赖其它模块</h3><p>compile project(‘:other’)</p>
<h3 id="2-3-4-动态版本"><a href="#2-3-4-动态版本" class="headerlink" title="2.3.4. 动态版本"></a>2.3.4. 动态版本</h3><p>在一些情形中，在构建你的app或者library的时候通过动态版本能使用到最新的依赖包。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">       compile <span class="string">&#x27;com.android.support:support-v4:22.2.+&#x27;</span><span class="comment">//我们告诉gradle,得到最新的生产版本。  </span></span><br><span class="line">       compile <span class="string">&#x27;com.android.support:appcompat-v7:22.2+&#x27;</span><span class="comment">//我们告诉gradle，我们想得到最新的minor版本，并且其最小的版本号是2。</span></span><br><span class="line">       compile <span class="string">&#x27;com.android.support:recyclerview-v7:+&#x27;</span><span class="comment">//我们告诉gradle,得到最新的library。  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你应该小心去使用动态版本，如果当你允许gradle去挑选最新版本，可能导致挑选的依赖版本并不是稳定版，这将会对构建产生很多问题，更糟糕的是你可能在你的服务器和私人pc上得到不同的依赖版本，这直接导致你的应用不同步。</p>
<p>如果你在你的build.gradle中使用了动态版本，Android studio将会警告你关于动态版本的潜在问题。</p>
<p>关于版本号的介绍</p>
<ul>
<li><p>Apache组织的目标是将APR独立出来形成单独的第三方库，因此对其而言稳定的API接口就成为一个非常重要的必须考虑的方面。不过由于APR需要不断的往前方展，因此API接口的变化又是必然的趋势，因此如何平衡稳定性和变化性是APR开发者面临的一个极需解决的问题。为此APR采用了严格的版本规则来实现这一点。用户只需要简单的判断APR版本号，就可以很容易确定当前版本的兼容性：向前兼容、向后兼容还是前后同时兼容。</p>
</li>
<li><p>APR中使用三个整数来记录APR版本号：MAJOR.MINOR.PATCH。MAJOR表示当前APR的主版本号，它的变化通常意味着APR的巨大的变化，比如体系结构的重新设计，API的重新设计等等，而且这种变化通常会导致APR版本的向前不兼容。</p>
</li>
<li><p>MINOR称之为APR的次版本号，它通常只反映了一些较大的更改，比如APR的API的增加等等，但是这些更改并不影响与旧版本源代码和二进制代码之间的兼容性。</p>
</li>
<li><p>PATCH通常称之为补丁版本，通常情况下如果只是对APR函数的修改而不影响API接口的话都会导致PATCH的变化。</p>
</li>
</ul>
<h2 id="2-4-全局设置"><a href="#2-4-全局设置" class="headerlink" title="2.4. 全局设置"></a>2.4. 全局设置</h2><p>更好的做法是你在全局的gradle文件中定义一些属性，然后在模块中运用它们。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">       compileSdkVersion = <span class="number">22</span></span><br><span class="line">       buildToolsVersion = <span class="string">&quot;22.0.1&quot;</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">       compileSdkVersion rootProject.ext.compileSdkVersion</span><br><span class="line">       buildToolsVersion rootProject.ext.buildToolsVersion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-aar文件"><a href="#2-5-aar文件" class="headerlink" title="2.5. aar文件"></a>2.5. aar文件</h2><p>如果你想分享一个library，该依赖包使用了Android api，或者包含了Android资源文件，那么aar文件适合你。</p>
<p>应用工程和依赖工程的区别在于输出文件，应用工程会生成APK文件，并且其可以安装在Android设备上，而依赖工程会生成.aar文件，该文件可以被Android应用工程当做依赖来使用。</p>
<h1 id="3-构建变体"><a href="#3-构建变体" class="headerlink" title="3. 构建变体"></a>3. 构建变体</h1><h2 id="3-1-构建版本"><a href="#3-1-构建版本" class="headerlink" title="3.1. 构建版本"></a>3.1. 构建版本</h2><h3 id="3-1-1-创建自己的构建版本"><a href="#3-1-1-创建自己的构建版本" class="headerlink" title="3.1.1. 创建自己的构建版本"></a>3.1.1. 创建自己的构建版本</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">staging.initWith(buildTypes.debug)</span><br><span class="line">staging &#123;</span><br><span class="line">    applicationIdSuffix <span class="string">&quot;.staging&quot;</span></span><br><span class="line">    versionNameSuffix <span class="string">&quot;-staging&quot;</span></span><br><span class="line">    debuggable = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initWith()方法创建了一个新版本的同时，复制所有存在的构建版本，类似继承。我们也可以复写该存在版本的所有属性。</p>
<h3 id="3-1-2-Source-sets"><a href="#3-1-2-Source-sets" class="headerlink" title="3.1.2. Source sets"></a>3.1.2. Source sets</h3><p>nothing to show</p>
<h2 id="3-2-product-flavors"><a href="#3-2-product-flavors" class="headerlink" title="3.2. product flavors"></a>3.2. product flavors</h2><p>和构建版本不同，product flavors用来为一个app创建不同版本。典型的例子是，一个app有付费和免费版。</p>
<p>如果你不确定是否需要一个新的构建版本或者product flavors，你应该问你自己，你是否需要内部使用和外部使用的apk。如果你需要一个完全新的app去发布，和之前的版本完全隔离开，那么你需要product flavors，否则你只是需要构建版本。</p>
<p>创建product flavors</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        red &#123;</span><br><span class="line">             applicationId <span class="string">&#x27;com.gradleforandroid.red&#x27;</span></span><br><span class="line">             versionCode <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">        blue &#123;</span><br><span class="line">             applicationId <span class="string">&#x27;com.gradleforandroid.blue&#x27;</span></span><br><span class="line">             minSdkVersion <span class="number">14</span></span><br><span class="line">             versionCode <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Groovy入门介绍"><a href="#4-Groovy入门介绍" class="headerlink" title="4. Groovy入门介绍"></a>4. <a href="http://www.groovy-lang.org/api.html">Groovy入门介绍</a></h1><h2 id="4-1-前提知识"><a href="#4-1-前提知识" class="headerlink" title="4.1. 前提知识"></a>4.1. 前提知识</h2><p>Groovy语句可以不用分号结尾。</p>
<p>Groovy中支持动态类型，即定义变量的时候可以不指定其类型。变量定义可以使用关键字def，注意虽然def不是必须的，但是为了代码清晰，建议还是使用def关键字。  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> variable1 = <span class="number">1</span>   <span class="comment">//可以不使用分号结尾  </span></span><br><span class="line"><span class="keyword">def</span> varable2 = <span class="string">&quot;I ama person&quot;</span>  </span><br><span class="line"><span class="keyword">def</span>  <span class="type">int</span> x = <span class="number">1</span>  <span class="comment">//变量定义时，也可以直接指定类型  </span></span><br></pre></td></tr></table></figure>

<p>函数定义时，参数的类型也可以不指定。比如:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">String testFunction(arg1,arg2)&#123;<span class="comment">//无需指定参数类型  </span></span><br><span class="line">  ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>除了变量定义可以不指定类型外，Groovy中函数的返回值也可以是无类型的。比如:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//无类型的函数定义，必须使用def关键字  </span></span><br><span class="line"><span class="keyword">def</span>  nonReturnTypeFunc()&#123;  </span><br><span class="line">    last_line   <span class="comment">//最后一行代码的执行结果就是本函数的返回值  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果指定了函数返回类型，则可不必加def关键字来定义函数  </span></span><br><span class="line">String getString()&#123;  </span><br><span class="line">   <span class="keyword">return</span><span class="string">&quot;I am a string&quot;</span>  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Groovy对字符串支持相当强大，充分吸收了一些脚本语言的优点。</p>
<p>单引号’’中的内容严格对应Java中的String，不对$符号进行转义：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">defsingleQuote=<span class="string">&#x27;I am $ dolloar&#x27;</span>  <span class="comment">//输出就是I am $ dolloar </span></span><br></pre></td></tr></table></figure>

<p>双引号””的内容则和脚本语言的处理有点像，如果字符中有$号的话，则它会$表达式先求值：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">defdoubleQuoteWithoutDollar = <span class="string">&quot;I am one dollar&quot;</span> <span class="comment">//输出 I am one dollar  </span></span><br><span class="line"><span class="keyword">def</span> x = <span class="number">1</span>  </span><br><span class="line">defdoubleQuoteWithDollar = <span class="string">&quot;I am $x dolloar&quot;</span> <span class="comment">//输出I am 1 dolloar</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">三个引号<span class="string">&#x27;&#x27;&#x27;xxx&#x27;&#x27;&#x27;</span>中的字符串支持随意换行 比如</span><br><span class="line"></span><br><span class="line">```groovy</span><br><span class="line">defmultieLines = <span class="string">&#x27;&#x27;&#x27; begin  </span></span><br><span class="line"><span class="string">line  1  </span></span><br><span class="line"><span class="string">line  2  </span></span><br><span class="line"><span class="string">end &#x27;&#x27;&#x27;</span>  </span><br></pre></td></tr></table></figure>

<p>最后，除了每行代码不用加分号外，Groovy中函数调用的时候还可以不加括号。比如：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;test&quot;</span>) ---&gt; println<span class="string">&quot;test&quot;</span>  </span><br></pre></td></tr></table></figure>

<p>注意，虽然写代码的时候，对于函数调用可以不带括号，但是Groovy经常把属性和函数调用混淆。比如:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> getSomething()&#123;  </span><br><span class="line">  <span class="string">&quot;hello&quot;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数要不要带括号，我个人意见是如果这个函数是Groovy API或者Gradle API中比较常用的，比如println，就可以不带括号，否则还是带括号。</p>
<h2 id="4-2-Collections"><a href="#4-2-Collections" class="headerlink" title="4.2. Collections"></a>4.2. Collections</h2><p>List：链表，其底层对应Java中的List接口，一般用ArrayList作为真正的实现类。</p>
<p>Map：键-值表，其底层对应Java中的LinkedHashMap。</p>
<p>Range：范围，它其实是List的一种拓展。</p>
<h2 id="4-3-方法"><a href="#4-3-方法" class="headerlink" title="4.3. 方法"></a>4.3. 方法</h2><h3 id="4-3-1-闭包"><a href="#4-3-1-闭包" class="headerlink" title="4.3.1. 闭包"></a>4.3.1. 闭包</h3><p>闭包，英文叫Closure，是Groovy中非常重要的一个数据类型或者说一种概念了。</p>
<p>闭包，是一种数据类型，它代表了一段可执行的代码。其外形如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> aClosure = &#123;<span class="comment">//闭包是一段代码，所以需要用花括号括起来..  </span></span><br><span class="line">    String param1, <span class="type">int</span> param2 -&gt;  <span class="comment">//这个箭头很关键。箭头前面是参数定义，箭头后面是代码  </span></span><br><span class="line">    println<span class="string">&quot;this is code&quot;</span> <span class="comment">//这是代码，最后一句是返回值，  </span></span><br><span class="line">   <span class="comment">//也可以使用return，和Groovy中普通函数一样  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> greeting = &#123; <span class="string">&quot;Hello, $it!&quot;</span> &#125;</span><br><span class="line"><span class="keyword">assert</span> greeting(<span class="string">&#x27;Patrick&#x27;</span>) == <span class="string">&#x27;Hello, Patrick!&#x27;</span></span><br><span class="line"></span><br><span class="line">等同于：</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> greeting = &#123; it -&gt; <span class="string">&quot;Hello, $it!&quot;</span>&#125;</span><br><span class="line"><span class="keyword">assert</span> greeting(<span class="string">&#x27;Patrick&#x27;</span>) == <span class="string">&#x27;Hello, Patrick!&#x27;</span></span><br><span class="line"></span><br><span class="line">但是，如果在闭包定义时，采用下面这种写法，则表示闭包没有参数！</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> noParamClosure = &#123; -&gt; <span class="literal">true</span> &#125;</span><br><span class="line">这个时候，我们就不能给noParamClosure传参数了！</span><br><span class="line">noParamClosure (<span class="string">&quot;test&quot;</span>)  &lt;==报错喔！</span><br></pre></td></tr></table></figure>

<p>Closure使用中的注意如下两点</p>
<ol>
<li>省略圆括号</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt;each(List&lt;T&gt; self, Closure closure)</span><br></pre></td></tr></table></figure>

<p>上面这个函数表示针对List的每一个元素都会调用closure做一些处理。这里的closure，就有点回调函数的感觉。但是在使用这个each函数的时候，我们传递一个怎样的Closure进去呢？比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> iamList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  <span class="comment">//定义一个List</span></span><br><span class="line">iamList.each&#123; <span class="comment">//调用它的each，这段代码的格式看不懂了吧？each是个函数，圆括号去哪了？</span></span><br><span class="line">      println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码有两个知识点：</p>
<p>each函数调用的圆括号不见了! 原来，Groovy中，当函数的最后一个参数是闭包的话，可以省略圆括号。比如</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> testClosure(<span class="type">int</span> a1,String b1, Closure closure)&#123;</span><br><span class="line">      <span class="comment">//dosomething</span></span><br><span class="line">     closure() <span class="comment">//调用闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么调用的时候，就可以免括号！</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">testClosure (<span class="number">4</span>, <span class="string">&quot;test&quot;</span>, &#123;</span><br><span class="line">   println<span class="string">&quot;i am in closure&quot;</span></span><br><span class="line">&#125; )  <span class="comment">//圆括号可以不写</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如何确定Closure的参数</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt;self, Closure closure)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> iamList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  <span class="comment">//定义一个List变量</span></span><br><span class="line">iamList.each&#123; <span class="comment">//调用它的each函数，只要传入一个Closure就可以了。</span></span><br><span class="line">  println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于each所需要的Closure，它的参数是什么？有多少个参数？返回值是什么？</p>
<p>Closure虽然很方便，但是它一定会和使用它的上下文有极强的关联。要不作为类似回调这样的东西，我如何知道调用者传递什么参数给Closure呢？<a href="http://www.groovy-lang.org/api.html">只能通过查询API文档才能了解上下文语义</a>。</p>
<p><img src="../../../../images/githubpages/gradle/groovy-each.png" alt="groovy-each"></p>
<h1 id="5-其他实践"><a href="#5-其他实践" class="headerlink" title="5. 其他实践"></a>5. 其他实践</h1><h2 id="5-1-加速模块构建"><a href="#5-1-加速模块构建" class="headerlink" title="5.1. 加速模块构建"></a>5.1. 加速模块构建</h2><p><a href="https://developer.android.com/studio/build/optimize-your-build.html">https://developer.android.com/studio/build/optimize-your-build.html</a></p>
<h2 id="5-2-集成签名配置"><a href="#5-2-集成签名配置" class="headerlink" title="5.2. 集成签名配置"></a>5.2. 集成签名配置</h2><p>nothing to show</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之核心36讲整理</title>
    <url>/iBlogWebsite/2018/08/14/2018/2018-08-14-Java%E4%B9%8B%E6%A0%B8%E5%BF%8336%E8%AE%B2%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>这里是将极客时间上杨晓峰老师的专栏文章，在这里整理出来方便自己后续复习用。文章分为5大模块：</p>
<ul>
<li>Java 基础：我会围绕 Java 语言基本特性和机制，由点带面，让你构建牢固的 Java 技术工底。  </li>
<li>Java 进阶：将围绕并发编程、Java 虚拟机等领域展开，助你攻坚大厂 Java 面试的核心阵地。  </li>
<li>Java 应用开发扩展：从数据库编程、主流开源框架、分布式开发等，帮你掌握 Java 开发的十八般兵器。  </li>
<li>Java 安全基础：让你理解常见的应用安全问题和处理方法，掌握如何写出符合大厂规范的安全代码。  </li>
<li>Java 性能基础：你将掌握相关工具、方法论与基础实践。  </li>
</ul>
<p>对于Android开发人员来说，后面章节内容更多偏向后端开发，对于这部分内容，我自己是量力而行。很多知识点以前只是听说或是了解不透彻，比如CAS、AQS、内存模型、多线程并发等，这次在专栏中，收获满满；只要用心读，保持清晰的头脑，应该还会有进一步的提升。</p>
<p>技术之外，杨老师在文章中有意的提到了许多思想层面的内容，个人觉得对于意识的提升非常有帮助。比如说“你需要尽量表现出自己的思维深入并系统化”、“知其然并知其所以然，明白基本组成和机制”、“应用场景是我们在选择哪个API前需要考虑的，不能一概而论的说A比B绝对好”等等。当然意识层面的提高也绝非说说而已，还需结合实践和自己的思考不断摸索和总结。</p>
<p>在某些文章中，我添加了一些自己不太熟悉的内容补充，在相应的章节里面做好记录，也算是查漏补缺，消除自己的疑虑吧。</p>
<ul>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/kai-pian-ci-yi-mian-shi-ti-wei-qie-ru-dian-ff0c-you-xiao-ti-sheng-ni-de-java-nei-gong.md">开篇词 | 以面试题为切入点，有效提升你的Java内功</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-1-jiang-tan-tan-ni-dui-java-ping-tai-de-li-jie-ff1f.md">第1讲 | 谈谈你对Java平台的理解？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-2-jiang-exception-he-error-you-shi-yao-qu-bie-ff1f.md">第2讲 | Exception和Error有什么区别？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-3-jiang-tan-tan-final-finally-finalize-you-shi-yao-bu-tong-ff1f.md">第3讲 | 谈谈final、finally、 finalize有什么不同？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-4-jiang-qiang-yin-yong-3001-ruan-yin-yong-3001-ruo-yin-yong-3001-huan-xiang-yin-yong-you-shi-yao-qu-bie-ff1f.md">第4讲 | 强引用、软引用、弱引用、幻象引用有什么区别？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-5-jiang-string-stringbuffer-stringbuilder-you-shi-yao-qu-bie-ff1f.md">第5讲 | String、StringBuffer、StringBuilder有什么区别？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-6-jiang-dong-tai-dai-li-shi-ji-yu-shi-yao-yuan-li-ff1f.md">第6讲 | 动态代理是基于什么原理？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-7-jiang-int-he-integer-you-shi-yao-qu-bie-ff1f.md">第7讲 | int和Integer有什么区别？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-8-jiang-dui-bi-vector-arraylist-linkedlist-you-he-qu-bie-ff1f.md">第8讲 | 对比Vector、ArrayList、LinkedList有何区别？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-9-jiang-dui-bi-hashtable-hashmap-treemap-you-shi-yao-bu-tong-ff1f.md">第9讲 | 对比Hashtable、HashMap、TreeMap有什么不同？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-10-jiang-ru-he-baozheng-ji-he-shi-xian-cheng-an-quan-76843f-concurrenthashmap-ru-he-shi-xian-gao-xiao-di-xian-cheng-an-quan-ff1f.md">第10讲 | 如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-11-jiang-java-ti-gong-le-na-xie-io-fang-shi-ff1f-nio-ru-he-shi-xian-duo-lu-fu-yong-ff1f.md">第11讲 | Java提供了哪些IO方式？ NIO如何实现多路复用？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-12-jiang-java-you-ji-zhong-wen-jian-kao-bei-fang-shi-ff1f-na-yi-zhong-zui-gao-xiao-ff1f.md">第12讲 | Java有几种文件拷贝方式？哪一种最高效？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-13-jiang-tan-tan-jie-kou-he-chou-xiang-lei-you-shi-yao-qu-bie-ff1f.md">第13讲 | 谈谈接口和抽象类有什么区别？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-14-jiang-tan-tan-ni-zhi-dao-de-she-ji-mo-shi-ff1f.md">第14讲 | 谈谈你知道的设计模式？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-15-jiang-synchronized-he-reentrantlock-you-shi-yao-qu-bie-ni-ff1f.md">第15讲 | synchronized和ReentrantLock有什么区别呢？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/zhou-mo-fu-li-tan-tan-wo-dui-java-xue-xi-he-mian-shi-de-kan-fa.md">周末福利 | 谈谈我对Java学习和面试的看法</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-16-jiang-synchronized-di-ceng-ru-he-shi-xian-ff1f-shi-yao-shi-suo-de-sheng-ji-3001-jiang-ji-ff1f.md">第16讲 | synchronized底层如何实现？什么是锁的升级、降级？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-17-jiang-yi-ge-xian-cheng-liang-ci-diao-yong-start-fang-fa-hui-chu-xian-shi-yao-qing-kuang-ff1f.md">第17讲 | 一个线程两次调用start()方法会出现什么情况？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-18-jiang-shi-yao-qing-kuang-xia-java-cheng-xu-hui-chan-sheng-si-suo-ff1f-ru-he-ding-wei-3001-xiu-fu-ff1f.md">第18讲 | 什么情况下Java程序会产生死锁？如何定位、修复？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-19-jiang-java-bing-fa-bao-ti-gong-le-na-xie-bing-fa-gong-ju-lei-ff1f.md">第19讲 | Java并发包提供了哪些并发工具类？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-20-jiang-bing-fa-bao-zhong-de-concurrentlinkedqueue-he-linkedblockingqueue-you-shi-yao-qu-bie-ff1f.md">第20讲 | 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-21-jiang-java-bing-fa-lei-ku-ti-gong-de-xian-cheng-chi-you-na-ji-zhong-ff1f-fen-bie-you-shi-yao-te-dian-ff1f.md">第21讲 | Java并发类库提供的线程池有哪几种？ 分别有什么特点？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-22-jiang-atomicinteger-di-ceng-shi-xian-yuan-li-shi-shi-yao-ff1f-ru-he-zai-zi-ji-de-chan-pin-dai-ma-zhong-ying-yong-cas-cao-zuo-ff1f.md">第22讲 | AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-23-jiang-qing-jie-shao-lei-jia-zai-guo-cheng-ff0c-shi-yao-shi-shuang-qin-wei-pai-mo-xing-ff1f.md">第23讲 | 请介绍类加载过程，什么是双亲委派模型？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-24-jiang-you-na-xie-fang-fa-ke-yi-zai-yun-xing-shi-dong-tai-sheng-cheng-yi-ge-java-lei-ff1f.md">第24讲 | 有哪些方法可以在运行时动态生成一个Java类？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-25-jiang-tan-tan-jvm-nei-cun-qu-yu-de-hua-fen-ff0c-na-xie-qu-yu-ke-neng-fa-sheng-outofmemoryerror.md">第25讲 | 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-26-jiang-ru-he-jian-kong-he-zhen-duan-jvm-dui-nei-he-dui-wai-nei-cun-shi-yong-ff1f.md">第26讲 | 如何监控和诊断JVM堆内和堆外内存使用？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-27-jiang-java-chang-jian-de-la-ji-shou-ji-qi-you-na-xie-ff1f.md">第27讲 | Java常见的垃圾收集器有哪些？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-28-jiang-tan-tan-ni-de-gc-diao-you-si-8def3f.md">第28讲 | 谈谈你的GC调优思路?</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-29-jiang-java-nei-cun-mo-xing-zhong-de-happen-before-shi-shi-yao-ff1f.md">第29讲 | Java内存模型中的happen-before是什么？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-30-jiang-java-cheng-xu-yun-xing-zai-docker-deng-rong-qi-huan-jing-you-na-xie-xin-wen-ti-ff1f.md">第30讲 | Java程序运行在Docker等容器环境有哪些新问题？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-31-jiang-ni-le-jie-java-ying-yong-kai-fa-zhong-de-zhu-ru-gong-ji-ma-ff1f.md">第31讲 | 你了解Java应用开发中的注入攻击吗？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-32-jiang-ru-he-xie-chu-an-quan-de-java-dai-ma-ff1f.md">第32讲 | 如何写出安全的Java代码？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-33-jiang-hou-tai-fu-wu-chu-xian-ming-xian-201c-bian-man-201d-ff0c-tan-tan-ni-de-zhen-duan-si-lu-ff1f.md">第33讲 | 后台服务出现明显“变慢”，谈谈你的诊断思路？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-34-jiang-you-ren-shuo-201c-lambda-neng-rang-java-cheng-xu-man-30-bei-201d-ff0c-ni-zen-yao-kan-ff1f.md">第34讲 | 有人说“Lambda能让Java程序慢30倍”，你怎么看？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-35-jiang-jvm-you-hua-java-dai-ma-shi-du-zuo-le-shi-yao-ff1f.md">第35讲 | JVM优化Java代码时都做了什么？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-36-jiang-tan-tan-mysql-zhi-chi-de-shi-wu-ge-li-ji-bie-ff0c-yi-ji-bei-guan-suo-he-le-guan-suo-de-yuan-li-he-ying-yong-chang-jing-ff1f.md">第36讲 | 谈谈MySQL支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-37-jiang-tan-tan-spring-bean-de-sheng-ming-zhou-qi-he-zuo-yong-yu-ff1f.md">第37讲 | 谈谈Spring Bean的生命周期和作用域？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-38-jiang-duibi-java-biao-zhun-nio-lei-ku-ff0c-ni-zhi-dao-netty-shi-ru-he-shi-xian-geng-gao-xing-neng-de-ma-ff1f.md">第38讲 | 对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-39-jiang-tan-tan-chang-yong-de-fen-bu-shi-id-de-she-ji-fang-an-ff1f-snowflake-shi-fou-shou-dong-ling-shi-qie-huan-ying-xiang-ff1f.md">第39讲 | 谈谈常用的分布式ID的设计方案？Snowflake是否受冬令时切换影响？</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/jie-shu-yu-ji-zhu-mei-you-zhong-dian.md">结束语 | 技术没有终点</a></li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>知识汇总</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之内存区域</title>
    <url>/iBlogWebsite/2018/09/14/2018/2018-09-14-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>下面这张图是结合《深入理解Java虚拟机2》以及《Java核心36讲》中的内容画出来的，理论上看算是比较详细的描述了JVM运行时内存区域。从图中可以看出主要包含了两部分：运行时数据区与其他数据区（主要指直接内存和Code Cache），而在运行时数据区中又分为线程隔离和线程共享。</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/jvm-runtime-memory-area.png?raw=true" alt="jvm-runtime-memory-area"></p>
<h1 id="1-运行时数据区"><a href="#1-运行时数据区" class="headerlink" title="1. 运行时数据区"></a>1. 运行时数据区</h1><h2 id="1-1-线程隔离"><a href="#1-1-线程隔离" class="headerlink" title="1.1. 线程隔离"></a>1.1. 线程隔离</h2><ul>
<li><p>程序计数器</p>
<p>程序计数器（PC，Program Counter Register）。在 JVM 规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。</p>
<p>该区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
</li>
<li><p>Java虚拟机栈</p>
<p>Java 虚拟机栈（Java Virtual Machine Stack）。每个线程在创建时都会创建一个虚拟机栈，它的生命周期与线程相同，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。</p>
<p>在一个时间点，对应的只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈。</p>
<p>栈帧中存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。栈帧结构详细说明可以参考<a href="https://blog.csdn.net/luanlouis/article/details/40043991">《Java虚拟机原理图解》3、JVM运行时数据区</a>。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展且无法申请到足够内存时，将会抛出OutOfMemoryError异常。</p>
</li>
<li><p>本地方法栈</p>
<p>本地方法栈（Native Method Stack）。它和 Java 虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个。在 Oracle Hotspot JVM 中，本地方法栈和 Java 虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
</li>
</ul>
<h2 id="1-2-线程共享"><a href="#1-2-线程共享" class="headerlink" title="1.2. 线程共享"></a>1.2. 线程共享</h2><ul>
<li><p>堆</p>
<p>堆（Heap），它是 Java 内存管理的核心区域，用来放置 Java 对象实例，几乎所有创建的 Java 对象实例都是被直接分配在堆上，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有对象都在堆上分配变得不是那么绝对了。堆被所有的线程共享，在虚拟机启动时，我们指定的 “Xmx” 之类参数就是用来指定最大堆空间等指标。理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。</p>
<p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
</li>
<li><p>方法区</p>
<p>方法区（Method Area）。这也是所有线程共享的一块内存区域，用于存储所谓的元（Meta）数据，例如类结构信息，以及对应的运行时常量池、类型信息、字段信息、方法信息、类变量、指向类加载器的引用、指向Class实例的引用、方法表等。由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK 8 中将永久代移除，同时增加了元数据区（Metaspace）。方法区结构的详细说明可以参考<a href="https://blog.csdn.net/luanlouis/article/details/40043991">《Java虚拟机原理图解》3、JVM运行时数据区</a>。</p>
<p>运行时常量池（Run-Time Constant Pool），这是方法区的一部分。如果仔细分析过反编译的类文件结构，你能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。Java 的常量池可以存放各种常量信息，<strong>不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</strong> 例如下面这段展示代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">testI</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="variable">testF</span> <span class="operator">=</span> <span class="number">1.234f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过javap命令后，观察它的常量池情况，第10行起：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  D:\Project\IntellJ2\DemoIO\src&gt;javap -v ConstantTest.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Classfile</span> /D:/Project/IntellJ2/DemoIO/src/ConstantTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2018</span>-<span class="number">9</span>-<span class="number">14</span>; size <span class="number">337</span> bytes</span><br><span class="line">  MD5 checksum 4088cb12575ced51f0f0f09ac26c14ff</span><br><span class="line">  Compiled from <span class="string">&quot;ConstantTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantTest</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">5.</span>#<span class="number">19</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Float              <span class="number">1.234f</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">4.</span>#<span class="number">20</span>         <span class="comment">// ConstantTest.testF:F</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">21</span>            <span class="comment">// ConstantTest</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">22</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">6</span> = Utf8               testI</span><br><span class="line">   #<span class="number">7</span> = Utf8               I</span><br><span class="line">   #<span class="number">8</span> = Utf8               ConstantValue</span><br><span class="line">   #<span class="number">9</span> = Integer            <span class="number">1</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               testF</span><br><span class="line">  #<span class="number">11</span> = Utf8               F</span><br><span class="line">  #<span class="number">12</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">13</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">14</span> = Utf8               Code</span><br><span class="line">  #<span class="number">15</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">16</span> = Utf8               &lt;clinit&gt;</span><br><span class="line">  #<span class="number">17</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">18</span> = Utf8               ConstantTest.java</span><br><span class="line">  #<span class="number">19</span> = NameAndType        #<span class="number">12</span>:#<span class="number">13</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">20</span> = NameAndType        #<span class="number">10</span>:#<span class="number">11</span>        <span class="comment">// testF:F</span></span><br><span class="line">  #<span class="number">21</span> = Utf8               ConstantTest</span><br><span class="line">  #<span class="number">22</span> = Utf8               java/lang/Object</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2-其他数据区"><a href="#2-其他数据区" class="headerlink" title="2. 其他数据区"></a>2. 其他数据区</h1><h2 id="2-1-直接内存"><a href="#2-1-直接内存" class="headerlink" title="2.1. 直接内存"></a>2.1. 直接内存</h2><p>直接内存（Direct Memory）区域并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分内存会被频繁地使用，而且也可能导致OutOfMemoryError异常。本机直接内存显然不会受到Java堆大小的限制，但肯定还是会受到本机总内存大小以及处理器寻址控件的限制。</p>
<p>在JDK1.4中新引入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用操作，从而避免了Java堆和Native堆中来回复制数据的麻烦。</p>
<p><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-12-jiang-java-you-ji-zhong-wen-jian-kao-bei-fang-shi-ff1f-na-yi-zhong-zui-gao-xiao-ff1f.md">第12讲 | Java有几种文件拷贝方式？哪一种最高效？</a> 这篇文章详细介绍了拷贝的实现机制以及NIO的特性，建议阅读以加深对DirectMemory的理解。</p>
<h2 id="2-2-Code-Cache等区域"><a href="#2-2-Code-Cache等区域" class="headerlink" title="2.2. Code Cache等区域"></a>2.2. Code Cache等区域</h2><p>JVM 本身是个本地程序，还需要其他的内存去完成各种基本任务，比如，JIT Compiler 在运行时对热点方法进行编译，就会将编译后的方法储存在 Code Cache 里面；GC 等功能需要运行在本地线程之中，类似部分都需要占用内存空间。这些是实现 JVM JIT 等功能的需要，但规范中并不涉及。</p>
<hr>
<p>参考： </p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
<li><a href="https://github.com/LeeeYou/The-core-of-Java-36/blob/master/di-25-jiang-tan-tan-jvm-nei-cun-qu-yu-de-hua-fen-ff0c-na-xie-qu-yu-ke-neng-fa-sheng-outofmemoryerror.md">第25讲 | 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之内部类</title>
    <url>/iBlogWebsite/2018/08/28/2018/2018-08-28-Java%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1. 成员内部类"></a>1. 成员内部类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Coco&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Jayden&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.name);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> o.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等。</p>
<p>Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性age。</p>
<p>定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 = 外部类对象.new 内部类( ); 。</p>
<p>编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}</p>
<p>成员内部类中不能存在任何 static 的变量和方法,可以定义常量: 1. 因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关,简而言之:在加载静态域时,根本没有外部类,所在在非静态内部类中不能定义静态域或方法,编译不通过;非静态内部类的作用域是实例级别 2. 常量是在编译器就确定的,放到所谓的常量池了。静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。</p>
<p>友情提示：1.外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字,如:Outer.this.name。</p>
<h1 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2. 静态内部类"></a>2. 静态内部类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Coco&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Jayden&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(Outer.name);</span><br><span class="line">            System.out.println(name);                  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问。如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员。</p>
<p>创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类();</p>
<h1 id="3-方法内部类"><a href="#3-方法内部类" class="headerlink" title="3. 方法内部类"></a>3. 方法内部类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用的形参为何要为 final???在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;访问外部类:&quot;</span> + a);</span><br><span class="line">                System.out.println(<span class="string">&quot;访问内部类:&quot;</span> + c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        i.print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        o.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。只能访问方法中定义的 final 类型的局部变量，当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在,直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量;而使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期。局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数;防止被篡改数据,而导致内部类得到的值不一致。</p>
<h1 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4. 匿名内部类"></a>4. 匿名内部类</h1><p>使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口；同时它没有class关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引用，当然这个引用是隐式的。</p>
<p>对于匿名内部类的使用存在一个缺陷，即它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> InnerClass <span class="title function_">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span>   num,String str2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>()&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> num + <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;        <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> out.getInnerClass(<span class="number">2</span>, <span class="string">&quot;chenssy&quot;</span>);</span><br><span class="line">        System.out.println(inner.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-注意事项"><a href="#4-1-注意事项" class="headerlink" title="4.1. 注意事项"></a>4.1. 注意事项</h2><p>1 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。<br>2 匿名内部类中是不能定义构造函数的。<br>3 匿名内部类中不能存在任何的静态成员变量和静态方法。<br>4 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。<br>5 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
<h2 id="4-2-使用的形参为什么要final修饰"><a href="#4-2-使用的形参为什么要final修饰" class="headerlink" title="4.2. 使用的形参为什么要final修饰"></a>4.2. 使用的形参为什么要final修饰</h2><p>在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数，所以他们两者是可以任意变化的</p>
<p>也就是说在内部类中对属性的改变并不会影响到外部的形参，然而这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。</p>
<p>简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之对象-Part2布局</title>
    <url>/iBlogWebsite/2018/09/17/2018/2018-09-17-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part2%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>对象的布局其实就是对象在虚拟机中的组成部分。在Hotspot虚拟机中，对象分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>对象头包括两部分信息：对象自身的运行时数据（官方称它为“Mark Word”）以及类型指针。</p>
<p>对象自身的运行时数据包含：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit。需要注意的是对象头信息是与对象自身定义的数据无关的额外存储成本。</p>
<p>类型指针是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，可以理解为对象的实例信息（即下文的oops）。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。</p>
<p>实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。Hotspot虚拟机默认的分配策略为：longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true，那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于Hotspot VM的自动内存管理系统要求对象其实地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<p>下面通过一个详细的例子说明JVM的分配策略以及对齐填充，以加深对象的布局理解。通过Unsafe拿到对象属性的offset与Instrumentation计算的大小对比是否一致，如下所以一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.javamex.classmexer.MemoryUtil;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SizeOfUnsafe</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String s; <span class="comment">//4</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> i;<span class="comment">//4</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> b;<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">double</span> d;<span class="comment">//8</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> b2;<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">private</span> Score obj;<span class="comment">//4</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> b3;<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> i2;<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        byUnsafe();</span><br><span class="line">        byInstrumentation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">byUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field[] declaredFields = Person.class.getDeclaredFields();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;定义顺序&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Field f : declaredFields) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;field &quot;</span> + f.getName() + <span class="string">&quot; \t offset : &quot;</span> + unsafe.objectFieldOffset(f) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;重排顺序&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Arrays.sort(declaredFields, (left, right) -&gt; Math.toIntExact(unsafe.objectFieldOffset(left) - unsafe.objectFieldOffset(right)));</span><br><span class="line">            <span class="keyword">for</span> (Field f : declaredFields) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;field &quot;</span> + f.getName() + <span class="string">&quot; \t offset : &quot;</span> + unsafe.objectFieldOffset(f) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">byInstrumentation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Shallow Size : 对象自身占用的内存大小，不包括它引用的对象。针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。针对数组类型的对象，它的大小是数组元素对象的大小总和。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Shallow Size: &quot;</span> + MemoryUtil.memoryUsageOf(person) + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Retained Size : 当前对象大小+当前对象可直接或间接引用到的对象的大小总和。(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Retained Size: &quot;</span> + MemoryUtil.deepMemoryUsageOf(person) + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果如下所示，可以看到重排顺序offset是36，加上4个字节即36 + 4 = 40 bytes，同Instrumentation计算出来的40 bytes一致。运行Instrumentation时，我这里采用了 <a href="https://www.javamex.com/classmexer/classmexer-0_03.zip">classmexer-0_03.zip</a> 这个jar包来帮我统计大小。我采用IntelliJ运行，需要添加一下jvm的运行时参数 <strong>-javaagent:classmexer.jar</strong>，如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义顺序</span><br><span class="line">field s 	 offset : <span class="number">32</span>	</span><br><span class="line">field i 	 offset : <span class="number">12</span>	</span><br><span class="line">field b 	 offset : <span class="number">28</span>	</span><br><span class="line">field d 	 offset : <span class="number">16</span>	</span><br><span class="line">field b2 	 offset : <span class="number">29</span>	</span><br><span class="line">field obj 	 offset : <span class="number">36</span>	</span><br><span class="line">field b3 	 offset : <span class="number">30</span>	</span><br><span class="line">field i2 	 offset : <span class="number">24</span>	</span><br><span class="line"></span><br><span class="line">重排顺序</span><br><span class="line">field i 	 offset : <span class="number">12</span>	</span><br><span class="line">field d 	 offset : <span class="number">16</span>	</span><br><span class="line">field i2 	 offset : <span class="number">24</span>	</span><br><span class="line">field b 	 offset : <span class="number">28</span>	</span><br><span class="line">field b2 	 offset : <span class="number">29</span>	</span><br><span class="line">field b3 	 offset : <span class="number">30</span>	</span><br><span class="line">field s 	 offset : <span class="number">32</span>	</span><br><span class="line">field obj 	 offset : <span class="number">36</span>	</span><br><span class="line"></span><br><span class="line">Shallow Size: <span class="number">40</span> bytes</span><br><span class="line">Retained Size: <span class="number">40</span> bytes</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/jvm-object-object-layout-analysis.png?raw=true" alt="jvm-object-object-layout-analysis"></p>
<p>下面分析未采用分配策略与采用了分配策略之间的区别，针对上述代码中的Person对象，如果未采用分配策略，直接分配内存，在内存中的布局如下所示，有9个对齐位，可以看到需要用到48 bytes：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[HEADER:   <span class="number">8</span> bytes]  <span class="number">8</span></span><br><span class="line">[oops:     <span class="number">4</span> bytes]  <span class="number">12</span></span><br><span class="line">[s:        <span class="number">4</span> bytes]  <span class="number">16</span></span><br><span class="line">[i:        <span class="number">4</span> bytes]  <span class="number">20</span></span><br><span class="line">[b:        <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">21</span></span><br><span class="line">[padding:  <span class="number">3</span> bytes]  <span class="number">24</span></span><br><span class="line">[d:        <span class="number">8</span> bytes]  <span class="number">32</span></span><br><span class="line">[b2:       <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">33</span></span><br><span class="line">[obj:      <span class="number">4</span> bytes]  <span class="number">37</span></span><br><span class="line">[b3:       <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">38</span></span><br><span class="line">[padding:  <span class="number">2</span> <span class="type">byte</span> ]  <span class="number">40</span></span><br><span class="line">[i2:       <span class="number">4</span> bytes]  <span class="number">44</span></span><br><span class="line">[padding:  <span class="number">4</span> <span class="type">byte</span> ]  <span class="number">48</span></span><br></pre></td></tr></table></figure>

<p>而采用分配策略后，按照longs/doubles、ints、shorts/chars、bytes/booleans、oops的顺序排列，在内存中的布局如下所示，只有1个对齐位，整体用到40 bytes，较上面的方式显然更加节省内存空间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[HEADER:   <span class="number">8</span> bytes]  <span class="number">8</span></span><br><span class="line">[oops:     <span class="number">4</span> bytes]  <span class="number">12</span></span><br><span class="line">[i:        <span class="number">4</span> bytes]  <span class="number">16</span></span><br><span class="line">[d:        <span class="number">8</span> bytes]  <span class="number">24</span></span><br><span class="line">[i2:       <span class="number">4</span> bytes]  <span class="number">28</span></span><br><span class="line">[b:        <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">29</span></span><br><span class="line">[b2:       <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">30</span></span><br><span class="line">[b3:       <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">31</span></span><br><span class="line">[padding:  <span class="number">1</span> <span class="type">byte</span> ]  <span class="number">32</span></span><br><span class="line">[s:        <span class="number">4</span> bytes]  <span class="number">36</span></span><br><span class="line">[obj:      <span class="number">4</span> bytes]  <span class="number">40</span></span><br></pre></td></tr></table></figure>

<p>另外关于对象头占用空间大小，这里说明一下32位系统和64位系统中对象所占用内存空间的大小：</p>
<ul>
<li>在32位系统下，存放Class Pointer的空间大小是4字节，MarkWord是4字节，对象头为8字节;</li>
<li>在64位系统下，存放Class Pointer的空间大小是8字节，MarkWord是8字节，对象头为16字节;</li>
<li>64位开启指针压缩的情况下，存放Class Pointer的空间大小是4字节，MarkWord是8字节，对象头为12字节;</li>
<li>如果是数组对象，对象头的大小为：数组对象头8字节+数组长度4字节+对齐4字节=16字节。其中对象引用占4字节（未开启指针压缩的64位为8字节），数组MarkWord为4字节（64位未开启指针压缩的为8字节）;</li>
<li>静态属性不算在对象大小内。</li>
</ul>
<hr>
<p>参考： </p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
<li><a href="https://www.jianshu.com/p/91e398d5d17c">Java对象内存布局</a></li>
<li><a href="https://blog.csdn.net/ITer_ZC/article/details/41822719">聊聊JVM（三）两种计算Java对象大小的方法</a></li>
<li><a href="http://www.importnew.com/1305.html">Java对象内存结构</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之对象-Part1创建</title>
    <url>/iBlogWebsite/2018/09/15/2018/2018-09-15-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part1%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p>这篇文章讨论一个在Java语言层面来看非常简单的问题：怎样创建对象？通常仅仅一个 new 关键字而已，但是在虚拟机中，对象（特指普通对象，不包括数组对象和Class对象）的创建流程又是怎样的呢？</p>
<p>根据 <a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a> 中的知识，我画出了虚拟机创建普通对象的流程如，如下所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/jvm-object-the-process-of-creating-common-objects-in-virtual-machines.png?raw=true" alt="jvm-object-the-process-of-creating-common-objects-in-virtual-machines"></p>
<p>虚拟机在遇到一条new指令时，首先会检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>在类加载检查通过后，接下来是虚拟机为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。Java堆是否规整决定了分配方式是 “指针碰撞” 还是 “空闲列表”。而Java堆是否规整依据的是GC的收集器采用的哪种分配算法，像Serial、ParNew等带整理算法的收集器，JVM会采用 “指针碰撞” 分配；而使用CMS这种标记-清除算法的收集器，JVM通常采用“空闲列表”分配。</p>
<ul>
<li><p>“指针碰撞”仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。因为所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器。</p>
</li>
<li><p>“空闲列表”是由于已使用内存和空间内存相互交错，虚拟机必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象示例，并更新列表上的记录。</p>
</li>
</ul>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>接下来虚拟机要对对象进行必要的设置，通俗说就是设置对象头：类的元数据信息、对象的哈希表、对象的GC分带年龄、是否启用偏斜锁等。后续会对对象头做详细介绍。</p>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——<init>方法还没有执行，所有的字段都还为零。所以，一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<hr>
<p>参考： </p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之对象-Part4是否还活着？</title>
    <url>/iBlogWebsite/2018/09/19/2018/2018-09-19-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part4%E6%98%AF%E5%90%A6%E8%BF%98%E6%B4%BB%E7%9D%80%EF%BC%9F/</url>
    <content><![CDATA[<p>这篇主要解决一个问题：怎样确定对象是否还“活着”？《深入理解Java虚拟机》中给出了两种方式：<strong>引用计数算法和可达性分析算法。</strong></p>
<p>引用计数算法是给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。客观地说，引用计数算法实现简单，判定效率也很高，也有一些著名的应用案例。但是主流的Java虚拟机没有选用引用计数算法来管理内存，<strong>其中最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p>
<p><strong>在主流的商用程序语言（Java、C#）的主流实现中，都是通过可达性分析来判定对象是否存活的。</strong> 这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。如下图所示，对象Object 5、Object 6、Object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/jvm-object-accessibility-analysis.png?raw=true" alt="jvm-object-accessibility-analysis"></p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<blockquote>
<p>虚拟机栈（栈帧中的本地变量表）中引用的对象。<br>方法区中类静态属性引用的对象。<br>方法区中常量引用的对象。<br>本地方法栈中JNI（即一般说的Native方法）引用的对象。</p>
</blockquote>
<hr>
<p>参考： </p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之GC-Part1收集算法</title>
    <url>/iBlogWebsite/2018/09/25/2018/2018-09-25-JVM%E7%B3%BB%E5%88%97%E4%B9%8BGC-Part1%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>下面介绍4种收集算法，分别是标记-清除算法、复制算法、标记-整理算法、分代收集算法。这里更多的是偏思想和算法的，理论性稍强。</p>
<h1 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h1><p>该算法分为 “标记” 和 “清除” 两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。后续的收集算法都是基于这种思路并对其不足进行改进而得到的。</p>
<p>它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，<strong>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</strong></p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-gc-mark-clear.png?raw=true" alt="jvm-gc-mark-clear"></p>
<h1 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a>2. 复制算法</h1><p>为了解决效率问题，复制算法应运而生，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p>不过这种算法的代价是将内存缩小为原来的一般，未免太高了一点。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-gc-copy.png?raw=true" alt="jvm-gc-copy"></p>
<span id="more"></span>

<p><strong>现在的商业虚拟机都采用这种收集算法来回收新生代</strong>，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
<p>Hotspot虚拟机默认Eden:Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80% + 10%），只有10%的内存会被 “浪费”。当然98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。</p>
<p>内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块Survivor空间没有足够存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>
<h1 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3. 标记-整理算法"></a>3. 标记-整理算法</h1><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，标记-整理算法应运而生，标记过程仍然与标记-清除算法一样，但不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-gc-mark-sort-out.png?raw=true" alt="jvm-gc-mark-sort-out"></p>
<h1 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h1><p>当前商业虚拟机的垃圾收集都采用分代收集算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用 <strong>[复制算法]</strong> ，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 <strong>[标记-清除]</strong> 或者 <strong>[标记-整理]</strong> 算法来进行回收。</p>
<hr>
<p>参考： </p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之泛型</title>
    <url>/iBlogWebsite/2018/09/20/2018/2018-09-20-Java%E4%B9%8B%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>“泛型”这个术语的意思是：“适用于许多许多的类型”，泛型在编程语言中出现时，其最初的目的是希望类或方法能够具备最广泛的表达能力。如何做到这一点呢，正是通过解耦类或方法与所使用的类型之间的约束。而落实到Java中的泛型并没有这么高的最求，因为Java中的泛型在其他编程语言看来（例如C++）是一种“伪泛型”，在Java中，泛型是这门语言首次发布大约10年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。而这一切都是由于Java设计者在设计1.0版本时所表现出来的短视造成的。</p>
<p>了解了这些背景之后，再看看Java中没有泛型之前，从集合中读取到的每一个对象都必须经过转换，如果有人不小心插入了类型错误的对象，在运行时的转换处理就会出错。有了泛型之后，可以告诉编译器每个集合中接受哪些对象类型。编译器自动地为你的插入进行转换，并在编译时告知是否插入了类型错误的对象。JDK1.5发行版本增加了泛型，主要用于解决集合框架的安全问题。<strong>泛型是一个类型安全机制，将运行时期出现的ClassCastException问题转移到编译时期，避免了强制转换的麻烦。</strong></p>
<h1 id="1-原始类型和泛型类型"><a href="#1-原始类型和泛型类型" class="headerlink" title="1. 原始类型和泛型类型"></a>1. 原始类型和泛型类型</h1><p>你需要知道怎么区分原始类型和泛型变量的类型：</p>
<ul>
<li>在调用泛型方法的时候，可以指定泛型，也可以不指定泛型。</li>
<li>在不指定泛型的情况下，泛型变量的类型为该方法中几种类型的同一个父类的最小级，直到Object。</li>
<li>在指定泛型的情况下，该方法中的几种类型必须是该泛型实例类型或者其子类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.test.basic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by leeeyou on 2017/4/14.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> TestGeneric1.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型</span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">f</span> <span class="operator">=</span> TestGeneric1.add(<span class="number">1</span>, <span class="number">1.2</span>);<span class="comment">//这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> TestGeneric1.add(<span class="number">1</span>, <span class="string">&quot;asd&quot;</span>);<span class="comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> TestGeneric1.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//指定了Integer，所以只能为Integer类型或者其子类</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> TestGeneric1.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>);<span class="comment">//编译错误，指定了Integer，不能为Float</span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">c</span> <span class="operator">=</span> TestGeneric1.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">add</span><span class="params">(T x, T y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-Java中泛型的特点"><a href="#2-Java中泛型的特点" class="headerlink" title="2. Java中泛型的特点"></a>2. Java中泛型的特点</h1><h2 id="2-1-擦除机制"><a href="#2-1-擦除机制" class="headerlink" title="2.1. 擦除机制"></a>2.1. 擦除机制</h2><p>Java中的泛型 <strong>基本上都是在编译器这个层次来实现的，</strong> 在生成的Java字节码中是不包含泛型的类型信息，使用泛型时加上的类型参数会在编译期间去掉，这个过程就称为类型擦除。</p>
<p>擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入Java语言。擦除使得现有的非泛型客户端代码能够在不改变的情况下继续使用，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会突然间破坏所有现有的代码。</p>
<p>而擦除的代价是显著的，泛型不能用于显示地引用运行时类型的操作之中，例如转型、instanceOf操作和new表达式。因为所有关于参数的类型信息都丢失了，作为开发人员我们需要提醒自己，你只是看起来好像拥有有关参数的类型信息而已。</p>
<p>擦除的整个过程也比较容易理解：首先找到用来替换类型参数的原始类型，这个具体类不指明则默认Object，如果指定了参数类型的上界，那么就使用这个上界来替换类型参数。同时去掉类型声明，即去掉&lt;&gt;的内容，比如T get()方法声明就变成Object get()，List&lt; String &gt;就变成了List。</p>
<h2 id="2-2-不可具体化的类型"><a href="#2-2-不可具体化的类型" class="headerlink" title="2.2. 不可具体化的类型"></a>2.2. 不可具体化的类型</h2><p>运行时包含的信息比它的编译时包含的信息更少。</p>
<h2 id="2-3-通配符"><a href="#2-3-通配符" class="headerlink" title="2.3. 通配符"></a>2.3. 通配符</h2><p>类型通配符一般是使用 ? 代替具体的类型实参，<strong>注意此处是类型实参，而不是类型形参</strong>。</p>
<h3 id="2-3-1-有界通配符"><a href="#2-3-1-有界通配符" class="headerlink" title="2.3.1. 有界通配符"></a>2.3.1. 有界通配符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testLowerBoundsWildcards</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;? <span class="built_in">super</span> Apple&gt; appleList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testUpperBoundsWildcards</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Apple</span>&gt; appleList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有界通配符描述的是<strong>引用了明确的类型</strong>，并不是意味着这个appleList将持有任何类型的Apple，它意味着“appleList引用某种还没有指定具体类型的Apple”。</p>
<h4 id="2-3-1-1-上界通配符"><a href="#2-3-1-1-上界通配符" class="headerlink" title="2.3.1.1. 上界通配符"></a>2.3.1.1. 上界通配符</h4><p>&lt;? extends T&gt; 表示包括T在内的任何T的子类。如下关系图所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/java-generic-extend.png?raw=true" alt="java-generic-extend"></p>
<p><em>List&lt;? extends Apple&gt; appleList;</em> 这句中的appleList能接收红色区域描述的<strong>任意类型中的（某一种）水果列表</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    List&lt;RedApple&gt; redAppleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    redAppleList.add(<span class="keyword">new</span> <span class="title class_">RedApple</span>(<span class="string">&quot;红苹果1&quot;</span>));</span><br><span class="line">    redAppleList.add(<span class="keyword">new</span> <span class="title class_">RedApple</span>(<span class="string">&quot;红苹果2&quot;</span>));</span><br><span class="line">    redAppleList.add(<span class="keyword">new</span> <span class="title class_">RedApple</span>(<span class="string">&quot;红苹果3&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        List&lt;Apple&gt; appleList = redAppleList; //error，这里明确规定要求是Apple类型，没有灵活性可言。？没有继承关系可言</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Apple</span>&gt; appleList = redAppleList;<span class="comment">//利用通配符的灵活性，可以成功将 红苹果列表 赋值给 苹果列表</span></span><br><span class="line">    <span class="keyword">for</span> (Fruit fruit : appleList) &#123;</span><br><span class="line">        System.out.println(fruit.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    List&lt;GreenApple&gt; greenApples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    greenApples.add(<span class="keyword">new</span> <span class="title class_">GreenApple</span>(<span class="string">&quot;绿苹果1&quot;</span>));</span><br><span class="line">    greenApples.add(<span class="keyword">new</span> <span class="title class_">GreenApple</span>(<span class="string">&quot;绿苹果2&quot;</span>));</span><br><span class="line">    greenApples.add(<span class="keyword">new</span> <span class="title class_">GreenApple</span>(<span class="string">&quot;绿苹果3&quot;</span>));</span><br><span class="line">    greenApples.add(<span class="keyword">new</span> <span class="title class_">GreenApple</span>(<span class="string">&quot;绿苹果4&quot;</span>));</span><br><span class="line">    appleList = greenApples;<span class="comment">//利用通配符，appleList 灵活的接收了 红苹果列表 和 绿苹果列表</span></span><br><span class="line">    <span class="keyword">for</span> (Fruit fruit : appleList) &#123;</span><br><span class="line">        System.out.println(fruit.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-2-下界通配符"><a href="#2-3-1-2-下界通配符" class="headerlink" title="2.3.1.2. 下界通配符"></a>2.3.1.2. 下界通配符</h4><p>&lt;? super T&gt; 表示包括T在内的任何T的父类。如下关系图所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/java-generic-super.png?raw=true" alt="java-generic-super"></p>
<p><em>List&lt;? extends Apple&gt; appleList;</em> 这句中的appleList就能接收红色区域描述的<strong>任意类型中的（某一种）水果列表</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    List&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;苹果1&quot;</span>));</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;苹果2&quot;</span>));</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;苹果3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;? <span class="built_in">super</span> Apple&gt; appleList = apples;</span><br><span class="line">    <span class="keyword">for</span> (Object object : appleList) &#123;</span><br><span class="line">        System.out.println(((Apple) object).getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    List&lt;Fruit&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    fruits.add(<span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;水果1&quot;</span>));</span><br><span class="line">    fruits.add(<span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;水果2&quot;</span>));</span><br><span class="line">    fruits.add(<span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;水果3&quot;</span>));</span><br><span class="line">    appleList = fruits;</span><br><span class="line">    <span class="keyword">for</span> (Object object : appleList) &#123;</span><br><span class="line">        System.out.println(((Fruit) object).getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    List&lt;RedApple&gt; redApples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    redApples.add(<span class="keyword">new</span> <span class="title class_">RedApple</span>(<span class="string">&quot;红苹果1&quot;</span>));</span><br><span class="line">    redApples.add(<span class="keyword">new</span> <span class="title class_">RedApple</span>(<span class="string">&quot;红苹果2&quot;</span>));</span><br><span class="line">    redApples.add(<span class="keyword">new</span> <span class="title class_">RedApple</span>(<span class="string">&quot;红苹果3&quot;</span>));</span><br><span class="line"><span class="comment">//        appleList = redApples;//error</span></span><br></pre></td></tr></table></figure>

<p>有界通配符让Java不同泛型之间的转换更容易了，但这样的转换带来的副作用就是容器的部分功能失效。其直观的影响就是：</p>
<ul>
<li>上界&lt;? extends Apple&gt;：不能往里存，只能往外取。<ul>
<li>原因是编译器只知道容器内是Apple或者它的派生类，但具体是什么类型不知道，可能是红苹果、绿苹果、蛇果、小苹果。反过来想如果编译器让通过编译，那么取出来的类型到底是哪个具体种类的苹果呢？不得而知。所以这里不允许往里存。</li>
</ul>
</li>
<li>下界&lt;? super Apple&gt;：不影响往里存，但往外取只能放在Object对象里。<ul>
<li>原因是下界规定了元素最小粒度的下限（这里最少是一个苹果），实际上是放松了容器元素的类型控制。既然元素是Apple的基类，那往里存粒度比Apple小的都可以。由于擦除的特性，元素的类型信息全部丢失，只能用Object对象来接收它。</li>
</ul>
</li>
</ul>
<h4 id="2-3-1-3-PECS原则"><a href="#2-3-1-3-PECS原则" class="headerlink" title="2.3.1.3. PECS原则"></a>2.3.1.3. PECS原则</h4><p>如果参数化类型表示一个生产者T(Producer)，即你想从列表中 <strong>读取</strong> T类型的元素，就使用&lt;? extends T&gt;，比如List&lt;? extends Apple&gt;，因此你不能往该列表中添加任何元素。</p>
<p>如果参数化类型表示一个消费者(Consumer)，即你想把T类型的元素 <strong>添加</strong> 到列表中，则使用&lt;? super T&gt;，比如List&lt;? super Apple&gt;，因此你不能保证从中读取到的元素的类型。</p>
<p><strong>这一点对于设计出优秀强大的泛型代码是一个不错的原则！</strong> 参考java.util.Collections里的copy方法，我们可以从Java开发团队的代码中获得到一些启发，copy方法中使用到了PECS原则，实现了对参数的保护。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copies all of the elements from one list into another.  After the</span></span><br><span class="line"><span class="comment">* operation, the index of each copied element in the destination list</span></span><br><span class="line"><span class="comment">* will be identical to its index in the source list.  The destination</span></span><br><span class="line"><span class="comment">* list must be at least as long as the source list.  If it is longer, the</span></span><br><span class="line"><span class="comment">* remaining elements in the destination list are unaffected. &lt;p&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This method runs in linear time.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  &lt;T&gt; the class of the objects in the lists</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  dest The destination list.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  src The source list.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IndexOutOfBoundsException if the destination list is too small</span></span><br><span class="line"><span class="comment">*         to contain the entire source List.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> UnsupportedOperationException if the destination list&#x27;s</span></span><br><span class="line"><span class="comment">*         list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">srcSize</span> <span class="operator">=</span> src.size();</span><br><span class="line">    <span class="keyword">if</span> (srcSize &gt; dest.size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Source does not fit in dest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srcSize &lt; COPY_THRESHOLD ||</span><br><span class="line">        (src <span class="keyword">instanceof</span> RandomAccess &amp;&amp; dest <span class="keyword">instanceof</span> RandomAccess)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++)</span><br><span class="line">            dest.set(i, src.get(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListIterator&lt;? <span class="built_in">super</span> T&gt; di=dest.listIterator();</span><br><span class="line">        ListIterator&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; si=src.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++) &#123;</span><br><span class="line">            di.next();</span><br><span class="line">            di.set(si.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-无界通配符"><a href="#2-3-2-无界通配符" class="headerlink" title="2.3.2. 无界通配符 ?"></a>2.3.2. 无界通配符 ?</h3><p>初看起来好像 ? 和 Object 的区别不大（实际情况也是会被擦除为Object），但是如果你声明List&lt;?&gt;，那么将不可以插入任何值（除了null，但是这个没有什么意义）。<strong>这里的 ? 是告诉编译器，我不知道或者不关心将会接受什么类型，但是请使用Java泛型机制来处理它。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou.test.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by leeeyou on 2017/4/14.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;?&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        data.add(<span class="string">&quot;&quot;</span>);<span class="comment">//编译报错</span></span><br><span class="line">        data.add(<span class="literal">null</span>);<span class="comment">//编译通过</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Object&gt; objList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        objList = stringList;<span class="comment">//编译报错</span></span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        resultList = stringList;<span class="comment">////编译通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List&lt;String&gt;能否转为List&lt;Object&gt;：不能，关键原因在于擦除，由于List&lt;Object&gt;中的类都是被Object替代，而List&lt;String&gt;中均被String替换。理解了上面的规则之后，就可以很容易的修正实例分析中给出的代码了。只需要把List&lt;Object&gt;改成List&lt;?&gt;即可。List&lt;String&gt;是List&lt;?&gt;的子类型，因此传递参数时不会发生错误。<strong>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</strong></p>
<p>无界通配符的一个重要作用就是当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by leeeyou on 2018/8/24.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnboundedWildcard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map map1;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;?, ?&gt; map2;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, ?&gt; map3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assign1</span><span class="params">(Map map)</span> &#123;</span><br><span class="line">        map1 = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assign2</span><span class="params">(Map&lt;?, ?&gt; map)</span> &#123;</span><br><span class="line">        map2 = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assign3</span><span class="params">(Map&lt;String, ?&gt; map)</span> &#123;</span><br><span class="line">        map3 = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">        assign2(<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">        assign3(<span class="keyword">new</span> <span class="title class_">HashMap</span>());<span class="comment">//Unchecked assignment: &#x27;java.util.HashMap&#x27; to &#x27;java.util.Map&lt;java.lang.String,?&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">        assign1(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-泛型中参数化类型为什么不考虑继承关系"><a href="#2-3-3-泛型中参数化类型为什么不考虑继承关系" class="headerlink" title="2.3.3. 泛型中参数化类型为什么不考虑继承关系"></a>2.3.3. 泛型中参数化类型为什么不考虑继承关系</h3><p>先看下面两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();<span class="comment">//编译错误</span></span><br><span class="line">ArrayList&lt;Object&gt; arrayList1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<p>我们先看第一种情况，将第一种情况拓展成下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; arrayList1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();  </span><br><span class="line">arrayList1.add(<span class="keyword">new</span> <span class="title class_">Object</span>());  </span><br><span class="line">arrayList1.add(<span class="keyword">new</span> <span class="title class_">Object</span>());  </span><br><span class="line">ArrayList&lt;String&gt; arrayList2=arrayList1;<span class="comment">//编译错误  </span></span><br></pre></td></tr></table></figure>

<p>实际上在第4行代码的时候，就会有编译错误。现在我们先假设它编译没错，当我们使用arrayList2引用用get()方法取值的时候，返回的都是String类型的对象（上面提到了类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了Object类型的对象，这样就会发生ClassCastException。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。</p>
<p>再看第二种情况，将第二种情况拓展成下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">arrayList1.add(<span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line">arrayList1.add(<span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line">ArrayList&lt;Object&gt; arrayList2=arrayList1;<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<p>这样的情况比第一种情况看上去似乎好些，最起码在我们用arrayList2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是这样做有什么意义？泛型出现的原因就是为了解决类型转换的问题，将类型错误的检测移入到编译器。我们使用了泛型，到头来还是要自己强转，违背了泛型设计的初衷，所以JVM不允许这么干。另外你如果又用arrayList2往里面add()新的对象，那等到取得时候，编译器怎么知道取出来的到底是String类型的，还是Object类型的呢？<strong>要格外注意，泛型中的引用传递的问题。</strong></p>
<hr>
<p>参考：</p>
<ol>
<li><a href="http://blog.csdn.net/lonelyroamer/article/details/7868820">java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></li>
<li><a href="https://book.douban.com/subject/2130190/">Java编程思想 （第4版）</a></li>
<li><a href="https://book.douban.com/subject/3360807/">Effective java 中文版（第2版）</a></li>
<li><a href="https://blog.csdn.net/hello_worldee/article/details/77934244">Java语法–通配符的上界通配符和下界通配符</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之GC-Part2收集器</title>
    <url>/iBlogWebsite/2018/09/25/2018/2018-09-25-JVM%E7%B3%BB%E5%88%97%E4%B9%8BGC-Part2%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7中作用于不同分代的收集器，如果两个收集器之间存在连线，就说明他们可以搭配使用。虚拟机所在的区域，则表示它是属于新生代收集器还是老年代收集器。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-gc-garbage-collector.png?raw=true" alt="jvm-gc-garbage-collector"></p>
<p>虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要更多解释就能证明：如果有一个放之四海皆准、任何场景下都适用的完美收集器存在，那么Hotspot虚拟机就没有必要实现那么多不同的收集器了。</p>
<h1 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h1><p>Serial 收集器是最基本、发展历史最悠久的收集器。<strong>这个收集器是一个单线程的收集器，</strong> 但它的单线程意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，<strong>更重要的是它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</strong> “Stop the world” 这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常的线程全部停掉，这对很多应用来说都是难以接受的。</p>
<p>从JDK1.3开始一直到JDK1.7，Hotspot虚拟机开发团队为消除或者减少工作线程因内存回收而导致停顿的努力一直在进行着，从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）乃至GC收集器的最前沿成果Garbage First（G1）收集器，我们看到一个越来越优秀、也越来越复杂的收集器出现，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除。寻找更优秀的垃圾收集器的工作仍在继续！</p>
<p>尽管如此，Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器。它也有着由于其他收集器的地方：简单而高效，对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。</p>
<span id="more"></span>

<h1 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h1><p><strong>ParNew其实就是Serial的多线程版本，</strong> 除了使用多条线程进行垃圾收集之外，其他行为包括Serial收集器可用的所有控制参数、收集算法、Stop the world、对象分配规则、回收策略都与Serial收集器完全一样。</p>
<p>ParNew收集器除了多线程收集之外，其他与Serial收集器并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有个与性能无关但很重要的原因，除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p>
<p>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证可以超越Serial收集器。当然，随着可以使用的CPU的数量的增多，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p>
<h1 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h1><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。</p>
<p><strong>Parallel Scavenge收集器的目标是达到一个可控制的吞吐量，</strong> 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量= 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<p>停顿时间越短就越合适需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>由于与吞吐量关系密切，Parallel Scavenge也经常成为 “吞吐量优先” 收集器。它提供了两个参数用于精确控制吞吐量，分别是最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 以及吞吐量大小 -XX:GCTimeRatio 。除了上述两个参数之外，Parallel Scavenge还有一个参数 -XX:UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p>
<h1 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h1><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要有两大用途：一种用途是在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后背预案，在并发收集发生Concurrent Mode Failure时使用。</p>
<h1 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h1><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。这个收集器在JDK1.6中才开始提供，在此之前，新生代的Parallel Scavenge一直处于比较尴尬的状态，原因是如果新生代选择了Parallel Scavenge，老年代除了Serial Old之外别无选择。</p>
<p>由于Serial Old收集器在服务端应用性能上的拖累，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。</p>
<p>直到Parallel Old出现后，“吞吐量优先” 收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p>
<h1 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h1><p>CMS（Concurrent Mark Sweep）是一种<strong>以获取最短回收停顿时间为目标的收集器，</strong> 目前很大一部分的Java应用几种在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>CMS基于标记-清除算法时间，整个过程分为4个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>其中初始标记、重新标记这两个步骤仍然需要 “Stop The World” 。初始化标记仅仅是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，但CMS还远远达不到完美的程度，主要有以下3个明显缺点：</p>
<ul>
<li>CMS收集器对CPU资源非常敏感。</li>
<li>CMS无法处理浮动垃圾（Floating Garbage），可能出现 “Concurrent Mode Failure” 失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待一下次GC时再清理掉。</li>
<li>CMS基于标记-清除算法实现，可能会产生大量碎片空间。</li>
</ul>
<h1 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h1><p>G1是一款面向服务端应用的垃圾收集器，Hotspot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p>
<ul>
<li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1仍然可以通过并发的方式让Java程序继续执行。</li>
<li>分代收集</li>
<li>空间整合</li>
<li>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ul>
<p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而Gl不再是这样。使用G1时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区城(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>
<p>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用,虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加人Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
<p>G1收集器的运作大致分为以下4个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>同CMS运作过程相似，这里不再细述。由于目前G1成熟版本的发布时间还很短，G1收集器几乎可以说还没有经过实际应用的考验，网络上关于G1收集器的性能测试也非常贫乏，到目前为止，还没有搜索到有关的生产环境下的性能测试报告。强调 “生产环境下的测试报告” 是因为对于垃圾收集器来说，仅仅通过简单的Java代码写个Microbenchmark程序来创建、移除Java对象，再用-XX:PrintGCDetails等参数来查看GC日志是很难做到准确衡量其性能的。</p>
<hr>
<p>参考： </p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之GC-Part4内存分配与回收策略</title>
    <url>/iBlogWebsite/2018/09/26/2018/2018-09-26-JVM%E7%B3%BB%E5%88%97%E4%B9%8BGC-Part4%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>Java技术体系中所倡导的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。</p>
<p>对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先的TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p>
<h1 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1. 对象优先在Eden分配"></a>1. 对象优先在Eden分配</h1><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<p>虚拟机提供了-XX:PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。在实际应用中，内存回收日志一般是打印到文件后通过日志工具进行分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * -Xms20M -Xmx20M -Xmn10M 限制了Java堆大小为20M，不可扩展，其中10M分配给新生代，剩下的10M分配给老年代。</span></span><br><span class="line"><span class="comment">     * -XX:SurvivorRatio=8决定了新生代中Eden区与一个Survivor区的空间比例是8:1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];  <span class="comment">// 出现一次Minor GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>我的电脑是64位系统，JVM默认跑的是Server模式，可通过java -version命令查看，目前64位只支持server模式；在32位的虚拟机在目录JAVA_HOME/jre/lib/i386/jvm.cfg 还是可以修改Clinet还是Server模式的 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\Project\IntellJ2\DemoIO&gt;java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_144&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_144</span>-b01)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(build <span class="number">25.144</span>-b01, mixed mode)</span></span><br></pre></td></tr></table></figure>

<p>运行时，设置JVM参数可以参考下图：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-gc-priority-allocation-of-objects-to-eden.png?raw=true" alt="jvm-gc-priority-allocation-of-objects-to-eden"></p>
<p>运行结果如下，打印了详细的GC信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0.125</span>: [GC (Allocation Failure) [PSYoungGen: 6303K-&gt;808K(9216K)] 6303K-&gt;4912K(19456K), <span class="number">0.0034768</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 7189K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">77</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffc3b610</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">78</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffeca020</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 10240K, used 4104K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space 10240K, <span class="number">40</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff002020</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used 3468K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>Allocation Failure表示向young generation（Eden）给新对象申请空间，但是young generation（Eden）剩余的合适空间不够所需的大小导致的Minor GC，采用的是Parallel Scavenge收集器。这次GC发生的原因是给allocation4分配内存的时候，发现Eden已被占用了6MB，剩余空间不足导致。GC期间虚拟机又发现已有的3个2MB大小的独享无法全部放入Survivor空间，所以只好通过分配担保机制提前转移到老年代去。</p>
<h1 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h1><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来 “安置” 它们。</p>
<p>虚拟机提供了一个 -XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGC2</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testPretenureSizeThreshold();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">     * PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPretenureSizeThreshold</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation;</span><br><span class="line">        allocation = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];  <span class="comment">//直接分配在老年代中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码跑在我的机器上，默认是没有任何作用的。因为我的JVM默认采用Parallel Scavenge收集器，allocation还是被分配到了Eden。GC日志如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 6467K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">78</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffc50fb0</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"> ParOldGen       total 10240K, used 0K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space 10240K, <span class="number">0</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used 3471K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>但是可以更换收集器，配置如下参数，就可以使用ParNew收集器，而禁止Parallel Scavenge收集器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms20M</span><br><span class="line">-Xmx20M</span><br><span class="line">-Xmn10M</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">3145728</span></span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:-UseParallelGC</span><br></pre></td></tr></table></figure>

<p>GC日志如下所示，可以看到allocation对象被直接分配到了老年代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> par <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 2371K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">28</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fee50fa0</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">40</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffa00010</span>, <span class="number">0x00000000ffa00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3468K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release</span><br></pre></td></tr></table></figure>

<h1 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h1><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每 “熬过” 一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGC3</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testTenuringThreshold();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment">     * -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTenuringThreshold</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];  <span class="comment">// 什么时候进入老年代决定于XX:MaxTenuringThreshold设置</span></span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="literal">null</span>;</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GC日志如下所示，可以看到allocation1对象需要256KB内存，Survivor空间可以容纳，但-XX:MaxTenuringThreshold=1时，allocation1在第二次发生GC时直接进入老年代，新生代已使用的内存GC后非常干净地变成0KB ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew</span><br><span class="line">Desired survivor size <span class="number">524288</span> bytes, <span class="keyword">new</span> <span class="title class_">threshold</span> <span class="number">1</span> (max <span class="number">1</span>)</span><br><span class="line">- age   <span class="number">1</span>:    <span class="number">1005424</span> bytes,    <span class="number">1005424</span> total</span><br><span class="line">: 6559K-&gt;1005K(9216K), <span class="number">0.0018478</span> secs] 6559K-&gt;5101K(19456K), <span class="number">0.0018747</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [ParNew</span><br><span class="line">Desired survivor size <span class="number">524288</span> bytes, <span class="keyword">new</span> <span class="title class_">threshold</span> <span class="number">1</span> (max <span class="number">1</span>)</span><br><span class="line">: 5101K-&gt;0K(9216K), <span class="number">0.0012918</span> secs] 9197K-&gt;5031K(19456K), <span class="number">0.0013053</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> par <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 4178K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">51</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff014930</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 5031K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">49</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffae9c18</span>, <span class="number">0x00000000ffae9e00</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3471K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release</span><br></pre></td></tr></table></figure>

<p>测试上面的场景，注意使用ParNew收集器，配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms20M</span><br><span class="line">-Xmx20M</span><br><span class="line">-Xmn10M</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">1</span></span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:-UseParallelGC</span><br></pre></td></tr></table></figure>

<p>当-XX:MaxTenuringThreshold=15时，GC之后，新生代仍然有388KB被占用，GC日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew</span><br><span class="line">Desired survivor size <span class="number">524288</span> bytes, <span class="keyword">new</span> <span class="title class_">threshold</span> <span class="number">1</span> (max <span class="number">15</span>)</span><br><span class="line">- age   <span class="number">1</span>:     <span class="number">918424</span> bytes,     <span class="number">918424</span> total</span><br><span class="line">: 6559K-&gt;914K(9216K), <span class="number">0.0017073</span> secs] 6559K-&gt;5010K(19456K), <span class="number">0.0017345</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [ParNew</span><br><span class="line">Desired survivor size <span class="number">524288</span> bytes, <span class="keyword">new</span> <span class="title class_">threshold</span> <span class="number">15</span> (max <span class="number">15</span>)</span><br><span class="line">- age   <span class="number">1</span>:        <span class="number">488</span> bytes,        <span class="number">488</span> total</span><br><span class="line">: 5094K-&gt;388K(9216K), <span class="number">0.0005842</span> secs] 9190K-&gt;5398K(19456K), <span class="number">0.0005957</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> par <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 4622K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">51</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff0226d8</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,  <span class="number">37</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff4611d0</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 5009K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">48</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffae4760</span>, <span class="number">0x00000000ffae4800</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3425K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 375K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release</span><br></pre></td></tr></table></figure>

<h1 id="4-动态对象年龄绑定"><a href="#4-动态对象年龄绑定" class="headerlink" title="4. 动态对象年龄绑定"></a>4. 动态对象年龄绑定</h1><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h1 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h1><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p>
<p>“冒险” 指冒了什么风险？前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p>
<p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePormotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>
<hr>
<p>参考： </p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之对象-Part3定位</title>
    <url>/iBlogWebsite/2018/09/18/2018/2018-09-18-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part3%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<p>Java程序通过栈上的reference数据来操作堆上的具体对象，由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。</p>
<p>句柄方式是通过在Java堆中划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。句柄的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（GC时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。如下图所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/jvm-object-access-object-by-handle.jpg?raw=true" alt="jvm-object-access-object-by-handle"></p>
<p>直接指针方式，reference中存储的直接就是对象地址，所以虚拟机设计者必须考虑如何放置访问类型数据的相关信息。直接指针的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多也是一项非常可观的执行成本。Hotspot虚拟机采用的是第二种方式进行对象访问，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。如下图所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/jvm-object-direct-pointer-access-to-objects.jpg?raw=true" alt="jvm-object-direct-pointer-access-to-objects"></p>
<hr>
<p>参考： </p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之GC-Part3GC分类</title>
    <url>/iBlogWebsite/2018/09/26/2018/2018-09-26-JVM%E7%B3%BB%E5%88%97%E4%B9%8BGC-Part3GC%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>这里谈论的GC分类主要是理清楚在各分代中会发生什么GC以及其作用是什么。</p>
<p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<p>我们可以认为Major GC == Full GC，它们是一个概念，就是针对 <strong>[老年代/永久代]</strong> 进行GC。因为取名叫Full就会让人疑惑，到底会不会先Minor GC。事实上Full GC本身不会先进行Minor GC，我们可以配置，让Full GC之前先进行一次Minor GC，因为老年代很多对象都会引用到新生代的对象，先进行一次Minor GC可以提高老年代GC的速度。比如老年代使用CMS时，设置CMSScavengeBeforeRemark优化，让CMS remark之前先进行一次Minor GC。</p>
<p>弄清楚了Full GC本意单纯就是针对老年代了之后，我们再进一步深入理解Full GC的含义。上篇文章介绍过，因为CMS主要可以分为initial mark(stop the world), concurrent mark, remark(stop the world), concurrent sweep几个阶段，其中initial mark和remark会stop the world。Full GC的次数和时间等同于老年代GC时 stop the world的次数和时间。</p>
<hr>
<p>参考： </p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
<li><a href="https://blog.csdn.net/ITer_ZC/article/details/41825395">聊聊JVM（四）深入理解Major GC, Full GC, CMS</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之类加载-Part2类加载机制</title>
    <url>/iBlogWebsite/2018/10/09/2018/2018-10-09-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD-Part2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-类加载的时机"><a href="#1-类加载的时机" class="headerlink" title="1. 类加载的时机"></a>1. 类加载的时机</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initalization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-class-loader-class-lifecycler.png?raw=true" alt="jvm-class-loader-class-lifecycler"></p>
<p>加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，<strong>而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。</strong></p>
<p>什么情况下需要开始类加载过程的第一个阶段：[加载]吗？Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”(而加载、验证、准备自然需要在此之前开始)：</p>
<ul>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：<strong>使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</strong></li>
<li>使用java.lang.reflect包的方法对类进行<strong>反射调用的时候</strong>，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ul>
<p><strong>对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这5中场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。</strong></p>
<span id="more"></span>

<h1 id="2-类加载的过程"><a href="#2-类加载的过程" class="headerlink" title="2. 类加载的过程"></a>2. 类加载的过程</h1><h2 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1. 加载"></a>2.1. 加载</h2><p>“加载”是“类加载（Class Loading）”过程的一个阶段，在加载阶段，虚拟机需要完成以下3件事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流 <strong>(org/fenixsoft/clazz/TestClass)</strong></li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</li>
</ul>
<h2 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2. 验证"></a>2.2. 验证</h2><p><strong>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。</strong> 不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。</p>
<h3 id="2-2-1-文件格式的验证"><a href="#2-2-1-文件格式的验证" class="headerlink" title="2.2.1. 文件格式的验证"></a>2.2.1. 文件格式的验证</h3><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。验证点大致有以下这些：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>
</ul>
<h3 id="2-2-2-元数据验证"><a href="#2-2-2-元数据验证" class="headerlink" title="2.2.2. 元数据验证"></a>2.2.2. 元数据验证</h3><p>对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。这个阶段可能包括的验证点如下：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）</li>
</ul>
<h3 id="2-2-3-字节码验证"><a href="#2-2-3-字节码验证" class="headerlink" title="2.2.3. 字节码验证"></a>2.2.3. 字节码验证</h3><p>该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</p>
<h3 id="2-2-4-符号引用验证"><a href="#2-2-4-符号引用验证" class="headerlink" title="2.2.4. 符号引用验证"></a>2.2.4. 符号引用验证</h3><p>这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。通常需要校验下列内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符号方法的字段描述符以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性是否可被当前类访问</li>
</ul>
<h2 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3. 准备"></a>2.3. 准备</h2><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值。</p>
<p>假设一个类变量的定义为：public static int value = 123;</p>
<p>那变量value在准备阶段过后的初始值是0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后存放于类构造器&lt;clinit&gt;()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。</p>
<p>基本数据类型的零值如下表：</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">零值</th>
<th align="center">数据类型</th>
<th align="center">零值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">0</td>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">(short)0</td>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">‘\u0000’</td>
<td align="center">reference</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">(byte)0</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>上面提到，在“通常情况”下初始值是零值，那相对的会有一些“特殊情况”：如果类字段的字段属性中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为：<br>public static final int value = 123;</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p>
<h2 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4. 解析"></a>2.4. 解析</h2><p><strong>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。</strong> 前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。</p>
<ul>
<li><p>符号引用（Symbolic Refrences）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>
</li>
<li><p>直接引用（Direct Refrences）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
</li>
</ul>
<p>对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池中的7种常量类型</p>
<ul>
<li>CONSTANT_Class_info</li>
<li>CONSTANT_Fieldref_info</li>
<li>CONSTANT_Methodref_info</li>
<li>CONSTANT_InterfaceMethodref_info</li>
<li>CONSTANT_MethodType_info</li>
<li>CONSTANT_MethodHandle_info</li>
<li>CONSTANT_InvokeDynamic_info</li>
</ul>
<p>对于后面3中，与JDK1.7新增的动态语言支持息息相关。</p>
<h2 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5. 初始化"></a>2.5. 初始化</h2><p>初始化是类加载过程的最后一步，到了此阶段才真正开始执行类中定义的Java程序代码。<strong>在准备阶段类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。</strong></p>
<p>这里简单说明下&lt;clinit&gt;()方法的执行规则:</p>
<p>1、&lt;clinit&gt;()方法是由编译器自动收集 <strong>类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，</strong> 编译器收集的顺序是由语句在源文件中 <strong>出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。</strong> </p>
<p>2、&lt;clinit&gt;()方法与实例构造器&lt;init&gt;()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法已经执行完毕。因此，在虚拟机中第一个被执行的&lt;clinit&gt;()方法的类肯定是java.lang.Object。</p>
<p>3、&lt;clinit&gt;()方法对于类或接口来说并不是必须的，<strong>如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。</strong></p>
<p>4、接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成&lt;clinit&gt;()方法。但是接口与类不同的是：执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。</p>
<p>5、虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p>
<p>思考下这段代码输出什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;	</span><br><span class="line">    <span class="keyword">static</span>&#123;		</span><br><span class="line">        a = <span class="number">2</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClinitTest</span>&#123;	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;		</span><br><span class="line">        System.out.println(Child.b);	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>思考下下面这段代码会输出什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleTon</span> <span class="variable">singleTon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleTon</span><span class="params">()</span> &#123;</span><br><span class="line">        count1++;</span><br><span class="line">        count2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SingleTon</span> <span class="variable">singleTon</span> <span class="operator">=</span> SingleTon.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;count1=&quot;</span> + singleTon.count1);</span><br><span class="line">        System.out.println(<span class="string">&quot;count2=&quot;</span> + singleTon.count2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，看完上面的知识，自己分析吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count1=1</span><br><span class="line">count2=0</span><br></pre></td></tr></table></figure>

<h1 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h1><p>虚拟机设计团队把类加载器阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，</strong> 否则即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p>这里所指的“相等”，<strong>包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。</strong> 如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果。</p>
<p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。</p>
<p>从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3中系统提供的类加载器。</p>
<ol>
<li><p>启动类加载器(Bootstrap ClassLoader)：这个类加载器负责将存放在&lt;JAVA_HOME&gt;\lib 目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且被虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</p>
</li>
<li><p>扩展类加载器(Extension ClassLoader)：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载&lt;JAVA_HOME&gt;\lib\ext 目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器(Application ClassLoader)：这个类加载器有sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。下图展示了类加载器的双亲委派模型（Parents Delegation Model）。</p>
</li>
</ol>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-class-loader-parental-delegation-model.png?raw=true" alt="jvm-class-loader-parental-delegation-model"></p>
<p>双亲委派模型的工作过程是：<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</strong></p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层级关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载起环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的化，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p>
<p>双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在java.lang.ClassLoader的loaderClass()方法之中，逻辑清晰易懂：<strong>先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，如父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是findClass的源码，最终调用native层的defineClass加载目标类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String var1) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class var2;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var2 = (Class)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">var1x</span> <span class="operator">=</span> var1.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                <span class="type">Resource</span> <span class="variable">var2</span> <span class="operator">=</span> URLClassLoader.<span class="built_in">this</span>.ucp.getResource(var1x, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (var2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> URLClassLoader.<span class="built_in">this</span>.defineClass(var1, var2);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var4) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(var1, var4);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="built_in">this</span>.acc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PrivilegedActionException var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (ClassNotFoundException)var4.getException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(var1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>参考： </p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
<li><a href="https://blog.csdn.net/ns_code/article/details/17881581">【深入Java虚拟机】之四：类加载机制</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之类加载-Part3字节码执行引擎</title>
    <url>/iBlogWebsite/2018/10/10/2018/2018-10-10-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD-Part3%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>在Java虚拟机规范中规定了字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观（Facade）。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。下面主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行。</p>
<h1 id="1-运行时栈帧结构"><a href="#1-运行时栈帧结构" class="headerlink" title="1. 运行时栈帧结构"></a>1. 运行时栈帧结构</h1><p>帧栈（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。帧栈存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p>
<p>在概念模型上，典型的栈帧结构如下图所示：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-class-loader-stack-frame.png?raw=true" alt="jvm-class-loader-stack-frame"></p>
<span id="more"></span>

<h2 id="1-1-局部变量表"><a href="#1-1-局部变量表" class="headerlink" title="1.1. 局部变量表"></a>1.1. 局部变量表</h2><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p>
<h2 id="1-2-操作数栈"><a href="#1-2-操作数栈" class="headerlink" title="1.2. 操作数栈"></a>1.2. 操作数栈</h2><p>操作数栈也常称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</p>
<h2 id="1-3-动态连接"><a href="#1-3-动态连接" class="headerlink" title="1.3. 动态连接"></a>1.3. 动态连接</h2><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。通过前面介绍，我们知道Class文件中的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p>
<h2 id="1-4-方法返回地址"><a href="#1-4-方法返回地址" class="headerlink" title="1.4. 方法返回地址"></a>1.4. 方法返回地址</h2><p>当一个方法开始执行后，只有两种方式可以退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。</p>
<p>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用throw字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口。一个方法使用异常完成出口的方法退出，是不会给它的上层调用者产生任何返回值的。</p>
<p>无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p>
<p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>
<h2 id="1-5-附加信息"><a href="#1-5-附加信息" class="headerlink" title="1.5. 附加信息"></a>1.5. 附加信息</h2><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现，在实际开发中，一般会把动态连接，方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</p>
<h1 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h1><p>方法调用并不等同于方法执行，<strong>方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法）</strong>，暂时还不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作，但前面已经讲过，Class文件的编译过程中不包含传统编译中的链接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。这个特性给Java带来了更强大的运动扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<h2 id="2-1-解析"><a href="#2-1-解析" class="headerlink" title="2.1. 解析"></a>2.1. 解析</h2><p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。</p>
<p>在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。</p>
<p>与之相应的是，在Java虚拟机里面提供了5条方法调用字节码指令，分别如下：</p>
<p>invokestatic: 调用静态方法。<br>invokespecial: 调用实例构造器&lt; init &gt;方法、私有方法和父类方法。<br>invokevirtual: 调用所有的虚方法。<br>invokeinterface: 调用接口方法，会在运行时再确定一个实现此接口的对象。<br>invokedynamic: 先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</p>
<p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以成为非虚方法，与之相反，其他方法成为虚方法（除去final方法，后文会提到）。</p>
<p>Java中的非虚方法除了使用invokestatic、invokespecial调用的方法之外还有一种，就是被final修饰的方法。虽然final方法是使用invokevirtual指令来调用的，但是由于它无法对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。在Java语言规范中明确说明了final方法是一种非虚方法。</p>
<p>解析调用一定是一个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派（Dispatch）调用则可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派。这两类分派方式的两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4中分派组合情况，下面我们再看看虚拟机中的方法分派是如何进行的。</p>
<h2 id="2-2-分派"><a href="#2-2-分派" class="headerlink" title="2.2. 分派"></a>2.2. 分派</h2><p>众所周知，Java是一门面向对象的程序语言，因为Java具备面向对象的3个基本特征：继承、封装和多态。本节讲解的分派调用过程将会揭示多态性特征的一些最基本的体现，如“重载”和“重写”在Java虚拟机之中是如何实现的，这里的实现当然不是语法上该如何写，我们关心的依然是虚拟机如何确定正确的目标方法。</p>
<h3 id="2-2-1-静态分派"><a href="#2-2-1-静态分派" class="headerlink" title="2.2.1. 静态分派"></a>2.2.1. 静态分派</h3><p>请先看一遍下面的代码，想想输出结果是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法静态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticDispatch</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Woman</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Human guy)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello,guy!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Man guy)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello,gentleman!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Woman guy)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello,lady!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">		<span class="type">Human</span> <span class="variable">woman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line">		<span class="type">StaticDispatch</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticDispatch</span>();</span><br><span class="line">		sr.sayHello(man);</span><br><span class="line">		sr.sayHello(woman);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码实际上是在考验读者对重载的理解程度，相信很多童鞋的答案会出乎意料。运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello,guy!</span><br><span class="line">hello,guy!</span><br></pre></td></tr></table></figure>

<p>为什么会选择执行参数类型为Human的重载呢？在解决这个问题之前，我们先按如下代码定义两个重要的概念。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br></pre></td></tr></table></figure>

<p>我们把上面代码中的“Human”称为变量的静态类型（Static Type），或者叫做外观类型（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实际类型变化</span></span><br><span class="line"><span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">man = <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态类型变化</span></span><br><span class="line">sr.sayHello((Man)man)</span><br><span class="line">sr.sayHello((Woman)man)</span><br></pre></td></tr></table></figure>

<p>解释了这两个概念，再回到上面的样例代码中。main()里面的两次sayHello()方法调用，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。代码中刻意地定义了两个静态类型相同但实际类型不同的变量，<strong>但虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的，因此在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main()方法里的两台invokevirtual指令的参数中。</strong></p>
<p><strong>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载</strong>。静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的。另外编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适的”版本。这种模糊的结论在由0和1构成的计算机世界中算是比较“稀罕”的事情，产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显示的静态类型，它的静态类型只能通过语言上的规则去理解和推断。下面的代码演示了何为“更加合适的”版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Overload</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello int&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Character arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Character&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">char</span> arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">char</span>... arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Serializable arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Serializable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        sayHello(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码运行后会输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello <span class="type">char</span></span><br></pre></td></tr></table></figure>

<p>这很好理解，’a’是一个char类型的数据，自然会寻找参数类型为char的重载方法，如果注释掉sayHello(char arg)方法，那输出会变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>这时发生了一次自动类型转换，’a’除了可以代表一个字符串，还可以代表数据97，因此参数类型为int的重载也是合适的。我们继续注释掉sayHello(int arg)方法，那输出会变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello <span class="type">long</span></span><br></pre></td></tr></table></figure>

<p>这时发生了两次自动类型转换，’a’转型为整数97之后，进一步转型为长整数97L，匹配了参数类型为long的重载。笔者在代码中没有写其他的类型如float、double等的重载，不过实际上自动类型还能继续发生多次，按照char-&gt;int-&gt;long-&gt;float-&gt;double的顺序转型进行匹配。但不会匹配到byte和short类型的重载，因此char到byte或short的转型是不安全的。我们继续注释掉sayHello(long arg)方法，那输出会变成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello Character</span><br></pre></td></tr></table></figure>

<p>这时发生一次自动装箱，‘a’ 被包装为它的封装类型java.lang.Character，所以匹配到了参数类型为Character的重载，继续注释掉sayHello(Character arg)方法，那输出会变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello Serializable</span><br></pre></td></tr></table></figure>

<p>这个输出可能会让人感觉摸不着头脑，一个字符或数字与序列化有什么关系？出现hello Serializable，是因为java.lang.Serializable是java.lang.Character类实现的一个接口，当自动装箱之后发现还是找不到装箱类，但是找到了装箱类实现了的接口类型，所以紧接着又发生一次自动转型。char可以转型为int，但是Character是绝对不会转型为Integer的，它只能安全地转型为它实现的接口或父类。Character还实现了另外一个接口java.lang.Comparable<Character>，如果同时出现两个参数分别为Serializable和Comparable<Character>的重载方法，那它们在此时的优先级是一样的。编译器无法确定要自动转型为哪种类型，会提示类型模糊，拒绝编译。程序必须在调用时显示地指定字面量的静态类型，如：sayHello((Comparable<Character>)’a’)，才能编译通过。下面继续注释掉sayHello(Serializable arg)方法，输出会变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello Object</span><br></pre></td></tr></table></figure>

<p>这时是char装箱后转型为父类了，如果有多个父类，那将在继承关系中从下往上开始搜索，越接近上层的优先级越低。即使方法调用传入的参数值为null时，这个规则仍然适用。我们把sayHello(Object arg)也注释掉，输出将会变为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello <span class="type">char</span> ...</span><br></pre></td></tr></table></figure>

<p>7个重载方法已经被注释得只剩一个了，可见变长参数的重载优先级是最低的，这时候字符’a’被当做了一个数组元素。笔者适用的是char类型的变长参数，读者在验证时还可以选择int类型、Character类型、Object类型等的变长参数重载来把上面的过程重新演示一遍。但要注意的是，有一些在单个参数中能独立的自动转型，如char转型为int，在变长参数中是不成立的。</p>
<p>上述代码演示了编译期间选择静态分配目标的过程，这个过程也是Java语言实现方法重载的本质。演示所用的这段程序属于很极端的例子，除了用作面试题为难求职者以外，在实际工作中几乎不可能有实际用途。这里拿来做演示仅仅是用于讲解重载时目标方法选择的过程。</p>
<p>另外还有一点读者可能比较容易混淆：笔者讲述的解析与分派这两者之间的关系并不是二选一的排他关系，他们是不同层次上去筛选、确定目标方法的过程。例如，前面说过，静态方法会在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的。</p>
<h3 id="2-2-2-动态分派"><a href="#2-2-2-动态分派" class="headerlink" title="2.2.2. 动态分派"></a>2.2.2. 动态分派</h3><p>了解了静态分派，我们接下来看一下动态分派的过程，它和多态性的另外一个重要体现————重写（Override）有着很密切的关联。请先看一遍下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法动态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicDispatch</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">		<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;man say hello&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Woman</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;woman say hello&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">		<span class="type">Human</span> <span class="variable">woman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line">		man.sayHello();</span><br><span class="line">		woman.sayHello();</span><br><span class="line">		man = <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line">		man.sayHello();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure>

<p>这个运行结果相信不会出乎任何人的意料，对于习惯了面向对象思维的Java程序员会觉得这是完全理所当然的。现在的问题还是和前面的一样，虚拟机是如何知道要调用哪个方法的？</p>
<p>显然这里不可能再根据静态类型来决定，因为静态类型同样都是Human的两个变量man和woman在调用sayHello()方法时执行了不同的行为，并且变量man在两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的实际类型不同，Java虚拟机是如何根据实际类型来分派方法执行版本的呢？我们使用javap命令输出这段代码的字节码，尝试从中寻找答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\Project\IntellJ2\DemoIO\src\dispatch&gt;javap -v DynamicDispatch.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Classfile</span> /D:/Project/IntellJ2/DemoIO/src/dispatch/DynamicDispatch.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2018</span>-<span class="number">11</span>-<span class="number">1</span>; size <span class="number">550</span> bytes</span><br><span class="line">  MD5 checksum cfa7c41119d8c82ca61562be4037dd16</span><br><span class="line">  Compiled from <span class="string">&quot;DynamicDispatch.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dispatch</span>.DynamicDispatch</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">8.</span>#<span class="number">22</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">23</span>            <span class="comment">// dispatch/DynamicDispatch$Man</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">2.</span>#<span class="number">22</span>         <span class="comment">// dispatch/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">24</span>            <span class="comment">// dispatch/DynamicDispatch$Woman</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">4.</span>#<span class="number">22</span>         <span class="comment">// dispatch/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">6</span> = Methodref          #<span class="number">12.</span>#<span class="number">25</span>        <span class="comment">// dispatch/DynamicDispatch$Human.sayHello:()V</span></span><br><span class="line">   #<span class="number">7</span> = Class              #<span class="number">26</span>            <span class="comment">// dispatch/DynamicDispatch</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">27</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">9</span> = Utf8               Woman</span><br><span class="line">  #<span class="number">10</span> = Utf8               InnerClasses</span><br><span class="line">  #<span class="number">11</span> = Utf8               Man</span><br><span class="line">  #<span class="number">12</span> = Class              #<span class="number">28</span>            <span class="comment">// dispatch/DynamicDispatch$Human</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               Human</span><br><span class="line">  #<span class="number">14</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">15</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">16</span> = Utf8               Code</span><br><span class="line">  #<span class="number">17</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">18</span> = Utf8               main</span><br><span class="line">  #<span class="number">19</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">20</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">21</span> = Utf8               DynamicDispatch.java</span><br><span class="line">  #<span class="number">22</span> = NameAndType        #<span class="number">14</span>:#<span class="number">15</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">23</span> = Utf8               dispatch/DynamicDispatch$Man</span><br><span class="line">  #<span class="number">24</span> = Utf8               dispatch/DynamicDispatch$Woman</span><br><span class="line">  #<span class="number">25</span> = NameAndType        #<span class="number">29</span>:#<span class="number">15</span>        <span class="comment">// sayHello:()V</span></span><br><span class="line">  #<span class="number">26</span> = Utf8               dispatch/DynamicDispatch</span><br><span class="line">  #<span class="number">27</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">28</span> = Utf8               dispatch/DynamicDispatch$Human</span><br><span class="line">  #<span class="number">29</span> = Utf8               sayHello</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> dispatch.DynamicDispatch();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class dispatch/DynamicDispatch$Man</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method dispatch/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class dispatch/DynamicDispatch$Woman</span></span><br><span class="line">        <span class="number">11</span>: dup</span><br><span class="line">        <span class="number">12</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method dispatch/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">15</span>: astore_2</span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method dispatch/DynamicDispatch$Human.sayHello:()V</span></span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method dispatch/DynamicDispatch$Human.sayHello:()V</span></span><br><span class="line">        <span class="number">24</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class dispatch/DynamicDispatch$Woman</span></span><br><span class="line">        <span class="number">27</span>: dup</span><br><span class="line">        <span class="number">28</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method dispatch/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">31</span>: astore_1</span><br><span class="line">        <span class="number">32</span>: aload_1</span><br><span class="line">        <span class="number">33</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method dispatch/DynamicDispatch$Human.sayHello:()V</span></span><br><span class="line">        <span class="number">36</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">24</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">25</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">26</span>: <span class="number">16</span></span><br><span class="line">        line <span class="number">27</span>: <span class="number">20</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">24</span></span><br><span class="line">        line <span class="number">29</span>: <span class="number">32</span></span><br><span class="line">        line <span class="number">30</span>: <span class="number">36</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;DynamicDispatch.java&quot;</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     <span class="keyword">static</span> #<span class="number">9</span>= #<span class="number">4</span> of #<span class="number">7</span>; <span class="comment">//Woman=class dispatch/DynamicDispatch$Woman of class dispatch/DynamicDispatch</span></span><br><span class="line">     <span class="keyword">static</span> #<span class="number">11</span>= #<span class="number">2</span> of #<span class="number">7</span>; <span class="comment">//Man=class dispatch/DynamicDispatch$Man of class dispatch/DynamicDispatch</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">abstract</span> #<span class="number">13</span>= #<span class="number">12</span> of #<span class="number">7</span>; <span class="comment">//Human=class dispatch/DynamicDispatch$Human of class dispatch/DynamicDispatch</span></span><br></pre></td></tr></table></figure>

<p>0 ~ 15行的字节码是准备动作，作用是建立man和woman的内存空间、调用Man和Woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表Slot之中，这个动作也就对应了代码中的这两句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Human</span> <span class="variable">woman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br></pre></td></tr></table></figure>

<p>接下来的16~21句是关键部分，16、20两句分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的sayHello()方法的所有者，称为接收者（Receiver）；17和21句是方法调用指令，这两条调用指令单从字节码角度来看，无论是指令还是参数都是完全一样的，但是这两句指令最终执行的目标方法并不相同。原因就需要从invokevirtual指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<p>由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>
<h3 id="2-2-3-单分派与多分派"><a href="#2-2-3-单分派与多分派" class="headerlink" title="2.2.3. 单分派与多分派"></a>2.2.3. 单分派与多分派</h3><p>方法的接收者与方法的参数统称为方法的宗量，这个定义最早应该来源于《Java与模式》一书。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p>
<p>单分派和多分派的定义读起来拗口，从字面上看也比较抽象，不过对照着实例看就不难理解了。下面代码中列举了一个Father和Son一起来做出“一个艰难的决定”的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单分派、多分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dispatch</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QQ</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">_360</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hardChoice</span><span class="params">(QQ arg)</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;father choose qq&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hardChoice</span><span class="params">(_360 arg)</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;father choose 360&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hardChoice</span><span class="params">(QQ arg)</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;son choose qq&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hardChoice</span><span class="params">(_360 arg)</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;son choose 360&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">		<span class="type">Father</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">		father.hardChoice(<span class="keyword">new</span> <span class="title class_">_360</span>());</span><br><span class="line">		son.hardChoice(<span class="keyword">new</span> <span class="title class_">QQ</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">father choose <span class="number">360</span></span><br><span class="line">son choose qq</span><br></pre></td></tr></table></figure>

<p>在main函数中调用了两次hardChoice()方法，这两次hardChoice()方法的选择结果在程序输出中已经显示得很清楚了。</p>
<p>我们来看看编译阶段编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点：一是静态类型是Father还是Son，二是方法参数是QQ还是360。这次选择结果的最终产物是产生了两条invokevirtual指令，两条指令的参数分别为常量池中指向Father.hardChoice(360)及Father.hardChoice(QQ)方法的符号引用。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</p>
<p>再看看运行阶段虚拟机的选择，也就是动态分派的过程。在执行“son.hardChoice(new QQ())”这句代码时，更准确地说，是在执行这句代码所对应的invokevirtual指令时，由于编译期已经决定目标方法的签名必须为hardChoice(QQ)，虚拟机此时不会关心传递过来的参数“QQ”到底是“腾讯QQ”还是“奇瑞QQ”，因为这时参数的静态类型、实际类型都对方法选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有此方法的接受者的实际类型是Father还是Son。因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p>
<p>根据上述论证的结果，我们可以总结依据：今天（包括已发布的Java1.8）的Java语言是一门静态多分派、动态单分派的语言。</p>
<h2 id="2-3-动态类型语言支持"><a href="#2-3-动态类型语言支持" class="headerlink" title="2.3. 动态类型语言支持"></a>2.3. 动态类型语言支持</h2><p>Java虚拟机的字节码指令集的数量从Sun公司的第一款Java虚拟机问世至JDK7来临之前的十余年时间里，一直没有发生任何变化。随着JDK7的发布，字节码指令集终于迎来了第一位新成员——invokedynamic指令。这条新增加的指令时JDK7实现“动态类型语言”(Dynamically Typed Language)支持而进行的改进之一，也是为JDK8可以顺利实现Lambda表达式做技术准备。在本节中，我们将详细讲解JDK7这项新特性出现的前因后果和它的深远意义。</p>
<h3 id="2-3-1-动态类型语言"><a href="#2-3-1-动态类型语言" class="headerlink" title="2.3.1. 动态类型语言"></a>2.3.1. 动态类型语言</h3><p>在介绍Java虚拟机的动态类型语言支持之前，我们要先弄明白动态类型语言是什么？它与Java语言、Java虚拟机有什么关系？了解JDK1.7提供动态类型语言支持的技术背景，对理解这个语言特性是很有必要的。</p>
<p>什么是动态类型语言？<strong>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期</strong>，满足这个特征的语言有很多，常用的包括：APL、Clojure、Erlang、Groovy、JavaScript、Jython、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk和Tcl等。相对的，在编译期就进行类型检查过程的语言（如C++和Java等）就是最常用的静态类型语言。</p>
<p>觉得上面定义过于概念化？那我们不妨通过两个例子以最浅显的方式来说明什么是“在编译期/运行期进行”和什么是“类型检查”。首先看下面这段简单的Java代码，它是否能正常编译和运行？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[][][] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>][<span class="number">0</span>][-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码能够正常编译，但运行的时候会报NegativeArraySizeException异常。在Java虚拟机规范中明确规定了NegativeArraySizeException是一个运行时异常，通俗一点来说，运行时异常就是只要代码不运行到这一行就不会有问题。与运行时异常相对应的是连接时异常，例如很常见的NoClassDefFoundError便属于连接时异常，即使会导致连接时异常的代码放在一条无法执行到的分支路径上，类加载时（Java的连接过程不在编译阶段，而在类加载阶段）也照样会抛出异常。</p>
<p>不过，在C语言中，含义相同的代码会在编译期报错：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">1</span>][<span class="number">0</span>][<span class="number">-1</span>];  <span class="comment">//GCC拒绝编译，报“size of array is negative”</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此看来，一门语言的哪一种检查行为要在运行期运行，哪一种检查要在编译期进行并没有必然的因果逻辑关系，关键是语言规范中人为规定的。再举一个例子来解释“类型检查”，例如下面这一句非常简单的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj.println(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>虽然每个人都能看懂这行代码要做什么，但对于计算机来说，这一行代码“没头没尾”是无法执行的，它需要一个具体的上下文才有讨论的意义。</p>
<p>现在假设这行代码是在Java语言中，并且变量obj的静态类型为java.io.PrintStream，那变量obj的实际类型就必须是PrintStream的子类（实现了PrintStream接口的类）才是合法的。否则，哪怕obj属于一个确实有用的println(String)方法，但与PrintStream接口没有继承关系，代码依然不可能运行——因为类型检查不合法。</p>
<p>但是相同的代码在ECMAScript(JavaScript)中情况则不一样，无论obj具体是何种类型，只要这种类型的定义中确实包含有println(String)方法，那方法调用便可成功。</p>
<p>这种差别产生的原因是Java语言在编译期间已将println(String)方法完整的符号引用生成出来，作为方法调用指令的参数存储到Class文件中，例如下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokevirtual #<span class="number">4</span>;<span class="comment">//Method java/io/PrintStream.println;(Ljava/lang/String;)V</span></span><br></pre></td></tr></table></figure>

<p>这个符号引用包含了此方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息，通过这个符号引用，虚拟机可以翻译出这个方法的直接引用。而在ECMAScript等动态类型语言中，<strong>变量obj本身是没有类型的，变量obj的值才具有类型</strong>，编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型（即方法接收者不固定）。“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个重要特征。</p>
<p>了解了动态和静态类型语言的区别后，也许读者的下一个问题就是动态、静态类型语言两者谁更好，或者谁更加先进？这种比较不会有确切答案，因为它们都有自己的优点，选择哪种语言是需要经过权衡的。静态类型语言在编译期确定类型，最显著的好处是编译器可以提供严谨的类型检查，这样与类型相关的问题能在编码的时候就及时发现，利于稳定性及代码达到更大规模。而动态类型语言在运行期确定类型，这可以为开发人员提供更大的灵活性，某些在静态类型语言中需要大量“臃肿”代码来实现的功能，由动态类型语言来实现可能会更加清晰和简洁，清晰和简洁通常也就意味着开发效率的提升。</p>
<h3 id="2-3-2-JDK1-7与动态类型"><a href="#2-3-2-JDK1-7与动态类型" class="headerlink" title="2.3.2. JDK1.7与动态类型"></a>2.3.2. JDK1.7与动态类型</h3><p>Java虚拟机毫无疑问是Java语言的运行平台，但对动态类型语言的支持一直都有所欠缺，主要表现在方法调用方面：JDK1.7以前的字节码指令集中，4条方法调用指令（invokevirtual、invokespecial、invokestatic、invokeinterface）的第一个参数都是被调用的方法的符号引用（CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info常量），前面已经提到过，方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定接收者类型。这样，在Java虚拟机上实现的动态类型语言就不得不使用其他方式（如编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配）来实现，这样势必让动态类型语言实现的复杂度增加，也可能带来额外的性能或者内存开销。尽管可以利用一些办法让这些开销尽量变小，但这种底层问题终归是应当在虚拟机层次上去解决才最合适，因此在Java虚拟机层面上提供动态类型的直接支持就成为了Java平台的发展趋势之一，这就是JDK1.7(JSR-292)中invokedynamic指令以及java.lang.invoke包出现的技术背景。</p>
<h3 id="2-3-3-java-lang-invoke包"><a href="#2-3-3-java-lang-invoke包" class="headerlink" title="2.3.3. java.lang.invoke包"></a>2.3.3. java.lang.invoke包</h3><p>JDK1.7实现了JSR-292，新加入的java.lang.invoke包就是JSR-292的一个重要组成部分，这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式以外，提供一种新的动态确定目标方法的机制，称为MethodHandle。这种表达方式也许不太懂？那不妨把MethodHandle与C/C++中的Function Pointer，或者C#里面的Delegate类比一下。举个例子，如果我们要实现一个带谓词的排序函数，在C/C++中常用的做法是把谓词定义为函数，用函数指针把谓词传递到排序方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> list[], const <span class="type">int</span> size, <span class="type">int</span> (*compare)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>)</span><br></pre></td></tr></table></figure>

<p>但Java语言做不到这一点，即没有办法单独地把一个函数作为参数进行传递。普遍的做法是设计一个带有compare()方法的Comparator接口，以实现了这个接口的对象作为参数，例如Collections.sort()就是这样定义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list, Comparator c)</span></span><br></pre></td></tr></table></figure>

<p>不过，在拥有Method Handle之后，Java语言也可以拥有类似于函数指针或者委托的方法别名的工具了。下面代码演示了MethodHandle的基本用途，无论obj是何种类型（临时定义的ClassA抑或是实现PrintStream接口的实现类System.out），都可以正确地调用到println()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dispatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JSR 292 MethodHandle基础用法演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodHandleTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> <span class="title class_">ClassA</span>();</span><br><span class="line">        <span class="comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。</span></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">&quot;icyfenix&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title function_">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和具体参数（methodType()第二个及以后的参数）。</span></span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">mt</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">        <span class="comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span></span><br><span class="line">        <span class="comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即是this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。</span></span><br><span class="line">        Class&lt;?&gt; receiveClass = reveiver.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;print class name : &quot;</span> + receiveClass.getSimpleName());</span><br><span class="line">        <span class="keyword">return</span> lookup().findVirtual(receiveClass, <span class="string">&quot;println&quot;</span>, mt).bindTo(reveiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下结果会随机出现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">print <span class="keyword">class</span> <span class="title class_">name</span> : ClassA</span><br><span class="line">icyfenix</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">print <span class="keyword">class</span> <span class="title class_">name</span> : PrintStream</span><br><span class="line">icyfenix</span><br></pre></td></tr></table></figure>

<p>实际上，方法getPrintlnHM()中模拟了invokevirtual指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个具体方法来实现。而这个方法本身的返回值（MethodHandle对象），可以视为对最终调用方法的一个“引用”。以此为基础，有了MethodHandle就可以写出类似于下面这样的函数声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list, MethodHandle compare)</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出，使用MethodHandle并没有什么困难，不过看完它的用法之后，读者大概就会产生疑问，相同的事情，用反射不是早就可以实现了吗？</p>
<p>确实，仅站在Java语言的角度来看，MethodHandle的使用方法和效果与Reflection有众多相似之处，不过，它们还是有以下这些区别：</p>
<ul>
<li><p>从本质上讲，Reflection和MethodHandle机制都是在模拟方法调用，但Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。在MethodHandles.lookup中的3个方法————findStatic()、findVirtual()、findSpecial()正是为了对应于invokestatic、invokevirtual&amp;invokeinterface和invokespecial这几条字节码指令的执行校验行为，而这些底层细节在使用Reflection API时是不需要关心的。</p>
</li>
<li><p>Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息多。前者是方法在Java一端的全面映像，包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息。而后者仅仅包含于执行该方法相关的信息。用通俗的话来讲，Reflection是重量级，而MethodHandle是轻量级。</p>
</li>
<li><p>由于MethodHandle是对字节码的方法指令调用的模板，所以理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应当可以采用类似思路去支持（但目前实现还不完善）。而通过反射去调用方法则不行。</p>
</li>
</ul>
<p>MethodHandle与Reflection除了上面列举的区别外，最关键的一点还在于去掉前面讨论施加的前提“仅站在Java语言的角度来看” ：Reflection API的设计目标是只为Java语言服务的，而MethodHandle则设计成可服务于所有Java虚拟机之上的语言，其中也包括Java语言。</p>
<h3 id="2-3-4-掌控方法分派规则"><a href="#2-3-4-掌控方法分派规则" class="headerlink" title="2.3.4. 掌控方法分派规则"></a>2.3.4. 掌控方法分派规则</h3><p>invokedynamic指令与前面4条“invoke”指令的最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定。在介绍Java虚拟机动态语言支持的最后一个小结中，笔者通过一个简单例子，帮助读者理解程序员在可以掌控方法分派规则之后，能做什么以前无法做到的事情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GrandFather</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">thinking</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i am grandfather&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_">GrandFather</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">thinking</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i am father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">thinking</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 请读者在这里填入适当的代码（不能修改其他地方的代码）</span></span><br><span class="line">       <span class="comment">// 实现调用祖父类的thinking()方法，打印&quot;i am grandfather&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Java程序中，可以通过“super”关键字很方便地调用到父类中的方法，但如果要访问祖类的方法呢？读者在阅读下面提供的解决方案之前，不妨自己思考一下，在JDK1.7之前有没有办法解决这个问题。</p>
<p>在JDK1.7之前，使用纯粹的Java语言很难处理这个问题（直接生成字节码就很简单，如使用ASM等字节码工具），原因是在Son类的thinking()方法中无法获取一个实际类型是GrandFather的对象引用，而invokevirtual指令的分派逻辑就是按照方法接收者的实际类型进行分派，这个逻辑是固化在虚拟机中的，程序员无法改变。在JDK1.7中，可以使用下面的方法解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thinking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MethodType</span> <span class="variable">mt</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">            <span class="type">MethodHandle</span> <span class="variable">mh</span> <span class="operator">=</span> lookup().findSpecial(GrandFather.class, <span class="string">&quot;thinking&quot;</span>, mt, getClass());</span><br><span class="line">            mh.invoke(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这段代码在JDK1.8中的输出结果是 <strong>i am father</strong>，findSpecial方法也需遵循JVM字节码里invokespecial指令的限制，即“它只能调用到传给findSpecial()方法的最后一个参数的直接父类的版本”。至于为何JAVA7某些版本可以越过直接父类限制而直接调用到GrantFather的方法，可能是因为findSpecial()得到的MethodHandle的具体语义在JSR 292的设计过程中有被调整过。有一段时间findSpecial()得到的MethodHandle确实可以超越invokespecial的限制去调用到任意版本的虚方法，但这种行为很快就被认为是bug而修正了。</p>
<p>当然上面的需求，如果实现是Java语言的话，利用Reflection API可以更快速的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;dispatch.GrandFather&quot;</span>);</span><br><span class="line">    <span class="type">GrandFather</span> <span class="variable">grandFather</span> <span class="operator">=</span> (GrandFather) aClass.newInstance();</span><br><span class="line">    grandFather.thinking();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;dispatch.GrandFather&quot;</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;thinking&quot;</span>);</span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    method.invoke(clazz.newInstance());</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException | ClassNotFoundException | IllegalAccessException | InvocationTargetException | InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p>参考： </p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
<li><a href="https://blog.csdn.net/ns_code/article/details/17881581">【深入Java虚拟机】之四：类加载机制</a></li>
<li><a href="https://my.oschina.net/floor/blog/1535062">JDK1.8下关于MethodHandle问题</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之高效并发-Part1内存模型</title>
    <url>/iBlogWebsite/2018/11/08/2018/2018-11-08-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91-Part1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在正式讲解Java虚拟机并发相关的知识之前，我们先花费一点时间去了解一下物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</p>
<p>“让计算机并发执行若干个运算任务” 与 “更充分地利用计算机处理器的效能” 之间的因果关系，看起来顺理成章，实际上它们之间的关系并没有想象中的那么简单，其中一个重要的复杂性来源是绝大多数的运算任务都不可能只靠处理器 “计算” 就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。<strong>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</strong></p>
<p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引人了一个新的问题：缓存一致性（Cache Coherence)。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory)， 如下图所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、 MESI(Illinois ProtocoI)、 MOSI、Synapse、Firefly及Dragon Protocol等。在本章中将会多次提到的 “内存模型” 一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-efficient-concurrency-processor-cache-main-memory.png?raw=true" alt="jvm-efficient-concurrency-processor-cache-main-memory"></p>
<p>除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输人代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序(Instruction Reorder）优化。 </p>
<h1 id="1-Java内存模型"><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h1><p>Java虚拟机规范中试图定义一种Java内存模型(Java Memory Model， JMM）来 <strong>屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</strong> 在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。 定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但是也必须定义得足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。经过长时间的验证和修补，在JDK 1.5（实现了JSR-133）发布后， Java内存模型已经成熟和完善起来了。 </p>
<span id="more"></span>

<h2 id="1-1-主内存与工作内存"><a href="#1-1-主内存与工作内存" class="headerlink" title="1.1. 主内存与工作内存"></a>1.1. 主内存与工作内存</h2><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图所示。 </p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-efficient-concurrency-threads-working-memory-and-main-memory.png?raw=true" alt="jvm-efficient-concurrency-threads-working-memory-and-main-memory"></p>
<p>这里所讲的主内存、工作内存与本书第2章所讲的Java内存区域中的Java堆、栈、方 法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。 </p>
<h2 id="1-2-内存间交互操作"><a href="#1-2-内存间交互操作" class="headerlink" title="1.2. 内存间交互操作"></a>1.2. 内存间交互操作</h2><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，<strong>Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的</strong>（对于double和long类型的变量来说，load、 stores、read和write操作在某些平台上允许有例外，这个问题后续再讨论。</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 </li>
<li>unlock（解锁）：作用于主内存的变最，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 </li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 </li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放人工作内存的变量副本中。 </li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变员的值传递给执行引擎， 每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 </li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 </li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变最的值传送到主内存中，以便随后的write操作使用。 </li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>如果要把一个变量从主内存复制到工作内存，那就要顺序地执行：read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意：Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说read与load之间、store与write之间是可插人其他指令的，如对主内存中的变量a、 b进行访问时，一种可能出现顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则： </p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 </li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 </li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。 </li>
<li>一个新的变量只能在主内存中 “诞生” ，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了 assign和load操作。 </li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 </li>
<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 </li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 </li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。 </li>
</ul>
<p>这8种内存访问操作以及上述规则限定，再加上稍后介绍的对volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。由于这种定义相当严谨但又十分烦琐，实践起来很麻烦，所以在后续章节中将介绍这种定义的一个等效判断原则——先行发生原则，用来确定一个访问在并发环境下是否安全。 </p>
<h2 id="1-3-对于volatile型变量的特殊规则"><a href="#1-3-对于volatile型变量的特殊规则" class="headerlink" title="1.3. 对于volatile型变量的特殊规则"></a>1.3. 对于volatile型变量的特殊规则</h2><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronlzcd来进行同步。了解volatile变最的语义对后面了解多线程操作的其他特性很有意义，在本节中我们将多花费一些时间去弄清楚volatile的语义到底是什么。 </p>
<p>Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，笔者先用不那么正式但通俗易懂的语言来介纽一下这个关键字的作用。</p>
<p>当一个变量定义为volatile之后，它已将具备两种特性，<strong>第一是保证此变量对所有线程的可见性，</strong> 这里的”可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值本会对线程B可见。 </p>
<p>关于volatile变量的可见性经常会被开发人员误解，认为以下描述成立： “volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。这句话的论据部分并没有错，但是其论据并不能得出 “基于volatile变量的运算在并发下是安全的” 这个结论。volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变最也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的，我们可以通过一段简单的演示来说明原因，请看下面代码示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile变量自增运算测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">race</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREADS_COUNT</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(THREADS_COUNT);</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(race);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码发起了20个线程，每个线程对race变量进行10000次自加操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。读者运往完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字，这是为什么呢？ </p>
<p>问题出现在自增运算 “race++” 之中，我们用Javap反编译这段代码后会得到代码清单12-2，发现只有一行代码的increase()方法在Class文件中是由4条字旅码指令构成的 (return指令不是由race++产生的，这条指令可以不计算) 从字节码层面上很容易就分析出并发失败的原因了：当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就编程了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>;</span><br><span class="line">descriptor: ()V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field race:I</span></span><br><span class="line">        <span class="number">3</span>: iconst_1</span><br><span class="line">        <span class="number">4</span>: iadd</span><br><span class="line">        <span class="number">5</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field race:I</span></span><br><span class="line">        <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">    line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">16</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>客观地说，笔者在此使用字节码来分析并发问题，仍然是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义，如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令，此处使用-XX:+PrintAssembly参数输出反汇编来分析会更加严谨一些，但考虑到读者阅读的方便，并且字节码己经能说明问题，所以此处使用字节码来分析。</p>
<p>由于volatile变量只能保证可见性，<strong>在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或JUC中的原子类）来保证原子性。</strong></p>
<ul>
<li><strong>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</strong></li>
<li><strong>变量不需要与其他的状态变量共同参与不变约束。</strong></li>
</ul>
<p>而在像如下的代码所示的这类场景就很适合使用volatile变最来控制并发，当shutdown()方法被调用时，能保证所有线程中执行的doWork()方法都立即停下来。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> shutdownRequested;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>&#123;</span><br><span class="line">    shutdownRequested = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!shutdownRequested)&#123;</span><br><span class="line">        <span class="comment">//do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用volatile变量的第二个语义是禁止指令重排序优化，</strong> 普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变址赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的 “线程内表现为串行的语义” (Within-Thread As-If-Serial Semantics)。 </p>
<p>上面的描述仍然不太容易理解，我们还是继续通过一个例子来看看为何指令重排序会干扰程序的并发执行，演示程序如代码所示。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="type">char</span>[] configText;</span><br><span class="line"><span class="comment">//此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialzed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设一下代码在线程A中执行</span></span><br><span class="line"><span class="comment">//模拟读取配置信息，当读取完成后将initialzed设置为true以通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设一下代码在线程B中执行</span></span><br><span class="line"><span class="comment">//等待initialzed为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span>(!initialzed)&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure>

<p>代码清单中的程序是一段伪代码，其中描述的场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。如果定义initialized变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一句的代码 “initiatized=true” 被提前执行（这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的礼编代码被提前执行）。这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生。</p>
<p>那为何说它禁止指令重排序呢？从硬件架构上讲，指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排 (A + 10)*2 与 A*2 + 10显然不相等，但指令3可以重排到指令1、2之前或者中间，只要保证CPU执行后面依赖到A、B值的操作时能获取到正确的A和B值即可。所以在本内CPU中，重排序看起来依然是有序的。因此，lock addl $0x0, (%esp)指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了 “指令重排序无法越过内存屏障” 的效果。 </p>
<p>解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义，它能让我们的代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrcnt包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为volatile就会比synchronized快多少。如果让volatile自己与自己比较，那可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插人许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁低，<strong>我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。</strong></p>
<h2 id="1-4-原子性、可见性与有序性"><a href="#1-4-原子性、可见性与有序性" class="headerlink" title="1.4. 原子性、可见性与有序性"></a>1.4. 原子性、可见性与有序性</h2><p>介绍完Java内存模型的相关操作和规则，我们再整体回顾一下这个模型的特征。Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，我们逐个来看下哪些操作实现了这3个特性。 </p>
<p><strong>原子性（Atomicity）</strong>：由Java内存模型来直接保证的原子性变员操作包括read、 load、 assign、uses、store和write，我们大致可以认为基木数据类型的访问读写是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。</p>
<p>如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块--synchronized关键字，因此在synchronized块之间的操作也具备原子性。 </p>
<p><strong>可见性（Visibility）</strong>：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。上文在讲解volatile变量的时候我们已详细讨论过这一点。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变址与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。 </p>
<p>除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。同步块的可见性是由 “对一个变量执行unlock操作之前，必须先把此变址同步回主内存中（执行 store、write操作）” 这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把 “this” 的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到 “初始化了一半” 的对象），那在其他线程中就能看见final字段的值。如下代码所示，变量i与j都其备可见性，它们无须同步就能被其他线程正确访问。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//也可以选择在构造函数中初始化</span></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有序性（Ordering）</strong>: Java内存模型的有序性在前面讲解volatile时也详细地讨论过了， Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指 “线程内表现为串行的语义”(Within-Thread As-If-Serial Semantics)，后半句是指 “指令重排序” 现象和 “工作内存与主内存同步延迟” 现象。 </p>
<p>Java语言提供了volatile。和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由 “一个变量在同一个时刻只允许一条线程对其进行lock操作” 这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。 </p>
<p>介绍完并发中3种重要的特性后，读者有没有发现synchronized关键字在需要这3种特性的时候都可以作为其中一种的解决方案？看起来很 “万能” 吧。的确，大部分的并发控制操作都能使用synchronized来完成。synchronized的 “万能” 也间接造就了它被程序员滥用的局面，越 “万能” 的并发控制，通常会伴随着越人的性能影响，这点后面再介绍。 </p>
<h2 id="1-5-先行发生原则"><a href="#1-5-先行发生原则" class="headerlink" title="1.5. 先行发生原则"></a>1.5. 先行发生原则</h2><p>如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将会变得很烦琐。但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个 “先行发生”（happens-before）的原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p>
<p>现在就来看看 “先行发生” 原则指的是什么，先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到， “影响” 包括修改了内存中共享变量的值、发送了消息、调用了方法等。这句话不难理解，但它意味着什么呢？我们可以举个例子来说明一下，如下代码清单中所示的这3句伪代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下操作在线程A中执行</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下操作在线程B中执行</span></span><br><span class="line">j = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下操作在线程C中执行</span></span><br><span class="line">i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>假设线程A中的操作 “i=1” 先行发生于线程B的操作 “j=i” ，那么可以确定在线程B的操作执行后，变量j的值一定等于1，得出这个结论的依据有两个：一是根据先行发生原则， “i=1” 的结果可以被观察到；二是线程C还没 “登场” ，线程A操作结束之后没有其他线程会修改变量i的值。现在再来考虑线程C，我们依然保持线程A和线程B之间的先行发生关系，而线程C出现在线程A和线程B的操作之间，但是线程C与线程B没有先行发生关系，那j的值会是多少呢？答案是不确定！ 1和2都有可能，因为线程C对变量i的影响可能会被线程B观察到，也可能不会，这时候线程B就存在读取到过期数据的风险，不具备多线程安全性。</p>
<p>下面是Java内存模型下一些 “天然的” 先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。 </p>
<ul>
<li><strong>程序次序规则（Program Order Rule）</strong>：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 </li>
<li><strong>管程锁定规则（Monitor Lock Rule）</strong>：对一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而 “后面” 是指时间上的先后顺序。 </li>
<li><strong>volatile变量规则（Volatile Variable Rule）</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的 “后面” 同样是指时间上的先后顺序。 </li>
<li><strong>线程启动规则（Thread Start Rule）</strong>：Thread对象的start()方法先行发生于此线程的每一个动作。 </li>
<li><strong>线程终止规则（Thread Termination Rule）</strong>：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。 </li>
<li><strong>线程中断规则（Thread Interruption Rule）</strong>：对线程interrupt()放法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interruptcd()方法检测到是否有中断发生。</li>
<li><strong>对象终结规则（Finalizer Rule）</strong>：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。 </li>
<li><strong>传递性（Transitivity）</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C， 那就可以得出操作A先行发生于操作C的结论。 </li>
</ul>
<p>Java语言无须任何同步手段保障就能成立的先行发生规则就只有上面这些了，笔者演示一下如何使用这些规则去判定操作间是否具备顺序性，对于读写共享变量的操作来说，就是线程是否安全，读者还可以从下面这个例子中感受一下 “时间上的先后顺序” 与 “先行发生” 之间有什么不同。如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码显示的是一组再普通不过的getter/setter方法，假设存在线程A和B，线程A先（时间上的先后）调用了 “setValue(1)” ，然后线程B调用了同一个对象的 “getValue()”，那么线程B收到的返回值是什么？ </p>
<p>我们依次分折一下先行发生原则中的各项规则，由于两个方法分别由线程A和线程B调用，不在一个线程中，所以程序次序规则在这里不适用；由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，因此我们可以判定尽管线程A在操作时间上先于线程B，但是无法确定线程B中 “getValue()” 方法的返回结果，换句话说这里面的操作不是线程安全的。 </p>
<p>那怎么修复这个问题呢？我们至少有两种比较简单的方案可以选择：要么把getter/setter方法都定义为synchronized方法，这样就可以套用管程锁定规则；要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景，这样就可以套用volatile变量规则来实现先行发生关系。通过上面的例子我们可以得出结论：一个操作 “时间上的先发生” 不代表这个操作会是 “先行发生” ，那如果一个操作 “先行发生” 是否就能推导出这个操作必定是 “时间上的先发生” 呢？很遗憾，<strong>这个推论也是不成立的，一个典型的例子就是多次提到的 “指令重排序”</strong> ，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下操作在同一个线程中执行</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>代码清单中的两条赋值语句在同一个线程之中，根据程序次序规则， “int i=1” 的操作先行发生于 “int j=2” ，但是 “int j=2” 的代码完全可能先被处理器执行，这并不影响先行发生原则的正确性，因为我们在这条线程之中没有办法感知到这点。 </p>
<p>上面两个例子综合起来证明了一个结论：<strong>时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</strong></p>
<hr>
<p>参考： </p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>高效并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之高效并发-Part2Java与线程</title>
    <url>/iBlogWebsite/2018/11/12/2018/2018-11-12-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91-Part2%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-线程的实现"><a href="#1-线程的实现" class="headerlink" title="1. 线程的实现"></a>1. 线程的实现</h1><p>我们知道，线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。 </p>
<p>主流的操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行start()且还未结束的java.lang.Thread类的实例就代表了一个线程。我们注意到Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的。在Java API中，一个Native方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（当然也可能是为了执行效率而使用Native方法，不过通常最高效率的手段也就是平台相关的手段）。正因为如此，作者把本节的标题定为“线程的实现” 而不是“Java线程的实现”。 实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。</p>
<h2 id="1-1-使用内核线程实现"><a href="#1-1-使用内核线程实现" class="headerlink" title="1.1. 使用内核线程实现"></a>1.1. 使用内核线程实现</h2><p>内核线程(Kernel-Levek Thread，KLT)就是直接由操作系统内核(Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器(Scheduler）对线程进行调度，井负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核（Multi-Threads Kernel）。</p>
<p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口————轻量级进程(Light Weight Process, LWP)，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型，如下图所示：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-efficient-concurrency-process-thread.png?raw=true" alt="jvm-efficient-concurrency-process-thread"></p>
<p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有它的局限性：首先由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。 </p>
<h2 id="1-2-使用用户线程实现"><a href="#1-2-使用用户线程实现" class="headerlink" title="1.2. 使用用户线程实现"></a>1.2. 使用用户线程实现</h2><p>从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程(User Thread, UT)，因此从这个定义上来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制。 </p>
<p>而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1：N的关系称为1对多的线程模型，如下图所示：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-efficient-concurrency-process-thread-one-to-many.png?raw=true" alt="jvm-efficient-concurrency-process-thread-one-to-many"></p>
<p>使用用户线程的优势在于并不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。线程的创建、切换和调度都是需要考虑的问题。而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至不可能完成。因为使用用户线程实现的程序一般都比较复杂，除了以前在不支持多线程的操作系统中（如DOS）的多线程程序与少数有特殊需求的程序外，现在使用用户线程的程序越来越少了，Java、Ruby等语言都曾经使用过用户线程，最终由都放弃使用它。</p>
<span id="more"></span>

<h2 id="1-3-使用用户线程加轻量级进程混合实现"><a href="#1-3-使用用户线程加轻量级进程混合实现" class="headerlink" title="1.3. 使用用户线程加轻量级进程混合实现"></a>1.3. 使用用户线程加轻量级进程混合实现</h2><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然康价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻最级进程则作为用户线程和内核线程之间的桥梁．这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险．在这种棍合模式中，用户线程与轻量级进程的数量比是不定的，即为N:M的关系，如下图示。这种就是多对多的线程模型。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-efficient-concurrency-process-thread-many-to-many.png?raw=true" alt="jvm-efficient-concurrency-process-thread-many-to-many"></p>
<p>许多UNIX系列的操作系统，如SoIaris、HP-UX等都提供厂N:M的线程模型实现。</p>
<h2 id="1-4-Java线程的实现"><a href="#1-4-Java线程的实现" class="headerlink" title="1.4. Java线程的实现"></a>1.4. Java线程的实现</h2><p>Java线程在JDK 1.2之前，是基于称为“绿色线程”（Green Threads）的用户线程实现的，而在JDK 1.2中，线程模型替换为基于操作系统原生线程模型来实现。因此，在目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定Java线程需要使用哪种线程模型来实现。线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是透明的。</p>
<p>对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模型就是一对一的。</p>
<p>而在Solaris平台中，由于操作系统的线程特性可以同时支持一对一（通过Bound Threads或Alternate Libthread实现）及多对多（通过LWP/Thread Based Synchronization 实现）的线程模型，因此在Solaris版的JDK中也对应提供了两个平台专有的虚拟机参数： -XX:+UseLWPSynchronization（默认值）和-XX:+UseBoundThreads来明确指定虚拟机使用哪种线程模型。</p>
<h1 id="2-Java线程调度"><a href="#2-Java线程调度" class="headerlink" title="2. Java线程调度"></a>2. Java线程调度</h1><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Scheduling）。</p>
<p>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。Lua语言中的“协同例程”就是这类实现。它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。很久以前的Windows ix系统就是使用协同式来实现多进程多任务的，相当不稳定，一个进程坚持不让出CPU执行时间就可能会导致整个系统崩溃。 </p>
<p>如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有个线程导致整个进程阻塞的问题，Java使用的线程调度方式就是抢占式调度。与前面所说的Windows 3.x的例子相对，在Windows 9x/NT内核中就是使用抢占式来实现多进程的，当一个进程出了问题，我们还可以使用任务管理器把这个进程“杀掉”，而不至于导致系统崩溃。 </p>
<p>虽然Java线程调度是系统自动完成的，但是我们还是可以“建议”系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点————这项操作可以通过设置线程优先级来完成。Java语言一共设置了10个级别的线程优先级（Thread.MIN PRIORITY至Thread.MAX_PRIORITY)，在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。 不过，线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应，如Solaris中有2147483648 (2到32次方) 种优先级，但Windows中就只有7种，比Java线程优先级多的系统还好说，中间留下一点空位就可以了，但比Java线程优先级少的系统，就不得不出现几个优先级相同的情况了。</p>
<p>上文说到“线程优先级并不是太靠谱”，不仅仅是说在一些平台上不同的优先级实际会变得相同这一点，还有其他情况让我们不能太依赖优先级：优先级可能会被系统自行改变。例如，在Windows系统中存在一个称为“优先级推进器”(Priority Boosting.当然它可以被关闭掉）的功能，它的大致作用就是当系统发现一个线程执行得特别“勤奋努力”的话，可能会越过线程优先级去为它分配执行时间。因此，我们不能在程序中通过优先级来完全准确地判断一组状态都办Ready的线程将会先执行哪一个。</p>
<h2 id="2-1-状态转换"><a href="#2-1-状态转换" class="headerlink" title="2.1. 状态转换"></a>2.1. 状态转换</h2><p>Java语言定义了5种线程状态，在任意一个时间点，一个线程只能在且只有其中的一种状态，这5种状态分别如下。 </p>
<ul>
<li>新建（New）：创建后尚未启动的线程处于这种状态。 </li>
<li>运行（Runable）: Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。 </li>
<li>无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时问，它们要等待被其他线程显式地唤醒。以下方法会让线程陷人无限期的等待状态：<ul>
<li>没有设置Timeout参数的Object.wait()方法。 </li>
<li>没有设置Timeout参数的Thread.join()方法。</li>
<li>LockSupport.park()方法。</li>
</ul>
</li>
<li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态： <ul>
<li>Thread.sleep()方法。 </li>
<li>设置了Timeout参数的Objcct.wait()方法。 </li>
<li>设置了Timeout参数的Thread.join()方法法。 </li>
<li>LockSupport.parkNanos()方法。 </li>
<li>LockSupport.parkUntil()方法。 </li>
</ul>
</li>
<li>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态” 在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 </li>
<li>结束（Teeminated）：已终止线程的线程状态，线程已经结束执行。</li>
</ul>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-efficient-concurrency-thread-status-transform.png?raw=true" alt="jvm-efficient-concurrency-thread-status-transform"></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>高效并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之类加载-Part1类文件结构</title>
    <url>/iBlogWebsite/2018/09/27/2018/2018-09-27-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD-Part1%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>想一想为什么ruby，groovy等语言能够运行在jvm上？因为Java虚拟机不和包括Java在内的任何语言绑定，它只与 “Class文件” 这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介，虚拟机并不关心Class的来源是何种语言。</p>
<p>Class文件对于Java虚拟机如此重要，所以我们有必要详细的了解Class文件的结构。下面这张图形象的展示了其基本组织结构：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-class-loader-basic-organization-structure-of-class-file.png?raw=true" alt="jvm-class-loader-basic-organization-structure-of-class-file"></p>
<p>Class文件是一组以8位字节为基础单元的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。</p>
<p>根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要以这两种数据类型为基础。</p>
<p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p>
<p>表示有多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以 “_info” 结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td>magic</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>constant_pool_count - 1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型集合。</p>
<p>Class的结构不像XML等描述语言，由于它没有任何分隔符号，在上表的数据项，无论是顺序还是数量，甚至于数据存储的字节序这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</p>
<h1 id="1-魔数与Class文件的版本"><a href="#1-魔数与Class文件的版本" class="headerlink" title="1. 魔数与Class文件的版本"></a>1. 魔数与Class文件的版本</h1><p>每个Class文件的头4个字节成为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif或者jpeg等文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。Class文件的魔数值为0xCAFEBABE（来杯咖啡吗？宝贝😆）。</p>
<p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是副版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，<strong>即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件</strong>。</p>
<p>例如，JDK1.1能支持版本号为45.0 ~ 45.65535的Class文件，无法执行版本号为46.0以上的Class文件，而JDK1.2则能支持45.0 ~ 46.65535的Class文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码编译成class后的十六进制如下所示，CAFEBABE后是次版本号0x0000，然后是主版本号0x0034，即十进制的52，也就是JDK8 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  Offset: <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0A 0B 0C <span class="number">0D</span> 0E <span class="number">0F</span> 	</span><br><span class="line"><span class="number">00000000</span>: CA FE BA BE <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">11</span> 0A <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> 0E <span class="number">07</span>    J~:&gt;..<span class="number">.4</span>........</span><br><span class="line"><span class="number">00000010</span>: <span class="number">00</span> <span class="number">0F</span> <span class="number">07</span> <span class="number">00</span> <span class="number">10</span> <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">61</span> <span class="number">67</span> <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> <span class="number">49</span> <span class="number">01</span>    ........age...I.</span><br><span class="line"><span class="number">00000020</span>: <span class="number">00</span> <span class="number">0D</span> <span class="number">43</span> <span class="number">6F</span> 6E <span class="number">73</span> <span class="number">74</span> <span class="number">61</span> 6E <span class="number">74</span> <span class="number">56</span> <span class="number">61</span> 6C <span class="number">75</span> <span class="number">65</span> <span class="number">03</span>    ..ConstantValue.</span><br><span class="line"><span class="number">00000030</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">12</span> <span class="number">01</span> <span class="number">00</span> <span class="number">06</span> 3C <span class="number">69</span> 6E <span class="number">69</span> <span class="number">74</span> 3E <span class="number">01</span> <span class="number">00</span> <span class="number">03</span>    .......&lt;init&gt;...</span><br><span class="line"><span class="number">00000040</span>: <span class="number">28</span> <span class="number">29</span> <span class="number">56</span> <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">43</span> <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0F</span> 4C <span class="number">69</span> 6E    ()V...Code...Lin</span><br><span class="line"><span class="number">00000050</span>: <span class="number">65</span> 4E <span class="number">75</span> <span class="number">6D</span> <span class="number">62</span> <span class="number">65</span> <span class="number">72</span> <span class="number">54</span> <span class="number">61</span> <span class="number">62</span> 6C <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> 0A <span class="number">53</span>    eNumberTable...S</span><br><span class="line"><span class="number">00000060</span>: <span class="number">6F</span> <span class="number">75</span> <span class="number">72</span> <span class="number">63</span> <span class="number">65</span> <span class="number">46</span> <span class="number">69</span> 6C <span class="number">65</span> <span class="number">01</span> <span class="number">00</span> 0E <span class="number">54</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span>    ourceFile...Test</span><br><span class="line"><span class="number">00000070</span>: <span class="number">43</span> 6C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> 2E 6A <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> 0C <span class="number">00</span> 08 <span class="number">00</span> 09 <span class="number">01</span>    Class.java......</span><br><span class="line">00000080: <span class="number">00</span> <span class="number">15</span> <span class="number">63</span> 6C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> 6C <span class="number">6F</span> <span class="number">61</span> <span class="number">64</span> <span class="number">65</span> <span class="number">72</span> <span class="number">2F</span> <span class="number">54</span> <span class="number">65</span>    ..classloader/Te</span><br><span class="line">00000090: <span class="number">73</span> <span class="number">74</span> <span class="number">43</span> 6C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">01</span> <span class="number">00</span> <span class="number">10</span> 6A <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2F</span> 6C    stClass...java/l</span><br><span class="line">000000a0: <span class="number">61</span> 6E <span class="number">67</span> <span class="number">2F</span> <span class="number">4F</span> <span class="number">62</span> 6A <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">00</span> <span class="number">21</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">03</span>    ang/Object.!....</span><br><span class="line">000000b0: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">19</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span>    ................</span><br><span class="line">000000c0: <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> 08 <span class="number">00</span> 09 <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> 0A    ................</span><br><span class="line">000000d0: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">1D</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> 2A B7 <span class="number">00</span> <span class="number">01</span>    ............*<span class="number">7.</span>.</span><br><span class="line"><span class="number">000000e0</span>: B1 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> 0B <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="number">1.</span>..............</span><br><span class="line">000000f0: <span class="number">03</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> 0C <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">0D</span>                   ...........</span><br></pre></td></tr></table></figure>

<h1 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h1><p>紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。</p>
<p>由于常量池中常亮的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（contant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的，例如上面的一段十六进制数据，0x00000034之后，是0x0011即十进制的17，这就代表常量池中有16项常亮，索引值范围为1 ~ 16。在Class文件格式规范制定之时，设计者将第0项常量空出来是由特殊考虑的，<strong>这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达 “不引用任何一个常量池项目” 的含义，这种情况就可以把索引值置为0来表示。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与之前习惯相同，是从0开始的。</strong></p>
<p>我们可以通过 javap -v TestClass.class 命令来验证常量池容量的准确性。如下所示，可以看到常量池的编号是从 #1 到 #16的，总共包含16个常量信息，与上面的分析一致 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\Project\IntellJ2\DemoIO\src\classloader&gt;javap -v TestClass.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Classfile</span> /D:/Project/IntellJ2/DemoIO/src/classloader/TestClass.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2018</span>-<span class="number">9</span>-<span class="number">27</span>; size <span class="number">251</span> bytes</span><br><span class="line">  MD5 checksum 0871ab3d9bd0c1e92f33089c478b2f67</span><br><span class="line">  Compiled from <span class="string">&quot;TestClass.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">classloader</span>.TestClass</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">3.</span>#<span class="number">14</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">15</span>            <span class="comment">// classloader/TestClass</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">16</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">4</span> = Utf8               age</span><br><span class="line">   #<span class="number">5</span> = Utf8               I</span><br><span class="line">   #<span class="number">6</span> = Utf8               ConstantValue</span><br><span class="line">   #<span class="number">7</span> = Integer            <span class="number">18</span></span><br><span class="line">   #<span class="number">8</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">9</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">10</span> = Utf8               Code</span><br><span class="line">  #<span class="number">11</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">13</span> = Utf8               TestClass.java</span><br><span class="line">  #<span class="number">14</span> = NameAndType        #<span class="number">8</span>:#<span class="number">9</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">15</span> = Utf8               classloader/TestClass</span><br><span class="line">  #<span class="number">16</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="type">int</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> classloader.TestClass();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;TestClass.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>常量池中主要存放两大类常量：<strong>字面量（Literal）和符号引用（Symbolic Refrences）</strong>，字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>
<ul>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
</ul>
<p>Java代码在进行javac编译的时候，并不像C和C++那样有“链接”这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。也就是说在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
<p>常量池中每一项常量都是一个表，在JDK1.7之前共有11中结构各不相同的表结构数据，在JDK1.7中为了更好地支持动态语言调用，又额外增加了3中（CONSTANT_MethodHandle_info、CONSTANT_MethodType_info和CONSTANT_InvokeDynamic_info）。</p>
<p>这14种表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位，代表当前这个常量属于哪种常量类型。这14种常量类型所代表的具体含义如下所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_Utf8_info</td>
<td>1</td>
<td>UTF-8 编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的部分符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>表示方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody></table>
<p>之所以说常量池是最烦琐的数据，是因为这14种数量类型各自均有自己的结构。至于详细的介绍，这里不再给出，下面贴出参考链接，讲的非常好：</p>
<p><a href="https://blog.csdn.net/luanlouis/article/details/40148053">《Java虚拟机原理图解》 1.2、class文件中的常量池</a><br><a href="https://blog.csdn.net/luanlouis/article/details/39960815">《Java虚拟机原理图解》 1.2.2、Class文件中的常量池详解（上）</a><br><a href="https://blog.csdn.net/luanlouis/article/details/40301985">《Java虚拟机原理图解》 1.2.3、Class文件中的常量池详解（下）</a><br><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机第6章6.3.2小节</a></p>
<h1 id="3-访问标志"><a href="#3-访问标志" class="headerlink" title="3. 访问标志"></a>3. 访问标志</h1><p>在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：<strong>这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的化，是否被声明为final等</strong>。具体的标志位及其含义如下所示：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为final，只有类可设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用invokespecial字节码指令的新语意，invokespecial指令的语意在JDK1.0.2发生过改变，为了区别这条指令使用哪种语意，JDK1.0.2之后编译出来的类的这个标志都必须为真</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类值为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识这个类并非由用户代码产生的</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标识这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标识这是一个枚举</td>
</tr>
</tbody></table>
<p>更加详细的访问标志资料，参考<a href="https://blog.csdn.net/luanlouis/article/details/41039269">《Java虚拟机原理图解》1.3、class文件中的访问标志、类索引、父类索引、接口索引集合</a></p>
<h1 id="4-类索引、父类索引与接口索引集合"><a href="#4-类索引、父类索引与接口索引集合" class="headerlink" title="4. 类索引、父类索引与接口索引集合"></a>4. 类索引、父类索引与接口索引集合</h1><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，<strong>除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0</strong>。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句后的接口顺序从左到右排列在接口索引集合中。</p>
<p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量。</p>
<h1 id="5-字段表集合"><a href="#5-字段表集合" class="headerlink" title="5. 字段表集合"></a>5. 字段表集合</h1><p>字段表（field_info）用于描述接口或者类中声明的变量。<strong>字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量</strong>。一个字段包含的信息有：字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。字段表的最终格式如下表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义如下表所示：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>字段是否public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>字段是否private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>字段是否protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>字段是否final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>字段是否volatile</td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td>0x0080</td>
<td>字段是否transient</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>字段是否由编译器自动产生的</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>字段是否enum</td>
</tr>
</tbody></table>
<p>很明显，在实际情况中，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志做多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，这些都是由Java本身的语言规则所决定的。</p>
<p>跟随access_flags标志的是两项索引值：name_index和descriptor_index。他们都是对常量池的引用，分别代表着字段的简单名称以及字段的方法的描述符。现在需要解释一下“简单名称”、“描述符”以及前面出现过多次的“全限定名”这三种特殊字符串的概念。</p>
<p>全限定名和简单名称很好理解，例如：“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。简单名称是指没有类型和参数修饰的方法或者字段名称。</p>
<p>相对于全限定名和简单名称来说，方法和字段的描述符就要复杂一些。<strong>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</strong>。根据描述符规则，基本数据类型以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，如下表所示：</p>
<table>
<thead>
<tr>
<th>标识字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>特殊类型void</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，如Ljava/lang/Object</td>
</tr>
</tbody></table>
<p>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组，将被记录为：“[[Ljava/lang/String;”，一个整型数组“int[]”将被记录为“[I”。</p>
<p><strong>用描述符描述方式时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内</strong>。如方法void add()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String;”，<strong>方法int indexOf(char[] source,int sourceOffset , int sourceCount , char[] target , int targetOffset , int targetCount , int fromIndex)的描述符为“([CII[CIII)I”</strong>。</p>
<p>字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自定添加指向外部类实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</p>
<p>关于更详细的关于字段表的介绍和举例，参考：<a href="https://blog.csdn.net/luanlouis/article/details/41046443">《Java虚拟机原理图解》1.4 class文件中的字段表集合–field字段在class文件中是怎样组织的</a></p>
<h1 id="6-方法表集合"><a href="#6-方法表集合" class="headerlink" title="6. 方法表集合"></a>6. 方法表集合</h1><p>理解了上一节关于字段表的内容，本节关于方法表的内容将会变得很简单。Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项，这些数据项目的含义也非常类似，仅在访问标志和属性表集合的可选项中有所区别。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对的，synchronized、native、strictfp和abstract关键字可以修饰方法，所以方法表的访问标志中增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。对于方法表，所有标志位及其取值可参见下表。</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>方法是否public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>方法是否private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>方法是否protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>方法是否static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>方法是否final</td>
</tr>
<tr>
<td>ACC_SYNCHRONIZED</td>
<td>0x0020</td>
<td>方法是否synchronized</td>
</tr>
<tr>
<td>ACC_BRIDGE</td>
<td>0x0040</td>
<td>方法是否是由编译器产生的桥接方法</td>
</tr>
<tr>
<td>ACC_VARARGS</td>
<td>0x0080</td>
<td>方法是否接受不定参数</td>
</tr>
<tr>
<td>ACC_NATIVE</td>
<td>0x0100</td>
<td>方法是否为native</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>方法是否为abstract</td>
</tr>
<tr>
<td>ACC_STRICTFP</td>
<td>0x0800</td>
<td>方法是否为strictfp</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>方法是否由编译器自动产生的</td>
</tr>
</tbody></table>
<p>行文至此，或许你会产生疑问：方法的代码放哪？其实方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，将在下一小节介绍。</p>
<p>与字段表集合相对应的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“&lt;clinit&gt;”方法和实例构造器“&lt;init&gt;”方法。</p>
<p><strong>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java语言里面是无法仅仅依赖返回值的不同来对一个已有方法进行重载的。但是在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。</strong></p>
<h1 id="7-属性表集合"><a href="#7-属性表集合" class="headerlink" title="7. 属性表集合"></a>7. 属性表集合</h1><p>属性表（attribute_info）的一般结构如下图所示：</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/jvm-class-loader-general-structure-of-the-attribute-table.png?raw=true" alt="jvm-class-loader-general-structure-of-the-attribute-table"></p>
<p>在《Java虚拟机规范（第2版）》中预定义了9项虚拟机实现应当能识别的属性，而在最新的《Java虚拟机规范（Java SE7）》版中，预定义属性已经增加到了21项。属性表的内容比较复杂，推荐熟悉Code、ConstantValue、Deprecated和Exceptions即可，其余的项有兴趣可自行扩展。</p>
<p>这里不再详细介绍，推荐参考《Java虚拟机原理图解》系列文章的<a href="https://blog.csdn.net/luanlouis/article/details/41113695">《Java虚拟机原理图解》1.5、 class文件中的方法表集合–method方法在class文件中是怎样组织的</a></p>
<hr>
<p>参考:</p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）</a></li>
<li><a href="https://blog.csdn.net/column/details/jvm-principle.html">Java虚拟机原理图解</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的签名机制，了解一下</title>
    <url>/iBlogWebsite/2018/11/27/2018/2018-11-27-Android%E4%B8%AD%E7%9A%84%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<p>这篇文章主要梳理Android中的应用签名是怎样执行的，以及为什么要这样做。</p>
<h1 id="1-应用签名"><a href="#1-应用签名" class="headerlink" title="1. 应用签名"></a>1. 应用签名</h1><p>给应用签名其实可以理解为给应用加上开发者自己的一套指纹，以便开发者后续可以继续创作和更新其应用。在 Android 平台上运行的每个应用都必须要有<strong>开发者的签名</strong>。Google Play 或 Android 设备上的软件包安装程序会拒绝没有获得签名就尝试安装的应用。</p>
<p>应用可以由第三方（OEM、运营商、其他应用市场）签名，也可以自行签名。Android 提供了使用自签名证书进行代码签名的功能，而开发者无需外部协助或许可即可生成自签名证书。应用并非必须由核心机构签名。Android 目前不对应用证书进行 CA 认证。</p>
<h2 id="1-1-APK签名方案"><a href="#1-1-APK签名方案" class="headerlink" title="1.1. APK签名方案"></a>1.1. APK签名方案</h2><p>Android 支持以下三种应用签名方案：</p>
<p>v1 方案：基于 JAR 签名。<br>v2 方案：APK 签名方案 v2（在 Android 7.0 中引入）。<br>v3 方案：APK 签名方案 v3（在 Android 9 中引入）。</p>
<p>为了最大限度地提高兼容性，请按照 v1、v2、v3 的先后顺序采用所有方案对应用进行签名。与只通过 v1 方案签名的应用相比，还通过 v2+ 方案签名的应用能够更快速地安装到 Android 7.0 及更高版本的设备上。更低版本的 Android 平台会忽略 v2+ 签名，这就需要应用包含 v1 签名。</p>
<p>另外在 Android P 中，v2 方案已更新为 v3 方案，以便在签名分块中包含其他信息，但在其他方面保持相同的工作方式。</p>
<p>V1和V2的区别在于：在验证期间，v2+ 方案会将 APK 文件视为 Blob，并对整个文件进行签名检查。对 APK 进行的任何修改（包括对 ZIP 元数据进行的修改）都会使 APK 签名作废。这种形式的 APK 验证不仅速度要快得多，而且能够发现更多种未经授权的修改。而V1方案需要对每个文件来验证完整性，耗时较长。</p>
<span id="more"></span>

<h1 id="2-以微信为例解析签名机制"><a href="#2-以微信为例解析签名机制" class="headerlink" title="2. 以微信为例解析签名机制"></a>2. 以微信为例解析签名机制</h1><p>这里主要是分析采用V1方案的签名机制，从<a href="https://sj.qq.com/myapp/detail.htm?apkName=com.tencent.mm">应用宝市场</a>下载一个最新的微信apk，版本号是[6.7.3_1360]，直接采用ZIP工具解压后的文件结构如下图所示，其中有个META-INF，就是今天分析的重点所在。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/android-ignature-mechanism-wechat-unzipped-directory.png?raw=true" alt="android-ignature-mechanism-wechat-unzipped-directory"></p>
<p>META-INF文件夹包括三个自动生成的文件：MANIFEST.MF、COM_TENC.SF、COM_TENC.RSA，如下图所示，这三个文件的生成顺序是MANIFEST.MF → COM_TENC.SF → COM_TENC.RSA。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/android-ignature-mechanism-wechat-meta-inf.png?raw=true" alt="android-ignature-mechanism-wechat-meta-inf"></p>
<p>在接下来的流程中，你可能需要如下两个网址跟着我一起验证：<br><a href="http://www.atool.org/file_hash.php">在线计算文件Hash值</a><br><a href="http://tomeko.net/online_tools/hex_to_base64.php?lang=en">在线编码转换</a></p>
<h2 id="2-1-MANIFEST-MF"><a href="#2-1-MANIFEST-MF" class="headerlink" title="2.1. MANIFEST.MF"></a>2.1. MANIFEST.MF</h2><p>MANIFEST.MF文件保存了我们apk里的除METE-INF外的文件的摘要信息，打开MANIFEST.MF文件，如下所示，第一行指明MANIFEST文件的版本号，第二行说明由谁创建的。然后下面的是关键内容，每组信息由Name和SHA1-Digest组成，我们接下来就验证这个文件：r/u/awk.9.png。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/android-ignature-mechanism-wechat-manifestmf.png?raw=true" alt="android-ignature-mechanism-wechat-manifestmf"></p>
<p>在解压后的资源文件夹中找到r/u/awk.9.png文件，如下所示，接着生成这个文件的SHA1值是：5e1a10fd73a97e1f6a2100aa6d0fa969771c7500，然后base64编码得到的值是：XhoQ/XOpfh9qIQCqbQ+paXccdQA=，跟MANIFEST.MF文件中的值正好匹配。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/android-ignature-mechanism-wechat-awk.9.png?raw=true" alt="android-ignature-mechanism-wechat-awk.9"></p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/android-ignature-mechanism-wechat-manifestmf-check-value.png?raw=true" alt="android-ignature-mechanism-wechat-manifestmf-check-value"></p>
<h2 id="2-2-COM-TENC-SF"><a href="#2-2-COM-TENC-SF" class="headerlink" title="2.2. COM_TENC.SF"></a>2.2. COM_TENC.SF</h2><p>微信里面的COM_TENC.SF，默认名称应该是CERT.SF，这个文件名是可以修改的，<strong>但是务必让.SF文件和.RSA文件的名称保持一致</strong>。打开SF文件后，如下图所示，可以看到跟前面讲到的MENIFEST.MF非常相似。下面先解决掉前面四行内容，第一行Signature-Version是SF文件的版本号，第二行SHA1-Digest-Manifest-Main-Attributes是MANIFEST.MF文件内头属性块的摘要值（SHA1→BASE64），第三行SHA1-Digest-Manifest是MANIFEST.MF文件的摘要值（SHA1→BASE64），第四行是创建者信息。</p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/android-ignature-mechanism-wechat-certsf.png?raw=true" alt="android-ignature-mechanism-wechat-certsf"></p>
<p>这里先验证SHA1-Digest-Manifest-Main-Attributes的正确性，先将MANIFEST.MF文件内头属性块的内容拷贝到一个新的文件中，记得结尾要空两行，如下图所示：<br><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/android-ignature-mechanism-wechat-certsf-sha1-digest-manifest-main-attributes.png?raw=true" alt="android-ignature-mechanism-wechat-certsf-sha1-digest-manifest-main-attributes"></p>
<p>然后对该文件计算SHA1→BASE64，如下图所示，SHA1后的值是：20836476a0032577b733ef112dfa037ee13e9ade，再BASE64后的值是：IINkdqADJXe3M+8RLfoDfuE+mt4=。该值与COM_TENC.SF中描述的SHA1-Digest-Manifest-Main-Attributes值正好匹配。COM_TENC.SF文件中的SHA1-Digest-Manifest的验证过程与MANIFEST.MF中验证r/u/awk.9.png的方法一致，这里不再赘述。<br><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/android-ignature-mechanism-wechat-certsf-sha1-digest-manifest-main-attributes-equals.png?raw=true" alt="android-ignature-mechanism-wechat-certsf-sha1-digest-manifest-main-attributes-equals"></p>
<p>COM_TENC.SF文件中的头四行信息搞定之后，再接着看下面的内容，同MANIFEST.MF中的一致，每组信息由Name和SHA1-Digest组成，这里的SHA1-Digest值是遍历了MANIFEST.MF中的每组信息，然后对每组信息再SHA1→BASE64后再写回到COM_TENC.SF的SHA1-Digest中。说的有点抽象，这里验证COM_TENC.SF中的第一组的正确性，即r/u/awk.9.png。</p>
<p>其实同上面我们验证SHA1-Digest-Manifest-Main-Attributes的方法一致，先从MANIFEST.MF中拷贝出r/u/awk.9.png这一组的内容到一个新的文件中，如下图所示，然后对这个CERTSF_awk.9.txt文件做SHA1→BASE64，计算出的SHA1值是：21a994456c64c7f81ef51f5876af99205543c014，再BASE64后的值是：IamURWxkx/ge9R9Ydq+ZIFVDwBQ=。该值与COM_TENC.SF中描述的r/u/awk.9.png的SHA1-Digest正好匹配。<br><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/android-ignature-mechanism-wechat-certsf-awk.9.png?raw=true" alt="android-ignature-mechanism-wechat-certsf-awk.9"></p>
<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2018/code/android-ignature-mechanism-wechat-certsf-awk.9-equals.png?raw=true" alt="android-ignature-mechanism-wechat-certsf-awk.9-equals"></p>
<p><strong>SF文件里保存的是MANIFEST.MF文件的SHA1→BASE64值以及MANIFEST.MF中每组摘要的SHA1→BASE64值。</strong></p>
<h2 id="2-3-COM-TENC-RSA"><a href="#2-3-COM-TENC-RSA" class="headerlink" title="2.3. COM_TENC.RSA"></a>2.3. COM_TENC.RSA</h2><p>MANIFEST.MF</p>
<blockquote>
<p>对文件内容做一次SHA-1算法，计算出文件的摘要信息，然后用Base64进行编码。</p>
</blockquote>
<p>CERT.SF</p>
<blockquote>
<ol>
<li>计算这个MANIFEST.MF文件的整体SHA-1值，再经过BASE64编码后，记录在CERT.SF主属性块（在文件头上）的SHA1-Digest-Manifest属性值下。</li>
<li>逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是SHA1-Digest</li>
</ol>
</blockquote>
<p>CERT.RSA</p>
<blockquote>
<p>把之前生成的CERT.SF文件，用私钥计算出签名，然后将签名以及包含公钥信息的数字证书一同写入CERT.RSA中保存。CERT.RSA是一个满足PKCS7格式的文件。</p>
</blockquote>
<h2 id="2-4-为何要这么来签名"><a href="#2-4-为何要这么来签名" class="headerlink" title="2.4. 为何要这么来签名"></a>2.4. 为何要这么来签名</h2><ol>
<li>如果你改变了apk包中的任何文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是验证失败，程序就不能成功安装。</li>
<li>如果你对更改过的文件相应的算出新的摘要值，然后更改MANIFEST.MF文件里面对应的属性值，那么必定与CERT.SF文件中算出的摘要值不一样，照样验证失败。</li>
<li>如果你还不死心，继续计算MANIFEST.MF的摘要值，相应的更改CERT.SF里面的值，那么数字签名值必定与CERT.RSA文件中记录的不一样，还是失败。</li>
<li>那么能不能继续伪造数字签名呢？不可能，因为没有数字证书对应的私钥。</li>
</ol>
<hr>
<p>参考： </p>
<ol>
<li><a href="https://source.android.com/security/apksigning">应用签名</a></li>
<li><a href="http://www.chenglong.ren/2016/12/30/android%E4%B8%AD%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90%E4%B9%8Bmeta-inf%E6%96%87%E4%BB%B6%E8%AE%B2%E8%A7%A3/">Android中签名原理和安全性分析之META-INF文件讲解</a></li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>签名机制</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之高效并发-Part3线程安全与锁优化</title>
    <url>/iBlogWebsite/2018/11/13/2018/2018-11-13-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91-Part3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1. 线程安全"></a>1. 线程安全</h1><p>“线程安全”这个名称，相信稍有经验的程序员都会听说过，甚至在代码编写和走查的时候可能还会经常挂在嘴边，但是如何找到一个不太拗口的概念来定义线程安全却不是一件容易的事情，笔者尝试在Google中搜索它的概念，找到的是类似于“如果一个对象可以安全地被多个线程同时使用，那它就是线程安全的”这样的定义并不能说它不正确，但是人们无法从中获取到任何有用的信息。 </p>
<p>笔者认为《Java Concurrency In Practice》的作者Brian Coca对“线程安全”有一个比较恰当的定义：“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”。</p>
<p>这个定义比较严谨，它要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。这点听起来简单，但其实并不容易做到，在大多数场景中，我们都会将这个定义弱化一些，如果把“调用这个对象的行为”限定为“单次调用”, 这个定义的其他描述也能够成立的话，我们就可以称它是线程安全了，为什么要弱化这个定义，现在暂且放下，稍后再详细探讨。</p>
<h2 id="1-1-Java语言中的线程安全"><a href="#1-1-Java语言中的线程安全" class="headerlink" title="1.1. Java语言中的线程安全"></a>1.1. Java语言中的线程安全</h2><p>按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<h3 id="1-1-1-不可变"><a href="#1-1-1-不可变" class="headerlink" title="1.1.1. 不可变"></a>1.1.1. 不可变</h3><p>在Java语言中（特指JDK 1.5以后，即Java内存模型被修正之后的Java语言），不可变(Immutable)的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施，在我们谈到final关键字带来的可见性时曾经提到过这一点，只要一个不可变的对象被正确地构建出来（没有发生this引用逃逸的情况），那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最简单和最纯粹的。</p>
<p>Java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，如果读者还没想明白这句话，不妨想一想java.lang.String类的对象，它是一个典代的不可变对象，我们调用它的substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。 </p>
<p>保证对象行为不影响自己状态的途径有很多种，其中最简单的就是把对象中带有状态的变量都声明为final，这样在构造函数结束之后，它就是不可变的，例如如下代码中 java.lang.Integer构造函数所示的，它通过将内部状态变量value定义为final来保障状态不变。 </p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java API中符合不可变要求的类型，除了上面提到的String之外，常用的还有枚举类型，以及java.lang.Number的部分子类，如Long和Double等数值包装类型，Biginteger和BigDecimal等大数据类型：但同为Number的子类型的原子类AtomicInteger和AtomicLong则并非不可变的，读者不妨看看这两个原子类的源码，想一想为什么。 </p>
<h3 id="1-1-2-绝对线程安全"><a href="#1-1-2-绝对线程安全" class="headerlink" title="1.1.2. 绝对线程安全"></a>1.1.2. 绝对线程安全</h3><p>绝对的线程安全完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的 <strong>一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至有时候是不切实际的代价</strong> 。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。我们可以通过Java API中一个不是“绝对线程安全”的线程安全类来看看这里的“绝对”是什么意思。</p>
<p>如果说java.util.Vector是一个线程安全的容器，相信所有的Java程序员对此都不会有异议，因为它的add(), get()和size()这类方法都是被synchronized修饰的，尽管这样效率很低的，但确实是安全的。但即使它所有的方法都被修饰成同步，也不意味着调用它的时候永远都不再需要同步手段了，请看如下测试代码。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVector</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">removeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">printThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        System.out.print((vector.get(i)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            removeThread.start();</span><br><span class="line">            printThread.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不要同时产生过多的线程，否则会导致操作系统假死</span></span><br><span class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一段时间就会抛出如下异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;Thread-1208204&quot;</span> java.lang.ArrayIndexOutOfBoundsException: Array index out of range: <span class="number">8</span></span><br><span class="line">	at java.util.Vector.remove(Vector.java:<span class="number">831</span>)</span><br><span class="line">	at thread.TestVector$<span class="number">1.</span>run(TestVector.java:<span class="number">19</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>

<p>很明显尽管这里使用到的Vector的get()、remove()和size()方法都是同步的，但是在多线程的环境中，如果不在方法调用端做额外的同步措施的话，使用这段代码仍然是不安全的，<strong>因为如果另一个线程恰好在错误的时间里删除了一个元素，导致序号i已经不再可用的话，再用i访问数组就会抛出一个ArraylndexOutOfBoundsException</strong> 。如果要保证这段代码能正确执行下去，我们不得不把removeThread和printThread的定义改成如下代码所示的样子。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVector</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">removeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (vector)&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                            vector.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">printThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (vector)&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                            System.out.print((vector.get(i)));</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            removeThread.start();</span><br><span class="line">            printThread.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不要同时产生过多的线程，否则会导致操作系统假死</span></span><br><span class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-相对线程安全"><a href="#1-1-3-相对线程安全" class="headerlink" title="1.1.3. 相对线程安全"></a>1.1.3. 相对线程安全</h3><p>相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。上面代码清单就是相对线程安全的明显的案例。 </p>
<p>在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collections的synchronizcdCollection()方法包装的集合等。</p>
<h3 id="1-1-4-线程兼容"><a href="#1-1-4-线程兼容" class="headerlink" title="1.1.4. 线程兼容"></a>1.1.4. 线程兼容</h3><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况，Java API中大部分的类都是属于线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。 </p>
<h3 id="1-1-5-线程对立"><a href="#1-1-5-线程对立" class="headerlink" title="1.1.5. 线程对立"></a>1.1.5. 线程对立</h3><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。 </p>
<p>一个线程对立的例子是Thread类的suspend()和resume()方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend()中断的线程就是即将要执行resume()执行的那个线程，那就肯定要产生死锁了。也正是由于这个原因suspend()和 resume()方法已经被JDK声明废弃(@Deprecated)了。常见的线程对立的操作还有System.setIn()、System.setOut()和System.runFinalizersOnExit()等。 </p>
<h2 id="1-2-线程安全的实现方式"><a href="#1-2-线程安全的实现方式" class="headerlink" title="1.2. 线程安全的实现方式"></a>1.2. 线程安全的实现方式</h2><h3 id="1-2-1-互斥同步"><a href="#1-2-1-互斥同步" class="headerlink" title="1.2.1. 互斥同步"></a>1.2.1. 互斥同步</h3><p>互斥同步（MutualExclusion &amp; Synchronization）是常见的一种并发正确性保障手段。<strong>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用</strong>。而互斥是实现同步的一种手段，临界区(Critical Section)、互斥量(Mutex）和信号址(Semaphore）都是主要的互斥实现方式。因此在这4个字里而，<strong>互斥是因，同步是果；互斥是方法，同步是目的</strong>。 </p>
<p>在Java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。 </p>
<p>根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p>
<p>在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的。首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块（如被synchronized修饰的getter()或setter()方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。所以synchronized是Java语言中一个重量级 (Heavyweight)的操作，有经验的程序员都会在确实必要的情况下才使用这种操作。而虑拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态之中。 </p>
<p>除了synchronized之外，我们还可以使用java.util.concurrent（下文称J.U.C）包中的重入锁(ReentrantLoek）来实现同步，在基本用法上，ReentrantLock与synchronized很相似， 他们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁 （lock()和unlock()方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁。不过，相比synchronized, ReentrantLock增加了一些高级功能．主要有以下3项：<strong>等待可中断、可实现公平锁，以及锁可以绑定多个条件。</strong> </p>
<ul>
<li>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。 </li>
<li>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。 </li>
<li>锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition()方法即可。 </li>
</ul>
<h3 id="1-2-2-非阻塞同步"><a href="#1-2-2-非阻塞同步" class="headerlink" title="1.2.2. 非阻塞同步"></a>1.2.2. 非阻塞同步</h3><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p>随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。 </p>
<p>为什么说使用乐观并发策略需要“硬件指令集的发展”才能进行呢？因为我们需要<strong>操作和冲突检测这两个步骤具备原子性</strong> ，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类执行常用的有：</p>
<ul>
<li>测试并设置（Test-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（Compare-and-Swap，下文称CAS）</li>
<li>加载链接/条件存储（Load-Linked/Store-Conditional，下文称LL/SC）</li>
</ul>
<p>CAS指令需要有3个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。 </p>
<p>在JDK 1.5之后，Java程序中才可以使用CAS操作，该操作由sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了。 </p>
<p>由于Unsafe类不是提供给用户程序调用的类（Unsafe.getUnsafe()的代码中限制了只有启动类加载器(Bootstrap ClassLoader)加载的Class才能访问它），因此如果不采用反射手段，我们只能通过其他的Java API来间接使用它，如J.U.C包里面的整数原子类，其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作。下面代码是在<a href="">JVM系列之高效并发-Part1内存模型</a>中的用例场景，现在通过AtomicInteger实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomic变量自增运算测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">race</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        race.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREADS_COUNT</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(THREADS_COUNT);</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>; i1 &lt; <span class="number">10000</span>; i1++) &#123;</span><br><span class="line">                    increase();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下：</span><br><span class="line"></span><br><span class="line"><span class="number">2000000</span></span><br></pre></td></tr></table></figure>

<p>使用AtomicInteger代替int后，程序输出了正确的结果，一切都要归功于incrementAndGet()方法的原子性。</p>
<p>尽管CAS看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，存在这样的一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。<strong>这个漏洞称为CAS操作的ABA问题</strong>。J.U.C包为了解决这个问题，提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类比较“鸡肋”，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。 </p>
<h1 id="2-锁优化"><a href="#2-锁优化" class="headerlink" title="2. 锁优化"></a>2. 锁优化</h1><p>高效并发是从JDK1.5到JDK1.6的一个重要改进，Hotspot虚拟机开发团队在这个版本花费了大量的精力去实现各锁优化技术，如适应性自旋(Adaptive Spinning)、锁消除 (Lock Elmination)、锁粗化(Lock Coarsening)、轻量级锁(LightweightLocking)和偏向锁 (Biased Locking)等，这些技术都是为了在线程之间高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<h2 id="2-1-自旋锁与自适应自旋"><a href="#2-1-自旋锁与自适应自旋" class="headerlink" title="2.1. 自旋锁与自适应自旋"></a>2.1. 自旋锁与自适应自旋</h2><p>前面我们讨论互斥同步的时候，提到了互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时虚拟机的开发团队也注意到在许多应用上，共享数锯的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。 </p>
<p>自旋锁在JDK1.4.2中就已经引入，只不过默认是关闭的，可以使用-XX:+UseSpinning参数来开启，在JDK1.6中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数-XX:PreBlockSpin来更改。 </p>
<p>在JDK1.6中引人了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。 </p>
<h2 id="2-2-锁消除"><a href="#2-2-锁消除" class="headerlink" title="2.2. 锁消除"></a>2.2. 锁消除</h2><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p>
<p>也许读者会有疑问，变量是否逃逸，对于虑拟机来说需要使用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢？答案是有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。我们来看看如下代码片段，这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concatString</span><span class="params">(String s1 , String s2 , String s3)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也知道，由于String是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来进行的，因此Javac编译器会对String连接做自动优化。在JDK1.5之前，会转化为StringBuffer对象的连续append()操作，在JDK1.5及以后的版本中，会转化为StringBuilder对象的连续append()操作，即可能是如下的代码段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concatString</span><span class="params">(String s1 , String s2 , String s3)</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在大家还认为这段代码没有涉及同步吗？每个StringBuffer.append()方法中都有一个同步块，锁就是sb对象。虚拟机观察变量sb，很决就会发现它的动态作用域被限制在concatString()方法内部。也就是说，sb的所有引用永远不会“逃逸”到concatString()方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p>
<h2 id="2-3-锁粗化"><a href="#2-3-锁粗化" class="headerlink" title="2.3. 锁粗化"></a>2.3. 锁粗化</h2><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小————只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。 </p>
<p>大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。 </p>
<p>上面代码中连续的append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，以上述代码为例，就是扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次就可以了。 </p>
<h2 id="2-4-轻量级锁"><a href="#2-4-轻量级锁" class="headerlink" title="2.4. 轻量级锁"></a>2.4. 轻量级锁</h2><p>轻量级锁是JDK1.6之中加人的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 </p>
<p>要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须从HotSpot虚拟机的对象（对象头部分）的内存布局开始介绍。HotSpot虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)，GC分代年龄(Generational GC Age)等，这部分数据的长度在32位和64位的虑拟机中分别为32bit和64bit，官方称它为“Mark Word”，它是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。 </p>
<p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。<strong>如果没有竟争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竟争，除了互斥锁的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢</strong>。</p>
<h2 id="2-5-偏向锁"><a href="#2-5-偏向锁" class="headerlink" title="2.5. 偏向锁"></a>2.5. 偏向锁</h2><p>偏向锁也是JDK1.6中引人的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p>偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡(Trade Off）性质的优化，也就是说，它并不一定总是对程序运行有利，<strong>如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的</strong>。在具体问题具体分析的前提下，有时候使用参数-XX:-UseBiasedLocking来禁止偏向锁优化反而可以提升性能。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>高效并发</tag>
      </tags>
  </entry>
  <entry>
    <title>常用git命令汇总</title>
    <url>/iBlogWebsite/2021/03/19/2021/2021-03-19-%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="1-基础linux命令"><a href="#1-基础linux命令" class="headerlink" title="1. 基础linux命令"></a>1. 基础linux命令</h1><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>清除屏幕</td>
<td>clear</td>
</tr>
<tr>
<td>重新初始化终端</td>
<td>reset</td>
</tr>
<tr>
<td>查看当前目录</td>
<td>pwd</td>
</tr>
<tr>
<td>将当前目录下的子文件&amp;子目录平铺在控制台</td>
<td>ls <br> ls -ll</td>
</tr>
<tr>
<td>往控制台输出信息</td>
<td>echo &#39;test content&#39; <br> echo &#39;test content&#39; &gt; test.txt</td>
</tr>
<tr>
<td>在当前目录下新建一个文件</td>
<td>touch [文件名]</td>
</tr>
<tr>
<td>查看对应文件的内容</td>
<td>cat [文件的url]</td>
</tr>
<tr>
<td>编辑文件</td>
<td>vim [文件的url] <br> &nbsp;&nbsp;- 按i键进入插入模式 <br> &nbsp;&nbsp;- 按esc键进行命令执行 <br> &nbsp;&nbsp;&nbsp;&nbsp;* q! 强制退出(不保存) <br> &nbsp;&nbsp;&nbsp;&nbsp;* wq 保存退出 <br> &nbsp;&nbsp;&nbsp;&nbsp;* set nu 设置行号</td>
</tr>
<tr>
<td>新建文件夹</td>
<td>mkdir [文件目录]</td>
</tr>
<tr>
<td>将对应目录下的子孙文件&amp;子孙目录平铺在控制台</td>
<td>find [目录名]</td>
</tr>
<tr>
<td>将对应目录下的文件平铺在控制台</td>
<td>find [目录名] -typef</td>
</tr>
<tr>
<td>删除文件</td>
<td>rm [文件名]</td>
</tr>
<tr>
<td>删除文件夹</td>
<td>rm -r [文件目录]</td>
</tr>
<tr>
<td>重命名</td>
<td>mv [源文件] [重命名文件]</td>
</tr>
<tr>
<td>查看历史命令</td>
<td>history</td>
</tr>
<tr>
<td>退出</td>
<td>exit</td>
</tr>
</tbody></table>
<h1 id="2-新建仓库"><a href="#2-新建仓库" class="headerlink" title="2. 新建仓库"></a>2. 新建仓库</h1><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>在当前目录新建一个git代码库</td>
<td>git init</td>
</tr>
<tr>
<td>新建一个目录，将其初始化为git代码库</td>
<td>git init [project-name]</td>
</tr>
<tr>
<td>下载一个项目和它到整个代码历史</td>
<td>git clone [url]</td>
</tr>
</tbody></table>
<h1 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h1><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>显示当前的git配置</td>
<td>git config --list</td>
</tr>
<tr>
<td>编辑git配置文件</td>
<td>git config -e [--global]</td>
</tr>
<tr>
<td>设置提交代码时的用户信息</td>
<td>git config [--global] user.name &quot;[name]&quot; <br> git config [--global] user.email &quot;[email address]&quot;</td>
</tr>
</tbody></table>
<h1 id="4-增加-删除文件"><a href="#4-增加-删除文件" class="headerlink" title="4. 增加/删除文件"></a>4. 增加/删除文件</h1><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>添加当前目录的所有文件到暂存区</td>
<td>git add .</td>
</tr>
<tr>
<td>删除工作区文件，并且将这次删除放入暂存区</td>
<td>git rm [file1] [file2] …</td>
</tr>
<tr>
<td>停止追踪指定文件，但该文件会保留在工作区</td>
<td>git rm --cached [file1]</td>
</tr>
<tr>
<td>改名文件，并且将这个改名放入暂存区</td>
<td>git mv [file-original] [file-renamed]</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="5-代码提交"><a href="#5-代码提交" class="headerlink" title="5. 代码提交"></a>5. 代码提交</h1><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>提交暂存区到仓库区</td>
<td>git commit -m [message]</td>
</tr>
<tr>
<td>将已commit过的文件直接提交到仓库区</td>
<td>git commit -a -m [message]</td>
</tr>
<tr>
<td>提交时显示所有diff信息</td>
<td>git commit -v</td>
</tr>
<tr>
<td>使用一次新的commit替代上一次提交 <br> 如果代码没任何变化，则用来改写上一次commit的提交信息</td>
<td>git commit --amend <br> git commit --amend -m [message]</td>
</tr>
<tr>
<td>重做上一次commit，并包括指定文件的新变化</td>
<td>git commit --amend [file1] [file2] …</td>
</tr>
</tbody></table>
<h1 id="6-分支"><a href="#6-分支" class="headerlink" title="6. 分支"></a>6. 分支</h1><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>列出所有本地分支</td>
<td>git branch</td>
</tr>
<tr>
<td>列出所有远程分支</td>
<td>git branch -r</td>
</tr>
<tr>
<td>列出所有本地分支和远程分支</td>
<td>git branch -a</td>
</tr>
<tr>
<td>新建一个分支，但依然停留在当前分支</td>
<td>git branch [branch-name]</td>
</tr>
<tr>
<td>新建一个分支，并切换到该分支</td>
<td>git checkout -b [branch] [commit]</td>
</tr>
<tr>
<td>切换到指定分支，并更新工作区</td>
<td>git checkout [branch-name]</td>
</tr>
<tr>
<td>切换到上一个分支</td>
<td>git checkout -</td>
</tr>
<tr>
<td>合并指定分支到当前分支</td>
<td>git merge [branch]</td>
</tr>
<tr>
<td>选择一个commit合并进当前分支</td>
<td>git cherry-pick [commit]</td>
</tr>
<tr>
<td>删除分支</td>
<td>git branch -d [branch-name]</td>
</tr>
<tr>
<td>强制删除分支，忽略该分支的变化</td>
<td>git branch -D [branch-name]</td>
</tr>
<tr>
<td>删除远程分支</td>
<td>git push origin --delete [branch-name] <br> git branch -dr [remote/branch]</td>
</tr>
</tbody></table>
<h1 id="7-标签"><a href="#7-标签" class="headerlink" title="7. 标签"></a>7. 标签</h1><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>列出所有tag</td>
<td>git tag</td>
</tr>
<tr>
<td>在当前commit新建一个tag</td>
<td>git tag [tag]</td>
</tr>
<tr>
<td>在指定commit新建一个tag</td>
<td>git tag [tag] [commit]</td>
</tr>
<tr>
<td>删除本地tag</td>
<td>git tag -d [tag]</td>
</tr>
<tr>
<td>删除远程tag</td>
<td>git push origin :refs/tags/[tagName]</td>
</tr>
<tr>
<td>查看tag信息</td>
<td>git show [tag]</td>
</tr>
<tr>
<td>提交指定tag</td>
<td>git push [remote] [tag]</td>
</tr>
<tr>
<td>提交所有tag</td>
<td>git push [remote] --tags</td>
</tr>
<tr>
<td>新建一个分支，指向某个tag</td>
<td>git checkout -b [branch] [tag]</td>
</tr>
</tbody></table>
<h1 id="8-查看信息"><a href="#8-查看信息" class="headerlink" title="8. 查看信息"></a>8. 查看信息</h1><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>显示有变更的文件</td>
<td>git status</td>
</tr>
<tr>
<td>显示当前分支的历史版本 <br> 原则是递归当前指针的父亲，父亲的父亲</td>
<td>git log</td>
</tr>
<tr>
<td>查看HEAD所指向的一个顺序提交列表 <br> reflog不遍历HEAD的祖先</td>
<td>git reflog</td>
</tr>
<tr>
<td>显示commit历史以及每次commit发生变更的文件</td>
<td>git log --stat</td>
</tr>
<tr>
<td>查看远程分支的日志</td>
<td>git log remotes/origin/[branchName]</td>
</tr>
<tr>
<td>以图表形式显示分支和提交信息</td>
<td>git log --all --decorate --oneline --graph</td>
</tr>
<tr>
<td>根据关键词搜索提交历史</td>
<td>git log -S [keyword]</td>
</tr>
<tr>
<td>显示过去5次提交</td>
<td>git log -5 --oneline</td>
</tr>
<tr>
<td>显示所有提交过的用户，按提交次数排序</td>
<td>git shortlog -sn</td>
</tr>
<tr>
<td>显示指定文件是什么人在什么时间修改过</td>
<td>git blame [file]</td>
</tr>
<tr>
<td>显示暂存区和工作区的差异</td>
<td>git diff</td>
</tr>
<tr>
<td>显示暂存区和上一个commit的差异</td>
<td>git diff --cached [file]</td>
</tr>
<tr>
<td>显示工作区与当前分支最新commit之间的差异</td>
<td>git diff HEAD</td>
</tr>
<tr>
<td>显示两次提交之间的差异</td>
<td>git diff [first-branch]…[second-branch]</td>
</tr>
<tr>
<td>显示已被修改的文件已被暂存但还未提交</td>
<td>git diff --staged</td>
</tr>
</tbody></table>
<h1 id="9-远程同步"><a href="#9-远程同步" class="headerlink" title="9. 远程同步"></a>9. 远程同步</h1><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>下载远程仓库的所有变动</td>
<td>git fetch [remote]</td>
</tr>
<tr>
<td>显示所有远程仓库</td>
<td>git remote -v</td>
</tr>
<tr>
<td>显示某个远程仓库的信息</td>
<td>git remote show [remote]</td>
</tr>
<tr>
<td>增加一个新的远程仓库并命名</td>
<td>git remote add [shortname] [url]</td>
</tr>
<tr>
<td>取回远程仓库的所有变化并与本地分支合并</td>
<td>git pull [remote] [branch]</td>
</tr>
<tr>
<td>上传本地指定分支到远程仓库</td>
<td>git push [remote] [branch] <br> git push [remote] HEAD:[current_branch_name]</td>
</tr>
<tr>
<td>强行推送当前分支到远程仓库，即使有冲突</td>
<td>git push [remote] –force</td>
</tr>
<tr>
<td>推送所有分支到远程仓库</td>
<td>git push [remote] --all</td>
</tr>
</tbody></table>
<h1 id="10-撤销"><a href="#10-撤销" class="headerlink" title="10. 撤销"></a>10. 撤销</h1><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>恢复暂存区的指定文件到工作区</td>
<td>git checkout [file]</td>
</tr>
<tr>
<td>恢复某个commit的指定文件到暂存区和工作区</td>
<td>git checkout [commit] [file]</td>
</tr>
<tr>
<td>恢复暂存区的所有文件到工作区</td>
<td>git checkout .</td>
</tr>
<tr>
<td>重置暂存区的指定文件，与上一次commit保持一致 <br> 但工作区不变（即只动暂存区的内容，针对指定文件重置）</td>
<td>git reset [file] <br> git reset --mixed HEAD [file]</td>
</tr>
<tr>
<td>重置暂存区与工作区，与上一次commit保持一致</td>
<td>git reset --hard</td>
</tr>
<tr>
<td>重置当前分支的HEAD为指定commit <br> 同时重置暂存区和工作区，与指定commit一致</td>
<td>git reset --hard [commit]</td>
</tr>
<tr>
<td>重置当前HEAD为指定commit，但保持暂存区和工作区不变</td>
<td>git reset --keep [commit]</td>
</tr>
<tr>
<td>新建一个commit，用来撤销指定commit <br> 后者的所有变化都将被前者抵消，并且应用到当前分支</td>
<td>git revert [commit]</td>
</tr>
</tbody></table>
<h1 id="11-存储"><a href="#11-存储" class="headerlink" title="11. 存储"></a>11. 存储</h1><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>将未完成的修改保存到一个栈上</td>
<td>git stash</td>
</tr>
<tr>
<td>应用上一次的存储</td>
<td>git stash apply</td>
</tr>
<tr>
<td>查看存储</td>
<td>git stash list</td>
</tr>
<tr>
<td>应用指定的存储</td>
<td>git stash apply [stash@{2}]</td>
</tr>
<tr>
<td>移除指定的存储</td>
<td>git stash drop [stash@{0}]</td>
</tr>
<tr>
<td>应用指定的存储然后将其出栈</td>
<td>git stash pop [stash@{0}]</td>
</tr>
</tbody></table>
<h1 id="12-git底层命令"><a href="#12-git底层命令" class="headerlink" title="12. git底层命令"></a>12. git底层命令</h1><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>查看存储对象的内容</td>
<td>git cat-file -p [commithash]</td>
</tr>
<tr>
<td>查看存储对象的类型</td>
<td>git cat-file -t [commithash]</td>
</tr>
<tr>
<td>查看暂存区内容</td>
<td>git ls-files -s</td>
</tr>
<tr>
<td>查看暂存区是否有文件</td>
<td>find .git/objects/ -type f</td>
</tr>
<tr>
<td>生成git对象并写进数据库</td>
<td>git hash-object -w [filename]</td>
</tr>
<tr>
<td>更新暂存区</td>
<td>git update-index --add --cacheinfo</td>
</tr>
<tr>
<td>生成树对象</td>
<td>git write-tree</td>
</tr>
<tr>
<td>生成commit对象</td>
<td>git commit-trees</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列之大纲整理</title>
    <url>/iBlogWebsite/2021/04/02/2021/2021-04-02-JVM%E7%B3%BB%E5%88%97%E5%A4%A7%E7%BA%B2%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2021/wallpaper/2021-04-02.jpg?raw=true" alt="2021-04-02"></p>
<p>这是JVM系列的第一篇，所以简单介绍下该系列的大纲，如下图所示：</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2018/code/jvm-outline.png?raw=true" alt="jvm-outline"></p>
<p>该系列文章绝大部分的素材来源是《深入理解Java虚拟机2》这本书，整个系列可以看做是学习笔记，自己是先通读了一遍该书，然后整理脑图，按照上面的大纲再逐篇整理。主要目的是理解虚拟机中一些高深又晦涩的概念，以及虚拟机底层运行的一些基本“常识”，打好这块的基础，以便后续更容易掌握Android平台上的热修复、插件化以及Hook技术等的一些原理。</p>
<p><a href="https://leeeyou.github.io/iBlogWebsite/2018/09/14/2018/2018-09-14-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/">JVM系列之内存区域</a></p>
<p><a href="https://leeeyou.github.io/iBlogWebsite/2018/09/15/2018/2018-09-15-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part1%E5%88%9B%E5%BB%BA/">JVM系列之对象-Part1创建</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2018/09/17/2018/2018-09-17-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part2%E5%B8%83%E5%B1%80/">JVM系列之对象-Part2布局</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2018/09/18/2018/2018-09-18-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part3%E5%AE%9A%E4%BD%8D/">JVM系列之对象-Part3定位</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2018/09/19/2018/2018-09-19-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part4%E6%98%AF%E5%90%A6%E8%BF%98%E6%B4%BB%E7%9D%80%EF%BC%9F/">JVM系列之对象-Part4是否还活着？</a></p>
<p><a href="https://leeeyou.github.io/iBlogWebsite/2018/09/25/2018/2018-09-25-JVM%E7%B3%BB%E5%88%97%E4%B9%8BGC-Part1%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/">JVM系列之GC-Part1收集算法</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2018/09/25/2018/2018-09-25-JVM%E7%B3%BB%E5%88%97%E4%B9%8BGC-Part2%E6%94%B6%E9%9B%86%E5%99%A8/">JVM系列之GC-Part2收集器</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2018/09/26/2018/2018-09-26-JVM%E7%B3%BB%E5%88%97%E4%B9%8BGC-Part3GC%E5%88%86%E7%B1%BB/">JVM系列之GC-Part3GC分类</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2018/09/26/2018/2018-09-26-JVM%E7%B3%BB%E5%88%97%E4%B9%8BGC-Part4%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/">JVM系列之GC-Part4内存分配与回收策略</a></p>
<p><a href="https://leeeyou.github.io/iBlogWebsite/2018/09/27/2018/2018-09-27-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD-Part1%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">JVM系列之类加载-Part1类文件结构</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2018/10/09/2018/2018-10-09-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD-Part2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">JVM系列之类加载-Part2类加载机制</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2018/10/10/2018/2018-10-10-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD-Part3%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/">JVM系列之类加载-Part3字节码执行引擎</a></p>
<p><a href="https://leeeyou.github.io/iBlogWebsite/2018/11/08/2018/2018-11-08-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91-Part1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">JVM系列之高效并发-Part1内存模型</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2018/11/12/2018/2018-11-12-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91-Part2%E7%BA%BF%E7%A8%8B/">JVM系列之高效并发-Part2Java与线程</a><br><a href="https://leeeyou.github.io/iBlogWebsite/2018/11/13/2018/2018-11-13-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91-Part3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">JVM系列之高效并发-Part3线程安全与锁优化</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Jetpack组件实战</title>
    <url>/iBlogWebsite/2021/07/26/2021/2021-07-26-Android%20Jetpack%E7%BB%84%E4%BB%B6%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2021/code/iSplash-version-1.gif?raw=true" alt="iSplash-version-1"></p>
<h2 id="iSplash项目首个版本"><a href="#iSplash项目首个版本" class="headerlink" title="iSplash项目首个版本"></a><a href="https://github.com/Leeeyou/iSplash.git">iSplash项目首个版本</a></h2><p>技术栈 : LifeCycle + LiveData + ViewModel + Coroutine + Navigation + Kotlin</p>
<h3 id="1-一个完整的网络加载流程是怎样的？"><a href="#1-一个完整的网络加载流程是怎样的？" class="headerlink" title="1. 一个完整的网络加载流程是怎样的？"></a>1. 一个完整的网络加载流程是怎样的？</h3><p>以拿取最新照片列表为例</p>
<ol>
<li>MainActivity -&gt; MainFragment -&gt; LatestPhotosFragment</li>
<li>在LatestPhotosFragment中创建LatestPhotoViewModel实例，通过LatestPhotoViewModel实例内部的LiveData观察数据变化，只要数据一更新UI就能即时被刷新</li>
<li>obtainLatestPhotoList函数内部就涉及到了LiveData、ViewModel、Coroutine的结合<ul>
<li>LiveData与ViewModel的结合：在ViewModel中使用LiveData包装数据，达到实时监控数据变化，实时更新UI的目的</li>
<li>ViewModel与Coroutine的结合：在ViewModel中访问suspend函数，并将结果更新到LiveData数据中</li>
</ul>
</li>
</ol>
<span id="more"></span>

<h3 id="2-MVVM架构图"><a href="#2-MVVM架构图" class="headerlink" title="2. MVVM架构图"></a>2. MVVM架构图</h3><ol>
<li><p>常规mvvm<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/MVVMPattern.png/660px-MVVMPattern.png" alt="常规mvvm"></p>
</li>
<li><p>Android下推荐的mvvm结构 </p>
</li>
</ol>
<p><img src="https://developer.android.com/topic/libraries/architecture/images/final-architecture.png?hl=zh-cn" alt="mvvm"></p>
<ol start="3">
<li>mvvm优劣势<ul>
<li>优势：解耦更彻底，不会像mvc一样造成Activity代码量巨大，也不会像mvp一样出现大量的presenter与view层的交互接口。双向绑定技术使得ViewModel更加关注业务逻辑的处理，而不需要去关心ui的刷新</li>
<li>劣势：数据绑定使得bug很难被调试，双向绑定技术不利于代码重用</li>
</ul>
</li>
</ol>
<h3 id="3-LifeCycle"><a href="#3-LifeCycle" class="headerlink" title="3. LifeCycle"></a>3. LifeCycle</h3><ol>
<li>官网文档链接：<a href="https://developer.android.com/topic/libraries/architecture/lifecycle?hl=zh-cn">https://developer.android.com/topic/libraries/architecture/lifecycle?hl=zh-cn</a></li>
<li>是什么？<ul>
<li>生命周期感知型组件，可感知另一个组件（如Activity和Fragment）的生命周期状态变化，并执行相应操作来做出响应</li>
</ul>
</li>
<li>为什么？<ul>
<li>传统模式下，过多代码放在生命周期方法中会导致Activity和Fragment中生命周期方法臃肿难以维护，条理性变差且不利于阅读</li>
<li>通过LifeCycle，我们可以将代码从生命周期方法移到组件本身中，针对不同场景可以注册多个观察者，让同一场景的事件处于同一观察者中，这样更便于后续维护，同时提示代码的阅读性，让代码相对优雅</li>
</ul>
</li>
<li>怎么做？<ul>
<li>implementation(“androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version”)</li>
<li>生命周期拥有者LifecycleOwner，即Activity和Fragment，ComponentActivity和Fragment都已实现了LifecycleOwner</li>
<li>生命周期观察者LifecycleObserver，可以是任意类，常见的有MVP中的p，自定义view等。主要分两步，首先创建一个Observer，然后添加到LifeCycle中  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➡️ State</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    DESTROYED, <span class="comment">// 0</span></span><br><span class="line">    INITIALIZED, <span class="comment">// 1</span></span><br><span class="line">    CREATED, <span class="comment">// 2</span></span><br><span class="line">    STARTED, <span class="comment">// 3</span></span><br><span class="line">    RESUMED; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAtLeast</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObserver</span> : LifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    fun <span class="title function_">connectListener</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    fun <span class="title function_">disconnectListener</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myLifecycleOwner.getLifecycle().addObserver(MyObserver())</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>原理是什么？<ul>
<li>LifeCycle组件实际上并没有带来什么新的功能，它通过 <strong>观察者模式+注解</strong> 让我们更方便的监听Activity和Fragment的生命周期变化。这种观察者模式的源码分析其实抓住两点即可：生产事件和消耗事件，对应这里就是Activity和Fragment生命周期变化时就是事件产生地，消耗事件就是我们设置的observer监听某些关心的生命周期。下面我们就从这两个切入点开始分析：</li>
<li>生产事件：AppCompatActivity - FragmentActivity | mFragmentLifecycleRegistry 会在每个生命周期方法中调起相应事件</li>
<li>具体调用链：<strong>FragmentActivity</strong> - <strong>mFragmentLifecycleRegistry</strong> - 相应生命周期方法 - handleLifecycleEvent - <strong>LifecycleRegistry|forwardPass</strong> - dispatchEvent - mLifecycleObserver.onStateChanged<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➡️ FragmentActivity</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➡️ LifecycleRegistry</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLifecycleEvent</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">    enforceMainThreadIfNeeded(<span class="string">&quot;handleLifecycleEvent&quot;</span>);</span><br><span class="line">    moveToState(event.getTargetState());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➡️ LifecycleRegistry</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LifecycleOwner</span> <span class="variable">lifecycleOwner</span> <span class="operator">=</span> mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;LifecycleOwner of this LifecycleRegistry is already&quot;</span></span><br><span class="line">                + <span class="string">&quot;garbage collected. It is too late to change lifecycle state.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较订阅队列中最老和最新订阅者的状态是否一致，以此来判断状态是否同步完毕</span></span><br><span class="line">    <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 判断订阅队列中最老订阅者其状态如果大于当前状态，则更新该订阅者的状态为当前状态</span></span><br><span class="line">        <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            backwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">        Map.Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">        <span class="comment">// 判断订阅队列中最新订阅者其状态如果小于当前状态，则更新该订阅者的状态为当前状态</span></span><br><span class="line">        <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            forwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNewEventOccurred = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➡️ ObserverWithState</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> &#123;</span><br><span class="line">    <span class="type">State</span> <span class="variable">newState</span> <span class="operator">=</span> event.getTargetState();</span><br><span class="line">    mState = min(mState, newState);</span><br><span class="line">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">    mState = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消耗事件：回调相对简单，就是在LifecycleEventObserver的实现中处理相应事件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是普通方式，监听所有的事件</span></span><br><span class="line">lifecycle.addObserver(object : LifecycleEventObserver &#123;</span><br><span class="line">  override fun <span class="title function_">onStateChanged</span><span class="params">(source: LifecycleOwner, event: Lifecycle.Event)</span> &#123;</span><br><span class="line">      d(</span><br><span class="line">          <span class="string">&quot;$&#123;event.targetState.name&#125; &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;$&#123;event.targetState.ordinal&#125; &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;$&#123;event.targetState.compareTo(Lifecycle.State.RESUMED)&#125;&quot;</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      when (event.targetState) &#123;</span><br><span class="line">          Lifecycle.State.CREATED -&gt; &#123;</span><br><span class="line">              d(<span class="string">&quot;CREATED&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          Lifecycle.State.STARTED -&gt; &#123;</span><br><span class="line">              d(<span class="string">&quot;STARTED&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          Lifecycle.State.RESUMED -&gt; &#123;</span><br><span class="line">              d(<span class="string">&quot;RESUMED&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          Lifecycle.State.DESTROYED -&gt; &#123;</span><br><span class="line">              d(<span class="string">&quot;DESTROYED&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">              d(<span class="string">&quot;ELSE&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>注解方式源码分析：上面通过addObserver注册观察者时，会将传入的LifecycleObserver包装成ObserverWithState，进而再次包装成ReflectiveGenericLifecycleObserver，它里面的onStateChanged会反射调用目标方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是注解方式，可方便的筛选自己关心的事件</span></span><br><span class="line">lifecycle.addObserver(object : LifecycleObserver &#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">    fun <span class="title function_">onA</span><span class="params">()</span> &#123;</span><br><span class="line">        d(<span class="string">&quot;onStart&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    fun <span class="title function_">onB</span><span class="params">()</span> &#123;</span><br><span class="line">        d(<span class="string">&quot;onResume&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    fun <span class="title function_">onC</span><span class="params">()</span> &#123;</span><br><span class="line">        d(<span class="string">&quot;onStop&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class="line">    fun <span class="title function_">onD</span><span class="params">()</span> &#123;</span><br><span class="line">        d(<span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">➡️ LifecycleRegistry</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> &#123;</span><br><span class="line">  enforceMainThreadIfNeeded(<span class="string">&quot;addObserver&quot;</span>);</span><br><span class="line">  <span class="type">State</span> <span class="variable">initialState</span> <span class="operator">=</span> mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">  <span class="comment">// 将observer包装成ObserverWithState</span></span><br><span class="line">  <span class="type">ObserverWithState</span> <span class="variable">statefulObserver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverWithState</span>(observer, initialState);</span><br><span class="line">  <span class="type">ObserverWithState</span> <span class="variable">previous</span> <span class="operator">=</span> mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➡️ ReflectiveGenericLifecycleObserver</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectiveGenericLifecycleObserver</span> <span class="keyword">implements</span> <span class="title class_">LifecycleEventObserver</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object mWrapped;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CallbackInfo mInfo;</span><br><span class="line"></span><br><span class="line">  ReflectiveGenericLifecycleObserver(Object wrapped) &#123;</span><br><span class="line">      mWrapped = wrapped;</span><br><span class="line">      mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source, <span class="meta">@NonNull</span> Event event)</span> &#123;</span><br><span class="line">      <span class="comment">// 反射调用目标方法</span></span><br><span class="line">      mInfo.invokeCallbacks(source, event, mWrapped);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➡️ ClassesInfoCache</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">invokeCallback</span><span class="params">(LifecycleOwner source, Lifecycle.Event event, Object target)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (mCallType) &#123;</span><br><span class="line">          <span class="keyword">case</span> CALL_TYPE_NO_ARG:</span><br><span class="line">              <span class="comment">// 反射调用目标方法</span></span><br><span class="line">              mMethod.invoke(target);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> CALL_TYPE_PROVIDER:</span><br><span class="line">              mMethod.invoke(target, source);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> CALL_TYPE_PROVIDER_WITH_EVENT:</span><br><span class="line">              mMethod.invoke(target, source, event);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to call observer method&quot;</span>, e.getCause());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="4-LiveData"><a href="#4-LiveData" class="headerlink" title="4. LiveData"></a>4. LiveData</h3><ul>
<li><p>官网文档链接：<a href="https://developer.android.com/topic/libraries/architecture/livedata?hl=zh-cn">https://developer.android.com/topic/libraries/architecture/livedata?hl=zh-cn</a></p>
</li>
<li><p>是什么？</p>
<p>LiveData是具有生命周期感知能力的数据存储器类，能遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期，而这种感知能力可确保LiveData仅更新处于活跃生命周期状态的应用组件观察者。</p>
</li>
<li><p>为什么？</p>
<ul>
<li>因为界面状态随时变化，每当这种情况出现时，LiveData会完成数据的更新。</li>
<li>因为绑定了LifeCycle关联了生命周期，在生命周期组件销毁后观察者会进行自我清理。同时如果观察者的生命周期处于非活跃状态，则它不会接收任何LiveData事件，不会因为Activity停止而导致崩溃。</li>
</ul>
</li>
<li><p>怎么做？</p>
<ul>
<li>implementation(“androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version”)</li>
<li>通过LiveData setValue和postValue 更新数据</li>
<li>通过observe(LifecycleOwner owner, Observer&lt;? super T&gt; observer)观察数据变化，就是这个owner使得LiveData可以感知到生命周期</li>
<li>可以单独使用LiveData，但更常用的做法是结合ViewModel；可以利用Transformations将LiveData数据【展开 - map】或者【转换 - switchMap】；可以利用MediatorLiveData合并多个LiveData源，任一源变化都会出发数据更新回调；最后可以结合kt协程来处理耗时任务。详情参考 <a href="https://github.com/Leeeyou/SampleOfLivedata.git">SampleLiveData</a></li>
</ul>
</li>
<li><p>原理是什么？</p>
<ul>
<li>观察者模式+LifeCycle，内部通过SafeIterableMap集合维护了观察者列表，当有数据更新时，会遍历map集合通知观察者回调其onChanged函数</li>
<li>注册观察者：LiveData|observe <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➡️ LiveData</span><br><span class="line"><span class="keyword">private</span> SafeIterableMap&lt;Observer&lt;? <span class="built_in">super</span> T&gt;, ObserverWrapper&gt; mObservers =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SafeIterableMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="built_in">super</span> T&gt; observer)</span> &#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LifecycleBoundObserver</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleBoundObserver</span>(owner, observer);</span><br><span class="line">    <span class="type">ObserverWrapper</span> <span class="variable">existing</span> <span class="operator">=</span> mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>更新数据：LiveData | setValue | dispatchingValue | considerNotify <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➡️ LiveData</span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">    mVersion++;</span><br><span class="line">    mData = value;</span><br><span class="line">    dispatchingValue(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="literal">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="built_in">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">considerNotify</span><span class="params">(ObserverWrapper observer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5-ViewModel"><a href="#5-ViewModel" class="headerlink" title="5. ViewModel"></a>5. ViewModel</h3><ul>
<li><p>官网文档链接：<a href="https://developer.android.com/topic/libraries/architecture/viewmodel?hl=zh-cn">https://developer.android.com/topic/libraries/architecture/viewmodel?hl=zh-cn</a></p>
</li>
<li><p>是什么？</p>
<p> 以注重生命周期的方式存储和管理界面相关的数据</p>
</li>
<li><p>为什么？</p>
<ul>
<li>为Activity和Fragment减负，将跟界面相关的数据全部委托给ViewModel来负责。典型应用场景是屏幕旋转，耗时任务异步回调</li>
<li>接管界面控制器中（Activity、Fragment），分离出视图数据所有权，使得界面数据的管理更加容易和高效</li>
</ul>
</li>
<li><p>怎么做？</p>
<ul>
<li><p>implementation(“androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version”)</p>
</li>
<li><p>怎么创建？</p>
<ul>
<li>便捷方式：private val viewModel: LatestPhotoViewModel by viewModels()</li>
<li>最终通过：ViewModelProvider(store, factory).get(viewModelClass.java)</li>
</ul>
</li>
<li><p>实操：实现一个定时器，在页面横竖屏切换时保留数值并继续计时，详情参考<a href="https://github.com/Leeeyou/SampleOfLivedata/blob/master/app/src/main/java/com/leeeyou123/samplelivedata/ViewModelActivity.kt">SampleLiveData</a></p>
</li>
<li><p>将Kotlin协程与架构组件一起使用</p>
<ul>
<li>对于ViewModelScope，使用androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0或更高版本<ul>
<li>为应用中的每个ViewModel定义了ViewModelScope。如果ViewModel已清除，则在此范围内启动的协程都会自动取消</li>
</ul>
</li>
<li>对于LifecycleScope，使用androidx.lifecycle:lifecycle-runtime-ktx:2.2.0或更高版本<ul>
<li>为每个Lifecycle对象定义了LifecycleScope。在此范围内启动的协程会在Lifecycle被销毁时取消</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原理是什么？</p>
<ul>
<li>首先ViewModel生命周期<br><img src="https://developer.android.com/images/topic/libraries/architecture/viewmodel-lifecycle.png?hl=zh_cn" alt="ViewModel生命周期"></li>
<li>存储原理<ul>
<li>创建ViewModel的流程上面已经提到过是通过ViewModelProvider | get，ViewModel则保存在ViewModelStore的mMap集合中，key是canonicalName，value是ViewModel实例，ViewModelStore是ViewModel的缓存管理者<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➡️ ViewModelProvider</span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="type">ViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> mViewModelStore.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> OnRequeryFactory) &#123;</span><br><span class="line">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> KeyedFactory) &#123;</span><br><span class="line">        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewModel = mFactory.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ViewModelStore实例化的切入点：ComponentActivity的构造函数中会创建ViewModelStore实例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➡️ ComponentActivity</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ComponentActivity</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">LifecycleEventObserver</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">              <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">          ensureViewModelStore();</span><br><span class="line">          getLifecycle().removeObserver(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>销毁原理<ul>
<li>从上层来看，对于ViewModel是回调onCleared函数进行销毁<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➡️ ViewModel</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCleared</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    mCleared = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mBagOfTags != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBagOfTags) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object value : mBagOfTags.values()) &#123;</span><br><span class="line">                closeWithRuntimeException(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onCleared();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>从内部来看，实际上是利用Lifecycle监听ON_DESTROY状态，然后调用ViewModelStore的clear方法将mMap清空<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➡️ ComponentActivity</span><br><span class="line"><span class="title function_">getLifecycle</span><span class="params">()</span>.addObserver(<span class="keyword">new</span> <span class="title class_">LifecycleEventObserver</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">            <span class="comment">// Clear out the available context</span></span><br><span class="line">            mContextAwareHelper.clearAvailableContext();</span><br><span class="line">            <span class="comment">// And clear the ViewModelStore</span></span><br><span class="line">            <span class="keyword">if</span> (!isChangingConfigurations()) &#123;</span><br><span class="line">                getViewModelStore().clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">➡️ ViewModelStore</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">        vm.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    mMap.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title>⎡稳扎稳打系列⎦：Handler机制全面解析1(1/3)</title>
    <url>/iBlogWebsite/2021/12/01/2021/2021-12-01-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%901/</url>
    <content><![CDATA[<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2021/wallpaper/2021-12-01-david-marcu-78A265wPiO4-unsplash.webp?raw=true" alt="2021-12-01"></p>
<h1 id="1-Handler的运行机制"><a href="#1-Handler的运行机制" class="headerlink" title="1. Handler的运行机制"></a>1. Handler的运行机制</h1><p>Handler的主要作用是将一个任务切换到某个指定的线程中去执行，常见的就是在子线程中发消息通知主线程更新UI。通过Handler发送消息到处理消息的过程，从应用层来看很简单(但其实底层有完善的机制作为支撑)，所以我们就从sendMessage入手开始分析。</p>
<p>无论Handler通过post还是sendMessage发消息，最终都会来到sendMessageAtTime，接着调用MessageQueue的enqueueMessage将Message消息按照执行时间入队列。另一边Looper的loop是个死循环，会不停的问MessageQueue要新消息，等拿到消息后会通过dispatchMessage进行分发，此时就将消息切换到了创建Looper所在的线程中执行，最后来到Handler的handleMessage中。</p>
<span id="more"></span>

<p>下图详细描述了Handler的运行机制，从左到右，从工作线程到UI线程</p>
<p><img src="https://github.com/Leeeyou/iBlogWebsite/blob/master/images/2021/code/2021-12-01-Handler-operating-mechanism.png?raw=true" alt="2021-12-01-Handler-operating-mechanism"></p>
<h2 id="1-1-ActivityThread、Handler、Looper、MessageQueue之间关系"><a href="#1-1-ActivityThread、Handler、Looper、MessageQueue之间关系" class="headerlink" title="1.1 ActivityThread、Handler、Looper、MessageQueue之间关系"></a>1.1 ActivityThread、Handler、Looper、MessageQueue之间关系</h2><p>在同一个线程中，它们之间的对应关系比如下表</p>
<table>
<thead>
<tr>
<th align="center">比较对象</th>
<th align="center">对应关系</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Thread - Handler</td>
<td align="center">1:n</td>
</tr>
<tr>
<td align="center">Thread - Looper</td>
<td align="center">1:1</td>
</tr>
<tr>
<td align="center">Thread - MessageQueue</td>
<td align="center">1:1</td>
</tr>
<tr>
<td align="center">⬇</td>
<td align="center">⬇</td>
</tr>
<tr>
<td align="center">Handler - Looper</td>
<td align="center">n:1</td>
</tr>
<tr>
<td align="center">Handler - MessageQueue</td>
<td align="center">n:1</td>
</tr>
</tbody></table>
<p>那系统是怎样保证这种对应关系的呢？想要了解这个问题，我们从ActivityThread主线程的main函数着手分析。ActivityThread是android应用的主线程，在main函数里面会开启主线程的Looper无限循环，以响应系统和用户的各类消息事件。</p>
<p><strong>frameworks/base/core/java/android/app/ActivityThread.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper(); <span class="comment">// 创建主线程Looper对象</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Looper.loop(); <span class="comment">// 开启主线程的消息循环且是个死循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>frameworks/base/core/java/android/os/Looper.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal数据结构，用于隔离其他线程，提供线程内的局部变量</span></span><br><span class="line"><span class="comment">// 注意这里sThreadLocal是静态不可变类型的，隶属于类级别</span></span><br><span class="line"><span class="comment">// 在同一进程中仅有一份sThreadLocal对象，而它将会被用做key保存到当前线程的ThreadLocalMap中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">false</span>);  <span class="comment">// 如有必要则创建Looper对象，且保存到ThreadLocal中</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper(); <span class="comment">// 从ThreadLocal中获取对象并赋值给sMainLooper</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>frameworks/base/core/java/android/os/Looper.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果looper对象已存在，则抛异常，不可重复创建</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则创建新的looper对象保存到ThreadLocal中</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>frameworks/base/core/java/android/os/Looper.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper(); <span class="comment">// 获取looper对象</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123; <span class="comment">// 如果对象为空则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (me.mInLoop) &#123; <span class="comment">// 如果重复调用则抛出异常</span></span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">                + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="literal">true</span>; <span class="comment">// 置标记位true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 开启死循环</span></span><br><span class="line">        <span class="comment">// 轮询一次MQ，如果返回false表明退出消息循环，即退出App；</span></span><br><span class="line">        <span class="comment">// 如果返回true表明继续死循环</span></span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>frameworks/base/core/java/android/os/Handler.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    mLooper = looper; <span class="comment">// 通过Looper.myLooper()获取当前线程的looper对象</span></span><br><span class="line">    mQueue = looper.mQueue; <span class="comment">// 通过looper对象获取MessageQueue对象</span></span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码分析了主线程中准备Looper到开启Looper死循环的全过程，每个App开启后只有一个ActivityThread主线程，但我们可以随意创建Handler对象，其实也很好理解，不同模块创建不同的Handler，所以ActivityThread:Handler是1:n的关系。</p>
<p>在prepareMainLooper阶段系统会依赖ThreadLocal保证looper对象在线程中的唯一性，重复调用prepare会抛出异常，所以ActivityThread:Looper是1:1的关系。</p>
<p>再看下Handler的构造函数源码，里面通过Looper的静态方法myLooper获取当前线程的looper对象，再通过该对象获取MessageQueue对象，而looper对象是线程唯一的，所以通过该对象获取到的MQ对象也是线程唯一的，因此ActivityThread:MessageQueue是1:1的关系。</p>
<p><strong>综上ActivityThread:Looper:MessageQueue:Handler是1:1:1:n的关系</strong>，有关ThreadLocal隔离线程保证唯一性的原理，参考<a href="https://leeeyou.github.io/iBlogWebsite/2017/04/14/2017/2017-04-14-Java%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/#15-ThreadLocal">[Java之基础知识汇总-15-ThreadLocal]</a></p>
<h2 id="1-2-Message的类型"><a href="#1-2-Message的类型" class="headerlink" title="1.2 Message的类型"></a>1.2 Message的类型</h2><p>Handler消息类型总共有三类，分别是同步消息、异步消息、消息屏障。</p>
<p>平时通过sendMessage或者post发出的消息都是同步消息，如果想发送异步消息，可以通过Message的setAsynchronous方法设置，源码如下：</p>
<p><strong>frameworks/base/core/java/android/os/Message.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAsynchronous</span><span class="params">(<span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        flags |= FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags &amp;= ~FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>frameworks/base/core/java/android/app/ActivityThread.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="type">int</span> what, Object obj, <span class="type">int</span> arg1, <span class="type">int</span> arg2, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>); <span class="comment">// 标记为异步消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三类是消息屏障，这个比较特殊，屏障是用于阻挡某个东西的，放在这里就是阻隔同步类型的消息，在应用层想要发出消息屏障需通过反射，因为该方法标记为hide。添加完消息屏障后会返回一个token，要移除消息屏障需依赖该token。源码如下：</p>
<p><strong>frameworks/base/core/java/android/os/MessageQueue.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">()</span> &#123; <span class="comment">// post消息屏障，返回token</span></span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">(<span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        msg.markInUse(); <span class="comment">// 标记为正在使用中，这里的开发方式值得借鉴</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token; <span class="comment">// 注意这里没有赋值target</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123; <span class="comment">// 如有必要按照when的先后顺序插入消息屏障</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token; <span class="comment">// 返回token</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeSyncBarrier</span><span class="params">(<span class="type">int</span> token)</span> &#123;</span><br><span class="line">    <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">    <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="comment">// 找到 target == null 的消息屏障，再比对token是否相同</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; (p.target != <span class="literal">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重复删除会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The specified message queue synchronization &quot;</span></span><br><span class="line">                    + <span class="string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种类型都介绍完毕了，在系统中它们是怎么运作起来的？这个直接看MessageQueue的next方法：</p>
<p><strong>frameworks/base/core/java/android/os/MessageQueue.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis); <span class="comment">// native层轮询一次MQ</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="comment">// 检查是否为消息屏障，是的话则会阻挡后续同步消息的执行</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123; </span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 记录消息屏障消息或者消息屏障期间第1条异步消息的前一条消息</span></span><br><span class="line">                    prevMsg = msg; </span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous()); <span class="comment">// 消息屏障期间，获取第1条异步消息执行</span></span><br><span class="line">                <span class="comment">// 消息屏障期间，如果没有异步消息，则msg最终会为null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;  </span><br><span class="line">                        <span class="comment">// 有消息屏障的情况下，将异步消息msg后面的消息接到prevMsg的next</span></span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                        <span class="comment">// 否则，将mMessages直接指向下一个消息</span></span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg; <span class="comment">// 返回消息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是消息屏障期间，消息队列不存在异步消息，同步消息是没机会执行的</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完next函数后，可以看出Handler机制中利用Message的target是否为null来标识当前消息是否为消息屏障，如果是消息屏障，则会从消息队列中找第一条异步消息执行，如果没找到则会一直死循环，直到消息屏障被移除或者异步消息到来。如果没有消息屏障，同步消息与异步消息没有什么区别。</p>
<p>消息屏障的作用可以看作是目前有一些紧急消息、优先级高的消息需要先执行，那么系统可以利用该屏障来发一些异步消息，让同步消息暂停一下，先跑一跑异步消息，优先响应“紧急事件”，完成消息的“插队执行”。</p>
<h2 id="1-3-消息分发回调的优先级是怎样的？"><a href="#1-3-消息分发回调的优先级是怎样的？" class="headerlink" title="1.3 消息分发回调的优先级是怎样的？"></a>1.3 消息分发回调的优先级是怎样的？</h2><p>消息分发回调的优先级是指Handler中回调处理的优先级，从下面源码可以看出Message自带的callback拥有最高优先级，其次是创建Handler时传进来的callback，最后才会回调handleMessage。</p>
<p><strong>frameworks/base/core/java/android/os/Handler.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123; <span class="comment">// Message自带的callback拥有最高优先级</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123; <span class="comment">// 创建Handler时传进来的callback拥有次高优先级</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg); <span class="comment">// 最后才会回调handleMessage</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是在某些插件化方案中，这里的mCallback可作为Hook点被使用。</p>
<p>例如插件化方案中想要启动插件Activity，需要解决AMS验证问题，这里可以预先注册Activity进行占坑，然后使用占坑Activity通过AMS验证，接着再还原插件Activity，当AMS发送消息给ActivityThread的H类时，就需要找个“靠谱”的Hook点来还原Activity，上述dispatchMessage的逻辑相对简单且不易改变，而此处的mCallback就可以作为Hook点来还原目标Activity。</p>
<p>具体就是用自定义的Callback来替换mCallback，还原TargetActivity到intent中。更细节的知识点请参考<a href="https://book.douban.com/subject/30358046/">[《Android进阶解密第15章》]</a></p>
<h2 id="1-4-Handler的内存泄漏"><a href="#1-4-Handler的内存泄漏" class="headerlink" title="1.4 Handler的内存泄漏"></a>1.4 Handler的内存泄漏</h2><p>说到这个问题，相信大部分人都会说是由于以非静态内部类方式创建的Handler持有了外部类Activity实例导致无法及时回收，从而导致内存泄漏。这样说固然没问题，但是不够精准，没有切中要害。仔细思考下是谁持有了Handler实例？又是怎样的场景导致Handler实例没有随Activity退出一同被销毁？</p>
<p>这里我们需要先补充一点JVM是怎样判断对象是否还活着的知识，参考<a href="https://leeeyou.github.io/iBlogWebsite/2018/09/19/2018/2018-09-19-JVM%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1-Part4%E6%98%AF%E5%90%A6%E8%BF%98%E6%B4%BB%E7%9D%80%EF%BC%9F/">[JVM系列之对象-Part4是否还活着？]</a>，总的来说当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，否则此对象可用即不会被回收。</p>
<p>有了JVM知识垫底后，再回到上面问题：是谁持有了Handler实例？</p>
<p>从<a href="https://leeeyou.github.io/iBlogWebsite/2021/12/01/2021/2021-12-01-Handler/">[1. Handler的运行机制]</a>中很容易知道Handler实例被存放在Message的target属性中，而Message最终又被投递到MessageQueue中等待Looper消息循环，而ActivityThread主线程消息循环是个死循环，在App运行期间是不会销毁的，所以有了下面一条引用链： <strong>ActivityThread -&gt; Looper -&gt; MessageQueue -&gt; Message -&gt; Handler -&gt; Activity</strong> 因此最终是ActivityThread主线程持有了Activity实例。</p>
<p>为什么Handler实例没有随Activity退出一同被销毁？<strong>可能Handler发送了延迟消息，可能在子线程中发送了Handler消息同时该子线程是个巨耗时的任务，而在退出Activity时我们没有主动清理掉延迟消息，也没有主动终止掉子线程的耗时任务</strong>，这种场景下Handler实例就不会随Activity退出一同被销毁。</p>
<p>那解决该问题有哪些方案呢？从JVM角度看，无非就是要及时切断Handler对象到GC Roots的引用链，或者让Handler对象压根就不要持有Activity实例，所以可以考虑一下几个方案：</p>
<ol>
<li>将强引用Activity改为弱引用Activity，让JVM有机会回收弱引用Activity实例</li>
<li>在退出Activity时，及时清理掉Handler的所有消息，及时终止子线程的耗时任务，让Handler对象到GC Roots“不可达”</li>
<li>以静态内部类或者外部类的方式使用Handler，避免非静态内部类持有外部类实例</li>
</ol>
<p>内存泄漏演示代码如下所示，详细工程<a href="https://github.com/Leeeyou/SampleHandler/blob/master/app/src/main/java/com/leeeyou123/samplehandler/HandlerLeakActivity.kt">[参考这里]</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leeeyou123.samplehandler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.os.Handler</span><br><span class="line"><span class="keyword">import</span> android.os.Looper</span><br><span class="line"><span class="keyword">import</span> android.os.Message</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"><span class="keyword">import</span> kotlin.concurrent.thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandlerLeakActivity</span> : AppCompatActivity() &#123;</span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_handler_leak)</span><br><span class="line"></span><br><span class="line">        findViewById&lt;TextView&gt;(R.id.tv_leak_1).setOnClickListener &#123;</span><br><span class="line">            mHandler.sendEmptyMessageDelayed(<span class="number">0</span>, <span class="number">20000</span>)</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;请查看LeakCanary&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">            finish()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        findViewById&lt;TextView&gt;(R.id.tv_leak_2).setOnClickListener &#123;</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;请查看LeakCanary&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">            thread &#123;</span><br><span class="line">                finish()</span><br><span class="line">                Thread.sleep(<span class="number">20000</span>)</span><br><span class="line">                mHandler.sendEmptyMessage(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">mHandler</span> <span class="operator">=</span> object : Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">        override fun <span class="title function_">handleMessage</span><span class="params">(msg: Message)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.handleMessage(msg)</span><br><span class="line">            when (msg.what) &#123;</span><br><span class="line">                <span class="number">0</span> -&gt; findViewById&lt;TextView&gt;(R.id.tv_leak_1).text = <span class="string">&quot;发送延迟消息了&quot;</span></span><br><span class="line">                <span class="number">1</span> -&gt; findViewById&lt;TextView&gt;(R.id.tv_leak_2).text = <span class="string">&quot;开启子线程耗时任务了&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h1><p>这一篇是《Handler机制全面解析》的第一篇，讲解了Handler的运行机制，ActivityThread、Handler、Looper、MessageQueue之间关系以及消息的类型，最后聊了Handler的内存泄漏问题，作为Handler的开篇，这些点都是基础且需要重点掌握和理解的。下一篇会重点聊MessageQueue和Looper的工作原理，敬请期待。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>稳扎稳打系列</tag>
      </tags>
  </entry>
  <entry>
    <title>⎡稳扎稳打系列⎦：Handler机制全面解析2(2/3)</title>
    <url>/iBlogWebsite/2021/12/16/2021/2021-12-16-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%902/</url>
    <content><![CDATA[<p><img src="https://github.com/Leeeyou/blog/blob/master/images/2021/wallpaper/2021-12-16-nikhil-pThIEv416pE-unsplash.webp?raw=true" alt="2021-12-16"></p>
<h1 id="1-MessageQueue的创建过程"><a href="#1-MessageQueue的创建过程" class="headerlink" title="1. MessageQueue的创建过程"></a>1. MessageQueue的创建过程</h1><p>即消息队列，以单链表的方式存储和管理着Message。在Andrid 2.3以前，只有Java世界的居民有资格向MessageQueue中添加消息以驱动Java世界的正常运转，但从Android 2.3开始，MessageQueue的核心部分下移至Native层，让Native世界的居民也能利用消息循环来处理他们所在世界的事情。因此MessageQueue心系Native和Java两个世界，担任着两个世界沟通的桥梁。下面即将从“存消息”和“取消息”两个动作详细分析Native和Java是怎么交流合作的。不过开始之前我们先扫清楚一些MessageQueue的细节知识点。</p>
<span id="more"></span>

<p>之所以说MessageQueue是单链表存储Message，是因为Message中保存着next Message，下面是Message中部分属性值说明：</p>
<p><strong>frameworks/base/core/java/android/os/Message.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="comment">// 用户自定义的消息编号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> what; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记位，标识消息是否处于使用中，是否为异步消息</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="type">int</span> flags; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息执行时间</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="meta">@VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> when; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随消息一起传输的数据</span></span><br><span class="line">    Bundle data; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标Handler，将在该Handler中处理消息回调</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    Handler target; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息自带的Callback</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    Runnable callback; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存下一条消息，单链表体现在此</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    Message next; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入消息池所需的锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sPoolSync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">    <span class="comment">// 消息池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool; </span><br><span class="line">    <span class="comment">// 记录消息池总大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sPoolSize</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息池的总大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">50</span>; </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Message的有消息池相关的属性定义sPool，实际上通过obtain()获取Message就是问这个sPool要，否则才新建。其中还有个next属性，它保存了下一条消息，单链表体现在此，类似链表指针指向下一个Message。</p>
<p>接着我们回到MessageQueue中，MessageQueue中的mMessages保存了Java层链表头的消息，而Message本身又指向了下一条消息，所以整个消息队列以单链表的形式来存储，这种数据结构在插入和删除方面有很大的优势，在遍历方面要稍弱，不过消息队列中本身就是从链表头开始一条一条消费，要遍历整个链表的场景相对来说还是较少的，即使发送延迟消息，也是先遍历后插入，插入时并不需要移动整个队列，这是它最大的优势。</p>
<p>MessageQueue中的mPtr保存的是Native层的NativeMessageQueue引用，该对象与Java层的MessageQueue一起，共同组成了Android消息机制中的消息队列，分别管理着各层的消息。</p>
<p>接着我们了解下MessageQueue的创建过程，下面直接从Java层的创建开始逐步进入到Native层的创建过程：</p>
<p><strong>frameworks/base/core/java/android/os/MessageQueue.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java层的创建代码</span></span><br><span class="line">MessageQueue(<span class="type">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    <span class="comment">// 调用native方法，该方法的真正实现是android_os_MessageQueue_nativeInit</span></span><br><span class="line">    mPtr = nativeInit(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>frameworks/base/core/jni/android_os_MessageQueue.cpp</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Native层的创建代码</span></span><br><span class="line"><span class="keyword">static</span> jlong <span class="title function_">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建NativeMessageQueue对象</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> <span class="title class_">NativeMessageQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">&quot;Unable to allocate native queue&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    <span class="comment">// reinterpret_cast是C++里的强制类型转换符</span></span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Native层创建NativeMessageQueue</span></span><br><span class="line">NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</span><br><span class="line">    <span class="comment">// 获取该线程的Looper对象，一个线程只会保存一份Looper实例，在Native层亦是如此</span></span><br><span class="line">    mLooper = Looper::getForThread(); </span><br><span class="line">    <span class="comment">// 如果为空则新建并设置到当前线程中</span></span><br><span class="line">    <span class="keyword">if</span> (mLooper == NULL) &#123; </span><br><span class="line">        mLooper = <span class="keyword">new</span> <span class="title class_">Looper</span>(<span class="literal">false</span>);</span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>system/core/libutils/Looper.cpp</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Native层创建Looper对象</span></span><br><span class="line">Looper::Looper(bool allowNonCallbacks)</span><br><span class="line">    : mAllowNonCallbacks(allowNonCallbacks),</span><br><span class="line">      mSendingMessage(<span class="literal">false</span>),</span><br><span class="line">      mPolling(<span class="literal">false</span>),</span><br><span class="line">      mEpollRebuildRequired(<span class="literal">false</span>),</span><br><span class="line">      mNextRequestSeq(WAKE_EVENT_FD_SEQ + <span class="number">1</span>),</span><br><span class="line">      mResponseIndex(<span class="number">0</span>),</span><br><span class="line">      mNextMessageUptime(LLONG_MAX) &#123;</span><br><span class="line">    <span class="comment">// 重置mWakeEventFd</span></span><br><span class="line">    mWakeEventFd.reset(eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC));</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mWakeEventFd.get() &lt; <span class="number">0</span>, <span class="string">&quot;Could not make wake event fd: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">    AutoMutex <span class="title function_">_l</span><span class="params">(mLock)</span>;</span><br><span class="line">    <span class="comment">// 重建epoll，内部会调用epoll_create和epoll_ctl</span></span><br><span class="line">    rebuildEpollLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看到这里，我们能清晰的看到在Native世界几乎有一套跟Java类似的架构来保证消息机制的运行，事实上Java层中的诸多机制设计都是如此，大部分核心逻辑都由Native层完成。</p>
<p>分析完MessageQueue的创建过程后，我们需要有个大概的认知就是MessageQueue连接着Java层和Native层（mPtr指向了NativeMessageQueue），同时核心逻辑下沉到Native层，在Native层几乎有一套类似的架构来共同完成Android的消息机制。</p>
<h1 id="2-往消息队列存消息"><a href="#2-往消息队列存消息" class="headerlink" title="2. 往消息队列存消息"></a>2. 往消息队列存消息</h1><p>新消息入队列最终会来到MessageQueue的enqueueMessage，源码分析如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="comment">// 应用层发出的msg都需要有target，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 安全性检查，如果msg正在使用，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果调用了quit，表示要退出消息循环，此时新消息再入队列已无意义，直接return</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse(); <span class="comment">// 标记msg正在使用 </span></span><br><span class="line">        msg.when = when; <span class="comment">// 赋值msg的when</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages; <span class="comment">// 链表头消息</span></span><br><span class="line">        <span class="type">boolean</span> needWake; <span class="comment">// 是否需要唤醒阻塞</span></span><br><span class="line">        <span class="comment">// 如果链表为空，或者新消息是立即执行的，或者新消息的执行时间早于链表头消息</span></span><br><span class="line">        <span class="comment">// 此时要重置链表头消息</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果已经阻塞了，或者是消息屏障，或者是异步消息，此时需要唤醒</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="comment">// 按照执行时间找到合适的位置准备插入msg</span></span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    <span class="comment">// 如果整个消息队列中本就存在异步消息，那么重置needWake的值为false，不需要调用nativeWake</span></span><br><span class="line">                    needWake = <span class="literal">false</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg; <span class="comment">// 插入msg</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            <span class="comment">// 唤醒Native层的阻塞，触发nativePollOnce结束等待</span></span><br><span class="line">            nativeWake(mPtr); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息入队整个过程是挺简单的，首先检查msg的target不能为空，然后上锁，接着是安全性校验，然后给新msg找个合适的插入位置执行插入，最后调用nativeWake()进行唤醒。</p>
<p>接着看看关于nativeWake的细节：</p>
<p><strong>frameworks/base/core/jni/android_os_MessageQueue.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">wake</span>(); <span class="comment">// 调用nativeMessageQueue的wake()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeMessageQueue::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLooper-&gt;<span class="built_in">wake</span>(); <span class="comment">// 调用native层Looper实例的wake()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>system/core/libutils/Looper.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 向管道mWakeEventFd中写入字符1，</span></span><br><span class="line">    <span class="comment">// TEMP_FAILURE_RETRY 是一个宏定义，当执行write失败后，会不断重复执行，直到执行成功为止。</span></span><br><span class="line">    <span class="type">ssize_t</span> nWrite = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">write</span>(mWakeEventFd.<span class="built_in">get</span>(), &amp;inc, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)));</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativeWake函数所做的事情就是向文件描述符中写入数字1，这样读端就会因为有数据可读而从等待状态中醒来。</p>
<p>至此消息入队从Java层到Native层基本分析完毕，我们再去查阅NativeMessageQueue源码发现并没有看到Native消息入队的代码，这是因为Native层的消息入队跟Java层的不一样，Native层的消息入队在Looper中：</p>
<p><strong>system/core/libutils/Looper.cpp</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123;</span><br><span class="line">    <span class="type">size_t</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex <span class="title function_">_l</span><span class="params">(mLock)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> <span class="variable">messageCount</span> <span class="operator">=</span> mMessageEnvelopes.size();</span><br><span class="line">        <span class="comment">// 按照执行时间，为msg找到准确的位置</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MessageEnvelope <span class="title function_">messageEnvelope</span><span class="params">(uptime, handler, message)</span>;</span><br><span class="line">        <span class="comment">// 插入msg</span></span><br><span class="line">        mMessageEnvelopes.insertAt(messageEnvelope, i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mSendingMessage和Java层中的那个mBlocked一样，是一个小小的优化措施</span></span><br><span class="line">        <span class="comment">// 如果当前Looper当前正在发送一个msg，则不需要再次wake</span></span><br><span class="line">        <span class="keyword">if</span> (mSendingMessage) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒epoll_wait</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意mMessageEnvelopes是定义在Looper.h中的Vector类型的集合，MessageEnvelope里面记录着收信人(handler)，发信时间(uptime)，信件内容(message)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MessageEnvelope</span> &#123;</span><br><span class="line">    <span class="built_in">MessageEnvelope</span>() : <span class="built_in">uptime</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MessageEnvelope</span>(<span class="type">nsecs_t</span> u, sp&lt;MessageHandler&gt; h, <span class="type">const</span> Message&amp; m)</span><br><span class="line">        : <span class="built_in">uptime</span>(u), <span class="built_in">handler</span>(std::<span class="built_in">move</span>(h)), <span class="built_in">message</span>(m) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间</span></span><br><span class="line">    <span class="type">nsecs_t</span> uptime; </span><br><span class="line">    <span class="comment">// 接收者</span></span><br><span class="line">    sp&lt;MessageHandler&gt; handler;</span><br><span class="line">    <span class="comment">// 内容</span></span><br><span class="line">    Message message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-向消息队列取消息"><a href="#3-向消息队列取消息" class="headerlink" title="3. 向消息队列取消息"></a>3. 向消息队列取消息</h1><p>以主线程为切入点，在main函数里面会开启Looper无限循环，在loop函数中会调用loopOnce，在这个函数中第一句就是获取msg：mQueue.next()，下面把这个过程的源码简单整理如下：</p>
<p><strong>frameworks/base/core/java/android/os/Looper.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        <span class="comment">// 轮询一次</span></span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me, <span class="keyword">final</span> <span class="type">long</span> ident, <span class="keyword">final</span> <span class="type">int</span> thresholdOverride)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取msg，可能会阻塞</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next(); </span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此会进入到MessageQueue的next函数，我们可能多少了解这个函数会导致阻塞，具体阻塞原理是怎样的可能就说不上来；在该函数的后半段涉及到IdleHandler，这里是在干什么，使用场景是怎样的可能也一知半解，接下来我们就详细的分析这个函数。</p>
<p><strong>frameworks/base/core/java/android/os/MessageQueue.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// mPtr是NativeMessageQueue的引用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr; </span><br><span class="line">    <span class="comment">// 如果这个对象都不存在了，那么消息机制就跑不动了，所以直接return</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里也是个死循环，不停的问MQ要msg</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在native层轮询一次，可能会阻塞</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="comment">// 检查是否为消息屏障，是的话则会阻挡后续同步消息的执行，这里在上一篇中有介绍</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 记录消息屏障消息或者消息屏障期间第1条异步消息的前一条消息</span></span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous()); <span class="comment">// 消息屏障期间，获取第1条异步消息执行</span></span><br><span class="line">                <span class="comment">// 消息屏障期间，如果没有异步消息，则msg最终会为null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 有消息屏障的情况下，将异步消息msg后面的消息接到prevMsg的next</span></span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 否则，将mMessages直接指向下一个消息</span></span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg; <span class="comment">// 返回消息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是消息屏障期间，消息队列不存在异步消息，同步消息是没机会执行的</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// mQuitting标志位是描述MessageQueue调用了quit后置为true的</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose(); <span class="comment">// 销毁native层的消息循环队列</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接下来这段都是处理IdleHandler，注意这里是在上面没有可用的msg后才进行的</span></span><br><span class="line">            <span class="comment">// 重新赋值IdleHandler的Count</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mBlocked = <span class="literal">true</span>; <span class="comment">// count也小于0，则置mBlocked为阻塞态</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建mPendingIdleHandlers实例对象</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历IdleHandler，并调用其queueIdle函数，最后remove掉该IdleHandler</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置IdleHandler的Count</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置超时时长</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数在上一节<a href="https://leeeyou.github.io/iBlogWebsite/2021/12/01/2021/2021-12-01-%E2%8E%A1%E7%A8%B3%E6%89%8E%E7%A8%B3%E6%89%93%E7%B3%BB%E5%88%97%E2%8E%A6%EF%BC%9AHandler%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%901/">[⎡稳扎稳打系列⎦：Handler机制全面解析1(1/3)]</a>中也有分析过，总的来说next是问MQ要一个msg，如果有则返回，如果无则阻塞；其中内部还涉及到消息屏障的逻辑，如果消息屏障来了，则会取消息队列中的异步消息先执行，同步消息就先缓一缓。下面将进一步分析里面的nativePollOnce函数。</p>
<p><strong>frameworks/base/core/jni/android_os_MessageQueue.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先获取到nativeMessageQueue</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="comment">// 再通过它调起native层的pollOnece</span></span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">pollOnce</span>(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeMessageQueue::pollOnce</span><span class="params">(JNIEnv* env, jobject pollObj, <span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;<span class="built_in">pollOnce</span>(timeoutMillis); <span class="comment">// 最终是通过native层的Looper调起pollOnece</span></span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;<span class="built_in">Throw</span>(mExceptionObj);</span><br><span class="line">        env-&gt;<span class="built_in">DeleteLocalRef</span>(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>system/core/libutils/Looper.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="type">int</span> timeoutMillis, <span class="type">int</span>* outFd, <span class="type">int</span>* outEvents, <span class="type">void</span>** outData)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 这里也是一个死循环</span></span><br><span class="line">        <span class="comment">// 先处理没有Callback方法的Response事件</span></span><br><span class="line">        <span class="keyword">while</span> (mResponseIndex &lt; mResponses.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> Response&amp; response = mResponses.<span class="built_in">itemAt</span>(mResponseIndex++);</span><br><span class="line">            <span class="type">int</span> ident = response.request.ident;</span><br><span class="line">            <span class="comment">// ident大于0，则表示没有callback, 因为POLL_CALLBACK = -2</span></span><br><span class="line">            <span class="keyword">if</span> (ident &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> fd = response.request.fd;</span><br><span class="line">                <span class="type">int</span> events = response.events;</span><br><span class="line">                <span class="type">void</span>* data = response.request.data;</span><br><span class="line">                <span class="comment">// 存储发生事件的文件描述符</span></span><br><span class="line">                <span class="keyword">if</span> (outFd != <span class="literal">nullptr</span>) *outFd = fd; </span><br><span class="line">                <span class="comment">// 存储在该文件描述符上发生了哪些事件</span></span><br><span class="line">                <span class="keyword">if</span> (outEvents != <span class="literal">nullptr</span>) *outEvents = events; </span><br><span class="line">                <span class="comment">// 存储上下文数据，可传递用户自定义的数据</span></span><br><span class="line">                <span class="keyword">if</span> (outData != <span class="literal">nullptr</span>) *outData = data; </span><br><span class="line">                <span class="keyword">return</span> ident;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (outFd != <span class="literal">nullptr</span>) *outFd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">nullptr</span>) *outEvents = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outData != <span class="literal">nullptr</span>) *outData = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再处理内部轮询，调用pollInner，注意这里是在for循环内部</span></span><br><span class="line">        result = <span class="built_in">pollInner</span>(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分析下pollOnce里面的四个参数：</p>
<ul>
<li>timeOutMillis：超时等待时间。如果为-1，则表示无限等待，直到有事件发生为止。如果值为0，则无需等待立即返回。</li>
<li>outFd：存储发生事件的那个文件描述符。</li>
<li>outEvents：存储在该文件描述符上发生了哪些事件，目前支持可读、可写、错误和中断4个事件。<ul>
<li>EVENT_INPUT 可读</li>
<li>EVENT_OUTPUT 可写</li>
<li>EVENT_ERROR 错误</li>
<li>EVENT_HANGUP 中断</li>
</ul>
</li>
<li>outData：存储上下文数据，这个数据是由用户在添加监听句柄时传递的，它的作用和pthread_create函数最后一个参数param一样，用来传递用户自定义的数据。</li>
</ul>
<p>pollOnce函数的返回值是如下四个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Result from Looper_pollOnce() and Looper_pollAll():</span></span><br><span class="line"><span class="comment">    * The poll was awoken using wake() before the timeout expired</span></span><br><span class="line"><span class="comment">    * and no callbacks were executed and no other file descriptors were ready.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 表示这次返回是由wake函数触发的，也就是管道写端的那次写事件触发的</span></span><br><span class="line">    POLL_WAKE = <span class="number">-1</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Result from Looper_pollOnce() and Looper_pollAll():</span></span><br><span class="line"><span class="comment">    * One or more callbacks were executed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 表示某个被监听的句柄因某种原因被触发</span></span><br><span class="line">    <span class="comment">// 这时outFd参数用于存储发生事件的文件句柄，outEvents用于存储所发生的事件</span></span><br><span class="line">    POLL_CALLBACK = <span class="number">-2</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Result from Looper_pollOnce() and Looper_pollAll():</span></span><br><span class="line"><span class="comment">    * The timeout expired.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 表示等待超时</span></span><br><span class="line">    POLL_TIMEOUT = <span class="number">-3</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Result from Looper_pollOnce() and Looper_pollAll():</span></span><br><span class="line"><span class="comment">    * An error occurred.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 表示等待过程中发生错误</span></span><br><span class="line">    POLL_ERROR = <span class="number">-4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接着分析pollInner函数，这个函数的逻辑比较复杂，代码较长，会真正涉及到epoll，大家调整下心态，准备发车：</p>
<p><strong>system/core/libutils/Looper.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算出真正需要等待的时间</span></span><br><span class="line">    <span class="keyword">if</span> (timeoutMillis != <span class="number">0</span> &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="type">int</span> messageTimeoutMillis = <span class="built_in">toMillisecondTimeoutDelay</span>(now, mNextMessageUptime);</span><br><span class="line">        <span class="keyword">if</span> (messageTimeoutMillis &gt;= <span class="number">0</span> &amp;&amp; (timeoutMillis &lt; <span class="number">0</span> || messageTimeoutMillis &lt; timeoutMillis)) &#123;</span><br><span class="line">            timeoutMillis = messageTimeoutMillis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Poll.</span></span><br><span class="line">    <span class="type">int</span> result = POLL_WAKE;</span><br><span class="line">    mResponses.<span class="built_in">clear</span>();</span><br><span class="line">    mResponseIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are about to idle.</span></span><br><span class="line">    <span class="comment">// 即将处于idle状态</span></span><br><span class="line">    mPolling = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">    <span class="comment">// 默认采用了epoll，调用epoll_wait等待感兴趣的事件或超时发生</span></span><br><span class="line">    <span class="type">int</span> eventCount = <span class="built_in">epoll_wait</span>(mEpollFd.<span class="built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No longer idling.</span></span><br><span class="line">    <span class="comment">// 不再处于idle状态</span></span><br><span class="line">    mPolling = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire lock.</span></span><br><span class="line">    <span class="comment">// 请求锁，从epoll_wait返回了，此时一定发生了什么事情</span></span><br><span class="line">    mLock.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rebuild epoll set if needed.</span></span><br><span class="line">    <span class="keyword">if</span> (mEpollRebuildRequired) &#123;</span><br><span class="line">        mEpollRebuildRequired = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// epoll重建，直接跳到Done</span></span><br><span class="line">        <span class="built_in">rebuildEpollLocked</span>();</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for poll error.</span></span><br><span class="line">    <span class="comment">// 返回值小于0，表示发生了错误</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">            <span class="keyword">goto</span> Done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Poll failed with an unexpected error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="comment">// 设置结果为POLL_ERROR并跳到Done</span></span><br><span class="line">        result = POLL_ERROR;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for poll timeout.</span></span><br><span class="line">    <span class="comment">// 返回值等于0，标识发生超时</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置结果为POLL_TIMEOUT并跳到Done</span></span><br><span class="line">        result = POLL_TIMEOUT;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle all events.</span></span><br><span class="line">    <span class="comment">// 根据epoll的用法，eventCount表示发生事件的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="type">const</span> SequenceNumber seq = eventItems[i].data.u64;</span><br><span class="line">        <span class="type">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="comment">// WAKE_EVENT_FD_SEQ的值就是1，上面分析过nativeWake函数就是向文件描述符中写入1，</span></span><br><span class="line">        <span class="comment">// 这样就能触发管道读端从epoll_wait函数返回了</span></span><br><span class="line">        <span class="keyword">if</span> (seq == WAKE_EVENT_FD_SEQ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="comment">// 直接读取并清空管道数据</span></span><br><span class="line">                <span class="built_in">awoken</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ALOGW</span>(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// mRequests和前面的mResponse相对应，它也是一个KeyedVector，其中存储了</span></span><br><span class="line">            <span class="comment">// fd和对应的Request结构体，该结构体封装了和监控文件句柄相关的一些上下文信息，</span></span><br><span class="line">            <span class="comment">// 例如回调函数等。</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; request_it = mRequests.<span class="built_in">find</span>(seq);</span><br><span class="line">            <span class="keyword">if</span> (request_it != mRequests.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span>&amp; request = request_it-&gt;second;</span><br><span class="line">                <span class="type">int</span> events = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将epoll返回的事件转换成上层LOOPER使用的事件</span></span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">                <span class="comment">// 每处理一个Request，就相应构造一个Response</span></span><br><span class="line">                mResponses.<span class="built_in">push</span>(&#123;.seq = seq, .events = events, .request = request&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ALOGW</span>(<span class="string">&quot;Ignoring unexpected epoll events 0x%x for sequence number %&quot;</span> PRIu64</span><br><span class="line">                      <span class="string">&quot; that is no longer registered.&quot;</span>,</span><br><span class="line">                      epollEvents, seq);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke pending message callbacks.</span></span><br><span class="line">    mNextMessageUptime = LLONG_MAX;</span><br><span class="line">    <span class="comment">//  开始处理Native的Message</span></span><br><span class="line">    <span class="keyword">while</span> (mMessageEnvelopes.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="type">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.<span class="built_in">itemAt</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class="line">            &#123; <span class="comment">// obtain handler</span></span><br><span class="line">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class="line">                Message message = messageEnvelope.message;</span><br><span class="line">                mMessageEnvelopes.<span class="built_in">removeAt</span>(<span class="number">0</span>);</span><br><span class="line">                mSendingMessage = <span class="literal">true</span>;</span><br><span class="line">                mLock.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="comment">// 调用Native的handler处理Native的Message</span></span><br><span class="line">                <span class="comment">// 从这里也可看出NativeMessage和Java层的Message没有什么关系</span></span><br><span class="line">                handler-&gt;<span class="built_in">handleMessage</span>(message);</span><br><span class="line">            &#125; <span class="comment">// release handler</span></span><br><span class="line"></span><br><span class="line">            mLock.<span class="built_in">lock</span>();</span><br><span class="line">            mSendingMessage = <span class="literal">false</span>;</span><br><span class="line">            result = POLL_CALLBACK; <span class="comment">// 发生回调</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The last message left at the head of the queue determines the next wakeup time.</span></span><br><span class="line">            mNextMessageUptime = messageEnvelope.uptime;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release lock.</span></span><br><span class="line">    mLock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理那些带回调函数的Response</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        Response&amp; response = mResponses.<span class="built_in">editItemAt</span>(i);</span><br><span class="line">        <span class="comment">// 有了回调函数，就能知道如何处理所发生的事情了</span></span><br><span class="line">        <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">            <span class="type">int</span> fd = response.request.fd;</span><br><span class="line">            <span class="type">int</span> events = response.events;</span><br><span class="line">            <span class="type">void</span>* data = response.request.data;</span><br><span class="line">            <span class="comment">// 调用回调函数处理所发生的事件</span></span><br><span class="line">            <span class="type">int</span> callbackResult = response.request.callback-&gt;<span class="built_in">handleEvent</span>(fd, events, data);</span><br><span class="line">            <span class="comment">// callback函数的返回值很重要，如果为0，表明不需要再次监视该文件句柄</span></span><br><span class="line">            <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">                AutoMutex _l(mLock);</span><br><span class="line">                <span class="built_in">removeSequenceNumberLocked</span>(response.seq); <span class="comment">// 移除fd</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            response.request.callback.<span class="built_in">clear</span>();</span><br><span class="line">            result = POLL_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pollInner的代码着实有点长，整理下所发生的事情：</p>
<ol>
<li>首先计算真正需要等待的时间</li>
<li>调用epoll_wait函数等待，这是阻塞方法，用于等待事件发生或者超时，这是也nativePollOnce阻塞的原因</li>
<li>epoll_wait被唤醒，有了函数返回值，返回值可能的情况如下：<ul>
<li>POLL_ERROR 发生错误，则直接跳到Done</li>
<li>POLL_TIMEOUT 发生超时，则直接跳到Done</li>
<li>正常流程，检测到某些文件句柄上有事件发生<ul>
<li>如果是管道读端的事件，则认为是控制命令，直接读取数据</li>
<li>如果是其他FD发生事件，则根据Request构造Response，并保存到Response数组中</li>
</ul>
</li>
</ul>
</li>
<li>Done标记的代码段是真正开始处理事件的地方<ul>
<li>首先处理Native的Message，调用Native handler的handlerMessage</li>
<li>接着处理Response数组中那些带有callback的事件，也就是POLL_CALLBACK类型的事件</li>
</ul>
</li>
</ol>
<p>到这里就基本分析完“取消息”的主要逻辑，总结一下消息的处理流程，首先是处理Native层的Message，然后是处理Native层的Request，最后才是Java层的Message。了解了这些细节后，也就明白了有时Java上层消息很少，但响应时间却较长的真正原因。</p>
<h1 id="4-Looper"><a href="#4-Looper" class="headerlink" title="4. Looper"></a>4. Looper</h1><h2 id="4-1-主线程中Looper-loop-无限循环跟ANR问题"><a href="#4-1-主线程中Looper-loop-无限循环跟ANR问题" class="headerlink" title="4.1 主线程中Looper.loop()无限循环跟ANR问题"></a>4.1 主线程中Looper.loop()无限循环跟ANR问题</h2><p>这个问题这样问其实有点混淆视听，Looper无限循环跟ANR是两件事。</p>
<h3 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h3><p>ANR即Application Not responding ，应用程序无响应。在Android中，如果由于某些耗时操作（网络请求或者IO操作）造成主线程阻塞一定时间（例如造成5s内不能响应用户事件或者BroadcastReceiver的onReceive方法执行时间超过10s），那么系统就会显示ANR对话框提示用户对应的应用处于无响应状态。</p>
<p>耗时操作导致ANR的情况如下：</p>
<ul>
<li>Service Timeout：前台服务在20s内未执行完，后台服务在200s内未执行完</li>
<li>Broadcast Timeout：前台广播在10s内未执行完，后台广告在60s内未执行完</li>
<li>ContentProvider Timeout：内容提供者，在publish过超时10s</li>
<li>InputDispatching Timeout：输入事件分发超时5s，包括按键和触摸事件</li>
</ul>
<p>造成主线程阻塞的具体时间如下：</p>
<p><strong>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BROADCAST_FG_TIMEOUT</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">1000</span>; <span class="comment">// 前台</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BROADCAST_BG_TIMEOUT</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">1000</span>; <span class="comment">// 后台</span></span><br></pre></td></tr></table></figure>

<p><strong>frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SERVICE_TIMEOUT</span> <span class="operator">=</span> <span class="number">20</span> * <span class="number">1000</span>; <span class="comment">// 前台</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SERVICE_BACKGROUND_TIMEOUT</span> <span class="operator">=</span> SERVICE_TIMEOUT * <span class="number">10</span>; <span class="comment">// 后台</span></span><br></pre></td></tr></table></figure>

<p><strong>frameworks/base/core/java/android/content/ContentResolver.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONTENT_PROVIDER_PUBLISH_TIMEOUT_MILLIS</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>总的来说ANR是因为消息队列当中的事件没有及时得到处理造成的，而我们在主线程中写个死循环基本上会造成ANR，是由于死循环阻塞了后面的事件处理。</p>
<h3 id="Looper无限循环的意义"><a href="#Looper无限循环的意义" class="headerlink" title="Looper无限循环的意义"></a>Looper无限循环的意义</h3><p>在以消息机制为基础的系统中，Looper无限循环是必不可少，否则当Looper停止也就意味着退出主线程，即退出程序。</p>
<p>Looper的主要作用就是无限循环，不停的问MQ要消息，然后递给Handler去处理，这里只是“传递”的作用，而且Looper会在无可用消息的情况下进入阻塞状态，属于阻塞式的死循环，这样就更少的消耗cpu资源了。</p>
<p>Android应用程序的主线程进入空闲等待状态的方式实际上就是在管道的读端等待管道中有新的内容可读，具体来说是通过Linux系统的Epoll机制中的epoll_wait函数进行的。当往Android应用程序的消息队列中加入新的消息时，会同时往管道中的写端写入内容(nativeWake)，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。因此Looper的无限循环并不会对CPU性能有过多的消耗。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>Looper无限循环是必不可少的，否则就意味着退出应用程序</li>
<li>Looper中是阻塞式的死循环，充当“中间人”的传递作用，拿到消息后再递给相应Handler处理</li>
<li>ANR是因为消息队列当中的事件没有及时得到处理造成的</li>
<li>死循环不会必然导致ANR</li>
</ul>
<h2 id="4-2-Looper-myLooper-setMessageLogging的使用"><a href="#4-2-Looper-myLooper-setMessageLogging的使用" class="headerlink" title="4.2 Looper.myLooper().setMessageLogging的使用"></a>4.2 Looper.myLooper().setMessageLogging的使用</h2><p>首先看看setMessageLogging的源码，就是设置一个Printer类型的入参给mLogging</p>
<p><strong>frameworks/base/core/java/android/os/Looper.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessageLogging</span><span class="params">(<span class="meta">@Nullable</span> Printer printer)</span> &#123;</span><br><span class="line">    mLogging = printer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在loopOnce中会获取mLogging，在开始处理消息前以及处理后调用Printer输出日志，这样就可以很容易知道主线程的耗时操作了。</p>
<p><strong>frameworks/base/core/java/android/os/Looper.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me, <span class="keyword">final</span> <span class="type">long</span> ident, <span class="keyword">final</span> <span class="type">int</span> thresholdOverride)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next(); <span class="comment">// might block</span></span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取printer</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">    <span class="comment">// 开始处理前，打印日志</span></span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span></span><br><span class="line">                + msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消息处理完，打印日志</span></span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>性能监控组件<a href="https://github.com/markzhai/AndroidPerformanceMonitor">[BlockCanary]</a>就是利用这个原理检测主线程上的各种卡顿问题，并可通过组件提供的各种信息分析出原因并进行修复。</p>
<h1 id="5-epoll机制"><a href="#5-epoll机制" class="headerlink" title="5. epoll机制"></a>5. epoll机制</h1><p>select/poll/epoll都是IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪（读或写就绪），则立刻通知相应程序进行读或写操作。本质上select/poll/epoll都是同步I/O，即读写是阻塞的。</p>
<p>不过开始了解epoll之前，要先熟悉下句柄和文件描述符的含义。</p>
<h2 id="5-1-句柄和文件描述符"><a href="#5-1-句柄和文件描述符" class="headerlink" title="5.1 句柄和文件描述符"></a>5.1 句柄和文件描述符</h2><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>句柄就是个数字，一般和当前系统下的整数的位数一样，比如32bit系统下就是4个字节。这个数字是一个对象的唯一标示，和对象一一对应。这个对象可以是一个块内存，一个资源，或者一个服务的context（如 socket，thread）等等。</p>
<p>句柄的英文是handle。在英文中有操作、处理、控制之类的意义。作为一个名词时，是指某个中间媒介，通过这个中间媒介可控制、操作某样东西。这样说有点抽象，举个例子。door handle是指门把手，通过门把手可以去控制门，但door handle并非door本身，只是一个中间媒介。又比如knife handle是刀柄，通过刀柄可以使用刀。</p>
<p>跟door handle类似，我们可以用file handle去操作file, 但file handle并非file本身。这个file handle就被翻译成文件句柄，同理还有各种资源句柄。</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<p>Linux 系统中，把一切都看做是文件，<strong>当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</strong></p>
<h2 id="5-2-select"><a href="#5-2-select" class="headerlink" title="5.2 select"></a>5.2 select</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span> <span class="params">(<span class="type">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>select函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。<strong>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</strong></p>
<h2 id="5-3-poll"><a href="#5-3-poll" class="headerlink" title="5.3 poll"></a>5.3 poll</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">int</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="type">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<p>从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。<strong>事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</strong></p>
<h2 id="5-4-epoll"><a href="#5-4-epoll" class="headerlink" title="5.4 epoll"></a>5.4 epoll</h2><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<h3 id="epoll操作过程"><a href="#epoll操作过程" class="headerlink" title="epoll操作过程"></a>epoll操作过程</h3><p>epoll操作过程需要三个接口，分别如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>；<span class="comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>int epoll_create(int size);</li>
</ol>
<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</p>
<p>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<ol start="2">
<li>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</li>
</ol>
<p>函数是对指定描述符fd执行op操作。</p>
<ul>
<li>epfd：是epoll_create()的返回值。</li>
<li>op：表示op操作，用三个宏来分别表示添加、删除和修改对fd的监听事件<ul>
<li>添加EPOLL_CTL_ADD</li>
<li>删除EPOLL_CTL_DEL</li>
<li>修改EPOLL_CTL_MOD。</li>
</ul>
</li>
<li>fd：是需要监听的fd（文件描述符）</li>
<li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">  <span class="type">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>events可以是以下几个宏的集合：</p>
<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li>
<li>EPOLLOUT：表示对应的文件描述符可以写；</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li>EPOLLERR：表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
<ol start="3">
<li>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</li>
</ol>
<p>等待epfd上的io事件，最多返回maxevents个事件。</p>
<p>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<ul>
<li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li>
</ul>
<h2 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h2><ul>
<li><strong>描述符数量限制</strong><ul>
<li>epoll监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048，举个例子：在1GB内存的机器上大约是10万左右，具体数目可以cat/proc/sys/fs/file-max查看，一般来说这个数目和系统内存关系很大。</li>
<li><strong>select的最大缺点就是进程打开的fd是有数量限制的</strong>。这对于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</li>
</ul>
</li>
<li><strong>遍历文件描述符问题</strong><ul>
<li>在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，</li>
<li>而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。<strong>此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。</strong></li>
</ul>
</li>
<li>IO效率<ul>
<li>epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。<strong>IO的效率不会随着监视FD的数量的增长而下降。</strong> </li>
<li>如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</li>
</ul>
</li>
</ul>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>这篇文章主要聚焦于MessageQueue和Looper在Java层和Native层的运行逻辑，从“存消息”和“取消息”切入分析内部细节，一直分析到epoll机制，整个链路是比较长的，涉及的知识点比较多。</p>
<p>在Looper小节中还重点分析了ANR和无限循环问题，最后详细介绍了epoll机制及其优势。下一篇是整个Handler系列的终结篇，会重点讨论延时消息原理，以及Android为什么选择管道模式作为进程间通信机制，屏幕刷新的sync信号与消息机制是怎样运作的，敬请期待。</p>
<hr>
<p>参考</p>
<ul>
<li><a href="https://www.kancloud.cn/alex_wsc/android-deep2/413391">心系两界的MessageQueue</a></li>
<li><a href="http://gityuan.com/2015/12/06/linux_epoll/">select/poll/epoll对比分析</a></li>
<li><a href="https://blog.csdn.net/XueyinGuo/article/details/113096163">select、poll、epoll - IO模型超详解</a></li>
<li><a href="https://segmentfault.com/a/1190000003063859?utm_source=Weibo&utm_medium=shareLink&utm_campaign=socialShare&from=timeline&isappinstalled=0">Linux IO模式及 select、poll、epoll详解</a></li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>稳扎稳打系列</tag>
      </tags>
  </entry>
</search>
